/*! FengMap 2016-07-21 02:14:06 */
function IsInVector(a, b) {
    if (0 == a.length)
        return !1;
    for (var c = 0; c < a.length; c++)
        if (a[c] == b)
            return !0;
    return !1
}
function isPointInSameExtent(a, b, c) {
    if (null == a)
        return 0;
    var d = a.QueryContainExtentId(b)
      , e = a.QueryContainExtentId(c);
    return d == e ? 1 : 0
}
function isNotAllNodeTreatHead(a) {
    for (var b = 0; b < a.length; b++)
        if (0 == a[b]._treatHead)
            return 1;
    return 0
}
function isNotAllPathinvalide(a) {
    for (var b = 0; b < a.size(); b++)
        if (a.get(a.keys[b])._weight < ERROR_WEIGHT)
            return 1;
    return 0
}
function is_zero(a) {
    return a < REAL_EPSILON && a > -REAL_EPSILON
}
function gt_zero(a) {
    return a > REAL_EPSILON
}
function lt_zero(a) {
    return a < -REAL_EPSILON
}
function pt_distance_to_line(a, b, c, d) {
    var e, f = b.x, g = b.y, h = c.x, i = c.y, j = a.x, k = a.y, l = h - f, m = i - g, n = Math.sqrt(l * l + m * m), o = j - f, p = k - g, q = Math.sqrt(o * o + p * p);
    if (is_zero(n))
        return is_zero(q) ? (d.x = b.x,
        d.y = b.y,
        e = 0) : (d.x = b.x,
        d.y = b.y,
        e = q);
    var r = l / n
      , s = m / n
      , t = r * o + s * p;
    if (!gt_zero(t))
        return d.x = b.x,
        d.y = b.y,
        e = q;
    if (!lt_zero(t - n)) {
        var u = j - h
          , v = k - i
          , w = Math.sqrt(u * u + v * v);
        return d.x = c.x,
        d.y = c.y,
        e = w
    }
    var x = f + t * r
      , y = g + t * s
      , z = j - x
      , A = k - y
      , B = Math.sqrt(z * z + A * A);
    return d.x = x,
    d.y = y,
    e = B
}
function DistanceofTwoPts(a, b) {
    return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y))
}
function is_same_pt(a, b) {
    return Math.abs(a.x - b.x) <= SMAE_EPSILON && Math.abs(a.y - b.y) <= SMAE_EPSILON
}
function NaviMap() {
    this.keys = new Array,
    this.data = new Object,
    this.clear = function() {
        delete this.keys,
        delete this.data,
        this.keys = new Array,
        this.data = new Object
    }
    ,
    this.put = function(a, b) {
        null == this.data[a] && this.keys.push(a),
        this.data[a] = b
    }
    ,
    this.get = function(a) {
        return this.data[a]
    }
    ,
    this.remove = function(a) {
        this.keys.remove(a),
        this.data[a] = null
    }
    ,
    this.each = function(a) {
        if ("function" == typeof a)
            for (var b = this.keys.length, c = 0; c < b; c++) {
                var d = this.keys[c];
                a(d, this.data[d], c)
            }
    }
    ,
    this.entrys = function() {
        for (var a = this.keys.length, b = new Array(a), c = 0; c < a; c++)
            b[c] = {
                key: this.keys[c],
                value: this.data[c]
            };
        return b
    }
    ,
    this.isEmpty = function() {
        return 0 == this.keys.length
    }
    ,
    this.size = function() {
        return this.keys.length
    }
    ,
    this.toString = function() {
        for (var a = "{", b = 0; b < this.keys.length; b++,
        a += ",") {
            var c = this.keys[b];
            a += c + "=" + this.data[c]
        }
        return a += "}"
    }
}
function Long(a, b, c) {
    this.low = 0 | a,
    this.high = 0 | b,
    this.unsigned = !!c
}
function isLong(a) {
    return (a && a.__isLong__) === !0
}
function fromInt(a, b) {
    var c, d, e;
    return b ? (a >>>= 0,
    (e = 0 <= a && a < 256) && (d = UINT_CACHE[a]) ? d : (c = fromBits(a, (0 | a) < 0 ? -1 : 0, !0),
    e && (UINT_CACHE[a] = c),
    c)) : (a |= 0,
    (e = -128 <= a && a < 128) && (d = INT_CACHE[a]) ? d : (c = fromBits(a, a < 0 ? -1 : 0, !1),
    e && (INT_CACHE[a] = c),
    c))
}
function fromNumber(a, b) {
    if (isNaN(a) || !isFinite(a))
        return b ? UZERO : ZERO;
    if (b) {
        if (a < 0)
            return UZERO;
        if (a >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE
    } else {
        if (a <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (a + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE
    }
    return a < 0 ? fromNumber(-a, b).neg() : fromBits(a % TWO_PWR_32_DBL | 0, a / TWO_PWR_32_DBL | 0, b)
}
function fromBits(a, b, c) {
    return new Long(a,b,c)
}
function fromString(a, b, c) {
    if (0 === a.length)
        throw Error("empty string");
    if ("NaN" === a || "Infinity" === a || "+Infinity" === a || "-Infinity" === a)
        return ZERO;
    if ("number" == typeof b && (c = b,
    b = !1),
    c = c || 10,
    c < 2 || 36 < c)
        throw RangeError("radix");
    var d;
    if ((d = a.indexOf("-")) > 0)
        throw Error("interior hyphen");
    if (0 === d)
        return fromString(a.substring(1), b, c).neg();
    for (var e = fromNumber(pow_dbl(c, 8)), f = ZERO, g = 0; g < a.length; g += 8) {
        var h = Math.min(8, a.length - g)
          , i = parseInt(a.substring(g, g + h), c);
        if (h < 8) {
            var j = fromNumber(pow_dbl(c, h));
            f = f.mul(j).add(fromNumber(i))
        } else
            f = f.mul(e),
            f = f.add(fromNumber(i))
    }
    return f.unsigned = b,
    f
}
function fromValue(a) {
    return a instanceof Long ? a : "number" == typeof a ? fromNumber(a) : "string" == typeof a ? fromString(a) : fromBits(a.low, a.high, a.unsigned)
}
function stringSource(a) {
    var b = 0;
    return function() {
        return b < a.length ? a.charCodeAt(b++) : null
    }
}
function stringDestination() {
    var a = []
      , b = [];
    return function() {
        return 0 === arguments.length ? b.join("") + stringFromCharCode.apply(String, a) : (a.length + arguments.length > 1024 && (b.push(stringFromCharCode.apply(String, a)),
        a.length = 0),
        void Array.prototype.push.apply(a, arguments))
    }
}
function ieee754_read(a, b, c, d, e) {
    var f, g, h = 8 * e - d - 1, i = (1 << h) - 1, j = i >> 1, k = -7, l = c ? e - 1 : 0, m = c ? -1 : 1, n = a[b + l];
    for (l += m,
    f = n & (1 << -k) - 1,
    n >>= -k,
    k += h; k > 0; f = 256 * f + a[b + l],
    l += m,
    k -= 8)
        ;
    for (g = f & (1 << -k) - 1,
    f >>= -k,
    k += d; k > 0; g = 256 * g + a[b + l],
    l += m,
    k -= 8)
        ;
    if (0 === f)
        f = 1 - j;
    else {
        if (f === i)
            return g ? NaN : (n ? -1 : 1) * (1 / 0);
        g += Math.pow(2, d),
        f -= j
    }
    return (n ? -1 : 1) * g * Math.pow(2, f - d)
}
function ieee754_write(a, b, c, d, e, f) {
    var g, h, i, j = 8 * f - e - 1, k = (1 << j) - 1, l = k >> 1, m = 23 === e ? Math.pow(2, -24) - Math.pow(2, -77) : 0, n = d ? 0 : f - 1, o = d ? 1 : -1, p = b < 0 || 0 === b && 1 / b < 0 ? 1 : 0;
    for (b = Math.abs(b),
    isNaN(b) || b === 1 / 0 ? (h = isNaN(b) ? 1 : 0,
    g = k) : (g = Math.floor(Math.log(b) / Math.LN2),
    b * (i = Math.pow(2, -g)) < 1 && (g--,
    i *= 2),
    b += g + l >= 1 ? m / i : m * Math.pow(2, 1 - l),
    b * i >= 2 && (g++,
    i /= 2),
    g + l >= k ? (h = 0,
    g = k) : g + l >= 1 ? (h = (b * i - 1) * Math.pow(2, e),
    g += l) : (h = b * Math.pow(2, l - 1) * Math.pow(2, e),
    g = 0)); e >= 8; a[c + n] = 255 & h,
    n += o,
    h /= 256,
    e -= 8)
        ;
    for (g = g << e | h,
    j += e; j > 0; a[c + n] = 255 & g,
    n += o,
    g /= 256,
    j -= 8)
        ;
    a[c + n - o] |= 128 * p
}
function fmMapDecode(a) {
    var b = _rootmap.build("Map").decode(a)
      , c = {};
    c.scene = null ,
    c.floors = [];
    for (var d = 0, e = b.buffers.length; d < e; d++) {
        var f = b.buffers[d]
          , g = f.len
          , h = f.data.offset
          , i = f.data.offset + g.low
          , j = f.data.buffer;
        if (1 == f.btype) {
            var k = _rootscene.build("Scene").decode(j.slice(h, i));
            c.scene = k
        } else {
            var l = f.gid
              , m = containsFloor(l, c.floors)
              , n = m.floor;
            if (m.index < 0 && (n.gid = l,
            n.biz = [],
            n.navi = [],
            n.geo = []),
            2 == f.btype) {
                var o = _rootfloor.build("FloorGeo").decode(j.slice(h, i));
                n.geo.push(o)
            }
            if (3 == f.btype) {
                var p = _rootfloor.build("FloorBiz").decode(j.slice(h, i));
                n.biz.push(p)
            }
            if (4 == f.btype) {
                var q = _rootfloor.build("FloorNavi").decode(j.slice(h, i));
                n.navi.push(q)
            }
            m.index < 0 ? c.floors.push(n) : c.floors[m.index] = n
        }
    }
    return c
}
function containsFloor(a, b) {
    for (var c = 0, d = b.length; c < d; c++)
        if (b[c].gid == a)
            return {
                index: c,
                floor: b[c]
            };
    return {
        index: -1,
        floor: {}
    }
}
function fmSceneDecode(a) {
    var b = _rootscene.build("Scene").decode(a);
    return b
}
function fmFloorGeoDecode(a) {
    var b = _rootfloor.build("FloorGeo").decode(a);
    return b
}
function fmFloorBizDecode(a) {
    var b = _rootfloor.build("FloorBiz").decode(a);
    return b
}
function fmFloorNaviDecode(a) {
    var b = _rootfloor.build("FloorNavi").decode(a);
    return b
}
var fm = window.fm || {}
  , fengmap = {
    VERSION: "1.1.1",
    BUILD: 1306
};
window.fengmap = fengmap;
var performance = performance || {};
fm.Ajax = function(a, b, c, d) {
    if (this.bindFunction = function(a, b) {
        return function() {
            return a.apply(b, [b])
        }
    }
    ,
    this.stateChange = function(a) {
        4 == this.request.readyState && (0 === window.location.protocol.indexOf("file") && 0 == this.request.status || 200 == this.request.status ? 1 == c ? this.callbackFunction(this.request.response) : this.callbackFunction(this.request.responseText) : ("function" == typeof this.failFunction && this.failFunction(this.request.response),
        console.log(this.request.status)))
    }
    ,
    this.getRequest = function() {
        return window.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : !!window.XMLHttpRequest && new XMLHttpRequest
    }
    ,
    this.postBody = arguments[4] || "",
    this.callbackFunction = b,
    this.failFunction = "function" == typeof d ? d : null ,
    this.url = a,
    this.request = this.getRequest(),
    this.request) {
        var e = this.request;
        e.onreadystatechange = this.bindFunction(this.stateChange, this),
        "" !== this.postBody ? (e.open("POST", a, !0),
        e.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
        e.setRequestHeader("Content-type", "application/x-www-form-urlencoded"),
        e.setRequestHeader("Connection", "close")) : e.open("GET", a, !0),
        c === !0 && (e.responseType = "arraybuffer"),
        e.send(this.postBody)
    }
}
,
fm.Evento = {
    convert: function(a, b) {
        return b = {},
        a.on = function(c, d) {
            return (b[c] = b[c] || []).push(d),
            a
        }
        ,
        a.once = function(b, c) {
            function d() {
                c.apply(a.off(b, d), arguments)
            }
            return d.h = c,
            a.on(b, d)
        }
        ,
        a.off = function(c, d) {
            for (var e = b[c], f = 0; d && e && e[f]; f++)
                e[f] != d && e[f].h != d || e.splice(f--, 1);
            return f || delete b[c],
            a
        }
        ,
        a.emit = function(c) {
            for (var d = b[c], e = 0; d && d[e]; )
                d[e++].apply(a, d.slice.call(arguments, 1));
            return a
        }
        ,
        a
    }
},
fm.addEvent = function(a, b, c) {
    null != a && "undefined" != typeof a && (a.addEventListener ? a.addEventListener(b, c, !1) : a.attachEvent ? a.attachEvent("on" + b, c) : a["on" + b] = c)
}
;
var fm = fm || {};
fm.REVISION = "76",
"function" == typeof define && define.amd ? define("three", fm) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = fm),
void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
void 0 === Math.sign && (Math.sign = function(a) {
    return a < 0 ? -1 : a > 0 ? 1 : +a
}
),
void 0 === Function.prototype.name && void 0 !== Object.defineProperty && Object.defineProperty(Function.prototype, "name", {
    get: function() {
        return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
    }
}),
void 0 === Object.assign && Object.defineProperty(Object, "assign", {
    writable: !0,
    configurable: !0,
    value: function(a) {
        "use strict";
        if (void 0 === a || null === a)
            throw new TypeError("Cannot convert first argument to object");
        for (var b = Object(a), c = 1, d = arguments.length; c !== d; ++c) {
            var e = arguments[c];
            if (void 0 !== e && null !== e) {
                e = Object(e);
                for (var f = Object.keys(e), g = 0, h = f.length; g !== h; ++g) {
                    var i = f[g]
                      , j = Object.getOwnPropertyDescriptor(e, i);
                    void 0 !== j && j.enumerable && (b[i] = e[i])
                }
            }
        }
        return b
    }
}),
fm.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
},
fm.CullFaceNone = 0,
fm.CullFaceBack = 1,
fm.CullFaceFront = 2,
fm.CullFaceFrontBack = 3,
fm.FrontFaceDirectionCW = 0,
fm.FrontFaceDirectionCCW = 1,
fm.BasicShadowMap = 0,
fm.PCFShadowMap = 1,
fm.PCFSoftShadowMap = 2,
fm.FrontSide = 0,
fm.BackSide = 1,
fm.DoubleSide = 2,
fm.FlatShading = 1,
fm.SmoothShading = 2,
fm.NoColors = 0,
fm.FaceColors = 1,
fm.VertexColors = 2,
fm.NoBlending = 0,
fm.NormalBlending = 1,
fm.AdditiveBlending = 2,
fm.SubtractiveBlending = 3,
fm.MultiplyBlending = 4,
fm.CustomBlending = 5,
fm.AddEquation = 100,
fm.SubtractEquation = 101,
fm.ReverseSubtractEquation = 102,
fm.MinEquation = 103,
fm.MaxEquation = 104,
fm.ZeroFactor = 200,
fm.OneFactor = 201,
fm.SrcColorFactor = 202,
fm.OneMinusSrcColorFactor = 203,
fm.SrcAlphaFactor = 204,
fm.OneMinusSrcAlphaFactor = 205,
fm.DstAlphaFactor = 206,
fm.OneMinusDstAlphaFactor = 207,
fm.DstColorFactor = 208,
fm.OneMinusDstColorFactor = 209,
fm.SrcAlphaSaturateFactor = 210,
fm.NeverDepth = 0,
fm.AlwaysDepth = 1,
fm.LessDepth = 2,
fm.LessEqualDepth = 3,
fm.EqualDepth = 4,
fm.GreaterEqualDepth = 5,
fm.GreaterDepth = 6,
fm.NotEqualDepth = 7,
fm.MultiplyOperation = 0,
fm.MixOperation = 1,
fm.AddOperation = 2,
fm.NoToneMapping = 0,
fm.LinearToneMapping = 1,
fm.ReinhardToneMapping = 2,
fm.Uncharted2ToneMapping = 3,
fm.CineonToneMapping = 4,
fm.UVMapping = 300,
fm.CubeReflectionMapping = 301,
fm.CubeRefractionMapping = 302,
fm.EquirectangularReflectionMapping = 303,
fm.EquirectangularRefractionMapping = 304,
fm.SphericalReflectionMapping = 305,
fm.CubeUVReflectionMapping = 306,
fm.CubeUVRefractionMapping = 307,
fm.RepeatWrapping = 1e3,
fm.ClampToEdgeWrapping = 1001,
fm.MirroredRepeatWrapping = 1002,
fm.NearestFilter = 1003,
fm.NearestMipMapNearestFilter = 1004,
fm.NearestMipMapLinearFilter = 1005,
fm.LinearFilter = 1006,
fm.LinearMipMapNearestFilter = 1007,
fm.LinearMipMapLinearFilter = 1008,
fm.UnsignedByteType = 1009,
fm.ByteType = 1010,
fm.ShortType = 1011,
fm.UnsignedShortType = 1012,
fm.IntType = 1013,
fm.UnsignedIntType = 1014,
fm.FloatType = 1015,
fm.HalfFloatType = 1025,
fm.UnsignedShort4444Type = 1016,
fm.UnsignedShort5551Type = 1017,
fm.UnsignedShort565Type = 1018,
fm.AlphaFormat = 1019,
fm.RGBFormat = 1020,
fm.RGBAFormat = 1021,
fm.LuminanceFormat = 1022,
fm.LuminanceAlphaFormat = 1023,
fm.RGBEFormat = fm.RGBAFormat,
fm.DepthFormat = 1026,
fm.RGB_S3TC_DXT1_Format = 2001,
fm.RGBA_S3TC_DXT1_Format = 2002,
fm.RGBA_S3TC_DXT3_Format = 2003,
fm.RGBA_S3TC_DXT5_Format = 2004,
fm.RGB_PVRTC_4BPPV1_Format = 2100,
fm.RGB_PVRTC_2BPPV1_Format = 2101,
fm.RGBA_PVRTC_4BPPV1_Format = 2102,
fm.RGBA_PVRTC_2BPPV1_Format = 2103,
fm.RGB_ETC1_Format = 2151,
fm.LoopOnce = 2200,
fm.LoopRepeat = 2201,
fm.LoopPingPong = 2202,
fm.InterpolateDiscrete = 2300,
fm.InterpolateLinear = 2301,
fm.InterpolateSmooth = 2302,
fm.ZeroCurvatureEnding = 2400,
fm.ZeroSlopeEnding = 2401,
fm.WrapAroundEnding = 2402,
fm.TrianglesDrawMode = 0,
fm.TriangleStripDrawMode = 1,
fm.TriangleFanDrawMode = 2,
fm.LinearEncoding = 3e3,
fm.sRGBEncoding = 3001,
fm.GammaEncoding = 3007,
fm.RGBEEncoding = 3002,
fm.LogLuvEncoding = 3003,
fm.RGBM7Encoding = 3004,
fm.RGBM16Encoding = 3005,
fm.RGBDEncoding = 3006,
fm.BasicDepthPacking = 3200,
fm.RGBADepthPacking = 3201,
fm.Vector2 = function(a, b) {
    this.x = a || 0,
    this.y = b || 0
}
,
fm.Vector2.prototype = {
    constructor: fm.Vector2,
    get width() {
        return this.x
    },
    set width(a) {
        this.x = a
    },
    get height() {
        return this.y
    },
    set height(a) {
        this.y = a
    },
    set: function(a, b) {
        return this.x = a,
        this.y = b,
        this
    },
    setScalar: function(a) {
        return this.x = a,
        this.y = a,
        this
    },
    setX: function(a) {
        return this.x = a,
        this
    },
    setY: function(a) {
        return this.y = a,
        this
    },
    setComponent: function(a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        default:
            throw new Error("index is out of range: " + a)
        }
    },
    getComponent: function(a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + a)
        }
    },
    clone: function() {
        return new this.constructor(this.x,this.y)
    },
    copy: function(a) {
        return this.x = a.x,
        this.y = a.y,
        this
    },
    add: function(a, b) {
        return void 0 !== b ? (console.warn("fm.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors(a, b)) : (this.x += a.x,
        this.y += a.y,
        this)
    },
    addScalar: function(a) {
        return this.x += a,
        this.y += a,
        this
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x,
        this.y = a.y + b.y,
        this
    },
    addScaledVector: function(a, b) {
        return this.x += a.x * b,
        this.y += a.y * b,
        this
    },
    sub: function(a, b) {
        return void 0 !== b ? (console.warn("fm.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors(a, b)) : (this.x -= a.x,
        this.y -= a.y,
        this)
    },
    subScalar: function(a) {
        return this.x -= a,
        this.y -= a,
        this
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x,
        this.y = a.y - b.y,
        this
    },
    multiply: function(a) {
        return this.x *= a.x,
        this.y *= a.y,
        this
    },
    multiplyScalar: function(a) {
        return isFinite(a) ? (this.x *= a,
        this.y *= a) : (this.x = 0,
        this.y = 0),
        this
    },
    divide: function(a) {
        return this.x /= a.x,
        this.y /= a.y,
        this
    },
    divideScalar: function(a) {
        return this.multiplyScalar(1 / a)
    },
    min: function(a) {
        return this.x = Math.min(this.x, a.x),
        this.y = Math.min(this.y, a.y),
        this
    },
    max: function(a) {
        return this.x = Math.max(this.x, a.x),
        this.y = Math.max(this.y, a.y),
        this
    },
    clamp: function(a, b) {
        return this.x = Math.max(a.x, Math.min(b.x, this.x)),
        this.y = Math.max(a.y, Math.min(b.y, this.y)),
        this
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new fm.Vector2,
            b = new fm.Vector2),
            a.set(c, c),
            b.set(d, d),
            this.clamp(a, b)
        }
    }(),
    clampLength: function(a, b) {
        var c = this.length();
        return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c),
        this
    },
    floor: function() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    },
    ceil: function() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    },
    round: function() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    },
    roundToZero: function() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    },
    negate: function() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y)
    },
    normalize: function() {
        return this.divideScalar(this.length())
    },
    angle: function() {
        var a = Math.atan2(this.y, this.x);
        return a < 0 && (a += 2 * Math.PI),
        a
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x
          , c = this.y - a.y;
        return b * b + c * c
    },
    setLength: function(a) {
        return this.multiplyScalar(a / this.length())
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b,
        this.y += (a.y - this.y) * b,
        this
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a),
        this
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0),
        this.x = a[b],
        this.y = a[b + 1],
        this
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []),
        void 0 === b && (b = 0),
        a[b] = this.x,
        a[b + 1] = this.y,
        a
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0),
        b = b * a.itemSize + c,
        this.x = a.array[b],
        this.y = a.array[b + 1],
        this
    },
    rotateAround: function(a, b) {
        var c = Math.cos(b)
          , d = Math.sin(b)
          , e = this.x - a.x
          , f = this.y - a.y;
        return this.x = e * c - f * d + a.x,
        this.y = e * d + f * c + a.y,
        this
    }
},
fm.Vector3 = function(a, b, c) {
    this.x = a || 0,
    this.y = b || 0,
    this.z = c || 0
}
,
fm.Vector3.prototype = {
    constructor: fm.Vector3,
    set: function(a, b, c) {
        return this.x = a,
        this.y = b,
        this.z = c,
        this
    },
    setScalar: function(a) {
        return this.x = a,
        this.y = a,
        this.z = a,
        this
    },
    setX: function(a) {
        return this.x = a,
        this
    },
    setY: function(a) {
        return this.y = a,
        this
    },
    setZ: function(a) {
        return this.z = a,
        this
    },
    setComponent: function(a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        case 2:
            this.z = b;
            break;
        default:
            throw new Error("index is out of range: " + a)
        }
    },
    getComponent: function(a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + a)
        }
    },
    clone: function() {
        return new this.constructor(this.x,this.y,this.z)
    },
    copy: function(a) {
        return this.x = a.x,
        this.y = a.y,
        this.z = a.z,
        this
    },
    add: function(a, b) {
        return void 0 !== b ? (console.warn("fm.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors(a, b)) : (this.x += a.x,
        this.y += a.y,
        this.z += a.z,
        this)
    },
    addScalar: function(a) {
        return this.x += a,
        this.y += a,
        this.z += a,
        this
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x,
        this.y = a.y + b.y,
        this.z = a.z + b.z,
        this
    },
    addScaledVector: function(a, b) {
        return this.x += a.x * b,
        this.y += a.y * b,
        this.z += a.z * b,
        this
    },
    sub: function(a, b) {
        return void 0 !== b ? (console.warn("fm.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors(a, b)) : (this.x -= a.x,
        this.y -= a.y,
        this.z -= a.z,
        this)
    },
    subScalar: function(a) {
        return this.x -= a,
        this.y -= a,
        this.z -= a,
        this
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x,
        this.y = a.y - b.y,
        this.z = a.z - b.z,
        this
    },
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("fm.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
        this.multiplyVectors(a, b)) : (this.x *= a.x,
        this.y *= a.y,
        this.z *= a.z,
        this)
    },
    multiplyScalar: function(a) {
        return isFinite(a) ? (this.x *= a,
        this.y *= a,
        this.z *= a) : (this.x = 0,
        this.y = 0,
        this.z = 0),
        this
    },
    multiplyVectors: function(a, b) {
        return this.x = a.x * b.x,
        this.y = a.y * b.y,
        this.z = a.z * b.z,
        this
    },
    applyEuler: function() {
        var a;
        return function(b) {
            return b instanceof fm.Euler == !1 && console.error("fm.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            void 0 === a && (a = new fm.Quaternion),
            this.applyQuaternion(a.setFromEuler(b)),
            this
        }
    }(),
    applyAxisAngle: function() {
        var a;
        return function(b, c) {
            return void 0 === a && (a = new fm.Quaternion),
            this.applyQuaternion(a.setFromAxisAngle(b, c)),
            this
        }
    }(),
    applyMatrix3: function(a) {
        var b = this.x
          , c = this.y
          , d = this.z
          , e = a.elements;
        return this.x = e[0] * b + e[3] * c + e[6] * d,
        this.y = e[1] * b + e[4] * c + e[7] * d,
        this.z = e[2] * b + e[5] * c + e[8] * d,
        this
    },
    applyMatrix4: function(a) {
        var b = this.x
          , c = this.y
          , d = this.z
          , e = a.elements;
        return this.x = e[0] * b + e[4] * c + e[8] * d + e[12],
        this.y = e[1] * b + e[5] * c + e[9] * d + e[13],
        this.z = e[2] * b + e[6] * c + e[10] * d + e[14],
        this
    },
    applyProjection: function(a) {
        var b = this.x
          , c = this.y
          , d = this.z
          , e = a.elements
          , f = 1 / (e[3] * b + e[7] * c + e[11] * d + e[15]);
        return this.x = (e[0] * b + e[4] * c + e[8] * d + e[12]) * f,
        this.y = (e[1] * b + e[5] * c + e[9] * d + e[13]) * f,
        this.z = (e[2] * b + e[6] * c + e[10] * d + e[14]) * f,
        this
    },
    applyQuaternion: function(a) {
        var b = this.x
          , c = this.y
          , d = this.z
          , e = a.x
          , f = a.y
          , g = a.z
          , h = a.w
          , i = h * b + f * d - g * c
          , j = h * c + g * b - e * d
          , k = h * d + e * c - f * b
          , l = -e * b - f * c - g * d;
        return this.x = i * h + l * -e + j * -g - k * -f,
        this.y = j * h + l * -f + k * -e - i * -g,
        this.z = k * h + l * -g + i * -f - j * -e,
        this
    },
    project: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Matrix4),
            a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)),
            this.applyProjection(a)
        }
    }(),
    unproject: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Matrix4),
            a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)),
            this.applyProjection(a)
        }
    }(),
    transformDirection: function(a) {
        var b = this.x
          , c = this.y
          , d = this.z
          , e = a.elements;
        return this.x = e[0] * b + e[4] * c + e[8] * d,
        this.y = e[1] * b + e[5] * c + e[9] * d,
        this.z = e[2] * b + e[6] * c + e[10] * d,
        this.normalize(),
        this
    },
    divide: function(a) {
        return this.x /= a.x,
        this.y /= a.y,
        this.z /= a.z,
        this
    },
    divideScalar: function(a) {
        return this.multiplyScalar(1 / a)
    },
    min: function(a) {
        return this.x = Math.min(this.x, a.x),
        this.y = Math.min(this.y, a.y),
        this.z = Math.min(this.z, a.z),
        this
    },
    max: function(a) {
        return this.x = Math.max(this.x, a.x),
        this.y = Math.max(this.y, a.y),
        this.z = Math.max(this.z, a.z),
        this
    },
    clamp: function(a, b) {
        return this.x = Math.max(a.x, Math.min(b.x, this.x)),
        this.y = Math.max(a.y, Math.min(b.y, this.y)),
        this.z = Math.max(a.z, Math.min(b.z, this.z)),
        this
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new fm.Vector3,
            b = new fm.Vector3),
            a.set(c, c, c),
            b.set(d, d, d),
            this.clamp(a, b)
        }
    }(),
    clampLength: function(a, b) {
        var c = this.length();
        return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c),
        this
    },
    floor: function() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    },
    ceil: function() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    },
    round: function() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    },
    roundToZero: function() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    },
    negate: function() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    },
    normalize: function() {
        return this.divideScalar(this.length())
    },
    setLength: function(a) {
        return this.multiplyScalar(a / this.length())
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b,
        this.y += (a.y - this.y) * b,
        this.z += (a.z - this.z) * b,
        this
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a),
        this
    },
    cross: function(a, b) {
        if (void 0 !== b)
            return console.warn("fm.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(a, b);
        var c = this.x
          , d = this.y
          , e = this.z;
        return this.x = d * a.z - e * a.y,
        this.y = e * a.x - c * a.z,
        this.z = c * a.y - d * a.x,
        this
    },
    crossVectors: function(a, b) {
        var c = a.x
          , d = a.y
          , e = a.z
          , f = b.x
          , g = b.y
          , h = b.z;
        return this.x = d * h - e * g,
        this.y = e * f - c * h,
        this.z = c * g - d * f,
        this
    },
    projectOnVector: function() {
        var a, b;
        return function(c) {
            return void 0 === a && (a = new fm.Vector3),
            a.copy(c).normalize(),
            b = this.dot(a),
            this.copy(a).multiplyScalar(b)
        }
    }(),
    projectOnPlane: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Vector3),
            a.copy(this).projectOnVector(b),
            this.sub(a)
        }
    }(),
    reflect: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Vector3),
            this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
        }
    }(),
    angleTo: function(a) {
        var b = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());
        return Math.acos(fm.Math.clamp(b, -1, 1))
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x
          , c = this.y - a.y
          , d = this.z - a.z;
        return b * b + c * c + d * d
    },
    setFromSpherical: function(a) {
        var b = Math.sin(a.phi) * a.radius;
        return this.x = b * Math.sin(a.theta),
        this.y = Math.cos(a.phi) * a.radius,
        this.z = b * Math.cos(a.theta),
        this
    },
    setFromMatrixPosition: function(a) {
        return this.setFromMatrixColumn(a, 3)
    },
    setFromMatrixScale: function(a) {
        var b = this.setFromMatrixColumn(a, 0).length()
          , c = this.setFromMatrixColumn(a, 1).length()
          , d = this.setFromMatrixColumn(a, 2).length();
        return this.x = b,
        this.y = c,
        this.z = d,
        this
    },
    setFromMatrixColumn: function(a, b) {
        return "number" == typeof a && (console.warn("fm.Vector3: setFromMatrixColumn now expects ( matrix, index )."),
        a = arguments[1],
        b = arguments[0]),
        this.fromArray(a.elements, 4 * b)
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0),
        this.x = a[b],
        this.y = a[b + 1],
        this.z = a[b + 2],
        this
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []),
        void 0 === b && (b = 0),
        a[b] = this.x,
        a[b + 1] = this.y,
        a[b + 2] = this.z,
        a
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0),
        b = b * a.itemSize + c,
        this.x = a.array[b],
        this.y = a.array[b + 1],
        this.z = a.array[b + 2],
        this
    }
},
fm.Vector4 = function(a, b, c, d) {
    this.x = a || 0,
    this.y = b || 0,
    this.z = c || 0,
    this.w = void 0 !== d ? d : 1
}
,
fm.Vector4.prototype = {
    constructor: fm.Vector4,
    set: function(a, b, c, d) {
        return this.x = a,
        this.y = b,
        this.z = c,
        this.w = d,
        this
    },
    setScalar: function(a) {
        return this.x = a,
        this.y = a,
        this.z = a,
        this.w = a,
        this
    },
    setX: function(a) {
        return this.x = a,
        this
    },
    setY: function(a) {
        return this.y = a,
        this
    },
    setZ: function(a) {
        return this.z = a,
        this
    },
    setW: function(a) {
        return this.w = a,
        this
    },
    setComponent: function(a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        case 2:
            this.z = b;
            break;
        case 3:
            this.w = b;
            break;
        default:
            throw new Error("index is out of range: " + a)
        }
    },
    getComponent: function(a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + a)
        }
    },
    clone: function() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    },
    copy: function(a) {
        return this.x = a.x,
        this.y = a.y,
        this.z = a.z,
        this.w = void 0 !== a.w ? a.w : 1,
        this
    },
    add: function(a, b) {
        return void 0 !== b ? (console.warn("fm.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors(a, b)) : (this.x += a.x,
        this.y += a.y,
        this.z += a.z,
        this.w += a.w,
        this)
    },
    addScalar: function(a) {
        return this.x += a,
        this.y += a,
        this.z += a,
        this.w += a,
        this
    },
    addVectors: function(a, b) {
        return this.x = a.x + b.x,
        this.y = a.y + b.y,
        this.z = a.z + b.z,
        this.w = a.w + b.w,
        this
    },
    addScaledVector: function(a, b) {
        return this.x += a.x * b,
        this.y += a.y * b,
        this.z += a.z * b,
        this.w += a.w * b,
        this
    },
    sub: function(a, b) {
        return void 0 !== b ? (console.warn("fm.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors(a, b)) : (this.x -= a.x,
        this.y -= a.y,
        this.z -= a.z,
        this.w -= a.w,
        this)
    },
    subScalar: function(a) {
        return this.x -= a,
        this.y -= a,
        this.z -= a,
        this.w -= a,
        this
    },
    subVectors: function(a, b) {
        return this.x = a.x - b.x,
        this.y = a.y - b.y,
        this.z = a.z - b.z,
        this.w = a.w - b.w,
        this
    },
    multiplyScalar: function(a) {
        return isFinite(a) ? (this.x *= a,
        this.y *= a,
        this.z *= a,
        this.w *= a) : (this.x = 0,
        this.y = 0,
        this.z = 0,
        this.w = 0),
        this
    },
    applyMatrix4: function(a) {
        var b = this.x
          , c = this.y
          , d = this.z
          , e = this.w
          , f = a.elements;
        return this.x = f[0] * b + f[4] * c + f[8] * d + f[12] * e,
        this.y = f[1] * b + f[5] * c + f[9] * d + f[13] * e,
        this.z = f[2] * b + f[6] * c + f[10] * d + f[14] * e,
        this.w = f[3] * b + f[7] * c + f[11] * d + f[15] * e,
        this
    },
    divideScalar: function(a) {
        return this.multiplyScalar(1 / a)
    },
    setAxisAngleFromQuaternion: function(a) {
        this.w = 2 * Math.acos(a.w);
        var b = Math.sqrt(1 - a.w * a.w);
        return b < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = a.x / b,
        this.y = a.y / b,
        this.z = a.z / b),
        this
    },
    setAxisAngleFromRotationMatrix: function(a) {
        var b, c, d, e, f = .01, g = .1, h = a.elements, i = h[0], j = h[4], k = h[8], l = h[1], m = h[5], n = h[9], o = h[2], p = h[6], q = h[10];
        if (Math.abs(j - l) < f && Math.abs(k - o) < f && Math.abs(n - p) < f) {
            if (Math.abs(j + l) < g && Math.abs(k + o) < g && Math.abs(n + p) < g && Math.abs(i + m + q - 3) < g)
                return this.set(1, 0, 0, 0),
                this;
            b = Math.PI;
            var r = (i + 1) / 2
              , s = (m + 1) / 2
              , t = (q + 1) / 2
              , u = (j + l) / 4
              , v = (k + o) / 4
              , w = (n + p) / 4;
            return r > s && r > t ? r < f ? (c = 0,
            d = .707106781,
            e = .707106781) : (c = Math.sqrt(r),
            d = u / c,
            e = v / c) : s > t ? s < f ? (c = .707106781,
            d = 0,
            e = .707106781) : (d = Math.sqrt(s),
            c = u / d,
            e = w / d) : t < f ? (c = .707106781,
            d = .707106781,
            e = 0) : (e = Math.sqrt(t),
            c = v / e,
            d = w / e),
            this.set(c, d, e, b),
            this
        }
        var x = Math.sqrt((p - n) * (p - n) + (k - o) * (k - o) + (l - j) * (l - j));
        return Math.abs(x) < .001 && (x = 1),
        this.x = (p - n) / x,
        this.y = (k - o) / x,
        this.z = (l - j) / x,
        this.w = Math.acos((i + m + q - 1) / 2),
        this
    },
    min: function(a) {
        return this.x = Math.min(this.x, a.x),
        this.y = Math.min(this.y, a.y),
        this.z = Math.min(this.z, a.z),
        this.w = Math.min(this.w, a.w),
        this
    },
    max: function(a) {
        return this.x = Math.max(this.x, a.x),
        this.y = Math.max(this.y, a.y),
        this.z = Math.max(this.z, a.z),
        this.w = Math.max(this.w, a.w),
        this
    },
    clamp: function(a, b) {
        return this.x = Math.max(a.x, Math.min(b.x, this.x)),
        this.y = Math.max(a.y, Math.min(b.y, this.y)),
        this.z = Math.max(a.z, Math.min(b.z, this.z)),
        this.w = Math.max(a.w, Math.min(b.w, this.w)),
        this
    },
    clampScalar: function() {
        var a, b;
        return function(c, d) {
            return void 0 === a && (a = new fm.Vector4,
            b = new fm.Vector4),
            a.set(c, c, c, c),
            b.set(d, d, d, d),
            this.clamp(a, b)
        }
    }(),
    floor: function() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    },
    ceil: function() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    },
    round: function() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    },
    roundToZero: function() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    },
    negate: function() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    },
    normalize: function() {
        return this.divideScalar(this.length())
    },
    setLength: function(a) {
        return this.multiplyScalar(a / this.length())
    },
    lerp: function(a, b) {
        return this.x += (a.x - this.x) * b,
        this.y += (a.y - this.y) * b,
        this.z += (a.z - this.z) * b,
        this.w += (a.w - this.w) * b,
        this
    },
    lerpVectors: function(a, b, c) {
        return this.subVectors(b, a).multiplyScalar(c).add(a),
        this
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0),
        this.x = a[b],
        this.y = a[b + 1],
        this.z = a[b + 2],
        this.w = a[b + 3],
        this
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []),
        void 0 === b && (b = 0),
        a[b] = this.x,
        a[b + 1] = this.y,
        a[b + 2] = this.z,
        a[b + 3] = this.w,
        a
    },
    fromAttribute: function(a, b, c) {
        return void 0 === c && (c = 0),
        b = b * a.itemSize + c,
        this.x = a.array[b],
        this.y = a.array[b + 1],
        this.z = a.array[b + 2],
        this.w = a.array[b + 3],
        this
    }
},
fm.Box2 = function(a, b) {
    this.min = void 0 !== a ? a : new fm.Vector2((+(1 / 0)),(+(1 / 0))),
    this.max = void 0 !== b ? b : new fm.Vector2((-(1 / 0)),(-(1 / 0)))
}
,
fm.Box2.prototype = {
    constructor: fm.Box2,
    set: function(a, b) {
        return this.min.copy(a),
        this.max.copy(b),
        this
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; b < c; b++)
            this.expandByPoint(a[b]);
        return this
    },
    setFromCenterAndSize: function() {
        var a = new fm.Vector2;
        return function(b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            return this.min.copy(b).sub(d),
            this.max.copy(b).add(d),
            this
        }
    }(),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.min.copy(a.min),
        this.max.copy(a.max),
        this
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = +(1 / 0),
        this.max.x = this.max.y = -(1 / 0),
        this
    },
    isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    },
    center: function(a) {
        var b = a || new fm.Vector2;
        return b.addVectors(this.min, this.max).multiplyScalar(.5)
    },
    size: function(a) {
        var b = a || new fm.Vector2;
        return b.subVectors(this.max, this.min)
    },
    expandByPoint: function(a) {
        return this.min.min(a),
        this.max.max(a),
        this
    },
    expandByVector: function(a) {
        return this.min.sub(a),
        this.max.add(a),
        this
    },
    expandByScalar: function(a) {
        return this.min.addScalar(-a),
        this.max.addScalar(a),
        this
    },
    containsPoint: function(a) {
        return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y)
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
    },
    getParameter: function(a, b) {
        var c = b || new fm.Vector2;
        return c.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
    },
    intersectsBox: function(a) {
        return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y)
    },
    clampPoint: function(a, b) {
        var c = b || new fm.Vector2;
        return c.copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function() {
        var a = new fm.Vector2;
        return function(b) {
            var c = a.copy(b).clamp(this.min, this.max);
            return c.sub(b).length()
        }
    }(),
    intersect: function(a) {
        return this.min.max(a.min),
        this.max.min(a.max),
        this
    },
    union: function(a) {
        return this.min.min(a.min),
        this.max.max(a.max),
        this
    },
    translate: function(a) {
        return this.min.add(a),
        this.max.add(a),
        this
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    }
},
fm.Box3 = function(a, b) {
    this.min = void 0 !== a ? a : new fm.Vector3((+(1 / 0)),(+(1 / 0)),(+(1 / 0))),
    this.max = void 0 !== b ? b : new fm.Vector3((-(1 / 0)),(-(1 / 0)),(-(1 / 0)))
}
,
fm.Box3.prototype = {
    constructor: fm.Box3,
    set: function(a, b) {
        return this.min.copy(a),
        this.max.copy(b),
        this
    },
    setFromArray: function(a) {
        for (var b = +(1 / 0), c = +(1 / 0), d = +(1 / 0), e = -(1 / 0), f = -(1 / 0), g = -(1 / 0), h = 0, i = a.length; h < i; h += 3) {
            var j = a[h]
              , k = a[h + 1]
              , l = a[h + 2];
            j < b && (b = j),
            k < c && (c = k),
            l < d && (d = l),
            j > e && (e = j),
            k > f && (f = k),
            l > g && (g = l)
        }
        this.min.set(b, c, d),
        this.max.set(e, f, g)
    },
    setFromPoints: function(a) {
        this.makeEmpty();
        for (var b = 0, c = a.length; b < c; b++)
            this.expandByPoint(a[b]);
        return this
    },
    setFromCenterAndSize: function() {
        var a = new fm.Vector3;
        return function(b, c) {
            var d = a.copy(c).multiplyScalar(.5);
            return this.min.copy(b).sub(d),
            this.max.copy(b).add(d),
            this
        }
    }(),
    setFromObject: function() {
        var a = new fm.Vector3;
        return function(b) {
            var c = this;
            return b.updateMatrixWorld(!0),
            this.makeEmpty(),
            b.traverse(function(b) {
                var d = b.geometry;
                if (void 0 !== d)
                    if (d instanceof fm.Geometry)
                        for (var e = d.vertices, f = 0, g = e.length; f < g; f++)
                            a.copy(e[f]),
                            a.applyMatrix4(b.matrixWorld),
                            c.expandByPoint(a);
                    else if (d instanceof fm.BufferGeometry && void 0 !== d.attributes.position)
                        for (var h = d.attributes.position.array, f = 0, g = h.length; f < g; f += 3)
                            a.fromArray(h, f),
                            a.applyMatrix4(b.matrixWorld),
                            c.expandByPoint(a)
            }),
            this
        }
    }(),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.min.copy(a.min),
        this.max.copy(a.max),
        this
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = this.min.z = +(1 / 0),
        this.max.x = this.max.y = this.max.z = -(1 / 0),
        this
    },
    isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    },
    center: function(a) {
        var b = a || new fm.Vector3;
        return b.addVectors(this.min, this.max).multiplyScalar(.5)
    },
    size: function(a) {
        var b = a || new fm.Vector3;
        return b.subVectors(this.max, this.min)
    },
    expandByPoint: function(a) {
        return this.min.min(a),
        this.max.max(a),
        this
    },
    expandByVector: function(a) {
        return this.min.sub(a),
        this.max.add(a),
        this
    },
    expandByScalar: function(a) {
        return this.min.addScalar(-a),
        this.max.addScalar(a),
        this
    },
    containsPoint: function(a) {
        return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z)
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
    },
    getParameter: function(a, b) {
        var c = b || new fm.Vector3;
        return c.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
    },
    intersectsBox: function(a) {
        return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z)
    },
    intersectsSphere: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Vector3),
            this.clampPoint(b.center, a),
            a.distanceToSquared(b.center) <= b.radius * b.radius
        }
    }(),
    intersectsPlane: function(a) {
        var b, c;
        return a.normal.x > 0 ? (b = a.normal.x * this.min.x,
        c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x,
        c = a.normal.x * this.min.x),
        a.normal.y > 0 ? (b += a.normal.y * this.min.y,
        c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y,
        c += a.normal.y * this.min.y),
        a.normal.z > 0 ? (b += a.normal.z * this.min.z,
        c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z,
        c += a.normal.z * this.min.z),
        b <= a.constant && c >= a.constant
    },
    clampPoint: function(a, b) {
        var c = b || new fm.Vector3;
        return c.copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function() {
        var a = new fm.Vector3;
        return function(b) {
            var c = a.copy(b).clamp(this.min, this.max);
            return c.sub(b).length()
        }
    }(),
    getBoundingSphere: function() {
        var a = new fm.Vector3;
        return function(b) {
            var c = b || new fm.Sphere;
            return c.center = this.center(),
            c.radius = .5 * this.size(a).length(),
            c
        }
    }(),
    intersect: function(a) {
        return this.min.max(a.min),
        this.max.min(a.max),
        this.isEmpty() && this.makeEmpty(),
        this
    },
    union: function(a) {
        return this.min.min(a.min),
        this.max.max(a.max),
        this
    },
    applyMatrix4: function() {
        var a = [new fm.Vector3, new fm.Vector3, new fm.Vector3, new fm.Vector3, new fm.Vector3, new fm.Vector3, new fm.Vector3, new fm.Vector3];
        return function(b) {
            return this.isEmpty() ? this : (a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b),
            a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b),
            a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b),
            a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b),
            a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b),
            a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b),
            a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b),
            a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b),
            this.setFromPoints(a),
            this)
        }
    }(),
    translate: function(a) {
        return this.min.add(a),
        this.max.add(a),
        this
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    }
},
fm.Color = function(a) {
    return 3 === arguments.length ? this.fromArray(arguments) : this.set(a)
}
,
fm.Color.prototype = {
    constructor: fm.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function(a) {
        return a instanceof fm.Color ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a),
        this
    },
    setScalar: function(a) {
        this.r = a,
        this.g = a,
        this.b = a
    },
    setHex: function(a) {
        return a = Math.floor(a),
        this.r = (a >> 16 & 255) / 255,
        this.g = (a >> 8 & 255) / 255,
        this.b = (255 & a) / 255,
        this
    },
    setRGB: function(a, b, c) {
        return this.r = a,
        this.g = b,
        this.b = c,
        this
    },
    setHSL: function() {
        function a(a, b, c) {
            return c < 0 && (c += 1),
            c > 1 && (c -= 1),
            c < 1 / 6 ? a + 6 * (b - a) * c : c < .5 ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
        }
        return function(b, c, d) {
            if (b = fm.Math.euclideanModulo(b, 1),
            c = fm.Math.clamp(c, 0, 1),
            d = fm.Math.clamp(d, 0, 1),
            0 === c)
                this.r = this.g = this.b = d;
            else {
                var e = d <= .5 ? d * (1 + c) : d + c - d * c
                  , f = 2 * d - e;
                this.r = a(f, e, b + 1 / 3),
                this.g = a(f, e, b),
                this.b = a(f, e, b - 1 / 3)
            }
            return this
        }
    }(),
    setStyle: function(a) {
        function b(b) {
            void 0 !== b && parseFloat(b) < 1 && console.warn("fm.Color: Alpha component of " + a + " will be ignored.")
        }
        var c;
        if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
            var d, e = c[1], f = c[2];
            switch (e) {
            case "rgb":
            case "rgba":
                if (d = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(f))
                    return this.r = Math.min(255, parseInt(d[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(d[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(d[3], 10)) / 255,
                    b(d[5]),
                    this;
                if (d = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(f))
                    return this.r = Math.min(100, parseInt(d[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(d[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(d[3], 10)) / 100,
                    b(d[5]),
                    this;
                break;
            case "hsl":
            case "hsla":
                if (d = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(f)) {
                    var g = parseFloat(d[1]) / 360
                      , h = parseInt(d[2], 10) / 100
                      , i = parseInt(d[3], 10) / 100;
                    return b(d[5]),
                    this.setHSL(g, h, i)
                }
            }
        } else if (c = /^\#([A-Fa-f0-9]+)$/.exec(a)) {
            var j = c[1]
              , k = j.length;
            if (3 === k)
                return this.r = parseInt(j.charAt(0) + j.charAt(0), 16) / 255,
                this.g = parseInt(j.charAt(1) + j.charAt(1), 16) / 255,
                this.b = parseInt(j.charAt(2) + j.charAt(2), 16) / 255,
                this;
            if (6 === k)
                return this.r = parseInt(j.charAt(0) + j.charAt(1), 16) / 255,
                this.g = parseInt(j.charAt(2) + j.charAt(3), 16) / 255,
                this.b = parseInt(j.charAt(4) + j.charAt(5), 16) / 255,
                this
        }
        if (a && a.length > 0) {
            var j = fm.ColorKeywords[a];
            void 0 !== j ? this.setHex(j) : console.warn("fm.Color: Unknown color " + a)
        }
        return this
    },
    clone: function() {
        return new this.constructor(this.r,this.g,this.b)
    },
    copy: function(a) {
        return this.r = a.r,
        this.g = a.g,
        this.b = a.b,
        this
    },
    copyGammaToLinear: function(a, b) {
        return void 0 === b && (b = 2),
        this.r = Math.pow(a.r, b),
        this.g = Math.pow(a.g, b),
        this.b = Math.pow(a.b, b),
        this
    },
    copyLinearToGamma: function(a, b) {
        void 0 === b && (b = 2);
        var c = b > 0 ? 1 / b : 1;
        return this.r = Math.pow(a.r, c),
        this.g = Math.pow(a.g, c),
        this.b = Math.pow(a.b, c),
        this
    },
    convertGammaToLinear: function() {
        var a = this.r
          , b = this.g
          , c = this.b;
        return this.r = a * a,
        this.g = b * b,
        this.b = c * c,
        this
    },
    convertLinearToGamma: function() {
        return this.r = Math.sqrt(this.r),
        this.g = Math.sqrt(this.g),
        this.b = Math.sqrt(this.b),
        this
    },
    getHex: function() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
    },
    getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6)
    },
    getHSL: function(a) {
        var b, c, d = a || {
            h: 0,
            s: 0,
            l: 0
        }, e = this.r, f = this.g, g = this.b, h = Math.max(e, f, g), i = Math.min(e, f, g), j = (i + h) / 2;
        if (i === h)
            b = 0,
            c = 0;
        else {
            var k = h - i;
            switch (c = j <= .5 ? k / (h + i) : k / (2 - h - i),
            h) {
            case e:
                b = (f - g) / k + (f < g ? 6 : 0);
                break;
            case f:
                b = (g - e) / k + 2;
                break;
            case g:
                b = (e - f) / k + 4
            }
            b /= 6
        }
        return d.h = b,
        d.s = c,
        d.l = j,
        d
    },
    getStyle: function() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    },
    offsetHSL: function(a, b, c) {
        var d = this.getHSL();
        return d.h += a,
        d.s += b,
        d.l += c,
        this.setHSL(d.h, d.s, d.l),
        this
    },
    add: function(a) {
        return this.r += a.r,
        this.g += a.g,
        this.b += a.b,
        this
    },
    addColors: function(a, b) {
        return this.r = a.r + b.r,
        this.g = a.g + b.g,
        this.b = a.b + b.b,
        this
    },
    addScalar: function(a) {
        return this.r += a,
        this.g += a,
        this.b += a,
        this
    },
    multiply: function(a) {
        return this.r *= a.r,
        this.g *= a.g,
        this.b *= a.b,
        this
    },
    multiplyScalar: function(a) {
        return this.r *= a,
        this.g *= a,
        this.b *= a,
        this
    },
    lerp: function(a, b) {
        return this.r += (a.r - this.r) * b,
        this.g += (a.g - this.g) * b,
        this.b += (a.b - this.b) * b,
        this
    },
    equals: function(a) {
        return a.r === this.r && a.g === this.g && a.b === this.b
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0),
        this.r = a[b],
        this.g = a[b + 1],
        this.b = a[b + 2],
        this
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []),
        void 0 === b && (b = 0),
        a[b] = this.r,
        a[b + 1] = this.g,
        a[b + 2] = this.b,
        a
    }
},
fm.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
},
fm.Quaternion = function(a, b, c, d) {
    this._x = a || 0,
    this._y = b || 0,
    this._z = c || 0,
    this._w = void 0 !== d ? d : 1
}
,
fm.Quaternion.prototype = {
    constructor: fm.Quaternion,
    get x() {
        return this._x
    },
    set x(a) {
        this._x = a,
        this.onChangeCallback()
    },
    get y() {
        return this._y
    },
    set y(a) {
        this._y = a,
        this.onChangeCallback()
    },
    get z() {
        return this._z
    },
    set z(a) {
        this._z = a,
        this.onChangeCallback()
    },
    get w() {
        return this._w
    },
    set w(a) {
        this._w = a,
        this.onChangeCallback()
    },
    set: function(a, b, c, d) {
        return this._x = a,
        this._y = b,
        this._z = c,
        this._w = d,
        this.onChangeCallback(),
        this
    },
    clone: function() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    },
    copy: function(a) {
        return this._x = a.x,
        this._y = a.y,
        this._z = a.z,
        this._w = a.w,
        this.onChangeCallback(),
        this
    },
    setFromEuler: function(a, b) {
        if (a instanceof fm.Euler == !1)
            throw new Error("fm.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var c = Math.cos(a._x / 2)
          , d = Math.cos(a._y / 2)
          , e = Math.cos(a._z / 2)
          , f = Math.sin(a._x / 2)
          , g = Math.sin(a._y / 2)
          , h = Math.sin(a._z / 2)
          , i = a.order;
        return "XYZ" === i ? (this._x = f * d * e + c * g * h,
        this._y = c * g * e - f * d * h,
        this._z = c * d * h + f * g * e,
        this._w = c * d * e - f * g * h) : "YXZ" === i ? (this._x = f * d * e + c * g * h,
        this._y = c * g * e - f * d * h,
        this._z = c * d * h - f * g * e,
        this._w = c * d * e + f * g * h) : "ZXY" === i ? (this._x = f * d * e - c * g * h,
        this._y = c * g * e + f * d * h,
        this._z = c * d * h + f * g * e,
        this._w = c * d * e - f * g * h) : "ZYX" === i ? (this._x = f * d * e - c * g * h,
        this._y = c * g * e + f * d * h,
        this._z = c * d * h - f * g * e,
        this._w = c * d * e + f * g * h) : "YZX" === i ? (this._x = f * d * e + c * g * h,
        this._y = c * g * e + f * d * h,
        this._z = c * d * h - f * g * e,
        this._w = c * d * e - f * g * h) : "XZY" === i && (this._x = f * d * e - c * g * h,
        this._y = c * g * e - f * d * h,
        this._z = c * d * h + f * g * e,
        this._w = c * d * e + f * g * h),
        b !== !1 && this.onChangeCallback(),
        this
    },
    setFromAxisAngle: function(a, b) {
        var c = b / 2
          , d = Math.sin(c);
        return this._x = a.x * d,
        this._y = a.y * d,
        this._z = a.z * d,
        this._w = Math.cos(c),
        this.onChangeCallback(),
        this
    },
    setFromRotationMatrix: function(a) {
        var b, c = a.elements, d = c[0], e = c[4], f = c[8], g = c[1], h = c[5], i = c[9], j = c[2], k = c[6], l = c[10], m = d + h + l;
        return m > 0 ? (b = .5 / Math.sqrt(m + 1),
        this._w = .25 / b,
        this._x = (k - i) * b,
        this._y = (f - j) * b,
        this._z = (g - e) * b) : d > h && d > l ? (b = 2 * Math.sqrt(1 + d - h - l),
        this._w = (k - i) / b,
        this._x = .25 * b,
        this._y = (e + g) / b,
        this._z = (f + j) / b) : h > l ? (b = 2 * Math.sqrt(1 + h - d - l),
        this._w = (f - j) / b,
        this._x = (e + g) / b,
        this._y = .25 * b,
        this._z = (i + k) / b) : (b = 2 * Math.sqrt(1 + l - d - h),
        this._w = (g - e) / b,
        this._x = (f + j) / b,
        this._y = (i + k) / b,
        this._z = .25 * b),
        this.onChangeCallback(),
        this
    },
    setFromUnitVectors: function() {
        var a, b, c = 1e-6;
        return function(d, e) {
            return void 0 === a && (a = new fm.Vector3),
            b = d.dot(e) + 1,
            b < c ? (b = 0,
            Math.abs(d.x) > Math.abs(d.z) ? a.set(-d.y, d.x, 0) : a.set(0, -d.z, d.y)) : a.crossVectors(d, e),
            this._x = a.x,
            this._y = a.y,
            this._z = a.z,
            this._w = b,
            this.normalize(),
            this
        }
    }(),
    inverse: function() {
        return this.conjugate().normalize(),
        this
    },
    conjugate: function() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this.onChangeCallback(),
        this
    },
    dot: function(a) {
        return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    },
    length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    },
    normalize: function() {
        var a = this.length();
        return 0 === a ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (a = 1 / a,
        this._x = this._x * a,
        this._y = this._y * a,
        this._z = this._z * a,
        this._w = this._w * a),
        this.onChangeCallback(),
        this
    },
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("fm.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
        this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
    },
    multiplyQuaternions: function(a, b) {
        var c = a._x
          , d = a._y
          , e = a._z
          , f = a._w
          , g = b._x
          , h = b._y
          , i = b._z
          , j = b._w;
        return this._x = c * j + f * g + d * i - e * h,
        this._y = d * j + f * h + e * g - c * i,
        this._z = e * j + f * i + c * h - d * g,
        this._w = f * j - c * g - d * h - e * i,
        this.onChangeCallback(),
        this
    },
    slerp: function(a, b) {
        if (0 === b)
            return this;
        if (1 === b)
            return this.copy(a);
        var c = this._x
          , d = this._y
          , e = this._z
          , f = this._w
          , g = f * a._w + c * a._x + d * a._y + e * a._z;
        if (g < 0 ? (this._w = -a._w,
        this._x = -a._x,
        this._y = -a._y,
        this._z = -a._z,
        g = -g) : this.copy(a),
        g >= 1)
            return this._w = f,
            this._x = c,
            this._y = d,
            this._z = e,
            this;
        var h = Math.sqrt(1 - g * g);
        if (Math.abs(h) < .001)
            return this._w = .5 * (f + this._w),
            this._x = .5 * (c + this._x),
            this._y = .5 * (d + this._y),
            this._z = .5 * (e + this._z),
            this;
        var i = Math.atan2(h, g)
          , j = Math.sin((1 - b) * i) / h
          , k = Math.sin(b * i) / h;
        return this._w = f * j + this._w * k,
        this._x = c * j + this._x * k,
        this._y = d * j + this._y * k,
        this._z = e * j + this._z * k,
        this.onChangeCallback(),
        this
    },
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
    },
    fromArray: function(a, b) {
        return void 0 === b && (b = 0),
        this._x = a[b],
        this._y = a[b + 1],
        this._z = a[b + 2],
        this._w = a[b + 3],
        this.onChangeCallback(),
        this
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []),
        void 0 === b && (b = 0),
        a[b] = this._x,
        a[b + 1] = this._y,
        a[b + 2] = this._z,
        a[b + 3] = this._w,
        a
    },
    onChange: function(a) {
        return this.onChangeCallback = a,
        this
    },
    onChangeCallback: function() {}
},
Object.assign(fm.Quaternion, {
    slerp: function(a, b, c, d) {
        return c.copy(a).slerp(b, d)
    },
    slerpFlat: function(a, b, c, d, e, f, g) {
        var h = c[d + 0]
          , i = c[d + 1]
          , j = c[d + 2]
          , k = c[d + 3]
          , l = e[f + 0]
          , m = e[f + 1]
          , n = e[f + 2]
          , o = e[f + 3];
        if (k !== o || h !== l || i !== m || j !== n) {
            var p = 1 - g
              , q = h * l + i * m + j * n + k * o
              , r = q >= 0 ? 1 : -1
              , s = 1 - q * q;
            if (s > Number.EPSILON) {
                var t = Math.sqrt(s)
                  , u = Math.atan2(t, q * r);
                p = Math.sin(p * u) / t,
                g = Math.sin(g * u) / t
            }
            var v = g * r;
            if (h = h * p + l * v,
            i = i * p + m * v,
            j = j * p + n * v,
            k = k * p + o * v,
            p === 1 - g) {
                var w = 1 / Math.sqrt(h * h + i * i + j * j + k * k);
                h *= w,
                i *= w,
                j *= w,
                k *= w
            }
        }
        a[b] = h,
        a[b + 1] = i,
        a[b + 2] = j,
        a[b + 3] = k
    }
}),
fm.Euler = function(a, b, c, d) {
    this._x = a || 0,
    this._y = b || 0,
    this._z = c || 0,
    this._order = d || fm.Euler.DefaultOrder
}
,
fm.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
fm.Euler.DefaultOrder = "XYZ",
fm.Euler.prototype = {
    constructor: fm.Euler,
    get x() {
        return this._x
    },
    set x(a) {
        this._x = a,
        this.onChangeCallback()
    },
    get y() {
        return this._y
    },
    set y(a) {
        this._y = a,
        this.onChangeCallback()
    },
    get z() {
        return this._z
    },
    set z(a) {
        this._z = a,
        this.onChangeCallback()
    },
    get order() {
        return this._order
    },
    set order(a) {
        this._order = a,
        this.onChangeCallback()
    },
    set: function(a, b, c, d) {
        return this._x = a,
        this._y = b,
        this._z = c,
        this._order = d || this._order,
        this.onChangeCallback(),
        this
    },
    clone: function() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    },
    copy: function(a) {
        return this._x = a._x,
        this._y = a._y,
        this._z = a._z,
        this._order = a._order,
        this.onChangeCallback(),
        this
    },
    setFromRotationMatrix: function(a, b, c) {
        var d = fm.Math.clamp
          , e = a.elements
          , f = e[0]
          , g = e[4]
          , h = e[8]
          , i = e[1]
          , j = e[5]
          , k = e[9]
          , l = e[2]
          , m = e[6]
          , n = e[10];
        return b = b || this._order,
        "XYZ" === b ? (this._y = Math.asin(d(h, -1, 1)),
        Math.abs(h) < .99999 ? (this._x = Math.atan2(-k, n),
        this._z = Math.atan2(-g, f)) : (this._x = Math.atan2(m, j),
        this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(k, -1, 1)),
        Math.abs(k) < .99999 ? (this._y = Math.atan2(h, n),
        this._z = Math.atan2(i, j)) : (this._y = Math.atan2(-l, f),
        this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(m, -1, 1)),
        Math.abs(m) < .99999 ? (this._y = Math.atan2(-l, n),
        this._z = Math.atan2(-g, j)) : (this._y = 0,
        this._z = Math.atan2(i, f))) : "ZYX" === b ? (this._y = Math.asin(-d(l, -1, 1)),
        Math.abs(l) < .99999 ? (this._x = Math.atan2(m, n),
        this._z = Math.atan2(i, f)) : (this._x = 0,
        this._z = Math.atan2(-g, j))) : "YZX" === b ? (this._z = Math.asin(d(i, -1, 1)),
        Math.abs(i) < .99999 ? (this._x = Math.atan2(-k, j),
        this._y = Math.atan2(-l, f)) : (this._x = 0,
        this._y = Math.atan2(h, n))) : "XZY" === b ? (this._z = Math.asin(-d(g, -1, 1)),
        Math.abs(g) < .99999 ? (this._x = Math.atan2(m, j),
        this._y = Math.atan2(h, f)) : (this._x = Math.atan2(-k, n),
        this._y = 0)) : console.warn("fm.Euler: .setFromRotationMatrix() given unsupported order: " + b),
        this._order = b,
        c !== !1 && this.onChangeCallback(),
        this
    },
    setFromQuaternion: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeRotationFromQuaternion(b),
            this.setFromRotationMatrix(a, c, d),
            this
        }
    }(),
    setFromVector3: function(a, b) {
        return this.set(a.x, a.y, a.z, b || this._order)
    },
    reorder: function() {
        var a = new fm.Quaternion;
        return function(b) {
            a.setFromEuler(this),
            this.setFromQuaternion(a, b)
        }
    }(),
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
    },
    fromArray: function(a) {
        return this._x = a[0],
        this._y = a[1],
        this._z = a[2],
        void 0 !== a[3] && (this._order = a[3]),
        this.onChangeCallback(),
        this
    },
    toArray: function(a, b) {
        return void 0 === a && (a = []),
        void 0 === b && (b = 0),
        a[b] = this._x,
        a[b + 1] = this._y,
        a[b + 2] = this._z,
        a[b + 3] = this._order,
        a
    },
    toVector3: function(a) {
        return a ? a.set(this._x, this._y, this._z) : new fm.Vector3(this._x,this._y,this._z)
    },
    onChange: function(a) {
        return this.onChangeCallback = a,
        this
    },
    onChangeCallback: function() {}
},
fm.Sphere = function(a, b) {
    this.center = void 0 !== a ? a : new fm.Vector3,
    this.radius = void 0 !== b ? b : 0
}
,
fm.Sphere.prototype = {
    constructor: fm.Sphere,
    set: function(a, b) {
        return this.center.copy(a),
        this.radius = b,
        this
    },
    setFromPoints: function() {
        var a = new fm.Box3;
        return function(b, c) {
            var d = this.center;
            void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
            for (var e = 0, f = 0, g = b.length; f < g; f++)
                e = Math.max(e, d.distanceToSquared(b[f]));
            return this.radius = Math.sqrt(e),
            this
        }
    }(),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.center.copy(a.center),
        this.radius = a.radius,
        this
    },
    empty: function() {
        return this.radius <= 0
    },
    containsPoint: function(a) {
        return a.distanceToSquared(this.center) <= this.radius * this.radius
    },
    distanceToPoint: function(a) {
        return a.distanceTo(this.center) - this.radius
    },
    intersectsSphere: function(a) {
        var b = this.radius + a.radius;
        return a.center.distanceToSquared(this.center) <= b * b
    },
    intersectsBox: function(a) {
        return a.intersectsSphere(this)
    },
    intersectsPlane: function(a) {
        return Math.abs(this.center.dot(a.normal) - a.constant) <= this.radius
    },
    clampPoint: function(a, b) {
        var c = this.center.distanceToSquared(a)
          , d = b || new fm.Vector3;
        return d.copy(a),
        c > this.radius * this.radius && (d.sub(this.center).normalize(),
        d.multiplyScalar(this.radius).add(this.center)),
        d
    },
    getBoundingBox: function(a) {
        var b = a || new fm.Box3;
        return b.set(this.center, this.center),
        b.expandByScalar(this.radius),
        b
    },
    applyMatrix4: function(a) {
        return this.center.applyMatrix4(a),
        this.radius = this.radius * a.getMaxScaleOnAxis(),
        this
    },
    translate: function(a) {
        return this.center.add(a),
        this
    },
    equals: function(a) {
        return a.center.equals(this.center) && a.radius === this.radius
    }
},
fm.Frustum = function(a, b, c, d, e, f) {
    this.planes = [void 0 !== a ? a : new fm.Plane, void 0 !== b ? b : new fm.Plane, void 0 !== c ? c : new fm.Plane, void 0 !== d ? d : new fm.Plane, void 0 !== e ? e : new fm.Plane, void 0 !== f ? f : new fm.Plane]
}
,
fm.Frustum.prototype = {
    constructor: fm.Frustum,
    set: function(a, b, c, d, e, f) {
        var g = this.planes;
        return g[0].copy(a),
        g[1].copy(b),
        g[2].copy(c),
        g[3].copy(d),
        g[4].copy(e),
        g[5].copy(f),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        for (var b = this.planes, c = 0; c < 6; c++)
            b[c].copy(a.planes[c]);
        return this
    },
    setFromMatrix: function(a) {
        var b = this.planes
          , c = a.elements
          , d = c[0]
          , e = c[1]
          , f = c[2]
          , g = c[3]
          , h = c[4]
          , i = c[5]
          , j = c[6]
          , k = c[7]
          , l = c[8]
          , m = c[9]
          , n = c[10]
          , o = c[11]
          , p = c[12]
          , q = c[13]
          , r = c[14]
          , s = c[15];
        return b[0].setComponents(g - d, k - h, o - l, s - p).normalize(),
        b[1].setComponents(g + d, k + h, o + l, s + p).normalize(),
        b[2].setComponents(g + e, k + i, o + m, s + q).normalize(),
        b[3].setComponents(g - e, k - i, o - m, s - q).normalize(),
        b[4].setComponents(g - f, k - j, o - n, s - r).normalize(),
        b[5].setComponents(g + f, k + j, o + n, s + r).normalize(),
        this
    },
    intersectsObject: function() {
        var a = new fm.Sphere;
        return function(b) {
            var c = b.geometry;
            return null === c.boundingSphere && c.computeBoundingSphere(),
            a.copy(c.boundingSphere),
            a.applyMatrix4(b.matrixWorld),
            this.intersectsSphere(a)
        }
    }(),
    intersectsSphere: function(a) {
        for (var b = this.planes, c = a.center, d = -a.radius, e = 0; e < 6; e++) {
            var f = b[e].distanceToPoint(c);
            if (f < d)
                return !1
        }
        return !0
    },
    intersectsBox: function() {
        var a = new fm.Vector3
          , b = new fm.Vector3;
        return function(c) {
            for (var d = this.planes, e = 0; e < 6; e++) {
                var f = d[e];
                a.x = f.normal.x > 0 ? c.min.x : c.max.x,
                b.x = f.normal.x > 0 ? c.max.x : c.min.x,
                a.y = f.normal.y > 0 ? c.min.y : c.max.y,
                b.y = f.normal.y > 0 ? c.max.y : c.min.y,
                a.z = f.normal.z > 0 ? c.min.z : c.max.z,
                b.z = f.normal.z > 0 ? c.max.z : c.min.z;
                var g = f.distanceToPoint(a)
                  , h = f.distanceToPoint(b);
                if (g < 0 && h < 0)
                    return !1
            }
            return !0
        }
    }(),
    containsPoint: function(a) {
        for (var b = this.planes, c = 0; c < 6; c++)
            if (b[c].distanceToPoint(a) < 0)
                return !1;
        return !0
    }
},
fm.Line3 = function(a, b) {
    this.start = void 0 !== a ? a : new fm.Vector3,
    this.end = void 0 !== b ? b : new fm.Vector3
}
,
fm.Line3.prototype = {
    constructor: fm.Line3,
    set: function(a, b) {
        return this.start.copy(a),
        this.end.copy(b),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.start.copy(a.start),
        this.end.copy(a.end),
        this
    },
    center: function(a) {
        var b = a || new fm.Vector3;
        return b.addVectors(this.start, this.end).multiplyScalar(.5)
    },
    delta: function(a) {
        var b = a || new fm.Vector3;
        return b.subVectors(this.end, this.start)
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end)
    },
    distance: function() {
        return this.start.distanceTo(this.end)
    },
    at: function(a, b) {
        var c = b || new fm.Vector3;
        return this.delta(c).multiplyScalar(a).add(this.start)
    },
    closestPointToPointParameter: function() {
        var a = new fm.Vector3
          , b = new fm.Vector3;
        return function(c, d) {
            a.subVectors(c, this.start),
            b.subVectors(this.end, this.start);
            var e = b.dot(b)
              , f = b.dot(a)
              , g = f / e;
            return d && (g = fm.Math.clamp(g, 0, 1)),
            g
        }
    }(),
    closestPointToPoint: function(a, b, c) {
        var d = this.closestPointToPointParameter(a, b)
          , e = c || new fm.Vector3;
        return this.delta(e).multiplyScalar(d).add(this.start)
    },
    applyMatrix4: function(a) {
        return this.start.applyMatrix4(a),
        this.end.applyMatrix4(a),
        this
    },
    equals: function(a) {
        return a.start.equals(this.start) && a.end.equals(this.end)
    }
},
fm.Math = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
        var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), c = new Array(36), d = 0;
        return function() {
            for (var e = 0; e < 36; e++)
                8 === e || 13 === e || 18 === e || 23 === e ? c[e] = "-" : 14 === e ? c[e] = "4" : (d <= 2 && (d = 33554432 + 16777216 * Math.random() | 0),
                a = 15 & d,
                d >>= 4,
                c[e] = b[19 === e ? 3 & a | 8 : a]);
            return c.join("")
        }
    }(),
    clamp: function(a, b, c) {
        return Math.max(b, Math.min(c, a))
    },
    euclideanModulo: function(a, b) {
        return (a % b + b) % b
    },
    mapLinear: function(a, b, c, d, e) {
        return d + (a - b) * (e - d) / (c - b)
    },
    smoothstep: function(a, b, c) {
        return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b),
        a * a * (3 - 2 * a))
    },
    smootherstep: function(a, b, c) {
        return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b),
        a * a * a * (a * (6 * a - 15) + 10))
    },
    random16: function() {
        return console.warn("fm.Math.random16() has been deprecated. Use Math.random() instead."),
        Math.random()
    },
    randInt: function(a, b) {
        return a + Math.floor(Math.random() * (b - a + 1))
    },
    randFloat: function(a, b) {
        return a + Math.random() * (b - a)
    },
    randFloatSpread: function(a) {
        return a * (.5 - Math.random())
    },
    degToRad: function(a) {
        return a * fm.Math.DEG2RAD
    },
    radToDeg: function(a) {
        return a * fm.Math.RAD2DEG
    },
    isPowerOfTwo: function(a) {
        return 0 === (a & a - 1) && 0 !== a
    },
    nearestPowerOfTwo: function(a) {
        return Math.pow(2, Math.round(Math.log(a) / Math.LN2))
    },
    nextPowerOfTwo: function(a) {
        return a--,
        a |= a >> 1,
        a |= a >> 2,
        a |= a >> 4,
        a |= a >> 8,
        a |= a >> 16,
        a++,
        a
    }
},
fm.Matrix3 = function() {
    this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]),
    arguments.length > 0 && console.error("fm.Matrix3: the constructor no longer reads arguments. use .set() instead.")
}
,
fm.Matrix3.prototype = {
    constructor: fm.Matrix3,
    set: function(a, b, c, d, e, f, g, h, i) {
        var j = this.elements;
        return j[0] = a,
        j[1] = d,
        j[2] = g,
        j[3] = b,
        j[4] = e,
        j[5] = h,
        j[6] = c,
        j[7] = f,
        j[8] = i,
        this
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    },
    clone: function() {
        return (new this.constructor).fromArray(this.elements)
    },
    copy: function(a) {
        var b = a.elements;
        return this.set(b[0], b[3], b[6], b[1], b[4], b[7], b[2], b[5], b[8]),
        this
    },
    setFromMatrix4: function(a) {
        var b = a.elements;
        return this.set(b[0], b[4], b[8], b[1], b[5], b[9], b[2], b[6], b[10]),
        this
    },
    applyToVector3Array: function() {
        var a;
        return function(b, c, d) {
            void 0 === a && (a = new fm.Vector3),
            void 0 === c && (c = 0),
            void 0 === d && (d = b.length);
            for (var e = 0, f = c; e < d; e += 3,
            f += 3)
                a.fromArray(b, f),
                a.applyMatrix3(this),
                a.toArray(b, f);
            return b
        }
    }(),
    applyToBuffer: function() {
        var a;
        return function(b, c, d) {
            void 0 === a && (a = new fm.Vector3),
            void 0 === c && (c = 0),
            void 0 === d && (d = b.length / b.itemSize);
            for (var e = 0, f = c; e < d; e++,
            f++)
                a.x = b.getX(f),
                a.y = b.getY(f),
                a.z = b.getZ(f),
                a.applyMatrix3(this),
                b.setXYZ(a.x, a.y, a.z);
            return b
        }
    }(),
    multiplyScalar: function(a) {
        var b = this.elements;
        return b[0] *= a,
        b[3] *= a,
        b[6] *= a,
        b[1] *= a,
        b[4] *= a,
        b[7] *= a,
        b[2] *= a,
        b[5] *= a,
        b[8] *= a,
        this
    },
    determinant: function() {
        var a = this.elements
          , b = a[0]
          , c = a[1]
          , d = a[2]
          , e = a[3]
          , f = a[4]
          , g = a[5]
          , h = a[6]
          , i = a[7]
          , j = a[8];
        return b * f * j - b * g * i - c * e * j + c * g * h + d * e * i - d * f * h
    },
    getInverse: function(a, b) {
        a instanceof fm.Matrix4 && console.error("fm.Matrix3.getInverse no longer takes a Matrix4 argument.");
        var c = a.elements
          , d = this.elements
          , e = c[0]
          , f = c[1]
          , g = c[2]
          , h = c[3]
          , i = c[4]
          , j = c[5]
          , k = c[6]
          , l = c[7]
          , m = c[8]
          , n = m * i - j * l
          , o = j * k - m * h
          , p = l * h - i * k
          , q = e * n + f * o + g * p;
        if (0 === q) {
            var r = "fm.Matrix3.getInverse(): can't invert matrix, determinant is 0";
            if (b)
                throw new Error(r);
            return console.warn(r),
            this.identity()
        }
        return d[0] = n,
        d[1] = g * l - m * f,
        d[2] = j * f - g * i,
        d[3] = o,
        d[4] = m * e - g * k,
        d[5] = g * h - j * e,
        d[6] = p,
        d[7] = f * k - l * e,
        d[8] = i * e - f * h,
        this.multiplyScalar(1 / q)
    },
    transpose: function() {
        var a, b = this.elements;
        return a = b[1],
        b[1] = b[3],
        b[3] = a,
        a = b[2],
        b[2] = b[6],
        b[6] = a,
        a = b[5],
        b[5] = b[7],
        b[7] = a,
        this
    },
    flattenToArrayOffset: function(a, b) {
        return console.warn("fm.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."),
        this.toArray(a, b)
    },
    getNormalMatrix: function(a) {
        return this.setFromMatrix4(a).getInverse(this).transpose()
    },
    transposeIntoArray: function(a) {
        var b = this.elements;
        return a[0] = b[0],
        a[1] = b[3],
        a[2] = b[6],
        a[3] = b[1],
        a[4] = b[4],
        a[5] = b[7],
        a[6] = b[2],
        a[7] = b[5],
        a[8] = b[8],
        this
    },
    fromArray: function(a) {
        return this.elements.set(a),
        this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []),
        void 0 === b && (b = 0);
        var c = this.elements;
        return a[b] = c[0],
        a[b + 1] = c[1],
        a[b + 2] = c[2],
        a[b + 3] = c[3],
        a[b + 4] = c[4],
        a[b + 5] = c[5],
        a[b + 6] = c[6],
        a[b + 7] = c[7],
        a[b + 8] = c[8],
        a
    }
},
fm.Matrix4 = function() {
    this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
    arguments.length > 0 && console.error("fm.Matrix4: the constructor no longer reads arguments. use .set() instead.")
}
,
fm.Matrix4.prototype = {
    constructor: fm.Matrix4,
    set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        var q = this.elements;
        return q[0] = a,
        q[4] = b,
        q[8] = c,
        q[12] = d,
        q[1] = e,
        q[5] = f,
        q[9] = g,
        q[13] = h,
        q[2] = i,
        q[6] = j,
        q[10] = k,
        q[14] = l,
        q[3] = m,
        q[7] = n,
        q[11] = o,
        q[15] = p,
        this
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    },
    clone: function() {
        return (new fm.Matrix4).fromArray(this.elements)
    },
    copy: function(a) {
        return this.elements.set(a.elements),
        this
    },
    copyPosition: function(a) {
        var b = this.elements
          , c = a.elements;
        return b[12] = c[12],
        b[13] = c[13],
        b[14] = c[14],
        this
    },
    extractBasis: function(a, b, c) {
        return a.setFromMatrixColumn(this, 0),
        b.setFromMatrixColumn(this, 1),
        c.setFromMatrixColumn(this, 2),
        this
    },
    makeBasis: function(a, b, c) {
        return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1),
        this
    },
    extractRotation: function() {
        var a;
        return function(b) {
            void 0 === a && (a = new fm.Vector3);
            var c = this.elements
              , d = b.elements
              , e = 1 / a.setFromMatrixColumn(b, 0).length()
              , f = 1 / a.setFromMatrixColumn(b, 1).length()
              , g = 1 / a.setFromMatrixColumn(b, 2).length();
            return c[0] = d[0] * e,
            c[1] = d[1] * e,
            c[2] = d[2] * e,
            c[4] = d[4] * f,
            c[5] = d[5] * f,
            c[6] = d[6] * f,
            c[8] = d[8] * g,
            c[9] = d[9] * g,
            c[10] = d[10] * g,
            this
        }
    }(),
    makeRotationFromEuler: function(a) {
        a instanceof fm.Euler == !1 && console.error("fm.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var b = this.elements
          , c = a.x
          , d = a.y
          , e = a.z
          , f = Math.cos(c)
          , g = Math.sin(c)
          , h = Math.cos(d)
          , i = Math.sin(d)
          , j = Math.cos(e)
          , k = Math.sin(e);
        if ("XYZ" === a.order) {
            var l = f * j
              , m = f * k
              , n = g * j
              , o = g * k;
            b[0] = h * j,
            b[4] = -h * k,
            b[8] = i,
            b[1] = m + n * i,
            b[5] = l - o * i,
            b[9] = -g * h,
            b[2] = o - l * i,
            b[6] = n + m * i,
            b[10] = f * h
        } else if ("YXZ" === a.order) {
            var p = h * j
              , q = h * k
              , r = i * j
              , s = i * k;
            b[0] = p + s * g,
            b[4] = r * g - q,
            b[8] = f * i,
            b[1] = f * k,
            b[5] = f * j,
            b[9] = -g,
            b[2] = q * g - r,
            b[6] = s + p * g,
            b[10] = f * h
        } else if ("ZXY" === a.order) {
            var p = h * j
              , q = h * k
              , r = i * j
              , s = i * k;
            b[0] = p - s * g,
            b[4] = -f * k,
            b[8] = r + q * g,
            b[1] = q + r * g,
            b[5] = f * j,
            b[9] = s - p * g,
            b[2] = -f * i,
            b[6] = g,
            b[10] = f * h
        } else if ("ZYX" === a.order) {
            var l = f * j
              , m = f * k
              , n = g * j
              , o = g * k;
            b[0] = h * j,
            b[4] = n * i - m,
            b[8] = l * i + o,
            b[1] = h * k,
            b[5] = o * i + l,
            b[9] = m * i - n,
            b[2] = -i,
            b[6] = g * h,
            b[10] = f * h
        } else if ("YZX" === a.order) {
            var t = f * h
              , u = f * i
              , v = g * h
              , w = g * i;
            b[0] = h * j,
            b[4] = w - t * k,
            b[8] = v * k + u,
            b[1] = k,
            b[5] = f * j,
            b[9] = -g * j,
            b[2] = -i * j,
            b[6] = u * k + v,
            b[10] = t - w * k
        } else if ("XZY" === a.order) {
            var t = f * h
              , u = f * i
              , v = g * h
              , w = g * i;
            b[0] = h * j,
            b[4] = -k,
            b[8] = i * j,
            b[1] = t * k + w,
            b[5] = f * j,
            b[9] = u * k - v,
            b[2] = v * k - u,
            b[6] = g * j,
            b[10] = w * k + t
        }
        return b[3] = 0,
        b[7] = 0,
        b[11] = 0,
        b[12] = 0,
        b[13] = 0,
        b[14] = 0,
        b[15] = 1,
        this
    },
    makeRotationFromQuaternion: function(a) {
        var b = this.elements
          , c = a.x
          , d = a.y
          , e = a.z
          , f = a.w
          , g = c + c
          , h = d + d
          , i = e + e
          , j = c * g
          , k = c * h
          , l = c * i
          , m = d * h
          , n = d * i
          , o = e * i
          , p = f * g
          , q = f * h
          , r = f * i;
        return b[0] = 1 - (m + o),
        b[4] = k - r,
        b[8] = l + q,
        b[1] = k + r,
        b[5] = 1 - (j + o),
        b[9] = n - p,
        b[2] = l - q,
        b[6] = n + p,
        b[10] = 1 - (j + m),
        b[3] = 0,
        b[7] = 0,
        b[11] = 0,
        b[12] = 0,
        b[13] = 0,
        b[14] = 0,
        b[15] = 1,
        this
    },
    lookAt: function() {
        var a, b, c;
        return function(d, e, f) {
            void 0 === a && (a = new fm.Vector3),
            void 0 === b && (b = new fm.Vector3),
            void 0 === c && (c = new fm.Vector3);
            var g = this.elements;
            return c.subVectors(d, e).normalize(),
            0 === c.lengthSq() && (c.z = 1),
            a.crossVectors(f, c).normalize(),
            0 === a.lengthSq() && (c.x += 1e-4,
            a.crossVectors(f, c).normalize()),
            b.crossVectors(c, a),
            g[0] = a.x,
            g[4] = b.x,
            g[8] = c.x,
            g[1] = a.y,
            g[5] = b.y,
            g[9] = c.y,
            g[2] = a.z,
            g[6] = b.z,
            g[10] = c.z,
            this
        }
    }(),
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("fm.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
        this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
    },
    premultiply: function(a) {
        return this.multiplyMatrices(a, this)
    },
    multiplyMatrices: function(a, b) {
        var c = a.elements
          , d = b.elements
          , e = this.elements
          , f = c[0]
          , g = c[4]
          , h = c[8]
          , i = c[12]
          , j = c[1]
          , k = c[5]
          , l = c[9]
          , m = c[13]
          , n = c[2]
          , o = c[6]
          , p = c[10]
          , q = c[14]
          , r = c[3]
          , s = c[7]
          , t = c[11]
          , u = c[15]
          , v = d[0]
          , w = d[4]
          , x = d[8]
          , y = d[12]
          , z = d[1]
          , A = d[5]
          , B = d[9]
          , C = d[13]
          , D = d[2]
          , E = d[6]
          , F = d[10]
          , G = d[14]
          , H = d[3]
          , I = d[7]
          , J = d[11]
          , K = d[15];
        return e[0] = f * v + g * z + h * D + i * H,
        e[4] = f * w + g * A + h * E + i * I,
        e[8] = f * x + g * B + h * F + i * J,
        e[12] = f * y + g * C + h * G + i * K,
        e[1] = j * v + k * z + l * D + m * H,
        e[5] = j * w + k * A + l * E + m * I,
        e[9] = j * x + k * B + l * F + m * J,
        e[13] = j * y + k * C + l * G + m * K,
        e[2] = n * v + o * z + p * D + q * H,
        e[6] = n * w + o * A + p * E + q * I,
        e[10] = n * x + o * B + p * F + q * J,
        e[14] = n * y + o * C + p * G + q * K,
        e[3] = r * v + s * z + t * D + u * H,
        e[7] = r * w + s * A + t * E + u * I,
        e[11] = r * x + s * B + t * F + u * J,
        e[15] = r * y + s * C + t * G + u * K,
        this
    },
    multiplyToArray: function(a, b, c) {
        var d = this.elements;
        return this.multiplyMatrices(a, b),
        c[0] = d[0],
        c[1] = d[1],
        c[2] = d[2],
        c[3] = d[3],
        c[4] = d[4],
        c[5] = d[5],
        c[6] = d[6],
        c[7] = d[7],
        c[8] = d[8],
        c[9] = d[9],
        c[10] = d[10],
        c[11] = d[11],
        c[12] = d[12],
        c[13] = d[13],
        c[14] = d[14],
        c[15] = d[15],
        this
    },
    multiplyScalar: function(a) {
        var b = this.elements;
        return b[0] *= a,
        b[4] *= a,
        b[8] *= a,
        b[12] *= a,
        b[1] *= a,
        b[5] *= a,
        b[9] *= a,
        b[13] *= a,
        b[2] *= a,
        b[6] *= a,
        b[10] *= a,
        b[14] *= a,
        b[3] *= a,
        b[7] *= a,
        b[11] *= a,
        b[15] *= a,
        this
    },
    applyToVector3Array: function() {
        var a;
        return function(b, c, d) {
            void 0 === a && (a = new fm.Vector3),
            void 0 === c && (c = 0),
            void 0 === d && (d = b.length);
            for (var e = 0, f = c; e < d; e += 3,
            f += 3)
                a.fromArray(b, f),
                a.applyMatrix4(this),
                a.toArray(b, f);
            return b
        }
    }(),
    applyToBuffer: function() {
        var a;
        return function(b, c, d) {
            void 0 === a && (a = new fm.Vector3),
            void 0 === c && (c = 0),
            void 0 === d && (d = b.length / b.itemSize);
            for (var e = 0, f = c; e < d; e++,
            f++)
                a.x = b.getX(f),
                a.y = b.getY(f),
                a.z = b.getZ(f),
                a.applyMatrix4(this),
                b.setXYZ(a.x, a.y, a.z);
            return b
        }
    }(),
    determinant: function() {
        var a = this.elements
          , b = a[0]
          , c = a[4]
          , d = a[8]
          , e = a[12]
          , f = a[1]
          , g = a[5]
          , h = a[9]
          , i = a[13]
          , j = a[2]
          , k = a[6]
          , l = a[10]
          , m = a[14]
          , n = a[3]
          , o = a[7]
          , p = a[11]
          , q = a[15];
        return n * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + o * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + p * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + q * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j)
    },
    transpose: function() {
        var a, b = this.elements;
        return a = b[1],
        b[1] = b[4],
        b[4] = a,
        a = b[2],
        b[2] = b[8],
        b[8] = a,
        a = b[6],
        b[6] = b[9],
        b[9] = a,
        a = b[3],
        b[3] = b[12],
        b[12] = a,
        a = b[7],
        b[7] = b[13],
        b[13] = a,
        a = b[11],
        b[11] = b[14],
        b[14] = a,
        this
    },
    flattenToArrayOffset: function(a, b) {
        return console.warn("fm.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."),
        this.toArray(a, b)
    },
    getPosition: function() {
        var a;
        return function() {
            return void 0 === a && (a = new fm.Vector3),
            console.warn("fm.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            a.setFromMatrixColumn(this, 3)
        }
    }(),
    setPosition: function(a) {
        var b = this.elements;
        return b[12] = a.x,
        b[13] = a.y,
        b[14] = a.z,
        this
    },
    getInverse: function(a, b) {
        var c = this.elements
          , d = a.elements
          , e = d[0]
          , f = d[1]
          , g = d[2]
          , h = d[3]
          , i = d[4]
          , j = d[5]
          , k = d[6]
          , l = d[7]
          , m = d[8]
          , n = d[9]
          , o = d[10]
          , p = d[11]
          , q = d[12]
          , r = d[13]
          , s = d[14]
          , t = d[15]
          , u = n * s * l - r * o * l + r * k * p - j * s * p - n * k * t + j * o * t
          , v = q * o * l - m * s * l - q * k * p + i * s * p + m * k * t - i * o * t
          , w = m * r * l - q * n * l + q * j * p - i * r * p - m * j * t + i * n * t
          , x = q * n * k - m * r * k - q * j * o + i * r * o + m * j * s - i * n * s
          , y = e * u + f * v + g * w + h * x;
        if (0 === y) {
            var z = "fm.Matrix4.getInverse(): can't invert matrix, determinant is 0";
            if (b)
                throw new Error(z);
            return console.warn(z),
            this.identity()
        }
        return c[0] = u,
        c[1] = r * o * h - n * s * h - r * g * p + f * s * p + n * g * t - f * o * t,
        c[2] = j * s * h - r * k * h + r * g * l - f * s * l - j * g * t + f * k * t,
        c[3] = n * k * h - j * o * h - n * g * l + f * o * l + j * g * p - f * k * p,
        c[4] = v,
        c[5] = m * s * h - q * o * h + q * g * p - e * s * p - m * g * t + e * o * t,
        c[6] = q * k * h - i * s * h - q * g * l + e * s * l + i * g * t - e * k * t,
        c[7] = i * o * h - m * k * h + m * g * l - e * o * l - i * g * p + e * k * p,
        c[8] = w,
        c[9] = q * n * h - m * r * h - q * f * p + e * r * p + m * f * t - e * n * t,
        c[10] = i * r * h - q * j * h + q * f * l - e * r * l - i * f * t + e * j * t,
        c[11] = m * j * h - i * n * h - m * f * l + e * n * l + i * f * p - e * j * p,
        c[12] = x,
        c[13] = m * r * g - q * n * g + q * f * o - e * r * o - m * f * s + e * n * s,
        c[14] = q * j * g - i * r * g - q * f * k + e * r * k + i * f * s - e * j * s,
        c[15] = i * n * g - m * j * g + m * f * k - e * n * k - i * f * o + e * j * o,
        this.multiplyScalar(1 / y)
    },
    scale: function(a) {
        var b = this.elements
          , c = a.x
          , d = a.y
          , e = a.z;
        return b[0] *= c,
        b[4] *= d,
        b[8] *= e,
        b[1] *= c,
        b[5] *= d,
        b[9] *= e,
        b[2] *= c,
        b[6] *= d,
        b[10] *= e,
        b[3] *= c,
        b[7] *= d,
        b[11] *= e,
        this
    },
    getMaxScaleOnAxis: function() {
        var a = this.elements
          , b = a[0] * a[0] + a[1] * a[1] + a[2] * a[2]
          , c = a[4] * a[4] + a[5] * a[5] + a[6] * a[6]
          , d = a[8] * a[8] + a[9] * a[9] + a[10] * a[10];
        return Math.sqrt(Math.max(b, c, d))
    },
    makeTranslation: function(a, b, c) {
        return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1),
        this
    },
    makeRotationX: function(a) {
        var b = Math.cos(a)
          , c = Math.sin(a);
        return this.set(1, 0, 0, 0, 0, b, -c, 0, 0, c, b, 0, 0, 0, 0, 1),
        this
    },
    makeRotationY: function(a) {
        var b = Math.cos(a)
          , c = Math.sin(a);
        return this.set(b, 0, c, 0, 0, 1, 0, 0, -c, 0, b, 0, 0, 0, 0, 1),
        this
    },
    makeRotationZ: function(a) {
        var b = Math.cos(a)
          , c = Math.sin(a);
        return this.set(b, -c, 0, 0, c, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    },
    makeRotationAxis: function(a, b) {
        var c = Math.cos(b)
          , d = Math.sin(b)
          , e = 1 - c
          , f = a.x
          , g = a.y
          , h = a.z
          , i = e * f
          , j = e * g;
        return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1),
        this
    },
    makeScale: function(a, b, c) {
        return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1),
        this
    },
    compose: function(a, b, c) {
        return this.makeRotationFromQuaternion(b),
        this.scale(c),
        this.setPosition(a),
        this
    },
    decompose: function() {
        var a, b;
        return function(c, d, e) {
            void 0 === a && (a = new fm.Vector3),
            void 0 === b && (b = new fm.Matrix4);
            var f = this.elements
              , g = a.set(f[0], f[1], f[2]).length()
              , h = a.set(f[4], f[5], f[6]).length()
              , i = a.set(f[8], f[9], f[10]).length()
              , j = this.determinant();
            j < 0 && (g = -g),
            c.x = f[12],
            c.y = f[13],
            c.z = f[14],
            b.elements.set(this.elements);
            var k = 1 / g
              , l = 1 / h
              , m = 1 / i;
            return b.elements[0] *= k,
            b.elements[1] *= k,
            b.elements[2] *= k,
            b.elements[4] *= l,
            b.elements[5] *= l,
            b.elements[6] *= l,
            b.elements[8] *= m,
            b.elements[9] *= m,
            b.elements[10] *= m,
            d.setFromRotationMatrix(b),
            e.x = g,
            e.y = h,
            e.z = i,
            this
        }
    }(),
    makeFrustum: function(a, b, c, d, e, f) {
        var g = this.elements
          , h = 2 * e / (b - a)
          , i = 2 * e / (d - c)
          , j = (b + a) / (b - a)
          , k = (d + c) / (d - c)
          , l = -(f + e) / (f - e)
          , m = -2 * f * e / (f - e);
        return g[0] = h,
        g[4] = 0,
        g[8] = j,
        g[12] = 0,
        g[1] = 0,
        g[5] = i,
        g[9] = k,
        g[13] = 0,
        g[2] = 0,
        g[6] = 0,
        g[10] = l,
        g[14] = m,
        g[3] = 0,
        g[7] = 0,
        g[11] = -1,
        g[15] = 0,
        this
    },
    makePerspective: function(a, b, c, d) {
        var e = c * Math.tan(fm.Math.DEG2RAD * a * .5)
          , f = -e
          , g = f * b
          , h = e * b;
        return this.makeFrustum(g, h, f, e, c, d)
    },
    makeOrthographic: function(a, b, c, d, e, f) {
        var g = this.elements
          , h = 1 / (b - a)
          , i = 1 / (c - d)
          , j = 1 / (f - e)
          , k = (b + a) * h
          , l = (c + d) * i
          , m = (f + e) * j;
        return g[0] = 2 * h,
        g[4] = 0,
        g[8] = 0,
        g[12] = -k,
        g[1] = 0,
        g[5] = 2 * i,
        g[9] = 0,
        g[13] = -l,
        g[2] = 0,
        g[6] = 0,
        g[10] = -2 * j,
        g[14] = -m,
        g[3] = 0,
        g[7] = 0,
        g[11] = 0,
        g[15] = 1,
        this
    },
    equals: function(a) {
        for (var b = this.elements, c = a.elements, d = 0; d < 16; d++)
            if (b[d] !== c[d])
                return !1;
        return !0
    },
    fromArray: function(a) {
        return this.elements.set(a),
        this
    },
    toArray: function(a, b) {
        void 0 === a && (a = []),
        void 0 === b && (b = 0);
        var c = this.elements;
        return a[b] = c[0],
        a[b + 1] = c[1],
        a[b + 2] = c[2],
        a[b + 3] = c[3],
        a[b + 4] = c[4],
        a[b + 5] = c[5],
        a[b + 6] = c[6],
        a[b + 7] = c[7],
        a[b + 8] = c[8],
        a[b + 9] = c[9],
        a[b + 10] = c[10],
        a[b + 11] = c[11],
        a[b + 12] = c[12],
        a[b + 13] = c[13],
        a[b + 14] = c[14],
        a[b + 15] = c[15],
        a
    }
},
fm.Plane = function(a, b) {
    this.normal = void 0 !== a ? a : new fm.Vector3(1,0,0),
    this.constant = void 0 !== b ? b : 0
}
,
fm.Plane.prototype = {
    constructor: fm.Plane,
    set: function(a, b) {
        return this.normal.copy(a),
        this.constant = b,
        this
    },
    setComponents: function(a, b, c, d) {
        return this.normal.set(a, b, c),
        this.constant = d,
        this
    },
    setFromNormalAndCoplanarPoint: function(a, b) {
        return this.normal.copy(a),
        this.constant = -b.dot(this.normal),
        this
    },
    setFromCoplanarPoints: function() {
        var a = new fm.Vector3
          , b = new fm.Vector3;
        return function(c, d, e) {
            var f = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
            return this.setFromNormalAndCoplanarPoint(f, c),
            this
        }
    }(),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.normal.copy(a.normal),
        this.constant = a.constant,
        this
    },
    normalize: function() {
        var a = 1 / this.normal.length();
        return this.normal.multiplyScalar(a),
        this.constant *= a,
        this
    },
    negate: function() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    },
    distanceToPoint: function(a) {
        return this.normal.dot(a) + this.constant
    },
    distanceToSphere: function(a) {
        return this.distanceToPoint(a.center) - a.radius
    },
    projectPoint: function(a, b) {
        return this.orthoPoint(a, b).sub(a).negate()
    },
    orthoPoint: function(a, b) {
        var c = this.distanceToPoint(a)
          , d = b || new fm.Vector3;
        return d.copy(this.normal).multiplyScalar(c)
    },
    intersectLine: function() {
        var a = new fm.Vector3;
        return function(b, c) {
            var d = c || new fm.Vector3
              , e = b.delta(a)
              , f = this.normal.dot(e);
            if (0 !== f) {
                var g = -(b.start.dot(this.normal) + this.constant) / f;
                if (!(g < 0 || g > 1))
                    return d.copy(e).multiplyScalar(g).add(b.start)
            } else if (0 === this.distanceToPoint(b.start))
                return d.copy(b.start)
        }
    }(),
    intersectsLine: function(a) {
        var b = this.distanceToPoint(a.start)
          , c = this.distanceToPoint(a.end);
        return b < 0 && c > 0 || c < 0 && b > 0
    },
    intersectsBox: function(a) {
        return a.intersectsPlane(this)
    },
    intersectsSphere: function(a) {
        return a.intersectsPlane(this)
    },
    coplanarPoint: function(a) {
        var b = a || new fm.Vector3;
        return b.copy(this.normal).multiplyScalar(-this.constant)
    },
    applyMatrix4: function() {
        var a = new fm.Vector3
          , b = new fm.Matrix3;
        return function(c, d) {
            var e = this.coplanarPoint(a).applyMatrix4(c)
              , f = d || b.getNormalMatrix(c)
              , g = this.normal.applyMatrix3(f).normalize();
            return this.constant = -e.dot(g),
            this
        }
    }(),
    translate: function(a) {
        return this.constant = this.constant - a.dot(this.normal),
        this
    },
    equals: function(a) {
        return a.normal.equals(this.normal) && a.constant === this.constant
    }
},
fm.Ray = function(a, b) {
    this.origin = void 0 !== a ? a : new fm.Vector3,
    this.direction = void 0 !== b ? b : new fm.Vector3
}
,
fm.Ray.prototype = {
    constructor: fm.Ray,
    set: function(a, b) {
        return this.origin.copy(a),
        this.direction.copy(b),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.origin.copy(a.origin),
        this.direction.copy(a.direction),
        this
    },
    at: function(a, b) {
        var c = b || new fm.Vector3;
        return c.copy(this.direction).multiplyScalar(a).add(this.origin)
    },
    lookAt: function(a) {
        this.direction.copy(a).sub(this.origin).normalize()
    },
    recast: function() {
        var a = new fm.Vector3;
        return function(b) {
            return this.origin.copy(this.at(b, a)),
            this
        }
    }(),
    closestPointToPoint: function(a, b) {
        var c = b || new fm.Vector3;
        c.subVectors(a, this.origin);
        var d = c.dot(this.direction);
        return d < 0 ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
    },
    distanceToPoint: function(a) {
        return Math.sqrt(this.distanceSqToPoint(a))
    },
    distanceSqToPoint: function() {
        var a = new fm.Vector3;
        return function(b) {
            var c = a.subVectors(b, this.origin).dot(this.direction);
            return c < 0 ? this.origin.distanceToSquared(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin),
            a.distanceToSquared(b))
        }
    }(),
    distanceSqToSegment: function() {
        var a = new fm.Vector3
          , b = new fm.Vector3
          , c = new fm.Vector3;
        return function(d, e, f, g) {
            a.copy(d).add(e).multiplyScalar(.5),
            b.copy(e).sub(d).normalize(),
            c.copy(this.origin).sub(a);
            var h, i, j, k, l = .5 * d.distanceTo(e), m = -this.direction.dot(b), n = c.dot(this.direction), o = -c.dot(b), p = c.lengthSq(), q = Math.abs(1 - m * m);
            if (q > 0)
                if (h = m * o - n,
                i = m * n - o,
                k = l * q,
                h >= 0)
                    if (i >= -k)
                        if (i <= k) {
                            var r = 1 / q;
                            h *= r,
                            i *= r,
                            j = h * (h + m * i + 2 * n) + i * (m * h + i + 2 * o) + p
                        } else
                            i = l,
                            h = Math.max(0, -(m * i + n)),
                            j = -h * h + i * (i + 2 * o) + p;
                    else
                        i = -l,
                        h = Math.max(0, -(m * i + n)),
                        j = -h * h + i * (i + 2 * o) + p;
                else
                    i <= -k ? (h = Math.max(0, -(-m * l + n)),
                    i = h > 0 ? -l : Math.min(Math.max(-l, -o), l),
                    j = -h * h + i * (i + 2 * o) + p) : i <= k ? (h = 0,
                    i = Math.min(Math.max(-l, -o), l),
                    j = i * (i + 2 * o) + p) : (h = Math.max(0, -(m * l + n)),
                    i = h > 0 ? l : Math.min(Math.max(-l, -o), l),
                    j = -h * h + i * (i + 2 * o) + p);
            else
                i = m > 0 ? -l : l,
                h = Math.max(0, -(m * i + n)),
                j = -h * h + i * (i + 2 * o) + p;
            return f && f.copy(this.direction).multiplyScalar(h).add(this.origin),
            g && g.copy(b).multiplyScalar(i).add(a),
            j
        }
    }(),
    intersectSphere: function() {
        var a = new fm.Vector3;
        return function(b, c) {
            a.subVectors(b.center, this.origin);
            var d = a.dot(this.direction)
              , e = a.dot(a) - d * d
              , f = b.radius * b.radius;
            if (e > f)
                return null ;
            var g = Math.sqrt(f - e)
              , h = d - g
              , i = d + g;
            return h < 0 && i < 0 ? null : h < 0 ? this.at(i, c) : this.at(h, c)
        }
    }(),
    intersectsSphere: function(a) {
        return this.distanceToPoint(a.center) <= a.radius
    },
    distanceToPlane: function(a) {
        var b = a.normal.dot(this.direction);
        if (0 === b)
            return 0 === a.distanceToPoint(this.origin) ? 0 : null ;
        var c = -(this.origin.dot(a.normal) + a.constant) / b;
        return c >= 0 ? c : null
    },
    intersectPlane: function(a, b) {
        var c = this.distanceToPlane(a);
        return null === c ? null : this.at(c, b)
    },
    intersectsPlane: function(a) {
        var b = a.distanceToPoint(this.origin);
        if (0 === b)
            return !0;
        var c = a.normal.dot(this.direction);
        return c * b < 0
    },
    intersectBox: function(a, b) {
        var c, d, e, f, g, h, i = 1 / this.direction.x, j = 1 / this.direction.y, k = 1 / this.direction.z, l = this.origin;
        return i >= 0 ? (c = (a.min.x - l.x) * i,
        d = (a.max.x - l.x) * i) : (c = (a.max.x - l.x) * i,
        d = (a.min.x - l.x) * i),
        j >= 0 ? (e = (a.min.y - l.y) * j,
        f = (a.max.y - l.y) * j) : (e = (a.max.y - l.y) * j,
        f = (a.min.y - l.y) * j),
        c > f || e > d ? null : ((e > c || c !== c) && (c = e),
        (f < d || d !== d) && (d = f),
        k >= 0 ? (g = (a.min.z - l.z) * k,
        h = (a.max.z - l.z) * k) : (g = (a.max.z - l.z) * k,
        h = (a.min.z - l.z) * k),
        c > h || g > d ? null : ((g > c || c !== c) && (c = g),
        (h < d || d !== d) && (d = h),
        d < 0 ? null : this.at(c >= 0 ? c : d, b)))
    },
    intersectsBox: function() {
        var a = new fm.Vector3;
        return function(b) {
            return null !== this.intersectBox(b, a)
        }
    }(),
    intersectTriangle: function() {
        var a = new fm.Vector3
          , b = new fm.Vector3
          , c = new fm.Vector3
          , d = new fm.Vector3;
        return function(e, f, g, h, i) {
            b.subVectors(f, e),
            c.subVectors(g, e),
            d.crossVectors(b, c);
            var j, k = this.direction.dot(d);
            if (k > 0) {
                if (h)
                    return null ;
                j = 1
            } else {
                if (!(k < 0))
                    return null ;
                j = -1,
                k = -k
            }
            a.subVectors(this.origin, e);
            var l = j * this.direction.dot(c.crossVectors(a, c));
            if (l < 0)
                return null ;
            var m = j * this.direction.dot(b.cross(a));
            if (m < 0)
                return null ;
            if (l + m > k)
                return null ;
            var n = -j * a.dot(d);
            return n < 0 ? null : this.at(n / k, i)
        }
    }(),
    applyMatrix4: function(a) {
        return this.direction.add(this.origin).applyMatrix4(a),
        this.origin.applyMatrix4(a),
        this.direction.sub(this.origin),
        this.direction.normalize(),
        this
    },
    equals: function(a) {
        return a.origin.equals(this.origin) && a.direction.equals(this.direction)
    }
},
fm.Spherical = function(a, b, c) {
    return this.radius = void 0 !== a ? a : 1,
    this.phi = void 0 !== b ? b : 0,
    this.theta = void 0 !== c ? c : 0,
    this
}
,
fm.Spherical.prototype = {
    constructor: fm.Spherical,
    set: function(a, b, c) {
        this.radius = a,
        this.phi = b,
        this.theta = c
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.radius.copy(a.radius),
        this.phi.copy(a.phi),
        this.theta.copy(a.theta),
        this
    },
    makeSafe: function() {
        var a = 1e-6;
        this.phi = Math.max(a, Math.min(Math.PI - a, this.phi))
    },
    setFromVector3: function(a) {
        return this.radius = a.length(),
        0 === this.radius ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(a.x, a.z),
        this.phi = Math.acos(fm.Math.clamp(a.y / this.radius, -1, 1))),
        this
    }
},
fm.Spline = function(a) {
    function b(a, b, c, d, e, f, g) {
        var h = .5 * (c - a)
          , i = .5 * (d - b);
        return (2 * (b - c) + h + i) * g + (-3 * (b - c) - 2 * h - i) * f + h * e + b
    }
    this.points = a;
    var c, d, e, f, g, h, i, j, k, l = [], m = {
        x: 0,
        y: 0,
        z: 0
    };
    this.initFromArray = function(a) {
        this.points = [];
        for (var b = 0; b < a.length; b++)
            this.points[b] = {
                x: a[b][0],
                y: a[b][1],
                z: a[b][2]
            }
    }
    ,
    this.getPoint = function(a) {
        return c = (this.points.length - 1) * a,
        d = Math.floor(c),
        e = c - d,
        l[0] = 0 === d ? d : d - 1,
        l[1] = d,
        l[2] = d > this.points.length - 2 ? this.points.length - 1 : d + 1,
        l[3] = d > this.points.length - 3 ? this.points.length - 1 : d + 2,
        h = this.points[l[0]],
        i = this.points[l[1]],
        j = this.points[l[2]],
        k = this.points[l[3]],
        f = e * e,
        g = e * f,
        m.x = b(h.x, i.x, j.x, k.x, e, f, g),
        m.y = b(h.y, i.y, j.y, k.y, e, f, g),
        m.z = b(h.z, i.z, j.z, k.z, e, f, g),
        m
    }
    ,
    this.getControlPointsArray = function() {
        var a, b, c = this.points.length, d = [];
        for (a = 0; a < c; a++)
            b = this.points[a],
            d[a] = [b.x, b.y, b.z];
        return d
    }
    ,
    this.getLength = function(a) {
        var b, c, d, e, f = 0, g = 0, h = 0, i = new fm.Vector3, j = new fm.Vector3, k = [], l = 0;
        for (k[0] = 0,
        a || (a = 100),
        d = this.points.length * a,
        i.copy(this.points[0]),
        b = 1; b < d; b++)
            c = b / d,
            e = this.getPoint(c),
            j.copy(e),
            l += j.distanceTo(i),
            i.copy(e),
            f = (this.points.length - 1) * c,
            g = Math.floor(f),
            g !== h && (k[g] = l,
            h = g);
        return k[k.length] = l,
        {
            chunks: k,
            total: l
        }
    }
    ,
    this.reparametrizeByArcLength = function(a) {
        var b, c, d, e, f, g, h, i, j = [], k = new fm.Vector3, l = this.getLength();
        for (j.push(k.copy(this.points[0]).clone()),
        b = 1; b < this.points.length; b++) {
            for (g = l.chunks[b] - l.chunks[b - 1],
            h = Math.ceil(a * g / l.total),
            e = (b - 1) / (this.points.length - 1),
            f = b / (this.points.length - 1),
            c = 1; c < h - 1; c++)
                d = e + c * (1 / h) * (f - e),
                i = this.getPoint(d),
                j.push(k.copy(i).clone());
            j.push(k.copy(this.points[b]).clone())
        }
        this.points = j
    }
}
,
fm.Triangle = function(a, b, c) {
    this.a = void 0 !== a ? a : new fm.Vector3,
    this.b = void 0 !== b ? b : new fm.Vector3,
    this.c = void 0 !== c ? c : new fm.Vector3
}
,
fm.Triangle.normal = function() {
    var a = new fm.Vector3;
    return function(b, c, d, e) {
        var f = e || new fm.Vector3;
        f.subVectors(d, c),
        a.subVectors(b, c),
        f.cross(a);
        var g = f.lengthSq();
        return g > 0 ? f.multiplyScalar(1 / Math.sqrt(g)) : f.set(0, 0, 0)
    }
}(),
fm.Triangle.barycoordFromPoint = function() {
    var a = new fm.Vector3
      , b = new fm.Vector3
      , c = new fm.Vector3;
    return function(d, e, f, g, h) {
        a.subVectors(g, e),
        b.subVectors(f, e),
        c.subVectors(d, e);
        var i = a.dot(a)
          , j = a.dot(b)
          , k = a.dot(c)
          , l = b.dot(b)
          , m = b.dot(c)
          , n = i * l - j * j
          , o = h || new fm.Vector3;
        if (0 === n)
            return o.set(-2, -1, -1);
        var p = 1 / n
          , q = (l * k - j * m) * p
          , r = (i * m - j * k) * p;
        return o.set(1 - q - r, r, q)
    }
}(),
fm.Triangle.containsPoint = function() {
    var a = new fm.Vector3;
    return function(b, c, d, e) {
        var f = fm.Triangle.barycoordFromPoint(b, c, d, e, a);
        return f.x >= 0 && f.y >= 0 && f.x + f.y <= 1
    }
}(),
fm.Triangle.prototype = {
    constructor: fm.Triangle,
    set: function(a, b, c) {
        return this.a.copy(a),
        this.b.copy(b),
        this.c.copy(c),
        this
    },
    setFromPointsAndIndices: function(a, b, c, d) {
        return this.a.copy(a[b]),
        this.b.copy(a[c]),
        this.c.copy(a[d]),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.a.copy(a.a),
        this.b.copy(a.b),
        this.c.copy(a.c),
        this
    },
    area: function() {
        var a = new fm.Vector3
          , b = new fm.Vector3;
        return function() {
            return a.subVectors(this.c, this.b),
            b.subVectors(this.a, this.b),
            .5 * a.cross(b).length()
        }
    }(),
    midpoint: function(a) {
        var b = a || new fm.Vector3;
        return b.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    },
    normal: function(a) {
        return fm.Triangle.normal(this.a, this.b, this.c, a)
    },
    plane: function(a) {
        var b = a || new fm.Plane;
        return b.setFromCoplanarPoints(this.a, this.b, this.c)
    },
    barycoordFromPoint: function(a, b) {
        return fm.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
    },
    containsPoint: function(a) {
        return fm.Triangle.containsPoint(a, this.a, this.b, this.c)
    },
    closestPointToPoint: function() {
        var a, b, c, d;
        return function(e, f) {
            void 0 === a && (a = new fm.Plane,
            b = [new fm.Line3, new fm.Line3, new fm.Line3],
            c = new fm.Vector3,
            d = new fm.Vector3);
            var g = f || new fm.Vector3
              , h = 1 / 0;
            if (a.setFromCoplanarPoints(this.a, this.b, this.c),
            a.projectPoint(e, c),
            this.containsPoint(c) === !0)
                g.copy(c);
            else {
                b[0].set(this.a, this.b),
                b[1].set(this.b, this.c),
                b[2].set(this.c, this.a);
                for (var i = 0; i < b.length; i++) {
                    b[i].closestPointToPoint(c, !0, d);
                    var j = c.distanceToSquared(d);
                    j < h && (h = j,
                    g.copy(d))
                }
            }
            return g
        }
    }(),
    equals: function(a) {
        return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
    }
},
fm.EventDispatcher = function() {}
,
fm.EventDispatcher.prototype = {
    constructor: fm.EventDispatcher,
    apply: function(a) {
        a.addEventListener = fm.EventDispatcher.prototype.addEventListener,
        a.hasEventListener = fm.EventDispatcher.prototype.hasEventListener,
        a.removeEventListener = fm.EventDispatcher.prototype.removeEventListener,
        a.dispatchEvent = fm.EventDispatcher.prototype.dispatchEvent
    },
    addEventListener: function(a, b) {
        void 0 === this._listeners && (this._listeners = {});
        var c = this._listeners;
        void 0 === c[a] && (c[a] = []),
        c[a].indexOf(b) === -1 && c[a].push(b)
    },
    hasEventListener: function(a, b) {
        if (void 0 === this._listeners)
            return !1;
        var c = this._listeners;
        return void 0 !== c[a] && c[a].indexOf(b) !== -1
    },
    removeEventListener: function(a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners
              , d = c[a];
            if (void 0 !== d) {
                var e = d.indexOf(b);
                e !== -1 && d.splice(e, 1)
            }
        }
    },
    dispatchEvent: function(a) {
        if (void 0 !== this._listeners) {
            var b = this._listeners
              , c = b[a.type];
            if (void 0 !== c) {
                a.target = this;
                for (var d = [], e = c.length, f = 0; f < e; f++)
                    d[f] = c[f];
                for (var f = 0; f < e; f++)
                    d[f].call(this, a)
            }
        }
    }
},
fm.Clock = function(a) {
    this.autoStart = void 0 === a || a,
    this.startTime = 0,
    this.oldTime = 0,
    this.elapsedTime = 0,
    this.running = !1
}
,
fm.Clock.prototype = {
    constructor: fm.Clock,
    start: function() {
        this.startTime = (performance || Date).now(),
        this.oldTime = this.startTime,
        this.running = !0
    },
    stop: function() {
        this.getElapsedTime(),
        this.running = !1
    },
    getElapsedTime: function() {
        return this.getDelta(),
        this.elapsedTime
    },
    getDelta: function() {
        var a = 0;
        if (this.autoStart && !this.running && this.start(),
        this.running) {
            var b = (performance || Date).now();
            a = (b - this.oldTime) / 1e3,
            this.oldTime = b,
            this.elapsedTime += a
        }
        return a
    }
},
fm.Geometry = function() {
    Object.defineProperty(this, "id", {
        value: fm.GeometryIdCount++
    }),
    this.uuid = fm.Math.generateUUID(),
    this.name = "",
    this.type = "Geometry",
    this.vertices = [],
    this.colors = [],
    this.faces = [],
    this.faceVertexUvs = [[]],
    this.morphTargets = [],
    this.morphNormals = [],
    this.skinWeights = [],
    this.skinIndices = [],
    this.lineDistances = [],
    this.boundingBox = null ,
    this.boundingSphere = null ,
    this.verticesNeedUpdate = !1,
    this.elementsNeedUpdate = !1,
    this.uvsNeedUpdate = !1,
    this.normalsNeedUpdate = !1,
    this.colorsNeedUpdate = !1,
    this.lineDistancesNeedUpdate = !1,
    this.groupsNeedUpdate = !1
}
,
fm.Geometry.prototype = {
    constructor: fm.Geometry,
    applyMatrix: function(a) {
        for (var b = (new fm.Matrix3).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) {
            var e = this.vertices[c];
            e.applyMatrix4(a)
        }
        for (var c = 0, d = this.faces.length; c < d; c++) {
            var f = this.faces[c];
            f.normal.applyMatrix3(b).normalize();
            for (var g = 0, h = f.vertexNormals.length; g < h; g++)
                f.vertexNormals[g].applyMatrix3(b).normalize()
        }
        return null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this.verticesNeedUpdate = !0,
        this.normalsNeedUpdate = !0,
        this
    },
    rotateX: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeRotationX(b),
            this.applyMatrix(a),
            this
        }
    }(),
    rotateY: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeRotationY(b),
            this.applyMatrix(a),
            this
        }
    }(),
    rotateZ: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeRotationZ(b),
            this.applyMatrix(a),
            this
        }
    }(),
    translate: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeTranslation(b, c, d),
            this.applyMatrix(a),
            this
        }
    }(),
    scale: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeScale(b, c, d),
            this.applyMatrix(a),
            this
        }
    }(),
    lookAt: function() {
        var a;
        return function(b) {
            void 0 === a && (a = new fm.Object3D),
            a.lookAt(b),
            a.updateMatrix(),
            this.applyMatrix(a.matrix)
        }
    }(),
    fromBufferGeometry: function(a) {
        function b(a, b, d, e) {
            var f = void 0 !== g ? [k[a].clone(), k[b].clone(), k[d].clone()] : []
              , n = void 0 !== h ? [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()] : []
              , o = new fm.Face3(a,b,d,f,n,e);
            c.faces.push(o),
            void 0 !== i && c.faceVertexUvs[0].push([l[a].clone(), l[b].clone(), l[d].clone()]),
            void 0 !== j && c.faceVertexUvs[1].push([m[a].clone(), m[b].clone(), m[d].clone()])
        }
        var c = this
          , d = null !== a.index ? a.index.array : void 0
          , e = a.attributes
          , f = e.position.array
          , g = void 0 !== e.normal ? e.normal.array : void 0
          , h = void 0 !== e.color ? e.color.array : void 0
          , i = void 0 !== e.uv ? e.uv.array : void 0
          , j = void 0 !== e.uv2 ? e.uv2.array : void 0;
        void 0 !== j && (this.faceVertexUvs[1] = []);
        for (var k = [], l = [], m = [], n = 0, o = 0; n < f.length; n += 3,
        o += 2)
            c.vertices.push(new fm.Vector3(f[n],f[n + 1],f[n + 2])),
            void 0 !== g && k.push(new fm.Vector3(g[n],g[n + 1],g[n + 2])),
            void 0 !== h && c.colors.push(new fm.Color(h[n],h[n + 1],h[n + 2])),
            void 0 !== i && l.push(new fm.Vector2(i[o],i[o + 1])),
            void 0 !== j && m.push(new fm.Vector2(j[o],j[o + 1]));
        if (void 0 !== d) {
            var p = a.groups;
            if (p.length > 0)
                for (var n = 0; n < p.length; n++)
                    for (var q = p[n], r = q.start, s = q.count, o = r, t = r + s; o < t; o += 3)
                        b(d[o], d[o + 1], d[o + 2], q.materialIndex);
            else
                for (var n = 0; n < d.length; n += 3)
                    b(d[n], d[n + 1], d[n + 2])
        } else
            for (var n = 0; n < f.length / 3; n += 3)
                b(n, n + 1, n + 2);
        return this.computeFaceNormals(),
        null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()),
        null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()),
        this
    },
    center: function() {
        this.computeBoundingBox();
        var a = this.boundingBox.center().negate();
        return this.translate(a.x, a.y, a.z),
        a
    },
    normalize: function() {
        this.computeBoundingSphere();
        var a = this.boundingSphere.center
          , b = this.boundingSphere.radius
          , c = 0 === b ? 1 : 1 / b
          , d = new fm.Matrix4;
        return d.set(c, 0, 0, -c * a.x, 0, c, 0, -c * a.y, 0, 0, c, -c * a.z, 0, 0, 0, 1),
        this.applyMatrix(d),
        this
    },
    computeFaceNormals: function() {
        for (var a = new fm.Vector3, b = new fm.Vector3, c = 0, d = this.faces.length; c < d; c++) {
            var e = this.faces[c]
              , f = this.vertices[e.a]
              , g = this.vertices[e.b]
              , h = this.vertices[e.c];
            a.subVectors(h, g),
            b.subVectors(f, g),
            a.cross(b),
            a.normalize(),
            e.normal.copy(a)
        }
    },
    computeVertexNormals: function(a) {
        void 0 === a && (a = !0);
        var b, c, d, e, f, g;
        for (g = new Array(this.vertices.length),
        b = 0,
        c = this.vertices.length; b < c; b++)
            g[b] = new fm.Vector3;
        if (a) {
            var h, i, j, k = new fm.Vector3, l = new fm.Vector3;
            for (d = 0,
            e = this.faces.length; d < e; d++)
                f = this.faces[d],
                h = this.vertices[f.a],
                i = this.vertices[f.b],
                j = this.vertices[f.c],
                k.subVectors(j, i),
                l.subVectors(h, i),
                k.cross(l),
                g[f.a].add(k),
                g[f.b].add(k),
                g[f.c].add(k)
        } else
            for (d = 0,
            e = this.faces.length; d < e; d++)
                f = this.faces[d],
                g[f.a].add(f.normal),
                g[f.b].add(f.normal),
                g[f.c].add(f.normal);
        for (b = 0,
        c = this.vertices.length; b < c; b++)
            g[b].normalize();
        for (d = 0,
        e = this.faces.length; d < e; d++) {
            f = this.faces[d];
            var m = f.vertexNormals;
            3 === m.length ? (m[0].copy(g[f.a]),
            m[1].copy(g[f.b]),
            m[2].copy(g[f.c])) : (m[0] = g[f.a].clone(),
            m[1] = g[f.b].clone(),
            m[2] = g[f.c].clone())
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0)
    },
    computeMorphNormals: function() {
        var a, b, c, d, e;
        for (c = 0,
        d = this.faces.length; c < d; c++)
            for (e = this.faces[c],
            e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(),
            e.__originalVertexNormals || (e.__originalVertexNormals = []),
            a = 0,
            b = e.vertexNormals.length; a < b; a++)
                e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
        var f = new fm.Geometry;
        for (f.faces = this.faces,
        a = 0,
        b = this.morphTargets.length; a < b; a++) {
            if (!this.morphNormals[a]) {
                this.morphNormals[a] = {},
                this.morphNormals[a].faceNormals = [],
                this.morphNormals[a].vertexNormals = [];
                var g, h, i = this.morphNormals[a].faceNormals, j = this.morphNormals[a].vertexNormals;
                for (c = 0,
                d = this.faces.length; c < d; c++)
                    g = new fm.Vector3,
                    h = {
                        a: new fm.Vector3,
                        b: new fm.Vector3,
                        c: new fm.Vector3
                    },
                    i.push(g),
                    j.push(h)
            }
            var k = this.morphNormals[a];
            f.vertices = this.morphTargets[a].vertices,
            f.computeFaceNormals(),
            f.computeVertexNormals();
            var g, h;
            for (c = 0,
            d = this.faces.length; c < d; c++)
                e = this.faces[c],
                g = k.faceNormals[c],
                h = k.vertexNormals[c],
                g.copy(e.normal),
                h.a.copy(e.vertexNormals[0]),
                h.b.copy(e.vertexNormals[1]),
                h.c.copy(e.vertexNormals[2])
        }
        for (c = 0,
        d = this.faces.length; c < d; c++)
            e = this.faces[c],
            e.normal = e.__originalFaceNormal,
            e.vertexNormals = e.__originalVertexNormals
    },
    computeTangents: function() {
        console.warn("fm.Geometry: .computeTangents() has been removed.")
    },
    computeLineDistances: function() {
        for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++)
            c > 0 && (a += b[c].distanceTo(b[c - 1])),
            this.lineDistances[c] = a
    },
    computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new fm.Box3),
        this.boundingBox.setFromPoints(this.vertices)
    },
    computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new fm.Sphere),
        this.boundingSphere.setFromPoints(this.vertices)
    },
    merge: function(a, b, c) {
        if (a instanceof fm.Geometry == !1)
            return void console.error("fm.Geometry.merge(): geometry not an instance of fm.Geometry.", a);
        var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, i = a.faces, j = this.faceVertexUvs[0], k = a.faceVertexUvs[0];
        void 0 === c && (c = 0),
        void 0 !== b && (d = (new fm.Matrix3).getNormalMatrix(b));
        for (var l = 0, m = g.length; l < m; l++) {
            var n = g[l]
              , o = n.clone();
            void 0 !== b && o.applyMatrix4(b),
            f.push(o)
        }
        for (l = 0,
        m = i.length; l < m; l++) {
            var p, q, r, s = i[l], t = s.vertexNormals, u = s.vertexColors;
            p = new fm.Face3(s.a + e,s.b + e,s.c + e),
            p.normal.copy(s.normal),
            void 0 !== d && p.normal.applyMatrix3(d).normalize();
            for (var v = 0, w = t.length; v < w; v++)
                q = t[v].clone(),
                void 0 !== d && q.applyMatrix3(d).normalize(),
                p.vertexNormals.push(q);
            p.color.copy(s.color);
            for (var v = 0, w = u.length; v < w; v++)
                r = u[v],
                p.vertexColors.push(r.clone());
            p.materialIndex = s.materialIndex + c,
            h.push(p)
        }
        for (l = 0,
        m = k.length; l < m; l++) {
            var x = k[l]
              , y = [];
            if (void 0 !== x) {
                for (var v = 0, w = x.length; v < w; v++)
                    y.push(x[v].clone());
                j.push(y)
            }
        }
    },
    mergeMesh: function(a) {
        return a instanceof fm.Mesh == !1 ? void console.error("fm.Geometry.mergeMesh(): mesh not an instance of fm.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(),
        void this.merge(a.geometry, a.matrix))
    },
    mergeVertices: function() {
        var a, b, c, d, e, f, g, h, i = {}, j = [], k = [], l = 4, m = Math.pow(10, l);
        for (c = 0,
        d = this.vertices.length; c < d; c++)
            a = this.vertices[c],
            b = Math.round(a.x * m) + "_" + Math.round(a.y * m) + "_" + Math.round(a.z * m),
            void 0 === i[b] ? (i[b] = c,
            j.push(this.vertices[c]),
            k[c] = j.length - 1) : k[c] = k[i[b]];
        var n = [];
        for (c = 0,
        d = this.faces.length; c < d; c++) {
            e = this.faces[c],
            e.a = k[e.a],
            e.b = k[e.b],
            e.c = k[e.c],
            f = [e.a, e.b, e.c];
            for (var o = -1, p = 0; p < 3; p++)
                if (f[p] === f[(p + 1) % 3]) {
                    o = p,
                    n.push(c);
                    break
                }
        }
        for (c = n.length - 1; c >= 0; c--) {
            var q = n[c];
            for (this.faces.splice(q, 1),
            g = 0,
            h = this.faceVertexUvs.length; g < h; g++)
                this.faceVertexUvs[g].splice(q, 1)
        }
        var r = this.vertices.length - j.length;
        return this.vertices = j,
        r
    },
    sortFacesByMaterialIndex: function() {
        function a(a, b) {
            return a.materialIndex - b.materialIndex
        }
        for (var b = this.faces, c = b.length, d = 0; d < c; d++)
            b[d]._id = d;
        b.sort(a);
        var e, f, g = this.faceVertexUvs[0], h = this.faceVertexUvs[1];
        g && g.length === c && (e = []),
        h && h.length === c && (f = []);
        for (var d = 0; d < c; d++) {
            var i = b[d]._id;
            e && e.push(g[i]),
            f && f.push(h[i])
        }
        e && (this.faceVertexUvs[0] = e),
        f && (this.faceVertexUvs[1] = f)
    },
    toJSON: function() {
        function a(a, b, c) {
            return c ? a | 1 << b : a & ~(1 << b)
        }
        function b(a) {
            var b = a.x.toString() + a.y.toString() + a.z.toString();
            return void 0 !== m[b] ? m[b] : (m[b] = l.length / 3,
            l.push(a.x, a.y, a.z),
            m[b])
        }
        function c(a) {
            var b = a.r.toString() + a.g.toString() + a.b.toString();
            return void 0 !== o[b] ? o[b] : (o[b] = n.length,
            n.push(a.getHex()),
            o[b])
        }
        function d(a) {
            var b = a.x.toString() + a.y.toString();
            return void 0 !== q[b] ? q[b] : (q[b] = p.length / 2,
            p.push(a.x, a.y),
            q[b])
        }
        var e = {
            metadata: {
                version: 4.4,
                type: "Geometry",
                generator: "Geometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        "" !== this.name && (e.name = this.name),
        void 0 !== this.parameters) {
            var f = this.parameters;
            for (var g in f)
                void 0 !== f[g] && (e[g] = f[g]);
            return e
        }
        for (var h = [], i = 0; i < this.vertices.length; i++) {
            var j = this.vertices[i];
            h.push(j.x, j.y, j.z)
        }
        for (var k = [], l = [], m = {}, n = [], o = {}, p = [], q = {}, i = 0; i < this.faces.length; i++) {
            var r = this.faces[i]
              , s = !0
              , t = !1
              , u = void 0 !== this.faceVertexUvs[0][i]
              , v = r.normal.length() > 0
              , w = r.vertexNormals.length > 0
              , x = 1 !== r.color.r || 1 !== r.color.g || 1 !== r.color.b
              , y = r.vertexColors.length > 0
              , z = 0;
            if (z = a(z, 0, 0),
            z = a(z, 1, s),
            z = a(z, 2, t),
            z = a(z, 3, u),
            z = a(z, 4, v),
            z = a(z, 5, w),
            z = a(z, 6, x),
            z = a(z, 7, y),
            k.push(z),
            k.push(r.a, r.b, r.c),
            k.push(r.materialIndex),
            u) {
                var A = this.faceVertexUvs[0][i];
                k.push(d(A[0]), d(A[1]), d(A[2]))
            }
            if (v && k.push(b(r.normal)),
            w) {
                var B = r.vertexNormals;
                k.push(b(B[0]), b(B[1]), b(B[2]))
            }
            if (x && k.push(c(r.color)),
            y) {
                var C = r.vertexColors;
                k.push(c(C[0]), c(C[1]), c(C[2]))
            }
        }
        return e.data = {},
        e.data.vertices = h,
        e.data.normals = l,
        n.length > 0 && (e.data.colors = n),
        p.length > 0 && (e.data.uvs = [p]),
        e.data.faces = k,
        e
    },
    clone: function() {
        return (new fm.Geometry).copy(this)
    },
    copy: function(a) {
        this.vertices = [],
        this.faces = [],
        this.faceVertexUvs = [[]];
        for (var b = a.vertices, c = 0, d = b.length; c < d; c++)
            this.vertices.push(b[c].clone());
        for (var e = a.faces, c = 0, d = e.length; c < d; c++)
            this.faces.push(e[c].clone());
        for (var c = 0, d = a.faceVertexUvs.length; c < d; c++) {
            var f = a.faceVertexUvs[c];
            void 0 === this.faceVertexUvs[c] && (this.faceVertexUvs[c] = []);
            for (var g = 0, h = f.length; g < h; g++) {
                for (var i = f[g], j = [], k = 0, l = i.length; k < l; k++) {
                    var m = i[k];
                    j.push(m.clone())
                }
                this.faceVertexUvs[c].push(j)
            }
        }
        return this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
fm.EventDispatcher.prototype.apply(fm.Geometry.prototype),
fm.GeometryIdCount = 0,
fm.BufferAttribute = function(a, b, c) {
    this.uuid = fm.Math.generateUUID(),
    this.array = a,
    this.itemSize = b,
    this.dynamic = !1,
    this.updateRange = {
        offset: 0,
        count: -1
    },
    this.version = 0,
    this.normalized = c === !0
}
,
fm.BufferAttribute.prototype = {
    constructor: fm.BufferAttribute,
    get count() {
        return this.array.length / this.itemSize
    },
    set needsUpdate(a) {
        a === !0 && this.version++
    },
    setDynamic: function(a) {
        return this.dynamic = a,
        this
    },
    copy: function(a) {
        return this.array = new a.array.constructor(a.array),
        this.itemSize = a.itemSize,
        this.dynamic = a.dynamic,
        this
    },
    copyAt: function(a, b, c) {
        a *= this.itemSize,
        c *= b.itemSize;
        for (var d = 0, e = this.itemSize; d < e; d++)
            this.array[a + d] = b.array[c + d];
        return this
    },
    copyArray: function(a) {
        return this.array.set(a),
        this
    },
    copyColorsArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("fm.BufferAttribute.copyColorsArray(): color is undefined", d),
            f = new fm.Color),
            b[c++] = f.r,
            b[c++] = f.g,
            b[c++] = f.b
        }
        return this
    },
    copyIndicesArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            b[c++] = f.a,
            b[c++] = f.b,
            b[c++] = f.c
        }
        return this
    },
    copyVector2sArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("fm.BufferAttribute.copyVector2sArray(): vector is undefined", d),
            f = new fm.Vector2),
            b[c++] = f.x,
            b[c++] = f.y
        }
        return this
    },
    copyVector3sArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("fm.BufferAttribute.copyVector3sArray(): vector is undefined", d),
            f = new fm.Vector3),
            b[c++] = f.x,
            b[c++] = f.y,
            b[c++] = f.z
        }
        return this
    },
    copyVector4sArray: function(a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            void 0 === f && (console.warn("fm.BufferAttribute.copyVector4sArray(): vector is undefined", d),
            f = new fm.Vector4),
            b[c++] = f.x,
            b[c++] = f.y,
            b[c++] = f.z,
            b[c++] = f.w
        }
        return this
    },
    set: function(a, b) {
        return void 0 === b && (b = 0),
        this.array.set(a, b),
        this
    },
    getX: function(a) {
        return this.array[a * this.itemSize]
    },
    setX: function(a, b) {
        return this.array[a * this.itemSize] = b,
        this
    },
    getY: function(a) {
        return this.array[a * this.itemSize + 1]
    },
    setY: function(a, b) {
        return this.array[a * this.itemSize + 1] = b,
        this
    },
    getZ: function(a) {
        return this.array[a * this.itemSize + 2]
    },
    setZ: function(a, b) {
        return this.array[a * this.itemSize + 2] = b,
        this
    },
    getW: function(a) {
        return this.array[a * this.itemSize + 3]
    },
    setW: function(a, b) {
        return this.array[a * this.itemSize + 3] = b,
        this
    },
    setXY: function(a, b, c) {
        return a *= this.itemSize,
        this.array[a + 0] = b,
        this.array[a + 1] = c,
        this
    },
    setXYZ: function(a, b, c, d) {
        return a *= this.itemSize,
        this.array[a + 0] = b,
        this.array[a + 1] = c,
        this.array[a + 2] = d,
        this
    },
    setXYZW: function(a, b, c, d, e) {
        return a *= this.itemSize,
        this.array[a + 0] = b,
        this.array[a + 1] = c,
        this.array[a + 2] = d,
        this.array[a + 3] = e,
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    }
},
fm.Int8Attribute = function(a, b) {
    return new fm.BufferAttribute(new Int8Array(a),b)
}
,
fm.Uint8Attribute = function(a, b) {
    return new fm.BufferAttribute(new Uint8Array(a),b)
}
,
fm.Uint8ClampedAttribute = function(a, b) {
    return new fm.BufferAttribute(new Uint8ClampedArray(a),b)
}
,
fm.Int16Attribute = function(a, b) {
    return new fm.BufferAttribute(new Int16Array(a),b)
}
,
fm.Uint16Attribute = function(a, b) {
    return new fm.BufferAttribute(new Uint16Array(a),b)
}
,
fm.Int32Attribute = function(a, b) {
    return new fm.BufferAttribute(new Int32Array(a),b)
}
,
fm.Uint32Attribute = function(a, b) {
    return new fm.BufferAttribute(new Uint32Array(a),b)
}
,
fm.Float32Attribute = function(a, b) {
    return new fm.BufferAttribute(new Float32Array(a),b)
}
,
fm.Float64Attribute = function(a, b) {
    return new fm.BufferAttribute(new Float64Array(a),b)
}
,
fm.DynamicBufferAttribute = function(a, b) {
    return console.warn("fm.DynamicBufferAttribute has been removed. Use new fm.BufferAttribute().setDynamic( true ) instead."),
    new fm.BufferAttribute(a,b).setDynamic(!0)
}
,
fm.BufferGeometry = function() {
    Object.defineProperty(this, "id", {
        value: fm.GeometryIdCount++
    }),
    this.uuid = fm.Math.generateUUID(),
    this.name = "",
    this.type = "BufferGeometry",
    this.index = null ,
    this.attributes = {},
    this.morphAttributes = {},
    this.groups = [],
    this.boundingBox = null ,
    this.boundingSphere = null ,
    this.drawRange = {
        start: 0,
        count: 1 / 0
    }
}
,
fm.BufferGeometry.prototype = {
    constructor: fm.BufferGeometry,
    getIndex: function() {
        return this.index
    },
    setIndex: function(a) {
        this.index = a
    },
    addAttribute: function(a, b) {
        return b instanceof fm.BufferAttribute == !1 && b instanceof fm.InterleavedBufferAttribute == !1 ? (console.warn("fm.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
        void this.addAttribute(a, new fm.BufferAttribute(arguments[1],arguments[2]))) : "index" === a ? (console.warn("fm.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
        void this.setIndex(b)) : (this.attributes[a] = b,
        this)
    },
    getAttribute: function(a) {
        return this.attributes[a]
    },
    removeAttribute: function(a) {
        return delete this.attributes[a],
        this
    },
    addGroup: function(a, b, c) {
        this.groups.push({
            start: a,
            count: b,
            materialIndex: void 0 !== c ? c : 0
        })
    },
    clearGroups: function() {
        this.groups = []
    },
    setDrawRange: function(a, b) {
        this.drawRange.start = a,
        this.drawRange.count = b
    },
    applyMatrix: function(a) {
        var b = this.attributes.position;
        void 0 !== b && (a.applyToVector3Array(b.array),
        b.needsUpdate = !0);
        var c = this.attributes.normal;
        if (void 0 !== c) {
            var d = (new fm.Matrix3).getNormalMatrix(a);
            d.applyToVector3Array(c.array),
            c.needsUpdate = !0
        }
        return null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
    },
    rotateX: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeRotationX(b),
            this.applyMatrix(a),
            this
        }
    }(),
    rotateY: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeRotationY(b),
            this.applyMatrix(a),
            this
        }
    }(),
    rotateZ: function() {
        var a;
        return function(b) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeRotationZ(b),
            this.applyMatrix(a),
            this
        }
    }(),
    translate: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeTranslation(b, c, d),
            this.applyMatrix(a),
            this
        }
    }(),
    scale: function() {
        var a;
        return function(b, c, d) {
            return void 0 === a && (a = new fm.Matrix4),
            a.makeScale(b, c, d),
            this.applyMatrix(a),
            this
        }
    }(),
    lookAt: function() {
        var a;
        return function(b) {
            void 0 === a && (a = new fm.Object3D),
            a.lookAt(b),
            a.updateMatrix(),
            this.applyMatrix(a.matrix)
        }
    }(),
    center: function() {
        this.computeBoundingBox();
        var a = this.boundingBox.center().negate();
        return this.translate(a.x, a.y, a.z),
        a
    },
    setFromObject: function(a) {
        var b = a.geometry;
        if (a instanceof fm.Points || a instanceof fm.Line) {
            var c = new fm.Float32Attribute(3 * b.vertices.length,3)
              , d = new fm.Float32Attribute(3 * b.colors.length,3);
            if (this.addAttribute("position", c.copyVector3sArray(b.vertices)),
            this.addAttribute("color", d.copyColorsArray(b.colors)),
            b.lineDistances && b.lineDistances.length === b.vertices.length) {
                var e = new fm.Float32Attribute(b.lineDistances.length,1);
                this.addAttribute("lineDistance", e.copyArray(b.lineDistances))
            }
            null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()),
            null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
        } else
            a instanceof fm.Mesh && b instanceof fm.Geometry && this.fromGeometry(b);
        return this
    },
    updateFromObject: function(a) {
        var b = a.geometry;
        if (a instanceof fm.Mesh) {
            var c = b.__directGeometry;
            if (void 0 === c)
                return this.fromGeometry(b);
            c.verticesNeedUpdate = b.verticesNeedUpdate,
            c.normalsNeedUpdate = b.normalsNeedUpdate,
            c.colorsNeedUpdate = b.colorsNeedUpdate,
            c.uvsNeedUpdate = b.uvsNeedUpdate,
            c.groupsNeedUpdate = b.groupsNeedUpdate,
            b.verticesNeedUpdate = !1,
            b.normalsNeedUpdate = !1,
            b.colorsNeedUpdate = !1,
            b.uvsNeedUpdate = !1,
            b.groupsNeedUpdate = !1,
            b = c
        }
        if (b.verticesNeedUpdate === !0) {
            var d = this.attributes.position;
            void 0 !== d && (d.copyVector3sArray(b.vertices),
            d.needsUpdate = !0),
            b.verticesNeedUpdate = !1
        }
        if (b.normalsNeedUpdate === !0) {
            var d = this.attributes.normal;
            void 0 !== d && (d.copyVector3sArray(b.normals),
            d.needsUpdate = !0),
            b.normalsNeedUpdate = !1
        }
        if (b.colorsNeedUpdate === !0) {
            var d = this.attributes.color;
            void 0 !== d && (d.copyColorsArray(b.colors),
            d.needsUpdate = !0),
            b.colorsNeedUpdate = !1
        }
        if (b.uvsNeedUpdate) {
            var d = this.attributes.uv;
            void 0 !== d && (d.copyVector2sArray(b.uvs),
            d.needsUpdate = !0),
            b.uvsNeedUpdate = !1
        }
        if (b.lineDistancesNeedUpdate) {
            var d = this.attributes.lineDistance;
            void 0 !== d && (d.copyArray(b.lineDistances),
            d.needsUpdate = !0),
            b.lineDistancesNeedUpdate = !1
        }
        return b.groupsNeedUpdate && (b.computeGroups(a.geometry),
        this.groups = b.groups,
        b.groupsNeedUpdate = !1),
        this
    },
    fromGeometry: function(a) {
        return a.__directGeometry = (new fm.DirectGeometry).fromGeometry(a),
        this.fromDirectGeometry(a.__directGeometry)
    },
    fromDirectGeometry: function(a) {
        var b = new Float32Array(3 * a.vertices.length);
        if (this.addAttribute("position", new fm.BufferAttribute(b,3).copyVector3sArray(a.vertices)),
        a.normals.length > 0) {
            var c = new Float32Array(3 * a.normals.length);
            this.addAttribute("normal", new fm.BufferAttribute(c,3).copyVector3sArray(a.normals))
        }
        if (a.colors.length > 0) {
            var d = new Float32Array(3 * a.colors.length);
            this.addAttribute("color", new fm.BufferAttribute(d,3).copyColorsArray(a.colors))
        }
        if (a.uvs.length > 0) {
            var e = new Float32Array(2 * a.uvs.length);
            this.addAttribute("uv", new fm.BufferAttribute(e,2).copyVector2sArray(a.uvs))
        }
        if (a.uvs2.length > 0) {
            var f = new Float32Array(2 * a.uvs2.length);
            this.addAttribute("uv2", new fm.BufferAttribute(f,2).copyVector2sArray(a.uvs2))
        }
        if (a.indices.length > 0) {
            var g = a.vertices.length > 65535 ? Uint32Array : Uint16Array
              , h = new g(3 * a.indices.length);
            this.setIndex(new fm.BufferAttribute(h,1).copyIndicesArray(a.indices))
        }
        this.groups = a.groups;
        for (var i in a.morphTargets) {
            for (var j = [], k = a.morphTargets[i], l = 0, m = k.length; l < m; l++) {
                var n = k[l]
                  , o = new fm.Float32Attribute(3 * n.length,3);
                j.push(o.copyVector3sArray(n))
            }
            this.morphAttributes[i] = j
        }
        if (a.skinIndices.length > 0) {
            var p = new fm.Float32Attribute(4 * a.skinIndices.length,4);
            this.addAttribute("skinIndex", p.copyVector4sArray(a.skinIndices))
        }
        if (a.skinWeights.length > 0) {
            var q = new fm.Float32Attribute(4 * a.skinWeights.length,4);
            this.addAttribute("skinWeight", q.copyVector4sArray(a.skinWeights))
        }
        return null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()),
        null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()),
        this
    },
    computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new fm.Box3);
        var a = this.attributes.position.array;
        void 0 !== a ? this.boundingBox.setFromArray(a) : this.boundingBox.makeEmpty(),
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('fm.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    },
    computeBoundingSphere: function() {
        var a = new fm.Box3
          , b = new fm.Vector3;
        return function() {
            null === this.boundingSphere && (this.boundingSphere = new fm.Sphere);
            var c = this.attributes.position.array;
            if (c) {
                var d = this.boundingSphere.center;
                a.setFromArray(c),
                a.center(d);
                for (var e = 0, f = 0, g = c.length; f < g; f += 3)
                    b.fromArray(c, f),
                    e = Math.max(e, d.distanceToSquared(b));
                this.boundingSphere.radius = Math.sqrt(e),
                isNaN(this.boundingSphere.radius) && console.error('fm.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
    }(),
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
        var a = this.index
          , b = this.attributes
          , c = this.groups;
        if (b.position) {
            var d = b.position.array;
            if (void 0 === b.normal)
                this.addAttribute("normal", new fm.BufferAttribute(new Float32Array(d.length),3));
            else
                for (var e = b.normal.array, f = 0, g = e.length; f < g; f++)
                    e[f] = 0;
            var h, i, j, k = b.normal.array, l = new fm.Vector3, m = new fm.Vector3, n = new fm.Vector3, o = new fm.Vector3, p = new fm.Vector3;
            if (a) {
                var q = a.array;
                0 === c.length && this.addGroup(0, q.length);
                for (var r = 0, s = c.length; r < s; ++r)
                    for (var t = c[r], u = t.start, v = t.count, f = u, g = u + v; f < g; f += 3)
                        h = 3 * q[f + 0],
                        i = 3 * q[f + 1],
                        j = 3 * q[f + 2],
                        l.fromArray(d, h),
                        m.fromArray(d, i),
                        n.fromArray(d, j),
                        o.subVectors(n, m),
                        p.subVectors(l, m),
                        o.cross(p),
                        k[h] += o.x,
                        k[h + 1] += o.y,
                        k[h + 2] += o.z,
                        k[i] += o.x,
                        k[i + 1] += o.y,
                        k[i + 2] += o.z,
                        k[j] += o.x,
                        k[j + 1] += o.y,
                        k[j + 2] += o.z
            } else
                for (var f = 0, g = d.length; f < g; f += 9)
                    l.fromArray(d, f),
                    m.fromArray(d, f + 3),
                    n.fromArray(d, f + 6),
                    o.subVectors(n, m),
                    p.subVectors(l, m),
                    o.cross(p),
                    k[f] = o.x,
                    k[f + 1] = o.y,
                    k[f + 2] = o.z,
                    k[f + 3] = o.x,
                    k[f + 4] = o.y,
                    k[f + 5] = o.z,
                    k[f + 6] = o.x,
                    k[f + 7] = o.y,
                    k[f + 8] = o.z;
            this.normalizeNormals(),
            b.normal.needsUpdate = !0
        }
    },
    merge: function(a, b) {
        if (a instanceof fm.BufferGeometry == !1)
            return void console.error("fm.BufferGeometry.merge(): geometry not an instance of fm.BufferGeometry.", a);
        void 0 === b && (b = 0);
        var c = this.attributes;
        for (var d in c)
            if (void 0 !== a.attributes[d])
                for (var e = c[d], f = e.array, g = a.attributes[d], h = g.array, i = g.itemSize, j = 0, k = i * b; j < h.length; j++,
                k++)
                    f[k] = h[j];
        return this
    },
    normalizeNormals: function() {
        for (var a, b, c, d, e = this.attributes.normal.array, f = 0, g = e.length; f < g; f += 3)
            a = e[f],
            b = e[f + 1],
            c = e[f + 2],
            d = 1 / Math.sqrt(a * a + b * b + c * c),
            e[f] *= d,
            e[f + 1] *= d,
            e[f + 2] *= d
    },
    toNonIndexed: function() {
        if (null === this.index)
            return console.warn("fm.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
            this;
        var a = new fm.BufferGeometry
          , b = this.index.array
          , c = this.attributes;
        for (var d in c) {
            for (var e = c[d], f = e.array, g = e.itemSize, h = new f.constructor(b.length * g), i = 0, j = 0, k = 0, l = b.length; k < l; k++) {
                i = b[k] * g;
                for (var m = 0; m < g; m++)
                    h[j++] = f[i++]
            }
            a.addAttribute(d, new fm.BufferAttribute(h,g))
        }
        return a
    },
    toJSON: function() {
        var a = {
            metadata: {
                version: 4.4,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (a.uuid = this.uuid,
        a.type = this.type,
        "" !== this.name && (a.name = this.name),
        void 0 !== this.parameters) {
            var b = this.parameters;
            for (var c in b)
                void 0 !== b[c] && (a[c] = b[c]);
            return a
        }
        a.data = {
            attributes: {}
        };
        var d = this.index;
        if (null !== d) {
            var e = Array.prototype.slice.call(d.array);
            a.data.index = {
                type: d.array.constructor.name,
                array: e
            }
        }
        var f = this.attributes;
        for (var c in f) {
            var g = f[c]
              , e = Array.prototype.slice.call(g.array);
            a.data.attributes[c] = {
                itemSize: g.itemSize,
                type: g.array.constructor.name,
                array: e,
                normalized: g.normalized
            }
        }
        var h = this.groups;
        h.length > 0 && (a.data.groups = JSON.parse(JSON.stringify(h)));
        var i = this.boundingSphere;
        return null !== i && (a.data.boundingSphere = {
            center: i.center.toArray(),
            radius: i.radius
        }),
        a
    },
    clone: function() {
        return (new fm.BufferGeometry).copy(this)
    },
    copy: function(a) {
        var b = a.index;
        null !== b && this.setIndex(b.clone());
        var c = a.attributes;
        for (var d in c) {
            var e = c[d];
            this.addAttribute(d, e.clone())
        }
        for (var f = a.groups, g = 0, h = f.length; g < h; g++) {
            var i = f[g];
            this.addGroup(i.start, i.count, i.materialIndex)
        }
        return this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
fm.EventDispatcher.prototype.apply(fm.BufferGeometry.prototype),
fm.BufferGeometry.MaxIndex = 65535,
fm.DirectGeometry = function() {
    Object.defineProperty(this, "id", {
        value: fm.GeometryIdCount++
    }),
    this.uuid = fm.Math.generateUUID(),
    this.name = "",
    this.type = "DirectGeometry",
    this.indices = [],
    this.vertices = [],
    this.normals = [],
    this.colors = [],
    this.uvs = [],
    this.uvs2 = [],
    this.groups = [],
    this.morphTargets = {},
    this.skinWeights = [],
    this.skinIndices = [],
    this.boundingBox = null ,
    this.boundingSphere = null ,
    this.verticesNeedUpdate = !1,
    this.normalsNeedUpdate = !1,
    this.colorsNeedUpdate = !1,
    this.uvsNeedUpdate = !1,
    this.groupsNeedUpdate = !1
}
,
fm.DirectGeometry.prototype = {
    constructor: fm.DirectGeometry,
    computeBoundingBox: fm.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: fm.Geometry.prototype.computeBoundingSphere,
    computeFaceNormals: function() {
        console.warn("fm.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
    },
    computeVertexNormals: function() {
        console.warn("fm.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
    },
    computeGroups: function(a) {
        for (var b, c, d = [], e = a.faces, f = 0; f < e.length; f++) {
            var g = e[f];
            g.materialIndex !== c && (c = g.materialIndex,
            void 0 !== b && (b.count = 3 * f - b.start,
            d.push(b)),
            b = {
                start: 3 * f,
                materialIndex: c
            })
        }
        void 0 !== b && (b.count = 3 * f - b.start,
        d.push(b)),
        this.groups = d
    },
    fromGeometry: function(a) {
        var b, c = a.faces, d = a.vertices, e = a.faceVertexUvs, f = e[0] && e[0].length > 0, g = e[1] && e[1].length > 0, h = a.morphTargets, i = h.length;
        if (i > 0) {
            b = [];
            for (var j = 0; j < i; j++)
                b[j] = [];
            this.morphTargets.position = b
        }
        var k, l = a.morphNormals, m = l.length;
        if (m > 0) {
            k = [];
            for (var j = 0; j < m; j++)
                k[j] = [];
            this.morphTargets.normal = k
        }
        for (var n = a.skinIndices, o = a.skinWeights, p = n.length === d.length, q = o.length === d.length, j = 0; j < c.length; j++) {
            var r = c[j];
            this.vertices.push(d[r.a], d[r.b], d[r.c]);
            var s = r.vertexNormals;
            if (3 === s.length)
                this.normals.push(s[0], s[1], s[2]);
            else {
                var t = r.normal;
                this.normals.push(t, t, t)
            }
            var u = r.vertexColors;
            if (3 === u.length)
                this.colors.push(u[0], u[1], u[2]);
            else {
                var v = r.color;
                this.colors.push(v, v, v)
            }
            if (f === !0) {
                var w = e[0][j];
                void 0 !== w ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("fm.DirectGeometry.fromGeometry(): Undefined vertexUv ", j),
                this.uvs.push(new fm.Vector2, new fm.Vector2, new fm.Vector2))
            }
            if (g === !0) {
                var w = e[1][j];
                void 0 !== w ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("fm.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", j),
                this.uvs2.push(new fm.Vector2, new fm.Vector2, new fm.Vector2))
            }
            for (var x = 0; x < i; x++) {
                var y = h[x].vertices;
                b[x].push(y[r.a], y[r.b], y[r.c])
            }
            for (var x = 0; x < m; x++) {
                var z = l[x].vertexNormals[j];
                k[x].push(z.a, z.b, z.c)
            }
            p && this.skinIndices.push(n[r.a], n[r.b], n[r.c]),
            q && this.skinWeights.push(o[r.a], o[r.b], o[r.c])
        }
        return this.computeGroups(a),
        this.verticesNeedUpdate = a.verticesNeedUpdate,
        this.normalsNeedUpdate = a.normalsNeedUpdate,
        this.colorsNeedUpdate = a.colorsNeedUpdate,
        this.uvsNeedUpdate = a.uvsNeedUpdate,
        this.groupsNeedUpdate = a.groupsNeedUpdate,
        this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
fm.EventDispatcher.prototype.apply(fm.DirectGeometry.prototype),
fm.Face3 = function(a, b, c, d, e, f) {
    this.a = a,
    this.b = b,
    this.c = c,
    this.normal = d instanceof fm.Vector3 ? d : new fm.Vector3,
    this.vertexNormals = Array.isArray(d) ? d : [],
    this.color = e instanceof fm.Color ? e : new fm.Color,
    this.vertexColors = Array.isArray(e) ? e : [],
    this.materialIndex = void 0 !== f ? f : 0
}
,
fm.Face3.prototype = {
    constructor: fm.Face3,
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.a = a.a,
        this.b = a.b,
        this.c = a.c,
        this.normal.copy(a.normal),
        this.color.copy(a.color),
        this.materialIndex = a.materialIndex;
        for (var b = 0, c = a.vertexNormals.length; b < c; b++)
            this.vertexNormals[b] = a.vertexNormals[b].clone();
        for (var b = 0, c = a.vertexColors.length; b < c; b++)
            this.vertexColors[b] = a.vertexColors[b].clone();
        return this
    }
},
fm.InterleavedBuffer = function(a, b) {
    this.uuid = fm.Math.generateUUID(),
    this.array = a,
    this.stride = b,
    this.dynamic = !1,
    this.updateRange = {
        offset: 0,
        count: -1
    },
    this.version = 0
}
,
fm.InterleavedBuffer.prototype = {
    constructor: fm.InterleavedBuffer,
    get length() {
        return this.array.length
    },
    get count() {
        return this.array.length / this.stride
    },
    set needsUpdate(a) {
        a === !0 && this.version++
    },
    setDynamic: function(a) {
        return this.dynamic = a,
        this
    },
    copy: function(a) {
        return this.array = new a.array.constructor(a.array),
        this.stride = a.stride,
        this.dynamic = a.dynamic,
        this
    },
    copyAt: function(a, b, c) {
        a *= this.stride,
        c *= b.stride;
        for (var d = 0, e = this.stride; d < e; d++)
            this.array[a + d] = b.array[c + d];
        return this
    },
    set: function(a, b) {
        return void 0 === b && (b = 0),
        this.array.set(a, b),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    }
},
fm.InterleavedBufferAttribute = function(a, b, c) {
    this.uuid = fm.Math.generateUUID(),
    this.data = a,
    this.itemSize = b,
    this.offset = c
}
,
fm.InterleavedBufferAttribute.prototype = {
    constructor: fm.InterleavedBufferAttribute,
    get length() {
        return console.warn("fm.BufferAttribute: .length has been deprecated. Please use .count."),
        this.array.length
    },
    get count() {
        return this.data.count
    },
    setX: function(a, b) {
        return this.data.array[a * this.data.stride + this.offset] = b,
        this
    },
    setY: function(a, b) {
        return this.data.array[a * this.data.stride + this.offset + 1] = b,
        this
    },
    setZ: function(a, b) {
        return this.data.array[a * this.data.stride + this.offset + 2] = b,
        this
    },
    setW: function(a, b) {
        return this.data.array[a * this.data.stride + this.offset + 3] = b,
        this
    },
    getX: function(a) {
        return this.data.array[a * this.data.stride + this.offset]
    },
    getY: function(a) {
        return this.data.array[a * this.data.stride + this.offset + 1]
    },
    getZ: function(a) {
        return this.data.array[a * this.data.stride + this.offset + 2]
    },
    getW: function(a) {
        return this.data.array[a * this.data.stride + this.offset + 3]
    },
    setXY: function(a, b, c) {
        return a = a * this.data.stride + this.offset,
        this.data.array[a + 0] = b,
        this.data.array[a + 1] = c,
        this
    },
    setXYZ: function(a, b, c, d) {
        return a = a * this.data.stride + this.offset,
        this.data.array[a + 0] = b,
        this.data.array[a + 1] = c,
        this.data.array[a + 2] = d,
        this
    },
    setXYZW: function(a, b, c, d, e) {
        return a = a * this.data.stride + this.offset,
        this.data.array[a + 0] = b,
        this.data.array[a + 1] = c,
        this.data.array[a + 2] = d,
        this.data.array[a + 3] = e,
        this
    }
},
fm.InstancedBufferAttribute = function(a, b, c) {
    fm.BufferAttribute.call(this, a, b),
    this.meshPerAttribute = c || 1
}
,
fm.InstancedBufferAttribute.prototype = Object.create(fm.BufferAttribute.prototype),
fm.InstancedBufferAttribute.prototype.constructor = fm.InstancedBufferAttribute,
fm.InstancedBufferAttribute.prototype.copy = function(a) {
    return fm.BufferAttribute.prototype.copy.call(this, a),
    this.meshPerAttribute = a.meshPerAttribute,
    this
}
,
fm.InstancedBufferGeometry = function() {
    fm.BufferGeometry.call(this),
    this.type = "InstancedBufferGeometry",
    this.maxInstancedCount = void 0
}
,
fm.InstancedBufferGeometry.prototype = Object.create(fm.BufferGeometry.prototype),
fm.InstancedBufferGeometry.prototype.constructor = fm.InstancedBufferGeometry,
fm.InstancedBufferGeometry.prototype.addGroup = function(a, b, c) {
    this.groups.push({
        start: a,
        count: b,
        instances: c
    })
}
,
fm.InstancedBufferGeometry.prototype.copy = function(a) {
    var b = a.index;
    null !== b && this.setIndex(b.clone());
    var c = a.attributes;
    for (var d in c) {
        var e = c[d];
        this.addAttribute(d, e.clone())
    }
    for (var f = a.groups, g = 0, h = f.length; g < h; g++) {
        var i = f[g];
        this.addGroup(i.start, i.count, i.instances)
    }
    return this
}
,
fm.EventDispatcher.prototype.apply(fm.InstancedBufferGeometry.prototype),
fm.InstancedInterleavedBuffer = function(a, b, c) {
    fm.InterleavedBuffer.call(this, a, b),
    this.meshPerAttribute = c || 1
}
,
fm.InstancedInterleavedBuffer.prototype = Object.create(fm.InterleavedBuffer.prototype),
fm.InstancedInterleavedBuffer.prototype.constructor = fm.InstancedInterleavedBuffer,
fm.InstancedInterleavedBuffer.prototype.copy = function(a) {
    return fm.InterleavedBuffer.prototype.copy.call(this, a),
    this.meshPerAttribute = a.meshPerAttribute,
    this
}
,
fm.Object3D = function() {
    function a() {
        e.setFromEuler(d, !1)
    }
    function b() {
        d.setFromQuaternion(e, void 0, !1)
    }
    Object.defineProperty(this, "id", {
        value: fm.Object3DIdCount++
    }),
    this.uuid = fm.Math.generateUUID(),
    this.name = "",
    this.type = "Object3D",
    this.parent = null ,
    this.children = [],
    this.up = fm.Object3D.DefaultUp.clone();
    var c = new fm.Vector3
      , d = new fm.Euler
      , e = new fm.Quaternion
      , f = new fm.Vector3(1,1,1);
    d.onChange(a),
    e.onChange(b),
    Object.defineProperties(this, {
        position: {
            enumerable: !0,
            value: c
        },
        rotation: {
            enumerable: !0,
            value: d
        },
        quaternion: {
            enumerable: !0,
            value: e
        },
        scale: {
            enumerable: !0,
            value: f
        },
        modelViewMatrix: {
            value: new fm.Matrix4
        },
        normalMatrix: {
            value: new fm.Matrix3
        }
    }),
    this.rotationAutoUpdate = !0,
    this.matrix = new fm.Matrix4,
    this.matrixWorld = new fm.Matrix4,
    this.matrixAutoUpdate = fm.Object3D.DefaultMatrixAutoUpdate,
    this.matrixWorldNeedsUpdate = !1,
    this.layers = new fm.Layers,
    this.visible = !0,
    this.castShadow = !1,
    this.receiveShadow = !1,
    this.frustumCulled = !0,
    this.renderOrder = 0,
    this.userData = {}
}
,
fm.Object3D.DefaultUp = new fm.Vector3(0,1,0),
fm.Object3D.DefaultMatrixAutoUpdate = !0,
fm.Object3D.prototype = {
    constructor: fm.Object3D,
    applyMatrix: function(a) {
        this.matrix.multiplyMatrices(a, this.matrix),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    },
    setRotationFromAxisAngle: function(a, b) {
        this.quaternion.setFromAxisAngle(a, b)
    },
    setRotationFromEuler: function(a) {
        this.quaternion.setFromEuler(a, !0)
    },
    setRotationFromMatrix: function(a) {
        this.quaternion.setFromRotationMatrix(a)
    },
    setRotationFromQuaternion: function(a) {
        this.quaternion.copy(a)
    },
    rotateOnAxis: function() {
        var a = new fm.Quaternion;
        return function(b, c) {
            return a.setFromAxisAngle(b, c),
            this.quaternion.multiply(a),
            this
        }
    }(),
    rotateX: function() {
        var a = new fm.Vector3(1,0,0);
        return function(b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    rotateY: function() {
        var a = new fm.Vector3(0,1,0);
        return function(b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    rotateZ: function() {
        var a = new fm.Vector3(0,0,1);
        return function(b) {
            return this.rotateOnAxis(a, b)
        }
    }(),
    translateOnAxis: function() {
        var a = new fm.Vector3;
        return function(b, c) {
            return a.copy(b).applyQuaternion(this.quaternion),
            this.position.add(a.multiplyScalar(c)),
            this
        }
    }(),
    translateX: function() {
        var a = new fm.Vector3(1,0,0);
        return function(b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    translateY: function() {
        var a = new fm.Vector3(0,1,0);
        return function(b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    translateZ: function() {
        var a = new fm.Vector3(0,0,1);
        return function(b) {
            return this.translateOnAxis(a, b)
        }
    }(),
    localToWorld: function(a) {
        return a.applyMatrix4(this.matrixWorld)
    },
    worldToLocal: function() {
        var a = new fm.Matrix4;
        return function(b) {
            return b.applyMatrix4(a.getInverse(this.matrixWorld))
        }
    }(),
    lookAt: function() {
        var a = new fm.Matrix4;
        return function(b) {
            a.lookAt(b, this.position, this.up),
            this.quaternion.setFromRotationMatrix(a)
        }
    }(),
    add: function(a) {
        if (arguments.length > 1) {
            for (var b = 0; b < arguments.length; b++)
                this.add(arguments[b]);
            return this
        }
        return a === this ? (console.error("fm.Object3D.add: object can't be added as a child of itself.", a),
        this) : (a instanceof fm.Object3D ? (null !== a.parent && a.parent.remove(a),
        a.parent = this,
        a.dispatchEvent({
            type: "added"
        }),
        this.children.push(a)) : console.error("fm.Object3D.add: object not an instance of fm.Object3D.", a),
        this)
    },
    remove: function(a) {
        if (arguments.length > 1)
            for (var b = 0; b < arguments.length; b++)
                this.remove(arguments[b]);
        var c = this.children.indexOf(a);
        c !== -1 && (a.parent = null ,
        a.dispatchEvent({
            type: "removed"
        }),
        this.children.splice(c, 1))
    },
    getObjectById: function(a) {
        return this.getObjectByProperty("id", a)
    },
    getObjectByName: function(a) {
        return this.getObjectByProperty("name", a)
    },
    getObjectByProperty: function(a, b) {
        if (this[a] === b)
            return this;
        for (var c = 0, d = this.children.length; c < d; c++) {
            var e = this.children[c]
              , f = e.getObjectByProperty(a, b);
            if (void 0 !== f)
                return f
        }
    },
    getWorldPosition: function(a) {
        var b = a || new fm.Vector3;
        return this.updateMatrixWorld(!0),
        b.setFromMatrixPosition(this.matrixWorld)
    },
    getWorldQuaternion: function() {
        var a = new fm.Vector3
          , b = new fm.Vector3;
        return function(c) {
            var d = c || new fm.Quaternion;
            return this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(a, d, b),
            d
        }
    }(),
    getWorldRotation: function() {
        var a = new fm.Quaternion;
        return function(b) {
            var c = b || new fm.Euler;
            return this.getWorldQuaternion(a),
            c.setFromQuaternion(a, this.rotation.order, !1)
        }
    }(),
    getWorldScale: function() {
        var a = new fm.Vector3
          , b = new fm.Quaternion;
        return function(c) {
            var d = c || new fm.Vector3;
            return this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(a, b, d),
            d
        }
    }(),
    getWorldDirection: function() {
        var a = new fm.Quaternion;
        return function(b) {
            var c = b || new fm.Vector3;
            return this.getWorldQuaternion(a),
            c.set(0, 0, 1).applyQuaternion(a)
        }
    }(),
    raycast: function() {},
    traverse: function(a) {
        a(this);
        for (var b = this.children, c = 0, d = b.length; c < d; c++)
            b[c].traverse(a)
    },
    traverseVisible: function(a) {
        if (this.visible !== !1) {
            a(this);
            for (var b = this.children, c = 0, d = b.length; c < d; c++)
                b[c].traverseVisible(a)
        }
    },
    traverseAncestors: function(a) {
        var b = this.parent;
        null !== b && (a(b),
        b.traverseAncestors(a))
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    },
    updateMatrixWorld: function(a) {
        this.matrixAutoUpdate === !0 && this.updateMatrix(),
        this.matrixWorldNeedsUpdate !== !0 && a !== !0 || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        a = !0);
        for (var b = 0, c = this.children.length; b < c; b++)
            this.children[b].updateMatrixWorld(a)
    },
    toJSON: function(a) {
        function b(a) {
            var b = [];
            for (var c in a) {
                var d = a[c];
                delete d.metadata,
                b.push(d)
            }
            return b
        }
        var c = void 0 === a || "" === a
          , d = {};
        c && (a = {
            geometries: {},
            materials: {},
            textures: {},
            images: {}
        },
        d.metadata = {
            version: 4.4,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        var e = {};
        if (e.uuid = this.uuid,
        e.type = this.type,
        "" !== this.name && (e.name = this.name),
        "{}" !== JSON.stringify(this.userData) && (e.userData = this.userData),
        this.castShadow === !0 && (e.castShadow = !0),
        this.receiveShadow === !0 && (e.receiveShadow = !0),
        this.visible === !1 && (e.visible = !1),
        e.matrix = this.matrix.toArray(),
        void 0 !== this.geometry && (void 0 === a.geometries[this.geometry.uuid] && (a.geometries[this.geometry.uuid] = this.geometry.toJSON(a)),
        e.geometry = this.geometry.uuid),
        void 0 !== this.material && (void 0 === a.materials[this.material.uuid] && (a.materials[this.material.uuid] = this.material.toJSON(a)),
        e.material = this.material.uuid),
        this.children.length > 0) {
            e.children = [];
            for (var f = 0; f < this.children.length; f++)
                e.children.push(this.children[f].toJSON(a).object)
        }
        if (c) {
            var g = b(a.geometries)
              , h = b(a.materials)
              , i = b(a.textures)
              , j = b(a.images);
            g.length > 0 && (d.geometries = g),
            h.length > 0 && (d.materials = h),
            i.length > 0 && (d.textures = i),
            j.length > 0 && (d.images = j)
        }
        return d.object = e,
        d
    },
    clone: function(a) {
        return (new this.constructor).copy(this, a)
    },
    copy: function(a, b) {
        if (void 0 === b && (b = !0),
        this.name = a.name,
        this.up.copy(a.up),
        this.position.copy(a.position),
        this.quaternion.copy(a.quaternion),
        this.scale.copy(a.scale),
        this.rotationAutoUpdate = a.rotationAutoUpdate,
        this.matrix.copy(a.matrix),
        this.matrixWorld.copy(a.matrixWorld),
        this.matrixAutoUpdate = a.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate,
        this.visible = a.visible,
        this.castShadow = a.castShadow,
        this.receiveShadow = a.receiveShadow,
        this.frustumCulled = a.frustumCulled,
        this.renderOrder = a.renderOrder,
        this.userData = JSON.parse(JSON.stringify(a.userData)),
        b === !0)
            for (var c = 0; c < a.children.length; c++) {
                var d = a.children[c];
                this.add(d.clone())
            }
        return this
    }
},
fm.EventDispatcher.prototype.apply(fm.Object3D.prototype),
fm.Object3DIdCount = 0,
fm.Layers = function() {
    this.mask = 1
}
,
fm.Layers.prototype = {
    constructor: fm.Layers,
    set: function(a) {
        this.mask = 1 << a
    },
    enable: function(a) {
        this.mask |= 1 << a
    },
    toggle: function(a) {
        this.mask ^= 1 << a
    },
    disable: function(a) {
        this.mask &= ~(1 << a)
    },
    test: function(a) {
        return 0 !== (this.mask & a.mask)
    }
},
function(a) {
    function b(a, b) {
        return a.distance - b.distance
    }
    function c(a, b, d, e) {
        if (a.visible !== !1 && (a.raycast(b, d),
        e === !0))
            for (var f = a.children, g = 0, h = f.length; g < h; g++)
                c(f[g], b, d, !0)
    }
    a.Raycaster = function(b, c, d, e) {
        this.ray = new a.Ray(b,c),
        this.near = d || 0,
        this.far = e || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("fm.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    ,
    a.Raycaster.prototype = {
        constructor: a.Raycaster,
        linePrecision: 1,
        set: function(a, b) {
            this.ray.set(a, b)
        },
        setFromCamera: function(b, c) {
            c instanceof a.PerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(c.matrixWorld),
            this.ray.direction.set(b.x, b.y, .5).unproject(c).sub(this.ray.origin).normalize()) : c instanceof a.OrthographicCamera ? (this.ray.origin.set(b.x, b.y, -1).unproject(c),
            this.ray.direction.set(0, 0, -1).transformDirection(c.matrixWorld)) : console.error("fm.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(a, d) {
            var e = [];
            return c(a, this, e, d),
            e.sort(b),
            e
        },
        intersectObjects: function(a, d) {
            var e = [];
            if (Array.isArray(a) === !1)
                return console.warn("fm.Raycaster.intersectObjects: objects is not an Array."),
                e;
            for (var f = 0, g = a.length; f < g; f++)
                c(a[f], this, e, d);
            return e.sort(b),
            e
        }
    }
}(fm),
fm.Uniform = function(a) {
    "string" == typeof a && (console.warn("fm.Uniform: Type parameter is no longer needed."),
    a = arguments[1]),
    this.value = a,
    this.dynamic = !1
}
,
fm.Uniform.prototype = {
    constructor: fm.Uniform,
    onUpdate: function(a) {
        return this.dynamic = !0,
        this.onUpdateCallback = a,
        this
    }
},
fm.Camera = function() {
    fm.Object3D.call(this),
    this.type = "Camera",
    this.matrixWorldInverse = new fm.Matrix4,
    this.projectionMatrix = new fm.Matrix4
}
,
fm.Camera.prototype = Object.create(fm.Object3D.prototype),
fm.Camera.prototype.constructor = fm.Camera,
fm.Camera.prototype.getWorldDirection = function() {
    var a = new fm.Quaternion;
    return function(b) {
        var c = b || new fm.Vector3;
        return this.getWorldQuaternion(a),
        c.set(0, 0, -1).applyQuaternion(a)
    }
}(),
fm.Camera.prototype.lookAt = function() {
    var a = new fm.Matrix4;
    return function(b) {
        a.lookAt(this.position, b, this.up),
        this.quaternion.setFromRotationMatrix(a)
    }
}(),
fm.Camera.prototype.clone = function() {
    return (new this.constructor).copy(this)
}
,
fm.Camera.prototype.copy = function(a) {
    return fm.Object3D.prototype.copy.call(this, a),
    this.matrixWorldInverse.copy(a.matrixWorldInverse),
    this.projectionMatrix.copy(a.projectionMatrix),
    this
}
,
fm.OrthographicCamera = function(a, b, c, d, e, f) {
    fm.Camera.call(this),
    this.type = "OrthographicCamera",
    this.zoom = 1,
    this.left = a,
    this.right = b,
    this.top = c,
    this.bottom = d,
    this.near = void 0 !== e ? e : .1,
    this.far = void 0 !== f ? f : 2e3,
    this.updateProjectionMatrix()
}
,
fm.OrthographicCamera.prototype = Object.create(fm.Camera.prototype),
fm.OrthographicCamera.prototype.constructor = fm.OrthographicCamera,
fm.OrthographicCamera.prototype.updateProjectionMatrix = function() {
    var a = (this.right - this.left) / (2 * this.zoom)
      , b = (this.top - this.bottom) / (2 * this.zoom)
      , c = (this.right + this.left) / 2
      , d = (this.top + this.bottom) / 2;
    this.projectionMatrix.makeOrthographic(c - a, c + a, d + b, d - b, this.near, this.far)
}
,
fm.OrthographicCamera.prototype.copy = function(a) {
    return fm.Camera.prototype.copy.call(this, a),
    this.left = a.left,
    this.right = a.right,
    this.top = a.top,
    this.bottom = a.bottom,
    this.near = a.near,
    this.far = a.far,
    this.zoom = a.zoom,
    this
}
,
fm.OrthographicCamera.prototype.toJSON = function(a) {
    var b = fm.Object3D.prototype.toJSON.call(this, a);
    return b.object.zoom = this.zoom,
    b.object.left = this.left,
    b.object.right = this.right,
    b.object.top = this.top,
    b.object.bottom = this.bottom,
    b.object.near = this.near,
    b.object.far = this.far,
    b
}
,
fm.PerspectiveCamera = function(a, b, c, d) {
    fm.Camera.call(this),
    this.type = "PerspectiveCamera",
    this.fov = void 0 !== a ? a : 50,
    this.zoom = 1,
    this.near = void 0 !== c ? c : .1,
    this.far = void 0 !== d ? d : 2e3,
    this.focus = 10,
    this.aspect = void 0 !== b ? b : 1,
    this.view = null ,
    this.filmGauge = 35,
    this.filmOffset = 0,
    this.updateProjectionMatrix()
}
,
fm.PerspectiveCamera.prototype = Object.create(fm.Camera.prototype),
fm.PerspectiveCamera.prototype.constructor = fm.PerspectiveCamera,
fm.PerspectiveCamera.prototype.setLens = function(a, b) {
    console.warn("fm.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
    void 0 !== b && (this.filmGauge = b),
    this.setFocalLength(a)
}
,
fm.PerspectiveCamera.prototype.setFocalLength = function(a) {
    var b = .5 * this.getFilmHeight() / a;
    this.fov = 2 * fm.Math.RAD2DEG * Math.atan(b),
    this.updateProjectionMatrix();
}
,
fm.PerspectiveCamera.prototype.getFocalLength = function() {
    var a = Math.tan(.5 * fm.Math.DEG2RAD * this.fov);
    return .5 * this.getFilmHeight() / a
}
,
fm.PerspectiveCamera.prototype.getEffectiveFOV = function() {
    return 2 * fm.Math.RAD2DEG * Math.atan(Math.tan(.5 * fm.Math.DEG2RAD * this.fov) / this.zoom)
}
,
fm.PerspectiveCamera.prototype.getFilmWidth = function() {
    return this.filmGauge * Math.min(this.aspect, 1)
}
,
fm.PerspectiveCamera.prototype.getFilmHeight = function() {
    return this.filmGauge / Math.max(this.aspect, 1)
}
,
fm.PerspectiveCamera.prototype.setViewOffset = function(a, b, c, d, e, f) {
    this.aspect = a / b,
    this.view = {
        fullWidth: a,
        fullHeight: b,
        offsetX: c,
        offsetY: d,
        width: e,
        height: f
    },
    this.updateProjectionMatrix()
}
,
fm.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
    var a = this.near
      , b = a * Math.tan(.5 * fm.Math.DEG2RAD * this.fov) / this.zoom
      , c = 2 * b
      , d = this.aspect * c
      , e = -.5 * d
      , f = this.view;
    if (null !== f) {
        var g = f.fullWidth
          , h = f.fullHeight;
        e += f.offsetX * d / g,
        b -= f.offsetY * c / h,
        d *= f.width / g,
        c *= f.height / h
    }
    var i = this.filmOffset;
    0 !== i && (e += a * i / this.getFilmWidth()),
    this.projectionMatrix.makeFrustum(e, e + d, b - c, b, a, this.far)
}
,
fm.PerspectiveCamera.prototype.copy = function(a) {
    return fm.Camera.prototype.copy.call(this, a),
    this.fov = a.fov,
    this.zoom = a.zoom,
    this.near = a.near,
    this.far = a.far,
    this.focus = a.focus,
    this.aspect = a.aspect,
    this.view = null === a.view ? null : Object.assign({}, a.view),
    this.filmGauge = a.filmGauge,
    this.filmOffset = a.filmOffset,
    this
}
,
fm.PerspectiveCamera.prototype.toJSON = function(a) {
    var b = fm.Object3D.prototype.toJSON.call(this, a);
    return b.object.fov = this.fov,
    b.object.zoom = this.zoom,
    b.object.near = this.near,
    b.object.far = this.far,
    b.object.focus = this.focus,
    b.object.aspect = this.aspect,
    null !== this.view && (b.object.view = Object.assign({}, this.view)),
    b.object.filmGauge = this.filmGauge,
    b.object.filmOffset = this.filmOffset,
    b
}
,
fm.ShapeUtils = {
    area: function(a) {
        for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++)
            c += a[d].x * a[e].y - a[e].x * a[d].y;
        return .5 * c
    },
    triangulate: function() {
        function a(a, b, c, d, e, f) {
            var g, h, i, j, k, l, m, n, o;
            if (h = a[f[b]].x,
            i = a[f[b]].y,
            j = a[f[c]].x,
            k = a[f[c]].y,
            l = a[f[d]].x,
            m = a[f[d]].y,
            Number.EPSILON > (j - h) * (m - i) - (k - i) * (l - h))
                return !1;
            var p, q, r, s, t, u, v, w, x, y, z, A, B, C, D;
            for (p = l - j,
            q = m - k,
            r = h - l,
            s = i - m,
            t = j - h,
            u = k - i,
            g = 0; g < e; g++)
                if (n = a[f[g]].x,
                o = a[f[g]].y,
                !(n === h && o === i || n === j && o === k || n === l && o === m) && (v = n - h,
                w = o - i,
                x = n - j,
                y = o - k,
                z = n - l,
                A = o - m,
                D = p * y - q * x,
                B = t * w - u * v,
                C = r * A - s * z,
                D >= -Number.EPSILON && C >= -Number.EPSILON && B >= -Number.EPSILON))
                    return !1;
            return !0
        }
        return function(b, c) {
            var d = b.length;
            if (d < 3)
                return null ;
            var e, f, g, h = [], i = [], j = [];
            if (fm.ShapeUtils.area(b) > 0)
                for (f = 0; f < d; f++)
                    i[f] = f;
            else
                for (f = 0; f < d; f++)
                    i[f] = d - 1 - f;
            var k = d
              , l = 2 * k;
            for (f = k - 1; k > 2; ) {
                if (l-- <= 0)
                    return console.warn("fm.ShapeUtils: Unable to triangulate polygon! in triangulate()"),
                    c ? j : h;
                if (e = f,
                k <= e && (e = 0),
                f = e + 1,
                k <= f && (f = 0),
                g = f + 1,
                k <= g && (g = 0),
                a(b, e, f, g, k, i)) {
                    var m, n, o, p, q;
                    for (m = i[e],
                    n = i[f],
                    o = i[g],
                    h.push([b[m], b[n], b[o]]),
                    j.push([i[e], i[f], i[g]]),
                    p = f,
                    q = f + 1; q < k; p++,
                    q++)
                        i[p] = i[q];
                    k--,
                    l = 2 * k
                }
            }
            return c ? j : h
        }
    }(),
    triangulateShape: function(a, b) {
        function c(a, b, c) {
            return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
        }
        function d(a, b, d, e, f) {
            var g = b.x - a.x
              , h = b.y - a.y
              , i = e.x - d.x
              , j = e.y - d.y
              , k = a.x - d.x
              , l = a.y - d.y
              , m = h * i - g * j
              , n = h * k - g * l;
            if (Math.abs(m) > Number.EPSILON) {
                var o;
                if (m > 0) {
                    if (n < 0 || n > m)
                        return [];
                    if (o = j * k - i * l,
                    o < 0 || o > m)
                        return []
                } else {
                    if (n > 0 || n < m)
                        return [];
                    if (o = j * k - i * l,
                    o > 0 || o < m)
                        return []
                }
                if (0 === o)
                    return !f || 0 !== n && n !== m ? [a] : [];
                if (o === m)
                    return !f || 0 !== n && n !== m ? [b] : [];
                if (0 === n)
                    return [d];
                if (n === m)
                    return [e];
                var p = o / m;
                return [{
                    x: a.x + p * g,
                    y: a.y + p * h
                }]
            }
            if (0 !== n || j * k !== i * l)
                return [];
            var q = 0 === g && 0 === h
              , r = 0 === i && 0 === j;
            if (q && r)
                return a.x !== d.x || a.y !== d.y ? [] : [a];
            if (q)
                return c(d, e, a) ? [a] : [];
            if (r)
                return c(a, b, d) ? [d] : [];
            var s, t, u, v, w, x, y, z;
            return 0 !== g ? (a.x < b.x ? (s = a,
            u = a.x,
            t = b,
            v = b.x) : (s = b,
            u = b.x,
            t = a,
            v = a.x),
            d.x < e.x ? (w = d,
            y = d.x,
            x = e,
            z = e.x) : (w = e,
            y = e.x,
            x = d,
            z = d.x)) : (a.y < b.y ? (s = a,
            u = a.y,
            t = b,
            v = b.y) : (s = b,
            u = b.y,
            t = a,
            v = a.y),
            d.y < e.y ? (w = d,
            y = d.y,
            x = e,
            z = e.y) : (w = e,
            y = e.y,
            x = d,
            z = d.y)),
            u <= y ? v < y ? [] : v === y ? f ? [] : [w] : v <= z ? [w, t] : [w, x] : u > z ? [] : u === z ? f ? [] : [s] : v <= z ? [s, t] : [s, x]
        }
        function e(a, b, c, d) {
            var e = b.x - a.x
              , f = b.y - a.y
              , g = c.x - a.x
              , h = c.y - a.y
              , i = d.x - a.x
              , j = d.y - a.y
              , k = e * h - f * g
              , l = e * j - f * i;
            if (Math.abs(k) > Number.EPSILON) {
                var m = i * h - j * g;
                return k > 0 ? l >= 0 && m >= 0 : l >= 0 || m >= 0
            }
            return l > 0
        }
        function f(a, b) {
            function c(a, b) {
                var c = s.length - 1
                  , d = a - 1;
                d < 0 && (d = c);
                var f = a + 1;
                f > c && (f = 0);
                var g = e(s[a], s[d], s[f], h[b]);
                if (!g)
                    return !1;
                var i = h.length - 1
                  , j = b - 1;
                j < 0 && (j = i);
                var k = b + 1;
                return k > i && (k = 0),
                g = e(h[b], h[j], h[k], s[a]),
                !!g
            }
            function f(a, b) {
                var c, e, f;
                for (c = 0; c < s.length; c++)
                    if (e = c + 1,
                    e %= s.length,
                    f = d(a, b, s[c], s[e], !0),
                    f.length > 0)
                        return !0;
                return !1
            }
            function g(a, c) {
                var e, f, g, h, i;
                for (e = 0; e < t.length; e++)
                    for (f = b[t[e]],
                    g = 0; g < f.length; g++)
                        if (h = g + 1,
                        h %= f.length,
                        i = d(a, c, f[g], f[h], !0),
                        i.length > 0)
                            return !0;
                return !1
            }
            for (var h, i, j, k, l, m, n, o, p, q, r, s = a.concat(), t = [], u = [], v = 0, w = b.length; v < w; v++)
                t.push(v);
            for (var x = 0, y = 2 * t.length; t.length > 0 && (y--,
            !(y < 0)); )
                for (j = x; j < s.length; j++) {
                    k = s[j],
                    i = -1;
                    for (var v = 0; v < t.length; v++)
                        if (m = t[v],
                        n = k.x + ":" + k.y + ":" + m,
                        void 0 === u[n]) {
                            h = b[m];
                            for (var z = 0; z < h.length; z++)
                                if (l = h[z],
                                c(j, z) && !f(k, l) && !g(k, l)) {
                                    i = z,
                                    t.splice(v, 1),
                                    o = s.slice(0, j + 1),
                                    p = s.slice(j),
                                    q = h.slice(i),
                                    r = h.slice(0, i + 1),
                                    s = o.concat(q).concat(r).concat(p),
                                    x = j;
                                    break
                                }
                            if (i >= 0)
                                break;
                            u[n] = !0
                        }
                    if (i >= 0)
                        break
                }
            return s
        }
        for (var g, h, i, j, k, l, m = {}, n = a.concat(), o = 0, p = b.length; o < p; o++)
            Array.prototype.push.apply(n, b[o]);
        for (g = 0,
        h = n.length; g < h; g++)
            k = n[g].x + ":" + n[g].y,
            void 0 !== m[k] && console.warn("fm.Shape: Duplicate point", k),
            m[k] = g;
        var q = f(a, b)
          , r = fm.ShapeUtils.triangulate(q, !1);
        for (g = 0,
        h = r.length; g < h; g++)
            for (j = r[g],
            i = 0; i < 3; i++)
                k = j[i].x + ":" + j[i].y,
                l = m[k],
                void 0 !== l && (j[i] = l);
        return r.concat()
    },
    isClockWise: function(a) {
        return fm.ShapeUtils.area(a) < 0
    },
    b2: function() {
        function a(a, b) {
            var c = 1 - a;
            return c * c * b
        }
        function b(a, b) {
            return 2 * (1 - a) * a * b
        }
        function c(a, b) {
            return a * a * b
        }
        return function(d, e, f, g) {
            return a(d, e) + b(d, f) + c(d, g)
        }
    }(),
    b3: function() {
        function a(a, b) {
            var c = 1 - a;
            return c * c * c * b
        }
        function b(a, b) {
            var c = 1 - a;
            return 3 * c * c * a * b
        }
        function c(a, b) {
            var c = 1 - a;
            return 3 * c * a * a * b
        }
        function d(a, b) {
            return a * a * a * b
        }
        return function(e, f, g, h, i) {
            return a(e, f) + b(e, g) + c(e, h) + d(e, i)
        }
    }()
},
fm.Curve = function() {}
,
fm.Curve.prototype = {
    constructor: fm.Curve,
    getPoint: function(a) {
        return console.warn("fm.Curve: Warning, getPoint() not implemented!"),
        null
    },
    getPointAt: function(a) {
        var b = this.getUtoTmapping(a);
        return this.getPoint(b)
    },
    getPoints: function(a) {
        a || (a = 5);
        var b, c = [];
        for (b = 0; b <= a; b++)
            c.push(this.getPoint(b / a));
        return c
    },
    getSpacedPoints: function(a) {
        a || (a = 5);
        var b, c = [];
        for (b = 0; b <= a; b++)
            c.push(this.getPointAt(b / a));
        return c
    },
    getLength: function() {
        var a = this.getLengths();
        return a[a.length - 1]
    },
    getLengths: function(a) {
        if (a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200),
        this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        var b, c, d = [], e = this.getPoint(0), f = 0;
        for (d.push(0),
        c = 1; c <= a; c++)
            b = this.getPoint(c / a),
            f += b.distanceTo(e),
            d.push(f),
            e = b;
        return this.cacheArcLengths = d,
        d
    },
    updateArcLengths: function() {
        this.needsUpdate = !0,
        this.getLengths()
    },
    getUtoTmapping: function(a, b) {
        var c, d = this.getLengths(), e = 0, f = d.length;
        c = b ? b : a * d[f - 1];
        for (var g, h = 0, i = f - 1; h <= i; )
            if (e = Math.floor(h + (i - h) / 2),
            g = d[e] - c,
            g < 0)
                h = e + 1;
            else {
                if (!(g > 0)) {
                    i = e;
                    break
                }
                i = e - 1
            }
        if (e = i,
        d[e] === c) {
            var j = e / (f - 1);
            return j
        }
        var k = d[e]
          , l = d[e + 1]
          , m = l - k
          , n = (c - k) / m
          , j = (e + n) / (f - 1);
        return j
    },
    getTangent: function(a) {
        var b = 1e-4
          , c = a - b
          , d = a + b;
        c < 0 && (c = 0),
        d > 1 && (d = 1);
        var e = this.getPoint(c)
          , f = this.getPoint(d)
          , g = f.clone().sub(e);
        return g.normalize()
    },
    getTangentAt: function(a) {
        var b = this.getUtoTmapping(a);
        return this.getTangent(b)
    }
},
fm.Curve.create = function(a, b) {
    return a.prototype = Object.create(fm.Curve.prototype),
    a.prototype.constructor = a,
    a.prototype.getPoint = b,
    a
}
,
fm.CurvePath = function() {
    this.curves = [],
    this.autoClose = !1
}
,
fm.CurvePath.prototype = Object.create(fm.Curve.prototype),
fm.CurvePath.prototype.constructor = fm.CurvePath,
fm.CurvePath.prototype.add = function(a) {
    this.curves.push(a)
}
,
fm.CurvePath.prototype.closePath = function() {
    var a = this.curves[0].getPoint(0)
      , b = this.curves[this.curves.length - 1].getPoint(1);
    a.equals(b) || this.curves.push(new fm.LineCurve(b,a))
}
,
fm.CurvePath.prototype.getPoint = function(a) {
    for (var b = a * this.getLength(), c = this.getCurveLengths(), d = 0; d < c.length; ) {
        if (c[d] >= b) {
            var e = c[d] - b
              , f = this.curves[d]
              , g = 1 - e / f.getLength();
            return f.getPointAt(g)
        }
        d++
    }
    return null
}
,
fm.CurvePath.prototype.getLength = function() {
    var a = this.getCurveLengths();
    return a[a.length - 1]
}
,
fm.CurvePath.prototype.getCurveLengths = function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
    for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++)
        b += this.curves[c].getLength(),
        a.push(b);
    return this.cacheLengths = a,
    a
}
,
fm.CurvePath.prototype.createPointsGeometry = function(a) {
    var b = this.getPoints(a);
    return this.createGeometry(b)
}
,
fm.CurvePath.prototype.createSpacedPointsGeometry = function(a) {
    var b = this.getSpacedPoints(a);
    return this.createGeometry(b)
}
,
fm.CurvePath.prototype.createGeometry = function(a) {
    for (var b = new fm.Geometry, c = 0, d = a.length; c < d; c++) {
        var e = a[c];
        b.vertices.push(new fm.Vector3(e.x,e.y,e.z || 0))
    }
    return b
}
,
fm.Font = function(a) {
    this.data = a
}
,
fm.Font.prototype = {
    constructor: fm.Font,
    generateShapes: function(a, b, c) {
        function d(a) {
            for (var c = String(a).split(""), d = b / f.resolution, g = 0, h = [], i = 0; i < c.length; i++) {
                var j = e(c[i], d, g);
                g += j.offset,
                h.push(j.path)
            }
            return h
        }
        function e(a, b, d) {
            var e = f.glyphs[a] || f.glyphs["?"];
            if (e) {
                var g, h, i, j, k, l, m, n, o, p, q, r = new fm.Path, s = [], t = fm.ShapeUtils.b2, u = fm.ShapeUtils.b3;
                if (e.o)
                    for (var v = e._cachedOutline || (e._cachedOutline = e.o.split(" ")), w = 0, x = v.length; w < x; ) {
                        var y = v[w++];
                        switch (y) {
                        case "m":
                            g = v[w++] * b + d,
                            h = v[w++] * b,
                            r.moveTo(g, h);
                            break;
                        case "l":
                            g = v[w++] * b + d,
                            h = v[w++] * b,
                            r.lineTo(g, h);
                            break;
                        case "q":
                            if (i = v[w++] * b + d,
                            j = v[w++] * b,
                            m = v[w++] * b + d,
                            n = v[w++] * b,
                            r.quadraticCurveTo(m, n, i, j),
                            q = s[s.length - 1]) {
                                k = q.x,
                                l = q.y;
                                for (var z = 1; z <= c; z++) {
                                    var A = z / c;
                                    t(A, k, m, i),
                                    t(A, l, n, j)
                                }
                            }
                            break;
                        case "b":
                            if (i = v[w++] * b + d,
                            j = v[w++] * b,
                            m = v[w++] * b + d,
                            n = v[w++] * b,
                            o = v[w++] * b + d,
                            p = v[w++] * b,
                            r.bezierCurveTo(m, n, o, p, i, j),
                            q = s[s.length - 1]) {
                                k = q.x,
                                l = q.y;
                                for (var z = 1; z <= c; z++) {
                                    var A = z / c;
                                    u(A, k, m, o, i),
                                    u(A, l, n, p, j)
                                }
                            }
                        }
                    }
                return {
                    offset: e.ha * b,
                    path: r
                }
            }
        }
        void 0 === b && (b = 100),
        void 0 === c && (c = 4);
        for (var f = this.data, g = d(a), h = [], i = 0, j = g.length; i < j; i++)
            Array.prototype.push.apply(h, g[i].toShapes());
        return h
    }
},
fm.Path = function(a) {
    fm.CurvePath.call(this),
    this.actions = [],
    a && this.fromPoints(a)
}
,
fm.Path.prototype = Object.create(fm.CurvePath.prototype),
fm.Path.prototype.constructor = fm.Path,
fm.Path.prototype.fromPoints = function(a) {
    this.moveTo(a[0].x, a[0].y);
    for (var b = 1, c = a.length; b < c; b++)
        this.lineTo(a[b].x, a[b].y)
}
,
fm.Path.prototype.moveTo = function(a, b) {
    this.actions.push({
        action: "moveTo",
        args: [a, b]
    })
}
,
fm.Path.prototype.lineTo = function(a, b) {
    var c = this.actions[this.actions.length - 1].args
      , d = c[c.length - 2]
      , e = c[c.length - 1]
      , f = new fm.LineCurve(new fm.Vector2(d,e),new fm.Vector2(a,b));
    this.curves.push(f),
    this.actions.push({
        action: "lineTo",
        args: [a, b]
    })
}
,
fm.Path.prototype.quadraticCurveTo = function(a, b, c, d) {
    var e = this.actions[this.actions.length - 1].args
      , f = e[e.length - 2]
      , g = e[e.length - 1]
      , h = new fm.QuadraticBezierCurve(new fm.Vector2(f,g),new fm.Vector2(a,b),new fm.Vector2(c,d));
    this.curves.push(h),
    this.actions.push({
        action: "quadraticCurveTo",
        args: [a, b, c, d]
    })
}
,
fm.Path.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
    var g = this.actions[this.actions.length - 1].args
      , h = g[g.length - 2]
      , i = g[g.length - 1]
      , j = new fm.CubicBezierCurve(new fm.Vector2(h,i),new fm.Vector2(a,b),new fm.Vector2(c,d),new fm.Vector2(e,f));
    this.curves.push(j),
    this.actions.push({
        action: "bezierCurveTo",
        args: [a, b, c, d, e, f]
    })
}
,
fm.Path.prototype.splineThru = function(a) {
    var b = Array.prototype.slice.call(arguments)
      , c = this.actions[this.actions.length - 1].args
      , d = c[c.length - 2]
      , e = c[c.length - 1]
      , f = [new fm.Vector2(d,e)];
    Array.prototype.push.apply(f, a);
    var g = new fm.SplineCurve(f);
    this.curves.push(g),
    this.actions.push({
        action: "splineThru",
        args: b
    })
}
,
fm.Path.prototype.arc = function(a, b, c, d, e, f) {
    var g = this.actions[this.actions.length - 1].args
      , h = g[g.length - 2]
      , i = g[g.length - 1];
    this.absarc(a + h, b + i, c, d, e, f)
}
,
fm.Path.prototype.absarc = function(a, b, c, d, e, f) {
    this.absellipse(a, b, c, c, d, e, f)
}
,
fm.Path.prototype.ellipse = function(a, b, c, d, e, f, g, h) {
    var i = this.actions[this.actions.length - 1].args
      , j = i[i.length - 2]
      , k = i[i.length - 1];
    this.absellipse(a + j, b + k, c, d, e, f, g, h)
}
,
fm.Path.prototype.absellipse = function(a, b, c, d, e, f, g, h) {
    var i = [a, b, c, d, e, f, g, h || 0]
      , j = new fm.EllipseCurve(a,b,c,d,e,f,g,h);
    this.curves.push(j);
    var k = j.getPoint(1);
    i.push(k.x),
    i.push(k.y),
    this.actions.push({
        action: "ellipse",
        args: i
    })
}
,
fm.Path.prototype.getSpacedPoints = function(a) {
    a || (a = 40);
    for (var b = [], c = 0; c < a; c++)
        b.push(this.getPoint(c / a));
    return this.autoClose && b.push(b[0]),
    b
}
,
fm.Path.prototype.getPoints = function(a) {
    a = a || 12;
    for (var b, c, d, e, f, g, h, i, j, k, l, m = fm.ShapeUtils.b2, n = fm.ShapeUtils.b3, o = [], p = 0, q = this.actions.length; p < q; p++) {
        var r = this.actions[p]
          , s = r.action
          , t = r.args;
        switch (s) {
        case "moveTo":
            o.push(new fm.Vector2(t[0],t[1]));
            break;
        case "lineTo":
            o.push(new fm.Vector2(t[0],t[1]));
            break;
        case "quadraticCurveTo":
            b = t[2],
            c = t[3],
            f = t[0],
            g = t[1],
            o.length > 0 ? (j = o[o.length - 1],
            h = j.x,
            i = j.y) : (j = this.actions[p - 1].args,
            h = j[j.length - 2],
            i = j[j.length - 1]);
            for (var u = 1; u <= a; u++) {
                var v = u / a;
                k = m(v, h, f, b),
                l = m(v, i, g, c),
                o.push(new fm.Vector2(k,l))
            }
            break;
        case "bezierCurveTo":
            b = t[4],
            c = t[5],
            f = t[0],
            g = t[1],
            d = t[2],
            e = t[3],
            o.length > 0 ? (j = o[o.length - 1],
            h = j.x,
            i = j.y) : (j = this.actions[p - 1].args,
            h = j[j.length - 2],
            i = j[j.length - 1]);
            for (var u = 1; u <= a; u++) {
                var v = u / a;
                k = n(v, h, f, d, b),
                l = n(v, i, g, e, c),
                o.push(new fm.Vector2(k,l))
            }
            break;
        case "splineThru":
            j = this.actions[p - 1].args;
            var w = new fm.Vector2(j[j.length - 2],j[j.length - 1])
              , x = [w]
              , y = a * t[0].length;
            x = x.concat(t[0]);
            for (var z = new fm.SplineCurve(x), u = 1; u <= y; u++)
                o.push(z.getPointAt(u / y));
            break;
        case "arc":
            for (var A, B = t[0], C = t[1], D = t[2], E = t[3], F = t[4], G = !!t[5], H = F - E, I = 2 * a, u = 1; u <= I; u++) {
                var v = u / I;
                G || (v = 1 - v),
                A = E + v * H,
                k = B + D * Math.cos(A),
                l = C + D * Math.sin(A),
                o.push(new fm.Vector2(k,l))
            }
            break;
        case "ellipse":
            var A, J, K, B = t[0], C = t[1], L = t[2], M = t[3], E = t[4], F = t[5], G = !!t[6], N = t[7], H = F - E, I = 2 * a;
            0 !== N && (J = Math.cos(N),
            K = Math.sin(N));
            for (var u = 1; u <= I; u++) {
                var v = u / I;
                if (G || (v = 1 - v),
                A = E + v * H,
                k = B + L * Math.cos(A),
                l = C + M * Math.sin(A),
                0 !== N) {
                    var O = k
                      , P = l;
                    k = (O - B) * J - (P - C) * K + B,
                    l = (O - B) * K + (P - C) * J + C
                }
                o.push(new fm.Vector2(k,l))
            }
        }
    }
    var Q = o[o.length - 1];
    return Math.abs(Q.x - o[0].x) < Number.EPSILON && Math.abs(Q.y - o[0].y) < Number.EPSILON && o.splice(o.length - 1, 1),
    this.autoClose && o.push(o[0]),
    o
}
,
fm.Path.prototype.toShapes = function(a, b) {
    function c(a) {
        for (var b = [], c = new fm.Path, d = 0, e = a.length; d < e; d++) {
            var f = a[d]
              , g = f.args
              , h = f.action;
            "moveTo" === h && 0 !== c.actions.length && (b.push(c),
            c = new fm.Path),
            c[h].apply(c, g)
        }
        return 0 !== c.actions.length && b.push(c),
        b
    }
    function d(a) {
        for (var b = [], c = 0, d = a.length; c < d; c++) {
            var e = a[c]
              , f = new fm.Shape;
            f.actions = e.actions,
            f.curves = e.curves,
            b.push(f)
        }
        return b
    }
    function e(a, b) {
        for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
            var g = b[e]
              , h = b[f]
              , i = h.x - g.x
              , j = h.y - g.y;
            if (Math.abs(j) > Number.EPSILON) {
                if (j < 0 && (g = b[f],
                i = -i,
                h = b[e],
                j = -j),
                a.y < g.y || a.y > h.y)
                    continue;if (a.y === g.y) {
                    if (a.x === g.x)
                        return !0
                } else {
                    var k = j * (a.x - g.x) - i * (a.y - g.y);
                    if (0 === k)
                        return !0;
                    if (k < 0)
                        continue;d = !d
                }
            } else {
                if (a.y !== g.y)
                    continue;if (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)
                    return !0
            }
        }
        return d
    }
    var f = fm.ShapeUtils.isClockWise
      , g = c(this.actions);
    if (0 === g.length)
        return [];
    if (b === !0)
        return d(g);
    var h, i, j, k = [];
    if (1 === g.length)
        return i = g[0],
        j = new fm.Shape,
        j.actions = i.actions,
        j.curves = i.curves,
        k.push(j),
        k;
    var l = !f(g[0].getPoints());
    l = a ? !l : l;
    var m, n = [], o = [], p = [], q = 0;
    o[q] = void 0,
    p[q] = [];
    for (var r = 0, s = g.length; r < s; r++)
        i = g[r],
        m = i.getPoints(),
        h = f(m),
        h = a ? !h : h,
        h ? (!l && o[q] && q++,
        o[q] = {
            s: new fm.Shape,
            p: m
        },
        o[q].s.actions = i.actions,
        o[q].s.curves = i.curves,
        l && q++,
        p[q] = []) : p[q].push({
            h: i,
            p: m[0]
        });
    if (!o[0])
        return d(g);
    if (o.length > 1) {
        for (var t = !1, u = [], v = 0, w = o.length; v < w; v++)
            n[v] = [];
        for (var v = 0, w = o.length; v < w; v++)
            for (var x = p[v], y = 0; y < x.length; y++) {
                for (var z = x[y], A = !0, B = 0; B < o.length; B++)
                    e(z.p, o[B].p) && (v !== B && u.push({
                        froms: v,
                        tos: B,
                        hole: y
                    }),
                    A ? (A = !1,
                    n[B].push(z)) : t = !0);
                A && n[v].push(z)
            }
        u.length > 0 && (t || (p = n))
    }
    for (var C, r = 0, D = o.length; r < D; r++) {
        j = o[r].s,
        k.push(j),
        C = p[r];
        for (var E = 0, F = C.length; E < F; E++)
            j.holes.push(C[E].h)
    }
    return k
}
,
fm.Shape = function() {
    fm.Path.apply(this, arguments),
    this.holes = []
}
,
fm.Shape.prototype = Object.create(fm.Path.prototype),
fm.Shape.prototype.constructor = fm.Shape,
fm.Shape.prototype.extrude = function(a) {
    return new fm.ExtrudeGeometry(this,a)
}
,
fm.Shape.prototype.makeGeometry = function(a) {
    return new fm.ShapeGeometry(this,a)
}
,
fm.Shape.prototype.getPointsHoles = function(a) {
    for (var b = [], c = 0, d = this.holes.length; c < d; c++)
        b[c] = this.holes[c].getPoints(a);
    return b
}
,
fm.Shape.prototype.extractAllPoints = function(a) {
    return {
        shape: this.getPoints(a),
        holes: this.getPointsHoles(a)
    }
}
,
fm.Shape.prototype.extractPoints = function(a) {
    return this.extractAllPoints(a)
}
,
fm.ExtrudeGeometry = function(a, b) {
    return "undefined" == typeof a ? void (a = []) : (fm.Geometry.call(this),
    this.type = "ExtrudeGeometry",
    a = Array.isArray(a) ? a : [a],
    this.addShapeList(a, b),
    void this.computeFaceNormals())
}
,
fm.ExtrudeGeometry.prototype = Object.create(fm.Geometry.prototype),
fm.ExtrudeGeometry.prototype.constructor = fm.ExtrudeGeometry,
fm.ExtrudeGeometry.prototype.addShapeList = function(a, b) {
    for (var c = a.length, d = 0; d < c; d++) {
        var e = a[d];
        this.addShape(e, b)
    }
}
,
fm.ExtrudeGeometry.prototype.addShape = function(a, b) {
    function c(a, b, c) {
        return b || console.error("fm.ExtrudeGeometry: vec does not exist"),
        b.clone().multiplyScalar(c).add(a)
    }
    function d(a, b, c) {
        var d, e, f = 1, g = a.x - b.x, h = a.y - b.y, i = c.x - a.x, j = c.y - a.y, k = g * g + h * h, l = g * j - h * i;
        if (Math.abs(l) > Number.EPSILON) {
            var m = Math.sqrt(k)
              , n = Math.sqrt(i * i + j * j)
              , o = b.x - h / m
              , p = b.y + g / m
              , q = c.x - j / n
              , r = c.y + i / n
              , s = ((q - o) * j - (r - p) * i) / (g * j - h * i);
            d = o + g * s - a.x,
            e = p + h * s - a.y;
            var t = d * d + e * e;
            if (t <= 2)
                return new fm.Vector2(d,e);
            f = Math.sqrt(t / 2)
        } else {
            var u = !1;
            g > Number.EPSILON ? i > Number.EPSILON && (u = !0) : g < -Number.EPSILON ? i < -Number.EPSILON && (u = !0) : Math.sign(h) === Math.sign(j) && (u = !0),
            u ? (d = -h,
            e = g,
            f = Math.sqrt(k)) : (d = g,
            e = h,
            f = Math.sqrt(k / 2))
        }
        return new fm.Vector2(d / f,e / f)
    }
    function e() {
        if (t) {
            var a = 0
              , b = Q * a;
            for (T = 0; T < R; T++)
                P = I[T],
                i(P[2] + b, P[1] + b, P[0] + b);
            for (a = v + 2 * s,
            b = Q * a,
            T = 0; T < R; T++)
                P = I[T],
                i(P[0] + b, P[1] + b, P[2] + b)
        } else {
            for (T = 0; T < R; T++)
                P = I[T],
                i(P[2], P[1], P[0]);
            for (T = 0; T < R; T++)
                P = I[T],
                i(P[0] + Q * v, P[1] + Q * v, P[2] + Q * v)
        }
    }
    function f() {
        var a = 0;
        for (g(J, a),
        a += J.length,
        A = 0,
        B = G.length; A < B; A++)
            z = G[A],
            g(z, a),
            a += z.length
    }
    function g(a, b) {
        var c, d;
        for (T = a.length; --T >= 0; ) {
            c = T,
            d = T - 1,
            d < 0 && (d = a.length - 1);
            var e = 0
              , f = v + 2 * s;
            for (e = 0; e < f; e++) {
                var g = Q * e
                  , h = Q * (e + 1)
                  , i = b + c + g
                  , k = b + d + g
                  , l = b + d + h
                  , m = b + c + h;
                j(i, k, l, m, a, e, f, c, d)
            }
        }
    }
    function h(a, b, c) {
        C.vertices.push(new fm.Vector3(a,b,c))
    }
    function i(a, b, c) {
        a += D,
        b += D,
        c += D,
        C.faces.push(new fm.Face3(a,b,c,null ,null ,0));
        var d = y.generateTopUV(C, a, b, c);
        C.faceVertexUvs[0].push(d)
    }
    function j(a, b, c, d, e, f, g, h, i) {
        a += D,
        b += D,
        c += D,
        d += D,
        C.faces.push(new fm.Face3(a,b,d,null ,null ,1)),
        C.faces.push(new fm.Face3(b,c,d,null ,null ,1));
        var j = y.generateSideWallUV(C, a, b, c, d);
        C.faceVertexUvs[0].push([j[0], j[1], j[3]]),
        C.faceVertexUvs[0].push([j[1], j[2], j[3]])
    }
    var k, l, m, n, o, p = void 0 !== b.amount ? b.amount : 100, q = void 0 !== b.bevelThickness ? b.bevelThickness : 6, r = void 0 !== b.bevelSize ? b.bevelSize : q - 2, s = void 0 !== b.bevelSegments ? b.bevelSegments : 3, t = void 0 === b.bevelEnabled || b.bevelEnabled, u = void 0 !== b.curveSegments ? b.curveSegments : 12, v = void 0 !== b.steps ? b.steps : 1, w = b.extrudePath, x = !1, y = void 0 !== b.UVGenerator ? b.UVGenerator : fm.ExtrudeGeometry.WorldUVGenerator;
    w && (k = w.getSpacedPoints(v),
    x = !0,
    t = !1,
    l = void 0 !== b.frames ? b.frames : new fm.TubeGeometry.FrenetFrames(w,v,(!1)),
    m = new fm.Vector3,
    n = new fm.Vector3,
    o = new fm.Vector3),
    t || (s = 0,
    q = 0,
    r = 0);
    var z, A, B, C = this, D = this.vertices.length, E = a.extractPoints(u), F = E.shape, G = E.holes, H = !fm.ShapeUtils.isClockWise(F);
    if (H) {
        for (F = F.reverse(),
        A = 0,
        B = G.length; A < B; A++)
            z = G[A],
            fm.ShapeUtils.isClockWise(z) && (G[A] = z.reverse());
        H = !1
    }
    var I = fm.ShapeUtils.triangulateShape(F, G)
      , J = F;
    for (A = 0,
    B = G.length; A < B; A++)
        z = G[A],
        F = F.concat(z);
    for (var K, L, M, N, O, P, Q = F.length, R = I.length, S = [], T = 0, U = J.length, V = U - 1, W = T + 1; T < U; T++,
    V++,
    W++)
        V === U && (V = 0),
        W === U && (W = 0),
        S[T] = d(J[T], J[V], J[W]);
    var X, Y = [], Z = S.concat();
    for (A = 0,
    B = G.length; A < B; A++) {
        for (z = G[A],
        X = [],
        T = 0,
        U = z.length,
        V = U - 1,
        W = T + 1; T < U; T++,
        V++,
        W++)
            V === U && (V = 0),
            W === U && (W = 0),
            X[T] = d(z[T], z[V], z[W]);
        Y.push(X),
        Z = Z.concat(X)
    }
    for (K = 0; K < s; K++) {
        for (M = K / s,
        N = q * (1 - M),
        L = r * Math.sin(M * Math.PI / 2),
        T = 0,
        U = J.length; T < U; T++)
            O = c(J[T], S[T], L),
            h(O.x, O.y, -N);
        for (A = 0,
        B = G.length; A < B; A++)
            for (z = G[A],
            X = Y[A],
            T = 0,
            U = z.length; T < U; T++)
                O = c(z[T], X[T], L),
                h(O.x, O.y, -N)
    }
    for (L = r,
    T = 0; T < Q; T++)
        O = t ? c(F[T], Z[T], L) : F[T],
        x ? (n.copy(l.normals[0]).multiplyScalar(O.x),
        m.copy(l.binormals[0]).multiplyScalar(O.y),
        o.copy(k[0]).add(n).add(m),
        h(o.x, o.y, o.z)) : h(O.x, O.y, 0);
    var $;
    for ($ = 1; $ <= v; $++)
        for (T = 0; T < Q; T++)
            O = t ? c(F[T], Z[T], L) : F[T],
            x ? (n.copy(l.normals[$]).multiplyScalar(O.x),
            m.copy(l.binormals[$]).multiplyScalar(O.y),
            o.copy(k[$]).add(n).add(m),
            h(o.x, o.y, o.z)) : h(O.x, O.y, p / v * $);
    for (K = s - 1; K >= 0; K--) {
        for (M = K / s,
        N = q * (1 - M),
        L = r * Math.sin(M * Math.PI / 2),
        T = 0,
        U = J.length; T < U; T++)
            O = c(J[T], S[T], L),
            h(O.x, O.y, p + N);
        for (A = 0,
        B = G.length; A < B; A++)
            for (z = G[A],
            X = Y[A],
            T = 0,
            U = z.length; T < U; T++)
                O = c(z[T], X[T], L),
                x ? h(O.x, O.y + k[v - 1].y, k[v - 1].x + N) : h(O.x, O.y, p + N)
    }
    e(),
    f()
}
,
fm.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function(a, b, c, d) {
        var e = a.vertices
          , f = e[b]
          , g = e[c]
          , h = e[d];
        return [new fm.Vector2(f.x,f.y), new fm.Vector2(g.x,g.y), new fm.Vector2(h.x,h.y)]
    },
    generateSideWallUV: function(a, b, c, d, e) {
        var f = a.vertices
          , g = f[b]
          , h = f[c]
          , i = f[d]
          , j = f[e];
        return Math.abs(g.y - h.y) < .01 ? [new fm.Vector2(g.x,1 - g.z), new fm.Vector2(h.x,1 - h.z), new fm.Vector2(i.x,1 - i.z), new fm.Vector2(j.x,1 - j.z)] : [new fm.Vector2(g.y,1 - g.z), new fm.Vector2(h.y,1 - h.z), new fm.Vector2(i.y,1 - i.z), new fm.Vector2(j.y,1 - j.z)]
    }
},
fm.PlaneGeometry = function(a, b, c, d) {
    fm.Geometry.call(this),
    this.type = "PlaneGeometry",
    this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    },
    this.fromBufferGeometry(new fm.PlaneBufferGeometry(a,b,c,d))
}
,
fm.PlaneGeometry.prototype = Object.create(fm.Geometry.prototype),
fm.PlaneGeometry.prototype.constructor = fm.PlaneGeometry,
fm.PlaneBufferGeometry = function(a, b, c, d) {
    fm.BufferGeometry.call(this),
    this.type = "PlaneBufferGeometry",
    this.parameters = {
        width: a,
        height: b,
        widthSegments: c,
        heightSegments: d
    };
    for (var e = a / 2, f = b / 2, g = Math.floor(c) || 1, h = Math.floor(d) || 1, i = g + 1, j = h + 1, k = a / g, l = b / h, m = new Float32Array(i * j * 3), n = new Float32Array(i * j * 3), o = new Float32Array(i * j * 2), p = 0, q = 0, r = 0; r < j; r++)
        for (var s = r * l - f, t = 0; t < i; t++) {
            var u = t * k - e;
            m[p] = u,
            m[p + 1] = -s,
            n[p + 2] = 1,
            o[q] = t / g,
            o[q + 1] = 1 - r / h,
            p += 3,
            q += 2
        }
    p = 0;
    for (var v = new (m.length / 3 > 65535 ? Uint32Array : Uint16Array)(g * h * 6), r = 0; r < h; r++)
        for (var t = 0; t < g; t++) {
            var w = t + i * r
              , x = t + i * (r + 1)
              , y = t + 1 + i * (r + 1)
              , z = t + 1 + i * r;
            v[p] = w,
            v[p + 1] = x,
            v[p + 2] = z,
            v[p + 3] = x,
            v[p + 4] = y,
            v[p + 5] = z,
            p += 6
        }
    this.setIndex(new fm.BufferAttribute(v,1)),
    this.addAttribute("position", new fm.BufferAttribute(m,3)),
    this.addAttribute("normal", new fm.BufferAttribute(n,3)),
    this.addAttribute("uv", new fm.BufferAttribute(o,2))
}
,
fm.PlaneBufferGeometry.prototype = Object.create(fm.BufferGeometry.prototype),
fm.PlaneBufferGeometry.prototype.constructor = fm.PlaneBufferGeometry,
fm.Light = function(a, b) {
    fm.Object3D.call(this),
    this.type = "Light",
    this.color = new fm.Color(a),
    this.intensity = void 0 !== b ? b : 1,
    this.receiveShadow = void 0
}
,
fm.Light.prototype = Object.create(fm.Object3D.prototype),
fm.Light.prototype.constructor = fm.Light,
fm.Light.prototype.copy = function(a) {
    return fm.Object3D.prototype.copy.call(this, a),
    this.color.copy(a.color),
    this.intensity = a.intensity,
    this
}
,
fm.Light.prototype.toJSON = function(a) {
    var b = fm.Object3D.prototype.toJSON.call(this, a);
    return b.object.color = this.color.getHex(),
    b.object.intensity = this.intensity,
    void 0 !== this.groundColor && (b.object.groundColor = this.groundColor.getHex()),
    void 0 !== this.distance && (b.object.distance = this.distance),
    void 0 !== this.angle && (b.object.angle = this.angle),
    void 0 !== this.decay && (b.object.decay = this.decay),
    void 0 !== this.penumbra && (b.object.penumbra = this.penumbra),
    b
}
,
fm.LightShadow = function(a) {
    this.camera = a,
    this.bias = 0,
    this.radius = 1,
    this.mapSize = new fm.Vector2(512,512),
    this.map = null ,
    this.matrix = new fm.Matrix4
}
,
fm.LightShadow.prototype = {
    constructor: fm.LightShadow,
    copy: function(a) {
        return this.camera = a.camera.clone(),
        this.bias = a.bias,
        this.radius = a.radius,
        this.mapSize.copy(a.mapSize),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    }
},
fm.AmbientLight = function(a, b) {
    fm.Light.call(this, a, b),
    this.type = "AmbientLight",
    this.castShadow = void 0
}
,
fm.AmbientLight.prototype = Object.create(fm.Light.prototype),
fm.AmbientLight.prototype.constructor = fm.AmbientLight,
fm.PointLight = function(a, b, c, d) {
    fm.Light.call(this, a, b),
    this.type = "PointLight",
    this.distance = void 0 !== c ? c : 0,
    this.decay = void 0 !== d ? d : 1,
    this.shadow = new fm.LightShadow(new fm.PerspectiveCamera(90,1,.5,500))
}
,
fm.PointLight.prototype = Object.create(fm.Light.prototype),
fm.PointLight.prototype.constructor = fm.PointLight,
Object.defineProperty(fm.PointLight.prototype, "power", {
    get: function() {
        return 4 * this.intensity * Math.PI
    },
    set: function(a) {
        this.intensity = a / (4 * Math.PI)
    }
}),
fm.PointLight.prototype.copy = function(a) {
    return fm.Light.prototype.copy.call(this, a),
    this.distance = a.distance,
    this.decay = a.decay,
    this.shadow = a.shadow.clone(),
    this
}
,
fm.DirectionalLight = function(a, b) {
    fm.Light.call(this, a, b),
    this.type = "DirectionalLight",
    this.position.set(0, 1, 0),
    this.updateMatrix(),
    this.target = new fm.Object3D,
    this.shadow = new fm.DirectionalLightShadow
}
,
fm.DirectionalLight.prototype = Object.create(fm.Light.prototype),
fm.DirectionalLight.prototype.constructor = fm.DirectionalLight,
fm.DirectionalLight.prototype.copy = function(a) {
    return fm.Light.prototype.copy.call(this, a),
    this.target = a.target.clone(),
    this.shadow = a.shadow.clone(),
    this
}
,
fm.DirectionalLightShadow = function(a) {
    fm.LightShadow.call(this, new fm.OrthographicCamera((-5),5,5,(-5),.5,500))
}
,
fm.DirectionalLightShadow.prototype = Object.create(fm.LightShadow.prototype),
fm.DirectionalLightShadow.prototype.constructor = fm.DirectionalLightShadow,
fm.Material = function() {
    Object.defineProperty(this, "id", {
        value: fm.MaterialIdCount++
    }),
    this.uuid = fm.Math.generateUUID(),
    this.name = "",
    this.type = "Material",
    this.side = fm.FrontSide,
    this.opacity = 1,
    this.transparent = !1,
    this.blending = fm.NormalBlending,
    this.blendSrc = fm.SrcAlphaFactor,
    this.blendDst = fm.OneMinusSrcAlphaFactor,
    this.blendEquation = fm.AddEquation,
    this.blendSrcAlpha = null ,
    this.blendDstAlpha = null ,
    this.blendEquationAlpha = null ,
    this.depthFunc = fm.LessEqualDepth,
    this.depthTest = !0,
    this.depthWrite = !0,
    this.clippingPlanes = null ,
    this.clipShadows = !1,
    this.colorWrite = !0,
    this.precision = null ,
    this.polygonOffset = !1,
    this.polygonOffsetFactor = 0,
    this.polygonOffsetUnits = 0,
    this.alphaTest = 0,
    this.premultipliedAlpha = !1,
    this.overdraw = 0,
    this.visible = !0,
    this._needsUpdate = !0
}
,
fm.Material.prototype = {
    constructor: fm.Material,
    get needsUpdate() {
        return this._needsUpdate
    },
    set needsUpdate(a) {
        a === !0 && this.update(),
        this._needsUpdate = a
    },
    setValues: function(a) {
        if (void 0 !== a)
            for (var b in a) {
                var c = a[b];
                if (void 0 !== c) {
                    var d = this[b];
                    void 0 !== d ? d instanceof fm.Color ? d.set(c) : d instanceof fm.Vector3 && c instanceof fm.Vector3 ? d.copy(c) : "overdraw" === b ? this[b] = Number(c) : this[b] = c : console.warn("fm." + this.type + ": '" + b + "' is not a property of this material.")
                } else
                    console.warn("fm.Material: '" + b + "' parameter is undefined.")
            }
    },
    toJSON: function(a) {
        function b(a) {
            var b = [];
            for (var c in a) {
                var d = a[c];
                delete d.metadata,
                b.push(d)
            }
            return b
        }
        var c = void 0 === a;
        c && (a = {
            textures: {},
            images: {}
        });
        var d = {
            metadata: {
                version: 4.4,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        if (d.uuid = this.uuid,
        d.type = this.type,
        "" !== this.name && (d.name = this.name),
        this.color instanceof fm.Color && (d.color = this.color.getHex()),
        .5 !== this.roughness && (d.roughness = this.roughness),
        .5 !== this.metalness && (d.metalness = this.metalness),
        this.emissive instanceof fm.Color && (d.emissive = this.emissive.getHex()),
        this.specular instanceof fm.Color && (d.specular = this.specular.getHex()),
        void 0 !== this.shininess && (d.shininess = this.shininess),
        this.map instanceof fm.Texture && (d.map = this.map.toJSON(a).uuid),
        this.alphaMap instanceof fm.Texture && (d.alphaMap = this.alphaMap.toJSON(a).uuid),
        this.lightMap instanceof fm.Texture && (d.lightMap = this.lightMap.toJSON(a).uuid),
        this.bumpMap instanceof fm.Texture && (d.bumpMap = this.bumpMap.toJSON(a).uuid,
        d.bumpScale = this.bumpScale),
        this.normalMap instanceof fm.Texture && (d.normalMap = this.normalMap.toJSON(a).uuid,
        d.normalScale = this.normalScale.toArray()),
        this.displacementMap instanceof fm.Texture && (d.displacementMap = this.displacementMap.toJSON(a).uuid,
        d.displacementScale = this.displacementScale,
        d.displacementBias = this.displacementBias),
        this.roughnessMap instanceof fm.Texture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid),
        this.metalnessMap instanceof fm.Texture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid),
        this.emissiveMap instanceof fm.Texture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid),
        this.specularMap instanceof fm.Texture && (d.specularMap = this.specularMap.toJSON(a).uuid),
        this.envMap instanceof fm.Texture && (d.envMap = this.envMap.toJSON(a).uuid,
        d.reflectivity = this.reflectivity),
        void 0 !== this.size && (d.size = this.size),
        void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation),
        void 0 !== this.vertexColors && this.vertexColors !== fm.NoColors && (d.vertexColors = this.vertexColors),
        void 0 !== this.shading && this.shading !== fm.SmoothShading && (d.shading = this.shading),
        void 0 !== this.blending && this.blending !== fm.NormalBlending && (d.blending = this.blending),
        void 0 !== this.side && this.side !== fm.FrontSide && (d.side = this.side),
        this.opacity < 1 && (d.opacity = this.opacity),
        this.transparent === !0 && (d.transparent = this.transparent),
        this.alphaTest > 0 && (d.alphaTest = this.alphaTest),
        this.premultipliedAlpha === !0 && (d.premultipliedAlpha = this.premultipliedAlpha),
        this.wireframe === !0 && (d.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (d.wireframeLinewidth = this.wireframeLinewidth),
        c) {
            var e = b(a.textures)
              , f = b(a.images);
            e.length > 0 && (d.textures = e),
            f.length > 0 && (d.images = f)
        }
        return d
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        this.name = a.name,
        this.side = a.side,
        this.opacity = a.opacity,
        this.transparent = a.transparent,
        this.blending = a.blending,
        this.blendSrc = a.blendSrc,
        this.blendDst = a.blendDst,
        this.blendEquation = a.blendEquation,
        this.blendSrcAlpha = a.blendSrcAlpha,
        this.blendDstAlpha = a.blendDstAlpha,
        this.blendEquationAlpha = a.blendEquationAlpha,
        this.depthFunc = a.depthFunc,
        this.depthTest = a.depthTest,
        this.depthWrite = a.depthWrite,
        this.colorWrite = a.colorWrite,
        this.precision = a.precision,
        this.polygonOffset = a.polygonOffset,
        this.polygonOffsetFactor = a.polygonOffsetFactor,
        this.polygonOffsetUnits = a.polygonOffsetUnits,
        this.alphaTest = a.alphaTest,
        this.premultipliedAlpha = a.premultipliedAlpha,
        this.overdraw = a.overdraw,
        this.visible = a.visible,
        this.clipShadows = a.clipShadows;
        var b = a.clippingPlanes
          , c = null ;
        if (null !== b) {
            var d = b.length;
            c = new Array(d);
            for (var e = 0; e !== d; ++e)
                c[e] = b[e].clone()
        }
        return this.clippingPlanes = c,
        this
    },
    update: function() {
        this.dispatchEvent({
            type: "update"
        })
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
fm.EventDispatcher.prototype.apply(fm.Material.prototype),
fm.MaterialIdCount = 0,
fm.ShaderMaterial = function(a) {
    fm.Material.call(this),
    this.type = "ShaderMaterial",
    this.defines = {},
    this.uniforms = {},
    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
    this.shading = fm.SmoothShading,
    this.linewidth = 1,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.fog = !1,
    this.lights = !1,
    this.clipping = !1,
    this.vertexColors = fm.NoColors,
    this.skinning = !1,
    this.morphTargets = !1,
    this.morphNormals = !1,
    this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1
    },
    this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0]
    },
    this.index0AttributeName = void 0,
    void 0 !== a && (void 0 !== a.attributes && console.error("fm.ShaderMaterial: attributes should now be defined in fm.BufferGeometry instead."),
    this.setValues(a))
}
,
fm.ShaderMaterial.prototype = Object.create(fm.Material.prototype),
fm.ShaderMaterial.prototype.constructor = fm.ShaderMaterial,
fm.ShaderMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.fragmentShader = a.fragmentShader,
    this.vertexShader = a.vertexShader,
    this.uniforms = fm.UniformsUtils.clone(a.uniforms),
    this.defines = a.defines,
    this.shading = a.shading,
    this.wireframe = a.wireframe,
    this.wireframeLinewidth = a.wireframeLinewidth,
    this.fog = a.fog,
    this.lights = a.lights,
    this.clipping = a.clipping,
    this.vertexColors = a.vertexColors,
    this.skinning = a.skinning,
    this.morphTargets = a.morphTargets,
    this.morphNormals = a.morphNormals,
    this.extensions = a.extensions,
    this
}
,
fm.ShaderMaterial.prototype.toJSON = function(a) {
    var b = fm.Material.prototype.toJSON.call(this, a);
    return b.uniforms = this.uniforms,
    b.vertexShader = this.vertexShader,
    b.fragmentShader = this.fragmentShader,
    b
}
,
fm.MeshStandardMaterial = function(a) {
    fm.Material.call(this),
    this.defines = {
        STANDARD: ""
    },
    this.type = "MeshStandardMaterial",
    this.color = new fm.Color(16777215),
    this.roughness = .5,
    this.metalness = .5,
    this.map = null ,
    this.lightMap = null ,
    this.lightMapIntensity = 1,
    this.aoMap = null ,
    this.aoMapIntensity = 1,
    this.emissive = new fm.Color(0),
    this.emissiveIntensity = 1,
    this.emissiveMap = null ,
    this.bumpMap = null ,
    this.bumpScale = 1,
    this.normalMap = null ,
    this.normalScale = new fm.Vector2(1,1),
    this.displacementMap = null ,
    this.displacementScale = 1,
    this.displacementBias = 0,
    this.roughnessMap = null ,
    this.metalnessMap = null ,
    this.alphaMap = null ,
    this.envMap = null ,
    this.envMapIntensity = 1,
    this.refractionRatio = .98,
    this.fog = !0,
    this.shading = fm.SmoothShading,
    this.blending = fm.NormalBlending,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.wireframeLinecap = "round",
    this.wireframeLinejoin = "round",
    this.vertexColors = fm.NoColors,
    this.skinning = !1,
    this.morphTargets = !1,
    this.morphNormals = !1,
    this.setValues(a)
}
,
fm.MeshStandardMaterial.prototype = Object.create(fm.Material.prototype),
fm.MeshStandardMaterial.prototype.constructor = fm.MeshStandardMaterial,
fm.MeshStandardMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.defines = {
        STANDARD: ""
    },
    this.color.copy(a.color),
    this.roughness = a.roughness,
    this.metalness = a.metalness,
    this.map = a.map,
    this.lightMap = a.lightMap,
    this.lightMapIntensity = a.lightMapIntensity,
    this.aoMap = a.aoMap,
    this.aoMapIntensity = a.aoMapIntensity,
    this.emissive.copy(a.emissive),
    this.emissiveMap = a.emissiveMap,
    this.emissiveIntensity = a.emissiveIntensity,
    this.bumpMap = a.bumpMap,
    this.bumpScale = a.bumpScale,
    this.normalMap = a.normalMap,
    this.normalScale.copy(a.normalScale),
    this.displacementMap = a.displacementMap,
    this.displacementScale = a.displacementScale,
    this.displacementBias = a.displacementBias,
    this.roughnessMap = a.roughnessMap,
    this.metalnessMap = a.metalnessMap,
    this.alphaMap = a.alphaMap,
    this.envMap = a.envMap,
    this.envMapIntensity = a.envMapIntensity,
    this.refractionRatio = a.refractionRatio,
    this.fog = a.fog,
    this.shading = a.shading,
    this.wireframe = a.wireframe,
    this.wireframeLinewidth = a.wireframeLinewidth,
    this.wireframeLinecap = a.wireframeLinecap,
    this.wireframeLinejoin = a.wireframeLinejoin,
    this.vertexColors = a.vertexColors,
    this.skinning = a.skinning,
    this.morphTargets = a.morphTargets,
    this.morphNormals = a.morphNormals,
    this
}
,
fm.MeshPhysicalMaterial = function(a) {
    fm.MeshStandardMaterial.call(this),
    this.defines = {
        PHYSICAL: ""
    },
    this.type = "MeshPhysicalMaterial",
    this.reflectivity = .5,
    this.setValues(a)
}
,
fm.MeshPhysicalMaterial.prototype = Object.create(fm.MeshStandardMaterial.prototype),
fm.MeshPhysicalMaterial.prototype.constructor = fm.MeshPhysicalMaterial,
fm.MeshPhysicalMaterial.prototype.copy = function(a) {
    return fm.MeshStandardMaterial.prototype.copy.call(this, a),
    this.defines = {
        PHYSICAL: ""
    },
    this.reflectivity = a.reflectivity,
    this
}
,
fm.MeshNormalMaterial = function(a) {
    fm.Material.call(this, a),
    this.type = "MeshNormalMaterial",
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.morphTargets = !1,
    this.setValues(a)
}
,
fm.MeshNormalMaterial.prototype = Object.create(fm.Material.prototype),
fm.MeshNormalMaterial.prototype.constructor = fm.MeshNormalMaterial,
fm.MeshNormalMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.wireframe = a.wireframe,
    this.wireframeLinewidth = a.wireframeLinewidth,
    this
}
,
fm.RawShaderMaterial = function(a) {
    fm.ShaderMaterial.call(this, a),
    this.type = "RawShaderMaterial"
}
,
fm.RawShaderMaterial.prototype = Object.create(fm.ShaderMaterial.prototype),
fm.RawShaderMaterial.prototype.constructor = fm.RawShaderMaterial,
fm.LineBasicMaterial = function(a) {
    fm.Material.call(this),
    this.type = "LineBasicMaterial",
    this.color = new fm.Color(16777215),
    this.linewidth = 1,
    this.linecap = "round",
    this.linejoin = "round",
    this.blending = fm.NormalBlending,
    this.vertexColors = fm.NoColors,
    this.fog = !0,
    this.setValues(a)
}
,
fm.LineBasicMaterial.prototype = Object.create(fm.Material.prototype),
fm.LineBasicMaterial.prototype.constructor = fm.LineBasicMaterial,
fm.LineBasicMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.color.copy(a.color),
    this.linewidth = a.linewidth,
    this.linecap = a.linecap,
    this.linejoin = a.linejoin,
    this.vertexColors = a.vertexColors,
    this.fog = a.fog,
    this
}
,
fm.LineDashedMaterial = function(a) {
    fm.Material.call(this),
    this.type = "LineDashedMaterial",
    this.color = new fm.Color(16777215),
    this.linewidth = 1,
    this.scale = 1,
    this.dashSize = 3,
    this.gapSize = 1,
    this.blending = fm.NormalBlending,
    this.vertexColors = fm.NoColors,
    this.fog = !0,
    this.setValues(a)
}
,
fm.LineDashedMaterial.prototype = Object.create(fm.Material.prototype),
fm.LineDashedMaterial.prototype.constructor = fm.LineDashedMaterial,
fm.LineDashedMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.color.copy(a.color),
    this.linewidth = a.linewidth,
    this.scale = a.scale,
    this.dashSize = a.dashSize,
    this.gapSize = a.gapSize,
    this.vertexColors = a.vertexColors,
    this.fog = a.fog,
    this
}
,
fm.MeshBasicMaterial = function(a) {
    fm.Material.call(this),
    this.type = "MeshBasicMaterial",
    this.color = new fm.Color(16777215),
    this.map = null ,
    this.aoMap = null ,
    this.aoMapIntensity = 1,
    this.specularMap = null ,
    this.alphaMap = null ,
    this.envMap = null ,
    this.combine = fm.MultiplyOperation,
    this.reflectivity = 1,
    this.refractionRatio = .98,
    this.fog = !0,
    this.shading = fm.SmoothShading,
    this.blending = fm.NormalBlending,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.wireframeLinecap = "round",
    this.wireframeLinejoin = "round",
    this.vertexColors = fm.NoColors,
    this.skinning = !1,
    this.morphTargets = !1,
    this.setValues(a)
}
,
fm.MeshBasicMaterial.prototype = Object.create(fm.Material.prototype),
fm.MeshBasicMaterial.prototype.constructor = fm.MeshBasicMaterial,
fm.MeshBasicMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.color.copy(a.color),
    this.map = a.map,
    this.aoMap = a.aoMap,
    this.aoMapIntensity = a.aoMapIntensity,
    this.specularMap = a.specularMap,
    this.alphaMap = a.alphaMap,
    this.envMap = a.envMap,
    this.combine = a.combine,
    this.reflectivity = a.reflectivity,
    this.refractionRatio = a.refractionRatio,
    this.fog = a.fog,
    this.shading = a.shading,
    this.wireframe = a.wireframe,
    this.wireframeLinewidth = a.wireframeLinewidth,
    this.wireframeLinecap = a.wireframeLinecap,
    this.wireframeLinejoin = a.wireframeLinejoin,
    this.vertexColors = a.vertexColors,
    this.skinning = a.skinning,
    this.morphTargets = a.morphTargets,
    this
}
,
fm.MeshDepthMaterial = function(a) {
    fm.Material.call(this),
    this.type = "MeshDepthMaterial",
    this.depthPacking = fm.BasicDepthPacking,
    this.skinning = !1,
    this.morphTargets = !1,
    this.map = null ,
    this.alphaMap = null ,
    this.displacementMap = null ,
    this.displacementScale = 1,
    this.displacementBias = 0,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.setValues(a)
}
,
fm.MeshDepthMaterial.prototype = Object.create(fm.Material.prototype),
fm.MeshDepthMaterial.prototype.constructor = fm.MeshDepthMaterial,
fm.MeshDepthMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.depthPacking = a.depthPacking,
    this.skinning = a.skinning,
    this.morphTargets = a.morphTargets,
    this.map = a.map,
    this.alphaMap = a.alphaMap,
    this.displacementMap = a.displacementMap,
    this.displacementScale = a.displacementScale,
    this.displacementBias = a.displacementBias,
    this.wireframe = a.wireframe,
    this.wireframeLinewidth = a.wireframeLinewidth,
    this
}
,
fm.MeshPhongMaterial = function(a) {
    fm.Material.call(this),
    this.type = "MeshPhongMaterial",
    this.color = new fm.Color(16777215),
    this.specular = new fm.Color(1118481),
    this.shininess = 30,
    this.map = null ,
    this.lightMap = null ,
    this.lightMapIntensity = 1,
    this.aoMap = null ,
    this.aoMapIntensity = 1,
    this.emissive = new fm.Color(0),
    this.emissiveIntensity = 1,
    this.emissiveMap = null ,
    this.bumpMap = null ,
    this.bumpScale = 1,
    this.normalMap = null ,
    this.normalScale = new fm.Vector2(1,1),
    this.displacementMap = null ,
    this.displacementScale = 1,
    this.displacementBias = 0,
    this.specularMap = null ,
    this.alphaMap = null ,
    this.envMap = null ,
    this.combine = fm.MultiplyOperation,
    this.reflectivity = 1,
    this.refractionRatio = .98,
    this.fog = !0,
    this.shading = fm.SmoothShading,
    this.blending = fm.NormalBlending,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.wireframeLinecap = "round",
    this.wireframeLinejoin = "round",
    this.vertexColors = fm.NoColors,
    this.skinning = !1,
    this.morphTargets = !1,
    this.morphNormals = !1,
    this.setValues(a)
}
,
fm.MeshPhongMaterial.prototype = Object.create(fm.Material.prototype),
fm.MeshPhongMaterial.prototype.constructor = fm.MeshPhongMaterial,
fm.MeshPhongMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.color.copy(a.color),
    this.specular.copy(a.specular),
    this.shininess = a.shininess,
    this.map = a.map,
    this.lightMap = a.lightMap,
    this.lightMapIntensity = a.lightMapIntensity,
    this.aoMap = a.aoMap,
    this.aoMapIntensity = a.aoMapIntensity,
    this.emissive.copy(a.emissive),
    this.emissiveMap = a.emissiveMap,
    this.emissiveIntensity = a.emissiveIntensity,
    this.bumpMap = a.bumpMap,
    this.bumpScale = a.bumpScale,
    this.normalMap = a.normalMap,
    this.normalScale.copy(a.normalScale),
    this.displacementMap = a.displacementMap,
    this.displacementScale = a.displacementScale,
    this.displacementBias = a.displacementBias,
    this.specularMap = a.specularMap,
    this.alphaMap = a.alphaMap,
    this.envMap = a.envMap,
    this.combine = a.combine,
    this.reflectivity = a.reflectivity,
    this.refractionRatio = a.refractionRatio,
    this.fog = a.fog,
    this.shading = a.shading,
    this.wireframe = a.wireframe,
    this.wireframeLinewidth = a.wireframeLinewidth,
    this.wireframeLinecap = a.wireframeLinecap,
    this.wireframeLinejoin = a.wireframeLinejoin,
    this.vertexColors = a.vertexColors,
    this.skinning = a.skinning,
    this.morphTargets = a.morphTargets,
    this.morphNormals = a.morphNormals,
    this
}
,
fm.MeshLambertMaterial = function(a) {
    fm.Material.call(this),
    this.type = "MeshLambertMaterial",
    this.color = new fm.Color(16777215),
    this.map = null ,
    this.lightMap = null ,
    this.lightMapIntensity = 1,
    this.aoMap = null ,
    this.aoMapIntensity = 1,
    this.emissive = new fm.Color(0),
    this.emissiveIntensity = 1,
    this.emissiveMap = null ,
    this.specularMap = null ,
    this.alphaMap = null ,
    this.envMap = null ,
    this.combine = fm.MultiplyOperation,
    this.reflectivity = 1,
    this.refractionRatio = .98,
    this.fog = !0,
    this.blending = fm.NormalBlending,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.wireframeLinecap = "round",
    this.wireframeLinejoin = "round",
    this.vertexColors = fm.NoColors,
    this.skinning = !1,
    this.morphTargets = !1,
    this.morphNormals = !1,
    this.setValues(a)
}
,
fm.MeshLambertMaterial.prototype = Object.create(fm.Material.prototype),
fm.MeshLambertMaterial.prototype.constructor = fm.MeshLambertMaterial,
fm.MeshLambertMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.color.copy(a.color),
    this.map = a.map,
    this.lightMap = a.lightMap,
    this.lightMapIntensity = a.lightMapIntensity,
    this.aoMap = a.aoMap,
    this.aoMapIntensity = a.aoMapIntensity,
    this.emissive.copy(a.emissive),
    this.emissiveMap = a.emissiveMap,
    this.emissiveIntensity = a.emissiveIntensity,
    this.specularMap = a.specularMap,
    this.alphaMap = a.alphaMap,
    this.envMap = a.envMap,
    this.combine = a.combine,
    this.reflectivity = a.reflectivity,
    this.refractionRatio = a.refractionRatio,
    this.fog = a.fog,
    this.wireframe = a.wireframe,
    this.wireframeLinewidth = a.wireframeLinewidth,
    this.wireframeLinecap = a.wireframeLinecap,
    this.wireframeLinejoin = a.wireframeLinejoin,
    this.vertexColors = a.vertexColors,
    this.skinning = a.skinning,
    this.morphTargets = a.morphTargets,
    this.morphNormals = a.morphNormals,
    this
}
,
fm.MultiMaterial = function(a) {
    this.uuid = fm.Math.generateUUID(),
    this.type = "MultiMaterial",
    this.materials = a instanceof Array ? a : [],
    this.visible = !0
}
,
fm.MultiMaterial.prototype = {
    constructor: fm.MultiMaterial,
    toJSON: function(a) {
        for (var b = {
            metadata: {
                version: 4.2,
                type: "material",
                generator: "MaterialExporter"
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        }, c = this.materials, d = 0, e = c.length; d < e; d++) {
            var f = c[d].toJSON(a);
            delete f.metadata,
            b.materials.push(f)
        }
        return b.visible = this.visible,
        b
    },
    clone: function() {
        for (var a = new this.constructor, b = 0; b < this.materials.length; b++)
            a.materials.push(this.materials[b].clone());
        return a.visible = this.visible,
        a
    }
},
fm.PointsMaterial = function(a) {
    fm.Material.call(this),
    this.type = "PointsMaterial",
    this.color = new fm.Color(16777215),
    this.map = null ,
    this.size = 1,
    this.sizeAttenuation = !0,
    this.blending = fm.NormalBlending,
    this.vertexColors = fm.NoColors,
    this.fog = !0,
    this.setValues(a)
}
,
fm.PointsMaterial.prototype = Object.create(fm.Material.prototype),
fm.PointsMaterial.prototype.constructor = fm.PointsMaterial,
fm.PointsMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.color.copy(a.color),
    this.map = a.map,
    this.size = a.size,
    this.sizeAttenuation = a.sizeAttenuation,
    this.vertexColors = a.vertexColors,
    this.fog = a.fog,
    this
}
,
fm.SpriteMaterial = function(a) {
    fm.Material.call(this),
    this.type = "SpriteMaterial",
    this.color = new fm.Color(16777215),
    this.map = null ,
    this.rotation = 0,
    this.fog = !1,
    this.setValues(a)
}
,
fm.SpriteMaterial.prototype = Object.create(fm.Material.prototype),
fm.SpriteMaterial.prototype.constructor = fm.SpriteMaterial,
fm.SpriteMaterial.prototype.copy = function(a) {
    return fm.Material.prototype.copy.call(this, a),
    this.color.copy(a.color),
    this.map = a.map,
    this.rotation = a.rotation,
    this.fog = a.fog,
    this
}
,
fm.Group = function() {
    fm.Object3D.call(this),
    this.type = "Group"
}
,
fm.Group.prototype = Object.create(fm.Object3D.prototype),
fm.Group.prototype.constructor = fm.Group,
fm.Line = function(a, b, c) {
    return 1 === c ? (console.warn("fm.Line: parameter fm.LinePieces no longer supported. Created fm.LineSegments instead."),
    new fm.LineSegments(a,b)) : (fm.Object3D.call(this),
    this.type = "Line",
    this.geometry = void 0 !== a ? a : new fm.Geometry,
    void (this.material = void 0 !== b ? b : new fm.LineBasicMaterial({
        color: 16777215 * Math.random()
    })))
}
,
fm.Line.prototype = Object.create(fm.Object3D.prototype),
fm.Line.prototype.constructor = fm.Line,
fm.Line.prototype.raycast = function() {
    var a = new fm.Matrix4
      , b = new fm.Ray
      , c = new fm.Sphere;
    return function(d, e) {
        var f = d.linePrecision
          , g = f * f
          , h = this.geometry
          , i = this.matrixWorld;
        if (null === h.boundingSphere && h.computeBoundingSphere(),
        c.copy(h.boundingSphere),
        c.applyMatrix4(i),
        d.ray.intersectsSphere(c) !== !1) {
            a.getInverse(i),
            b.copy(d.ray).applyMatrix4(a);
            var j = new fm.Vector3
              , k = new fm.Vector3
              , l = new fm.Vector3
              , m = new fm.Vector3
              , n = this instanceof fm.LineSegments ? 2 : 1;
            if (h instanceof fm.BufferGeometry) {
                var o = h.index
                  , p = h.attributes
                  , q = p.position.array;
                if (null !== o)
                    for (var r = o.array, s = 0, t = r.length - 1; s < t; s += n) {
                        var u = r[s]
                          , v = r[s + 1];
                        j.fromArray(q, 3 * u),
                        k.fromArray(q, 3 * v);
                        var w = b.distanceSqToSegment(j, k, m, l);
                        if (!(w > g)) {
                            m.applyMatrix4(this.matrixWorld);
                            var x = d.ray.origin.distanceTo(m);
                            x < d.near || x > d.far || e.push({
                                distance: x,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: s,
                                face: null ,
                                faceIndex: null ,
                                object: this
                            })
                        }
                    }
                else
                    for (var s = 0, t = q.length / 3 - 1; s < t; s += n) {
                        j.fromArray(q, 3 * s),
                        k.fromArray(q, 3 * s + 3);
                        var w = b.distanceSqToSegment(j, k, m, l);
                        if (!(w > g)) {
                            m.applyMatrix4(this.matrixWorld);
                            var x = d.ray.origin.distanceTo(m);
                            x < d.near || x > d.far || e.push({
                                distance: x,
                                point: l.clone().applyMatrix4(this.matrixWorld),
                                index: s,
                                face: null ,
                                faceIndex: null ,
                                object: this
                            })
                        }
                    }
            } else if (h instanceof fm.Geometry)
                for (var y = h.vertices, z = y.length, s = 0; s < z - 1; s += n) {
                    var w = b.distanceSqToSegment(y[s], y[s + 1], m, l);
                    if (!(w > g)) {
                        m.applyMatrix4(this.matrixWorld);
                        var x = d.ray.origin.distanceTo(m);
                        x < d.near || x > d.far || e.push({
                            distance: x,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            index: s,
                            face: null ,
                            faceIndex: null ,
                            object: this
                        })
                    }
                }
        }
    }
}(),
fm.Line.prototype.clone = function() {
    return new this.constructor(this.geometry,this.material).copy(this)
}
,
fm.LineStrip = 0,
fm.LinePieces = 1,
fm.LineSegments = function(a, b) {
    fm.Line.call(this, a, b),
    this.type = "LineSegments"
}
,
fm.LineSegments.prototype = Object.create(fm.Line.prototype),
fm.LineSegments.prototype.constructor = fm.LineSegments,
fm.LOD = function() {
    fm.Object3D.call(this),
    this.type = "LOD",
    Object.defineProperties(this, {
        levels: {
            enumerable: !0,
            value: []
        }
    })
}
,
fm.LOD.prototype = Object.create(fm.Object3D.prototype),
fm.LOD.prototype.constructor = fm.LOD,
fm.LOD.prototype.addLevel = function(a, b) {
    void 0 === b && (b = 0),
    b = Math.abs(b);
    for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++)
        ;
    c.splice(d, 0, {
        distance: b,
        object: a
    }),
    this.add(a)
}
,
fm.LOD.prototype.getObjectForDistance = function(a) {
    for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++)
        ;
    return b[c - 1].object
}
,
fm.LOD.prototype.raycast = function() {
    var a = new fm.Vector3;
    return function(b, c) {
        a.setFromMatrixPosition(this.matrixWorld);
        var d = b.ray.origin.distanceTo(a);
        this.getObjectForDistance(d).raycast(b, c)
    }
}(),
fm.LOD.prototype.update = function() {
    var a = new fm.Vector3
      , b = new fm.Vector3;
    return function(c) {
        var d = this.levels;
        if (d.length > 1) {
            a.setFromMatrixPosition(c.matrixWorld),
            b.setFromMatrixPosition(this.matrixWorld);
            var e = a.distanceTo(b);
            d[0].object.visible = !0;
            for (var f = 1, g = d.length; f < g && e >= d[f].distance; f++)
                d[f - 1].object.visible = !1,
                d[f].object.visible = !0;
            for (; f < g; f++)
                d[f].object.visible = !1
        }
    }
}(),
fm.LOD.prototype.copy = function(a) {
    fm.Object3D.prototype.copy.call(this, a, !1);
    for (var b = a.levels, c = 0, d = b.length; c < d; c++) {
        var e = b[c];
        this.addLevel(e.object.clone(), e.distance)
    }
    return this
}
,
fm.LOD.prototype.toJSON = function(a) {
    var b = fm.Object3D.prototype.toJSON.call(this, a);
    b.object.levels = [];
    for (var c = this.levels, d = 0, e = c.length; d < e; d++) {
        var f = c[d];
        b.object.levels.push({
            object: f.object.uuid,
            distance: f.distance
        })
    }
    return b
}
,
fm.Mesh = function(a, b) {
    fm.Object3D.call(this),
    this.type = "Mesh",
    this.geometry = void 0 !== a ? a : new fm.Geometry,
    this.material = void 0 !== b ? b : new fm.MeshBasicMaterial({
        color: 16777215 * Math.random()
    }),
    this.drawMode = fm.TrianglesDrawMode,
    this.updateMorphTargets()
}
,
fm.Mesh.prototype = Object.create(fm.Object3D.prototype),
fm.Mesh.prototype.constructor = fm.Mesh,
fm.Mesh.prototype.setDrawMode = function(a) {
    this.drawMode = a
}
,
fm.Mesh.prototype.updateMorphTargets = function() {
    if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) {
        this.morphTargetBase = -1,
        this.morphTargetInfluences = [],
        this.morphTargetDictionary = {};
        for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++)
            this.morphTargetInfluences.push(0),
            this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a
    }
}
,
fm.Mesh.prototype.getMorphTargetIndexByName = function(a) {
    return void 0 !== this.morphTargetDictionary[a] ? this.morphTargetDictionary[a] : (console.warn("fm.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0."),
    0)
}
,
fm.Mesh.prototype.raycast = function() {
    function a(a, b, c, d, e, f, g) {
        return fm.Triangle.barycoordFromPoint(a, b, c, d, p),
        e.multiplyScalar(p.x),
        f.multiplyScalar(p.y),
        g.multiplyScalar(p.z),
        e.add(f).add(g),
        e.clone()
    }
    function b(a, b, c, d, e, f, g) {
        var h, i = a.material;
        if (h = i.side === fm.BackSide ? c.intersectTriangle(f, e, d, !0, g) : c.intersectTriangle(d, e, f, i.side !== fm.DoubleSide, g),
        null === h)
            return null ;
        r.copy(g),
        r.applyMatrix4(a.matrixWorld);
        var j = b.ray.origin.distanceTo(r);
        return j < b.near || j > b.far ? null : {
            distance: j,
            point: r.clone(),
            object: a
        }
    }
    function c(c, d, e, f, j, k, l, p) {
        g.fromArray(f, 3 * k),
        h.fromArray(f, 3 * l),
        i.fromArray(f, 3 * p);
        var r = b(c, d, e, g, h, i, q);
        return r && (j && (m.fromArray(j, 2 * k),
        n.fromArray(j, 2 * l),
        o.fromArray(j, 2 * p),
        r.uv = a(q, g, h, i, m, n, o)),
        r.face = new fm.Face3(k,l,p,fm.Triangle.normal(g, h, i)),
        r.faceIndex = k),
        r
    }
    var d = new fm.Matrix4
      , e = new fm.Ray
      , f = new fm.Sphere
      , g = new fm.Vector3
      , h = new fm.Vector3
      , i = new fm.Vector3
      , j = new fm.Vector3
      , k = new fm.Vector3
      , l = new fm.Vector3
      , m = new fm.Vector2
      , n = new fm.Vector2
      , o = new fm.Vector2
      , p = new fm.Vector3
      , q = new fm.Vector3
      , r = new fm.Vector3;
    return function(p, r) {
        var s = this.geometry
          , t = this.material
          , u = this.matrixWorld;
        if (void 0 !== t && (null === s.boundingSphere && s.computeBoundingSphere(),
        f.copy(s.boundingSphere),
        f.applyMatrix4(u),
        p.ray.intersectsSphere(f) !== !1 && (d.getInverse(u),
        e.copy(p.ray).applyMatrix4(d),
        null === s.boundingBox || e.intersectsBox(s.boundingBox) !== !1))) {
            var v, w;
            if (s instanceof fm.BufferGeometry) {
                var x, y, z, A = s.index, B = s.attributes, C = B.position.array;
                if (void 0 !== B.uv && (v = B.uv.array),
                null !== A)
                    for (var D = A.array, E = 0, F = D.length; E < F; E += 3)
                        x = D[E],
                        y = D[E + 1],
                        z = D[E + 2],
                        w = c(this, p, e, C, v, x, y, z),
                        w && (w.faceIndex = Math.floor(E / 3),
                        r.push(w));
                else
                    for (var E = 0, F = C.length; E < F; E += 9)
                        x = E / 3,
                        y = x + 1,
                        z = x + 2,
                        w = c(this, p, e, C, v, x, y, z),
                        w && (w.index = x,
                        r.push(w))
            } else if (s instanceof fm.Geometry) {
                var G, H, I, J = t instanceof fm.MultiMaterial, K = J === !0 ? t.materials : null , L = s.vertices, M = s.faces, N = s.faceVertexUvs[0];
                N.length > 0 && (v = N);
                for (var O = 0, P = M.length; O < P; O++) {
                    var Q = M[O]
                      , R = J === !0 ? K[Q.materialIndex] : t;
                    if (void 0 !== R) {
                        if (G = L[Q.a],
                        H = L[Q.b],
                        I = L[Q.c],
                        R.morphTargets === !0) {
                            var S = s.morphTargets
                              , T = this.morphTargetInfluences;
                            g.set(0, 0, 0),
                            h.set(0, 0, 0),
                            i.set(0, 0, 0);
                            for (var U = 0, V = S.length; U < V; U++) {
                                var W = T[U];
                                if (0 !== W) {
                                    var X = S[U].vertices;
                                    g.addScaledVector(j.subVectors(X[Q.a], G), W),
                                    h.addScaledVector(k.subVectors(X[Q.b], H), W),
                                    i.addScaledVector(l.subVectors(X[Q.c], I), W)
                                }
                            }
                            g.add(G),
                            h.add(H),
                            i.add(I),
                            G = g,
                            H = h,
                            I = i
                        }
                        if (w = b(this, p, e, G, H, I, q)) {
                            if (v) {
                                var Y = v[O];
                                m.copy(Y[0]),
                                n.copy(Y[1]),
                                o.copy(Y[2]),
                                w.uv = a(q, G, H, I, m, n, o)
                            }
                            w.face = Q,
                            w.faceIndex = O,
                            r.push(w)
                        }
                    }
                }
            }
        }
    }
}(),
fm.Mesh.prototype.clone = function() {
    return new this.constructor(this.geometry,this.material).copy(this)
}
,
fm.Points = function(a, b) {
    fm.Object3D.call(this),
    this.type = "Points",
    this.geometry = void 0 !== a ? a : new fm.Geometry,
    this.material = void 0 !== b ? b : new fm.PointsMaterial({
        color: 16777215 * Math.random()
    })
}
,
fm.Points.prototype = Object.create(fm.Object3D.prototype),
fm.Points.prototype.constructor = fm.Points,
fm.Points.prototype.raycast = function() {
    var a = new fm.Matrix4
      , b = new fm.Ray
      , c = new fm.Sphere;
    return function(d, e) {
        function f(a, c) {
            var f = b.distanceSqToPoint(a);
            if (f < l) {
                var h = b.closestPointToPoint(a);
                h.applyMatrix4(i);
                var j = d.ray.origin.distanceTo(h);
                if (j < d.near || j > d.far)
                    return;
                e.push({
                    distance: j,
                    distanceToRay: Math.sqrt(f),
                    point: h.clone(),
                    index: c,
                    face: null ,
                    object: g
                })
            }
        }
        var g = this
          , h = this.geometry
          , i = this.matrixWorld
          , j = d.params.Points.threshold;
        if (null === h.boundingSphere && h.computeBoundingSphere(),
        c.copy(h.boundingSphere),
        c.applyMatrix4(i),
        d.ray.intersectsSphere(c) !== !1) {
            a.getInverse(i),
            b.copy(d.ray).applyMatrix4(a);
            var k = j / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , l = k * k
              , m = new fm.Vector3;
            if (h instanceof fm.BufferGeometry) {
                var n = h.index
                  , o = h.attributes
                  , p = o.position.array;
                if (null !== n)
                    for (var q = n.array, r = 0, s = q.length; r < s; r++) {
                        var t = q[r];
                        m.fromArray(p, 3 * t),
                        f(m, t)
                    }
                else
                    for (var r = 0, u = p.length / 3; r < u; r++)
                        m.fromArray(p, 3 * r),
                        f(m, r)
            } else
                for (var v = h.vertices, r = 0, u = v.length; r < u; r++)
                    f(v[r], r)
        }
    }
}(),
fm.Points.prototype.clone = function() {
    return new this.constructor(this.geometry,this.material).copy(this)
}
,
fm.Sprite = function() {
    var a = new Uint16Array([0, 1, 2, 0, 2, 3])
      , b = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0])
      , c = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
      , d = new fm.BufferGeometry;
    return d.setIndex(new fm.BufferAttribute(a,1)),
    d.addAttribute("position", new fm.BufferAttribute(b,3)),
    d.addAttribute("uv", new fm.BufferAttribute(c,2)),
    function(a) {
        fm.Object3D.call(this),
        this.type = "Sprite",
        this.geometry = d,
        this.material = void 0 !== a ? a : new fm.SpriteMaterial
    }
}(),
fm.Sprite.prototype = Object.create(fm.Object3D.prototype),
fm.Sprite.prototype.constructor = fm.Sprite,
fm.Sprite.prototype.raycast = function() {
    var a = new fm.Vector3;
    return function(b, c) {
        a.setFromMatrixPosition(this.matrixWorld);
        var d = b.ray.distanceSqToPoint(a)
          , e = this.scale.x * this.scale.y / 4;
        d > e || c.push({
            distance: Math.sqrt(d),
            point: this.position,
            face: null ,
            object: this
        })
    }
}(),
fm.Sprite.prototype.clone = function() {
    return new this.constructor(this.material).copy(this)
}
,
fm.Particle = fm.Sprite,
fm.LensFlare = function(a, b, c, d, e) {
    fm.Object3D.call(this),
    this.lensFlares = [],
    this.positionScreen = new fm.Vector3,
    this.customUpdateCallback = void 0,
    void 0 !== a && this.add(a, b, c, d, e)
}
,
fm.LensFlare.prototype = Object.create(fm.Object3D.prototype),
fm.LensFlare.prototype.constructor = fm.LensFlare,
fm.LensFlare.prototype.add = function(a, b, c, d, e, f) {
    void 0 === b && (b = -1),
    void 0 === c && (c = 0),
    void 0 === f && (f = 1),
    void 0 === e && (e = new fm.Color(16777215)),
    void 0 === d && (d = fm.NormalBlending),
    c = Math.min(c, Math.max(0, c)),
    this.lensFlares.push({
        texture: a,
        size: b,
        distance: c,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 0,
        opacity: f,
        color: e,
        blending: d
    })
}
,
fm.LensFlare.prototype.updateLensFlares = function() {
    var a, b, c = this.lensFlares.length, d = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
    for (a = 0; a < c; a++)
        b = this.lensFlares[a],
        b.x = this.positionScreen.x + d * b.distance,
        b.y = this.positionScreen.y + e * b.distance,
        b.wantedRotation = b.x * Math.PI * .25,
        b.rotation += .25 * (b.wantedRotation - b.rotation)
}
,
fm.LensFlare.prototype.copy = function(a) {
    fm.Object3D.prototype.copy.call(this, a),
    this.positionScreen.copy(a.positionScreen),
    this.customUpdateCallback = a.customUpdateCallback;
    for (var b = 0, c = a.lensFlares.length; b < c; b++)
        this.lensFlares.push(a.lensFlares[b]);
    return this
}
,
fm.Skeleton = function(a, b, c) {
    if (this.useVertexTexture = void 0 === c || c,
    this.identityMatrix = new fm.Matrix4,
    a = a || [],
    this.bones = a.slice(0),
    this.useVertexTexture) {
        var d = Math.sqrt(4 * this.bones.length);
        d = fm.Math.nextPowerOfTwo(Math.ceil(d)),
        d = Math.max(d, 4),
        this.boneTextureWidth = d,
        this.boneTextureHeight = d,
        this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4),
        this.boneTexture = new fm.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,fm.RGBAFormat,fm.FloatType)
    } else
        this.boneMatrices = new Float32Array(16 * this.bones.length);
    if (void 0 === b)
        this.calculateInverses();
    else if (this.bones.length === b.length)
        this.boneInverses = b.slice(0);
    else {
        console.warn("fm.Skeleton bonInverses is the wrong length."),
        this.boneInverses = [];
        for (var e = 0, f = this.bones.length; e < f; e++)
            this.boneInverses.push(new fm.Matrix4)
    }
}
,
fm.Skeleton.prototype.calculateInverses = function() {
    this.boneInverses = [];
    for (var a = 0, b = this.bones.length; a < b; a++) {
        var c = new fm.Matrix4;
        this.bones[a] && c.getInverse(this.bones[a].matrixWorld),
        this.boneInverses.push(c)
    }
}
,
fm.Skeleton.prototype.pose = function() {
    for (var a, b = 0, c = this.bones.length; b < c; b++)
        a = this.bones[b],
        a && a.matrixWorld.getInverse(this.boneInverses[b]);
    for (var b = 0, c = this.bones.length; b < c; b++)
        a = this.bones[b],
        a && (a.parent ? (a.matrix.getInverse(a.parent.matrixWorld),
        a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld),
        a.matrix.decompose(a.position, a.quaternion, a.scale))
}
,
fm.Skeleton.prototype.update = function() {
    var a = new fm.Matrix4;
    return function() {
        for (var b = 0, c = this.bones.length; b < c; b++) {
            var d = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
            a.multiplyMatrices(d, this.boneInverses[b]),
            a.toArray(this.boneMatrices, 16 * b)
        }
        this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
    }
}(),
fm.Skeleton.prototype.clone = function() {
    return new fm.Skeleton(this.bones,this.boneInverses,this.useVertexTexture)
}
,
fm.SkinnedMesh = function(a, b, c) {
    fm.Mesh.call(this, a, b),
    this.type = "SkinnedMesh",
    this.bindMode = "attached",
    this.bindMatrix = new fm.Matrix4,
    this.bindMatrixInverse = new fm.Matrix4;
    var d = [];
    if (this.geometry && void 0 !== this.geometry.bones) {
        for (var e, f, g = 0, h = this.geometry.bones.length; g < h; ++g)
            f = this.geometry.bones[g],
            e = new fm.Bone(this),
            d.push(e),
            e.name = f.name,
            e.position.fromArray(f.pos),
            e.quaternion.fromArray(f.rotq),
            void 0 !== f.scl && e.scale.fromArray(f.scl);
        for (var g = 0, h = this.geometry.bones.length; g < h; ++g)
            f = this.geometry.bones[g],
            f.parent !== -1 && null !== f.parent && void 0 !== d[f.parent] ? d[f.parent].add(d[g]) : this.add(d[g])
    }
    this.normalizeSkinWeights(),
    this.updateMatrixWorld(!0),
    this.bind(new fm.Skeleton(d,(void 0),c), this.matrixWorld)
}
,
fm.SkinnedMesh.prototype = Object.create(fm.Mesh.prototype),
fm.SkinnedMesh.prototype.constructor = fm.SkinnedMesh,
fm.SkinnedMesh.prototype.bind = function(a, b) {
    this.skeleton = a,
    void 0 === b && (this.updateMatrixWorld(!0),
    this.skeleton.calculateInverses(),
    b = this.matrixWorld),
    this.bindMatrix.copy(b),
    this.bindMatrixInverse.getInverse(b)
}
,
fm.SkinnedMesh.prototype.pose = function() {
    this.skeleton.pose()
}
,
fm.SkinnedMesh.prototype.normalizeSkinWeights = function() {
    if (this.geometry instanceof fm.Geometry)
        for (var a = 0; a < this.geometry.skinWeights.length; a++) {
            var b = this.geometry.skinWeights[a]
              , c = 1 / b.lengthManhattan();
            c !== 1 / 0 ? b.multiplyScalar(c) : b.set(1, 0, 0, 0)
        }
    else if (this.geometry instanceof fm.BufferGeometry)
        for (var d = new fm.Vector4, e = this.geometry.attributes.skinWeight, a = 0; a < e.count; a++) {
            d.x = e.getX(a),
            d.y = e.getY(a),
            d.z = e.getZ(a),
            d.w = e.getW(a);
            var c = 1 / d.lengthManhattan();
            c !== 1 / 0 ? d.multiplyScalar(c) : d.set(1, 0, 0, 0),
            e.setXYZW(a, d.x, d.y, d.z, d.w)
        }
}
,
fm.SkinnedMesh.prototype.updateMatrixWorld = function(a) {
    fm.Mesh.prototype.updateMatrixWorld.call(this, !0),
    "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("fm.SkinnedMesh unrecognized bindMode: " + this.bindMode)
}
,
fm.SkinnedMesh.prototype.clone = function() {
    return new this.constructor(this.geometry,this.material,this.useVertexTexture).copy(this)
}
,
fm.ImmediateRenderObject = function(a) {
    fm.Object3D.call(this),
    this.material = a,
    this.render = function(a) {}
}
,
fm.ImmediateRenderObject.prototype = Object.create(fm.Object3D.prototype),
fm.ImmediateRenderObject.prototype.constructor = fm.ImmediateRenderObject,
fm.LineCurve = function(a, b) {
    this.v1 = a,
    this.v2 = b
}
,
fm.LineCurve.prototype = Object.create(fm.Curve.prototype),
fm.LineCurve.prototype.constructor = fm.LineCurve,
fm.LineCurve.prototype.getPoint = function(a) {
    var b = this.v2.clone().sub(this.v1);
    return b.multiplyScalar(a).add(this.v1),
    b
}
,
fm.LineCurve.prototype.getPointAt = function(a) {
    return this.getPoint(a)
}
,
fm.LineCurve.prototype.getTangent = function(a) {
    var b = this.v2.clone().sub(this.v1);
    return b.normalize()
}
,
fm.Scene = function() {
    fm.Object3D.call(this),
    this.type = "Scene",
    this.fog = null ,
    this.overrideMaterial = null ,
    this.autoUpdate = !0
}
,
fm.Scene.prototype = Object.create(fm.Object3D.prototype),
fm.Scene.prototype.constructor = fm.Scene,
fm.Scene.prototype.copy = function(a, b) {
    return fm.Object3D.prototype.copy.call(this, a, b),
    null !== a.fog && (this.fog = a.fog.clone()),
    null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()),
    this.autoUpdate = a.autoUpdate,
    this.matrixAutoUpdate = a.matrixAutoUpdate,
    this
}
,
fm.Fog = function(a, b, c) {
    this.name = "",
    this.color = new fm.Color(a),
    this.near = void 0 !== b ? b : 1,
    this.far = void 0 !== c ? c : 1e3
}
,
fm.Fog.prototype.clone = function() {
    return new fm.Fog(this.color.getHex(),this.near,this.far)
}
,
fm.FogExp2 = function(a, b) {
    this.name = "",
    this.color = new fm.Color(a),
    this.density = void 0 !== b ? b : 25e-5
}
,
fm.FogExp2.prototype.clone = function() {
    return new fm.FogExp2(this.color.getHex(),this.density)
}
,
fm.Texture = function(a, b, c, d, e, f, g, h, i, j) {
    Object.defineProperty(this, "id", {
        value: fm.TextureIdCount++
    }),
    this.uuid = fm.Math.generateUUID(),
    this.name = "",
    this.sourceFile = "",
    this.image = void 0 !== a ? a : fm.Texture.DEFAULT_IMAGE,
    this.mipmaps = [],
    this.mapping = void 0 !== b ? b : fm.Texture.DEFAULT_MAPPING,
    this.wrapS = void 0 !== c ? c : fm.ClampToEdgeWrapping,
    this.wrapT = void 0 !== d ? d : fm.ClampToEdgeWrapping,
    this.magFilter = void 0 !== e ? e : fm.LinearFilter,
    this.minFilter = void 0 !== f ? f : fm.LinearMipMapLinearFilter,
    this.anisotropy = void 0 !== i ? i : 1,
    this.format = void 0 !== g ? g : fm.RGBAFormat,
    this.type = void 0 !== h ? h : fm.UnsignedByteType,
    this.offset = new fm.Vector2(0,0),
    this.repeat = new fm.Vector2(1,1),
    this.generateMipmaps = !0,
    this.premultiplyAlpha = !1,
    this.flipY = !0,
    this.unpackAlignment = 4,
    this.encoding = void 0 !== j ? j : fm.LinearEncoding,
    this.version = 0,
    this.onUpdate = null
}
,
fm.Texture.DEFAULT_IMAGE = void 0,
fm.Texture.DEFAULT_MAPPING = fm.UVMapping,
fm.Texture.prototype = {
    constructor: fm.Texture,
    set needsUpdate(a) {
        a === !0 && this.version++
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.image = a.image,
        this.mipmaps = a.mipmaps.slice(0),
        this.mapping = a.mapping,
        this.wrapS = a.wrapS,
        this.wrapT = a.wrapT,
        this.magFilter = a.magFilter,
        this.minFilter = a.minFilter,
        this.anisotropy = a.anisotropy,
        this.format = a.format,
        this.type = a.type,
        this.offset.copy(a.offset),
        this.repeat.copy(a.repeat),
        this.generateMipmaps = a.generateMipmaps,
        this.premultiplyAlpha = a.premultiplyAlpha,
        this.flipY = a.flipY,
        this.unpackAlignment = a.unpackAlignment,
        this.encoding = a.encoding,
        this
    },
    toJSON: function(a) {
        function b(a) {
            var b;
            return void 0 !== a.toDataURL ? b = a : (b = document.createElement("canvas"),
            b.width = a.width,
            b.height = a.height,
            b.getContext("2d").drawImage(a, 0, 0, a.width, a.height)),
            b.width > 2048 || b.height > 2048 ? b.toDataURL("image/jpeg", .6) : b.toDataURL("image/png")
        }
        if (void 0 !== a.textures[this.uuid])
            return a.textures[this.uuid];
        var c = {
            metadata: {
                version: 4.4,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            wrap: [this.wrapS, this.wrapT],
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy
        };
        if (void 0 !== this.image) {
            var d = this.image;
            void 0 === d.uuid && (d.uuid = fm.Math.generateUUID()),
            void 0 === a.images[d.uuid] && (a.images[d.uuid] = {
                uuid: d.uuid,
                url: b(d)
            }),
            c.image = d.uuid
        }
        return a.textures[this.uuid] = c,
        c
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    },
    transformUv: function(a) {
        if (this.mapping === fm.UVMapping) {
            if (a.multiply(this.repeat),
            a.add(this.offset),
            a.x < 0 || a.x > 1)
                switch (this.wrapS) {
                case fm.RepeatWrapping:
                    a.x = a.x - Math.floor(a.x);
                    break;
                case fm.ClampToEdgeWrapping:
                    a.x = a.x < 0 ? 0 : 1;
                    break;
                case fm.MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(a.x) % 2) ? a.x = Math.ceil(a.x) - a.x : a.x = a.x - Math.floor(a.x)
                }
            if (a.y < 0 || a.y > 1)
                switch (this.wrapT) {
                case fm.RepeatWrapping:
                    a.y = a.y - Math.floor(a.y);
                    break;
                case fm.ClampToEdgeWrapping:
                    a.y = a.y < 0 ? 0 : 1;
                    break;
                case fm.MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(a.y) % 2) ? a.y = Math.ceil(a.y) - a.y : a.y = a.y - Math.floor(a.y)
                }
            this.flipY && (a.y = 1 - a.y)
        }
    }
},
fm.EventDispatcher.prototype.apply(fm.Texture.prototype),
fm.TextureIdCount = 0,
fm.CompressedTexture = function(a, b, c, d, e, f, g, h, i, j, k, l) {
    fm.Texture.call(this, null , f, g, h, i, j, d, e, k, l),
    this.image = {
        width: b,
        height: c
    },
    this.mipmaps = a,
    this.flipY = !1,
    this.generateMipmaps = !1
}
,
fm.CompressedTexture.prototype = Object.create(fm.Texture.prototype),
fm.CompressedTexture.prototype.constructor = fm.CompressedTexture,
fm.DataTexture = function(a, b, c, d, e, f, g, h, i, j, k, l) {
    fm.Texture.call(this, null , f, g, h, i, j, d, e, k, l),
    this.image = {
        data: a,
        width: b,
        height: c
    },
    this.magFilter = void 0 !== i ? i : fm.NearestFilter,
    this.minFilter = void 0 !== j ? j : fm.NearestFilter,
    this.flipY = !1,
    this.generateMipmaps = !1
}
,
fm.DataTexture.prototype = Object.create(fm.Texture.prototype),
fm.DataTexture.prototype.constructor = fm.DataTexture,
fm.DepthTexture = function(a, b, c, d, e, f, g, h, i) {
    fm.Texture.call(this, null , d, e, f, g, h, fm.DepthFormat, c, i),
    this.image = {
        width: a,
        height: b
    },
    this.type = void 0 !== c ? c : fm.UnsignedShortType,
    this.magFilter = void 0 !== g ? g : fm.NearestFilter,
    this.minFilter = void 0 !== h ? h : fm.NearestFilter,
    this.flipY = !1,
    this.generateMipmaps = !1
}
,
fm.DepthTexture.prototype = Object.create(fm.Texture.prototype),
fm.DepthTexture.prototype.constructor = fm.DepthTexture,
fm.CanvasTexture = function(a, b, c, d, e, f, g, h, i) {
    fm.Texture.call(this, a, b, c, d, e, f, g, h, i),
    this.needsUpdate = !0
}
,
fm.CanvasTexture.prototype = Object.create(fm.Texture.prototype),
fm.CanvasTexture.prototype.constructor = fm.CanvasTexture,
fm.Cache = {
    enabled: !1,
    files: {},
    add: function(a, b) {
        this.enabled !== !1 && (this.files[a] = b)
    },
    get: function(a) {
        if (this.enabled !== !1)
            return this.files[a]
    },
    remove: function(a) {
        delete this.files[a]
    },
    clear: function() {
        this.files = {}
    }
},
fm.LoadingManager = function(a, b, c) {
    var d = this
      , e = !1
      , f = 0
      , g = 0;
    this.onStart = void 0,
    this.onLoad = a,
    this.onProgress = b,
    this.onError = c,
    this.itemStart = function(a) {
        g++,
        e === !1 && void 0 !== d.onStart && d.onStart(a, f, g),
        e = !0
    }
    ,
    this.itemEnd = function(a) {
        f++,
        void 0 !== d.onProgress && d.onProgress(a, f, g),
        f === g && (e = !1,
        void 0 !== d.onLoad && d.onLoad())
    }
    ,
    this.itemError = function(a) {
        void 0 !== d.onError && d.onError(a)
    }
}
,
fm.DefaultLoadingManager = new fm.LoadingManager,
fm.TextureLoader = function(a) {
    this.manager = void 0 !== a ? a : fm.DefaultLoadingManager
}
,
fm.TextureLoader.prototype = {
    constructor: fm.TextureLoader,
    load: function(a, b, c, d) {
        var e = new fm.Texture
          , f = new fm.ImageLoader(this.manager);
        return f.setCrossOrigin(this.crossOrigin),
        f.setPath(this.path),
        f.load(a, function(a) {
            e.image = a,
            e.needsUpdate = !0,
            void 0 !== b && b(e)
        }, c, d),
        e
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a
    },
    setPath: function(a) {
        this.path = a
    }
},
fm.ImageLoader = function(a) {
    this.manager = void 0 !== a ? a : fm.DefaultLoadingManager
}
,
fm.ImageLoader.prototype = {
    constructor: fm.ImageLoader,
    load: function(a, b, c, d) {
        void 0 !== this.path && (a = this.path + a);
        var e = this
          , f = fm.Cache.get(a);
        if (void 0 !== f)
            return e.manager.itemStart(a),
            b ? setTimeout(function() {
                b(f),
                e.manager.itemEnd(a)
            }, 0) : e.manager.itemEnd(a),
            f;
        var g = document.createElement("img");
        return g.addEventListener("load", function(c) {
            fm.Cache.add(a, this),
            b && b(this),
            e.manager.itemEnd(a)
        }, !1),
        void 0 !== c && g.addEventListener("progress", function(a) {
            c(a)
        }, !1),
        g.addEventListener("error", function(b) {
            d && d(b),
            e.manager.itemError(a)
        }, !1),
        void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin),
        e.manager.itemStart(a),
        g.src = a,
        g
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a
    },
    setPath: function(a) {
        this.path = a
    }
},
fm.UniformsUtils = {
    merge: function(a) {
        for (var b = {}, c = 0; c < a.length; c++) {
            var d = this.clone(a[c]);
            for (var e in d)
                b[e] = d[e]
        }
        return b
    },
    clone: function(a) {
        var b = {};
        for (var c in a) {
            b[c] = {};
            for (var d in a[c]) {
                var e = a[c][d];
                e instanceof fm.Color || e instanceof fm.Vector2 || e instanceof fm.Vector3 || e instanceof fm.Vector4 || e instanceof fm.Matrix3 || e instanceof fm.Matrix4 || e instanceof fm.Texture ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e
            }
        }
        return b
    }
},
fm.UniformsLib = {
    common: {
        diffuse: {
            type: "c",
            value: new fm.Color(15658734)
        },
        opacity: {
            type: "1f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new fm.Vector4(0,0,1,1)
        },
        specularMap: {
            type: "t",
            value: null
        },
        alphaMap: {
            type: "t",
            value: null
        },
        envMap: {
            type: "t",
            value: null
        },
        flipEnvMap: {
            type: "1f",
            value: -1
        },
        reflectivity: {
            type: "1f",
            value: 1
        },
        refractionRatio: {
            type: "1f",
            value: .98
        }
    },
    aomap: {
        aoMap: {
            type: "t",
            value: null
        },
        aoMapIntensity: {
            type: "1f",
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            type: "t",
            value: null
        },
        lightMapIntensity: {
            type: "1f",
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            type: "t",
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            type: "t",
            value: null
        },
        bumpScale: {
            type: "1f",
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            type: "t",
            value: null
        },
        normalScale: {
            type: "v2",
            value: new fm.Vector2(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            type: "t",
            value: null
        },
        displacementScale: {
            type: "1f",
            value: 1
        },
        displacementBias: {
            type: "1f",
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            type: "t",
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            type: "t",
            value: null
        }
    },
    fog: {
        fogDensity: {
            type: "1f",
            value: 25e-5
        },
        fogNear: {
            type: "1f",
            value: 1
        },
        fogFar: {
            type: "1f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new fm.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            type: "3fv",
            value: []
        },
        directionalLights: {
            type: "sa",
            value: [],
            properties: {
                direction: {
                    type: "v3"
                },
                color: {
                    type: "c"
                },
                shadow: {
                    type: "1i"
                },
                shadowBias: {
                    type: "1f"
                },
                shadowRadius: {
                    type: "1f"
                },
                shadowMapSize: {
                    type: "v2"
                }
            }
        },
        directionalShadowMap: {
            type: "tv",
            value: []
        },
        directionalShadowMatrix: {
            type: "m4v",
            value: []
        },
        spotLights: {
            type: "sa",
            value: [],
            properties: {
                color: {
                    type: "c"
                },
                position: {
                    type: "v3"
                },
                direction: {
                    type: "v3"
                },
                distance: {
                    type: "1f"
                },
                coneCos: {
                    type: "1f"
                },
                penumbraCos: {
                    type: "1f"
                },
                decay: {
                    type: "1f"
                },
                shadow: {
                    type: "1i"
                },
                shadowBias: {
                    type: "1f"
                },
                shadowRadius: {
                    type: "1f"
                },
                shadowMapSize: {
                    type: "v2"
                }
            }
        },
        spotShadowMap: {
            type: "tv",
            value: []
        },
        spotShadowMatrix: {
            type: "m4v",
            value: []
        },
        pointLights: {
            type: "sa",
            value: [],
            properties: {
                color: {
                    type: "c"
                },
                position: {
                    type: "v3"
                },
                decay: {
                    type: "1f"
                },
                distance: {
                    type: "1f"
                },
                shadow: {
                    type: "1i"
                },
                shadowBias: {
                    type: "1f"
                },
                shadowRadius: {
                    type: "1f"
                },
                shadowMapSize: {
                    type: "v2"
                }
            }
        },
        pointShadowMap: {
            type: "tv",
            value: []
        },
        pointShadowMatrix: {
            type: "m4v",
            value: []
        },
        hemisphereLights: {
            type: "sa",
            value: [],
            properties: {
                direction: {
                    type: "v3"
                },
                skyColor: {
                    type: "c"
                },
                groundColor: {
                    type: "c"
                }
            }
        }
    },
    points: {
        diffuse: {
            type: "c",
            value: new fm.Color(15658734)
        },
        opacity: {
            type: "1f",
            value: 1
        },
        size: {
            type: "1f",
            value: 1
        },
        scale: {
            type: "1f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new fm.Vector4(0,0,1,1)
        }
    }
},
fm.ShaderChunk = {},
fm.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n   diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
fm.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n  uniform sampler2D alphaMap;\n#endif\n",
fm.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
fm.ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n reflectedLight.indirectDiffuse *= ambientOcclusion;\n   #if defined( USE_ENVMAP ) && defined( PHYSICAL )\n      float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n       reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n   #endif\n#endif\n",
fm.ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n    uniform sampler2D aoMap;\n  uniform float aoMapIntensity;\n#endif",
fm.ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n",
fm.ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n",
fm.ShaderChunk.bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n    return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n       if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n            float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n           float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n         return distanceFalloff * maxDistanceCutoffFactor;\n#else\n          return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n       }\n     return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n   return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n float a2 = pow2( alpha );\n float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n   float a2 = pow2( alpha );\n float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n float a2 = pow2( alpha );\n float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n    float alpha = pow2( roughness );\n  vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n   float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n   float dotNH = saturate( dot( geometry.normal, halfDir ) );\n    float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n    vec3 F = F_Schlick( specularColor, dotLH );\n   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n   float D = D_GGX( alpha, dotNH );\n  return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n   float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n   const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n  vec4 r = roughness * c0 + c1;\n float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n  return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n   return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n   float dotNH = saturate( dot( geometry.normal, halfDir ) );\n    float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n    vec3 F = F_Schlick( specularColor, dotLH );\n   float G = G_BlinnPhong_Implicit( );\n   float D = D_BlinnPhong( shininess, dotNH );\n   return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n  return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
fm.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n    uniform sampler2D bumpMap;\n    uniform float bumpScale;\n  vec2 dHdxy_fwd() {\n        vec2 dSTdx = dFdx( vUv );\n     vec2 dSTdy = dFdy( vUv );\n     float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n      float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n        float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n        return vec2( dBx, dBy );\n  }\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n      vec3 vSigmaX = dFdx( surf_pos );\n      vec3 vSigmaY = dFdy( surf_pos );\n      vec3 vN = surf_norm;\n      vec3 R1 = cross( vSigmaY, vN );\n       vec3 R2 = cross( vN, vSigmaX );\n       float fDet = dot( vSigmaX, R1 );\n      vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n      return normalize( abs( fDet ) * surf_norm - vGrad );\n  }\n#endif\n",
fm.ShaderChunk.clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n    for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n        vec4 plane = clippingPlanes[ i ];\n     if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n }\n#endif\n",
fm.ShaderChunk.clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n   #if ! defined( PHYSICAL ) && ! defined( PHONG )\n       varying vec3 vViewPosition;\n   #endif\n    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
fm.ShaderChunk.clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n  varying vec3 vViewPosition;\n#endif\n",
fm.ShaderChunk.clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n   vViewPosition = - mvPosition.xyz;\n#endif\n",
fm.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n diffuseColor.rgb *= vColor;\n#endif",
fm.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n    varying vec3 vColor;\n#endif\n",
fm.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n  varying vec3 vColor;\n#endif",
fm.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n   vColor.xyz = color.xyz;\n#endif",
fm.ShaderChunk.common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n   return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n vec3 color;\n   vec3 direction;\n   bool visible;\n};\nstruct ReflectedLight {\n    vec3 directDiffuse;\n   vec3 directSpecular;\n  vec3 indirectDiffuse;\n vec3 indirectSpecular;\n};\nstruct GeometricContext {\n vec3 position;\n    vec3 normal;\n  vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n   return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n   float distance = dot( planeNormal, point - pointOnPlane );\n    return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n  return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n   return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n",
fm.ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\nconst float cubeUV_textureSize = 1024.0;\nint getFaceFromDirection(vec3 direction) {\n    vec3 absDirection = abs(direction);\n   int face = -1;\n    if( absDirection.x > absDirection.z ) {\n       if(absDirection.x > absDirection.y )\n          face = direction.x > 0.0 ? 0 : 3;\n     else\n          face = direction.y > 0.0 ? 1 : 4;\n }\n else {\n        if(absDirection.z > absDirection.y )\n          face = direction.z > 0.0 ? 2 : 5;\n     else\n          face = direction.y > 0.0 ? 1 : 4;\n }\n return face;\n}\nfloat cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\nfloat cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n float dxRoughness = dFdx(roughness);\n  float dyRoughness = dFdy(roughness);\n  vec3 dx = dFdx( vec * scale * dxRoughness );\n  vec3 dy = dFdy( vec * scale * dyRoughness );\n  float d = max( dot( dx, dx ), dot( dy, dy ) );\n    d = clamp(d, 1.0, cubeUV_rangeClamp);\n float mipLevel = 0.5 * log2(d);\n   return vec2(floor(mipLevel), fract(mipLevel));\n}\nfloat cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n    mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n   float a = 16.0 * cubeUV_rcpTextureSize;\n   vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n  vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n float powScale = exp2_packed.x * exp2_packed.y;\n   float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n   float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n bool bRes = mipLevel == 0.0;\n  scale =  bRes && (scale < a) ? a : scale;\n vec3 r;\n   vec2 offset;\n  int face = getFaceFromDirection(direction);\n   float rcpPowScale = 1.0 / powScale;\n   if( face == 0) {\n      r = vec3(direction.x, -direction.z, direction.y);\n     offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n      offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n else if( face == 1) {\n     r = vec3(direction.y, direction.x, direction.z);\n      offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n       offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n else if( face == 2) {\n     r = vec3(direction.z, direction.x, direction.y);\n      offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n       offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n else if( face == 3) {\n     r = vec3(direction.x, direction.z, direction.y);\n      offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n       offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n  }\n else if( face == 4) {\n     r = vec3(direction.y, direction.x, -direction.z);\n     offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n  }\n else {\n        r = vec3(direction.z, -direction.x, direction.y);\n     offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n  }\n r = normalize(r);\n float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n  vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n   vec2 base = offset + vec2( texelOffset );\n return base + s * ( scale - 2.0 * texelOffset );\n}\nfloat cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n    float roughnessVal = roughness* cubeUV_maxLods3;\n  float r1 = floor(roughnessVal);\n   float r2 = r1 + 1.0;\n  float t = fract(roughnessVal);\n    vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n   float s = mipInfo.y;\n  float level0 = mipInfo.x;\n float level1 = level0 + 1.0;\n  level1 = level1 > 5.0 ? 5.0 : level1;\n level0 += min( floor( s + 0.5 ), 5.0 );\n   vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n   vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n   vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n vec4 result = mix(color10, color20, t);\n   return vec4(result.rgb, 1.0);\n}\n#endif\n",
fm.ShaderChunk.defaultnormal_vertex = "#ifdef FLIP_SIDED\n  objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
fm.ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n   transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
fm.ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n  uniform sampler2D displacementMap;\n    uniform float displacementScale;\n  uniform float displacementBias;\n#endif\n",
fm.ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n vec4 emissiveColor = texture2D( emissiveMap, vUv );\n   emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n    totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
fm.ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n    uniform sampler2D emissiveMap;\n#endif\n",
fm.ShaderChunk.encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n",
fm.ShaderChunk.encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
fm.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n   #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n       vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n       #ifdef ENVMAP_MODE_REFLECTION\n         vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n     #else\n         vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n        #endif\n    #else\n     vec3 reflectVec = vReflect;\n   #endif\n    #ifdef DOUBLE_SIDED\n       float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n   #else\n     float flipNormal = 1.0;\n   #endif\n    #ifdef ENVMAP_TYPE_CUBE\n       vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n #elif defined( ENVMAP_TYPE_EQUIREC )\n      vec2 sampleUV;\n        sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n       sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n     vec4 envColor = texture2D( envMap, sampleUV );\n    #elif defined( ENVMAP_TYPE_SPHERE )\n       vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n        vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n  #endif\n    envColor = envMapTexelToLinear( envColor );\n   #ifdef ENVMAP_BLENDING_MULTIPLY\n       outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n  #elif defined( ENVMAP_BLENDING_MIX )\n      outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n  #elif defined( ENVMAP_BLENDING_ADD )\n      outgoingLight += envColor.xyz * specularStrength * reflectivity;\n  #endif\n#endif\n",
fm.ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n   uniform float reflectivity;\n   uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n       varying vec3 vWorldPosition;\n  #endif\n    #ifdef ENVMAP_TYPE_CUBE\n       uniform samplerCube envMap;\n   #else\n     uniform sampler2D envMap;\n #endif\n    uniform float flipEnvMap;\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n     uniform float refractionRatio;\n    #else\n     varying vec3 vReflect;\n    #endif\n#endif\n",
fm.ShaderChunk.envmap_pars_vertex = "#ifdef USE_ENVMAP\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n        varying vec3 vWorldPosition;\n  #else\n     varying vec3 vReflect;\n        uniform float refractionRatio;\n    #endif\n#endif\n",
fm.ShaderChunk.envmap_vertex = "#ifdef USE_ENVMAP\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n        vWorldPosition = worldPosition.xyz;\n   #else\n     vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n        vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n        #ifdef ENVMAP_MODE_REFLECTION\n         vReflect = reflect( cameraToVertex, worldNormal );\n        #else\n         vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n       #endif\n    #endif\n#endif\n",
fm.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n #ifdef USE_LOGDEPTHBUF_EXT\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n   #else\n     float depth = gl_FragCoord.z / gl_FragCoord.w;\n    #endif\n    #ifdef FOG_EXP2\n       float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n    #else\n     float fogFactor = smoothstep( fogNear, fogFar, depth );\n   #endif\n    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
fm.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n    uniform vec3 fogColor;\n    #ifdef FOG_EXP2\n       uniform float fogDensity;\n #else\n     uniform float fogNear;\n        uniform float fogFar;\n #endif\n#endif",
fm.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n   reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
fm.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n  uniform sampler2D lightMap;\n   uniform float lightMapIntensity;\n#endif",
fm.ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n       getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n     dotNL = dot( geometry.normal, directLight.direction );\n        directLightColor_Diffuse = PI * directLight.color;\n        vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n      #ifdef DOUBLE_SIDED\n           vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n      #endif\n    }\n#endif\n#if NUM_SPOT_LIGHTS > 0\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n        getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n       dotNL = dot( geometry.normal, directLight.direction );\n        directLightColor_Diffuse = PI * directLight.color;\n        vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n      #ifdef DOUBLE_SIDED\n           vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n      #endif\n    }\n#endif\n#if NUM_DIR_LIGHTS > 0\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n     getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n     dotNL = dot( geometry.normal, directLight.direction );\n        directLightColor_Diffuse = PI * directLight.color;\n        vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n      #ifdef DOUBLE_SIDED\n           vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n      #endif\n    }\n#endif\n#if NUM_HEMI_LIGHTS > 0\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n        vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n       #ifdef DOUBLE_SIDED\n           vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n        #endif\n    }\n#endif\n",
fm.ShaderChunk.lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n    vec3 irradiance = ambientLightColor;\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n     irradiance *= PI;\n #endif\n    return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n struct DirectionalLight {\n     vec3 direction;\n       vec3 color;\n       int shadow;\n       float shadowBias;\n     float shadowRadius;\n       vec2 shadowMapSize;\n   };\n    uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n       directLight.color = directionalLight.color;\n       directLight.direction = directionalLight.direction;\n       directLight.visible = true;\n   }\n#endif\n#if NUM_POINT_LIGHTS > 0\n   struct PointLight {\n       vec3 position;\n        vec3 color;\n       float distance;\n       float decay;\n      int shadow;\n       float shadowBias;\n     float shadowRadius;\n       vec2 shadowMapSize;\n   };\n    uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n   void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n     vec3 lVector = pointLight.position - geometry.position;\n       directLight.direction = normalize( lVector );\n     float lightDistance = length( lVector );\n      if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n           directLight.color = pointLight.color;\n         directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n            directLight.visible = true;\n       } else {\n          directLight.color = vec3( 0.0 );\n          directLight.visible = false;\n      }\n }\n#endif\n#if NUM_SPOT_LIGHTS > 0\n    struct SpotLight {\n        vec3 position;\n        vec3 direction;\n       vec3 color;\n       float distance;\n       float decay;\n      float coneCos;\n        float penumbraCos;\n        int shadow;\n       float shadowBias;\n     float shadowRadius;\n       vec2 shadowMapSize;\n   };\n    uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n  void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n       vec3 lVector = spotLight.position - geometry.position;\n        directLight.direction = normalize( lVector );\n     float lightDistance = length( lVector );\n      float angleCos = dot( directLight.direction, spotLight.direction );\n       if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n          float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n          directLight.color = spotLight.color;\n          directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n         directLight.visible = true;\n       } else {\n          directLight.color = vec3( 0.0 );\n          directLight.visible = false;\n      }\n }\n#endif\n#if NUM_HEMI_LIGHTS > 0\n    struct HemisphereLight {\n      vec3 direction;\n       vec3 skyColor;\n        vec3 groundColor;\n };\n    uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n  vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n     float dotNL = dot( geometry.normal, hemiLight.direction );\n        float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n      vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n        #ifndef PHYSICALLY_CORRECT_LIGHTS\n         irradiance *= PI;\n     #endif\n        return irradiance;\n    }\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n   vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n        #ifdef DOUBLE_SIDED\n           float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n       #else\n         float flipNormal = 1.0;\n       #endif\n        vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n      #ifdef ENVMAP_TYPE_CUBE\n           vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n          #ifdef TEXTURE_LOD_EXT\n                vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n           #else\n             vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n         #endif\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n     #elif defined( ENVMAP_TYPE_CUBE_UV )\n          vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n          vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n        #else\n         vec4 envMapColor = vec4( 0.0 );\n       #endif\n        return PI * envMapColor.rgb * envMapIntensity;\n    }\n float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n        float maxMIPLevelScalar = float( maxMIPLevel );\n       float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n     return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n  }\n vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n       #ifdef ENVMAP_MODE_REFLECTION\n         vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n      #else\n         vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n     #endif\n        #ifdef DOUBLE_SIDED\n           float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n       #else\n         float flipNormal = 1.0;\n       #endif\n        reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n     float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n      #ifdef ENVMAP_TYPE_CUBE\n           vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n         #ifdef TEXTURE_LOD_EXT\n                vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n            #else\n             vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n          #endif\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n     #elif defined( ENVMAP_TYPE_CUBE_UV )\n          vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n         vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n       #elif defined( ENVMAP_TYPE_EQUIREC )\n          vec2 sampleUV;\n            sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n           sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n         #ifdef TEXTURE_LOD_EXT\n                vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n         #else\n             vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n           #endif\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n     #elif defined( ENVMAP_TYPE_SPHERE )\n           vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n            #ifdef TEXTURE_LOD_EXT\n                vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n           #else\n             vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n         #endif\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n     #endif\n        return envMapColor.rgb * envMapIntensity;\n }\n#endif\n",
fm.ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
fm.ShaderChunk.lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n    vec3    diffuseColor;\n vec3    specularColor;\n    float   specularShininess;\n    float   specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n   float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n  vec3 irradiance = dotNL * directLight.color;\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n     irradiance *= PI;\n #endif\n    reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n   reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n  reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct             RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse        RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )   (0)\n",
fm.ShaderChunk.lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n  material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n#else\n   material.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#endif\n",
fm.ShaderChunk.lights_physical_pars_fragment = "struct PhysicalMaterial {\n vec3    diffuseColor;\n float   specularRoughness;\n    vec3    specularColor;\n    #ifndef STANDARD\n  #endif\n};\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n  float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n  vec3 irradiance = dotNL * directLight.color;\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n     irradiance *= PI;\n #endif\n    reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n   reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n  reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct              RE_Direct_Physical\n#define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular        RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
fm.ShaderChunk.lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n PointLight pointLight;\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n       pointLight = pointLights[ i ];\n        getPointDirectLightIrradiance( pointLight, geometry, directLight );\n       #ifdef USE_SHADOWMAP\n      directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n      #endif\n        RE_Direct( directLight, geometry, material, reflectedLight );\n }\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n    SpotLight spotLight;\n  for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n        spotLight = spotLights[ i ];\n      getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n     #ifdef USE_SHADOWMAP\n      directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n     #endif\n        RE_Direct( directLight, geometry, material, reflectedLight );\n }\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n DirectionalLight directionalLight;\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n     directionalLight = directionalLights[ i ];\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n       #ifdef USE_SHADOWMAP\n      directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n       #endif\n        RE_Direct( directLight, geometry, material, reflectedLight );\n }\n#endif\n#if defined( RE_IndirectDiffuse )\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n #ifdef USE_LIGHTMAP\n       vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n        #ifndef PHYSICALLY_CORRECT_LIGHTS\n         lightMapIrradiance *= PI;\n     #endif\n        irradiance += lightMapIrradiance;\n #endif\n    #if ( NUM_HEMI_LIGHTS > 0 )\n       for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n            irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n        }\n #endif\n    #if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n        irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n #endif\n    RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n    vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n    RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n",
fm.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n   gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
fm.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n    uniform float logDepthBufFC;\n  #ifdef USE_LOGDEPTHBUF_EXT\n        varying float vFragDepth;\n #endif\n#endif\n",
fm.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n  #ifdef USE_LOGDEPTHBUF_EXT\n        varying float vFragDepth;\n #endif\n    uniform float logDepthBufFC;\n#endif",
fm.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n   gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n    #ifdef USE_LOGDEPTHBUF_EXT\n        vFragDepth = 1.0 + gl_Position.w;\n #else\n     gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n    #endif\n#endif\n",
fm.ShaderChunk.map_fragment = "#ifdef USE_MAP\n vec4 texelColor = texture2D( map, vUv );\n  texelColor = mapTexelToLinear( texelColor );\n  diffuseColor *= texelColor;\n#endif\n",
fm.ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n    uniform sampler2D map;\n#endif\n",
fm.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n    vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
fm.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n   uniform vec4 offsetRepeat;\n    uniform sampler2D map;\n#endif\n",
fm.ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n   vec4 texelMetalness = texture2D( metalnessMap, vUv );\n metalnessFactor *= texelMetalness.r;\n#endif\n",
fm.ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n  uniform sampler2D metalnessMap;\n#endif",
fm.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n  objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n   objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n   objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n   objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
fm.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n #ifndef USE_MORPHNORMALS\n  uniform float morphTargetInfluences[ 8 ];\n #else\n uniform float morphTargetInfluences[ 4 ];\n #endif\n#endif",
fm.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n  transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n  transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n  transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n  transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n  #ifndef USE_MORPHNORMALS\n  transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n  transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n  transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n  transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n  #endif\n#endif\n",
fm.ShaderChunk.normal_fragment = "#ifdef FLAT_SHADED\n  vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n  vec3 normal = normalize( vNormal );\n   #ifdef DOUBLE_SIDED\n       normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n   #endif\n#endif\n#ifdef USE_NORMALMAP\n  normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n   normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
fm.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n    uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n      vec3 q0 = dFdx( eye_pos.xyz );\n        vec3 q1 = dFdy( eye_pos.xyz );\n        vec2 st0 = dFdx( vUv.st );\n        vec2 st1 = dFdy( vUv.st );\n        vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n        vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n       vec3 N = normalize( surf_norm );\n      vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n      mapN.xy = normalScale * mapN.xy;\n      mat3 tsn = mat3( S, T, N );\n       return normalize( tsn * mapN );\n   }\n#endif\n",
fm.ShaderChunk.packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nvec4 packDepthToRGBA( const in float value ) {\n   const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n vec4 res = mod( value * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n res -= res.xxyz * bit_mask;\n   return res;\n}\nfloat unpackRGBAToDepth( const in vec4 rgba ) {\n   const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n    return dot( rgba, bitSh );\n}\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
fm.ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
fm.ShaderChunk.project_vertex = "#ifdef USE_SKINNING\n  vec4 mvPosition = modelViewMatrix * skinned;\n#else\n   vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
fm.ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n   vec4 texelRoughness = texture2D( roughnessMap, vUv );\n roughnessFactor *= texelRoughness.r;\n#endif\n",
fm.ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n  uniform sampler2D roughnessMap;\n#endif",
fm.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n    #if NUM_DIR_LIGHTS > 0\n        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n     varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n   #endif\n    #if NUM_SPOT_LIGHTS > 0\n       uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n       varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n #endif\n    #if NUM_POINT_LIGHTS > 0\n      uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n     varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n   #endif\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n      return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n }\n float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n        const vec2 offset = vec2( 0.0, 1.0 );\n     vec2 texelSize = vec2( 1.0 ) / size;\n      vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n        float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n       float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n       float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n       float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n       vec2 f = fract( uv * size + 0.5 );\n        float a = mix( lb, lt, f.y );\n     float b = mix( rb, rt, f.y );\n     float c = mix( a, b, f.x );\n       return c;\n }\n float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n      shadowCoord.xyz /= shadowCoord.w;\n     shadowCoord.z += shadowBias;\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n     bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n      bool frustumTest = all( frustumTestVec );\n     if ( frustumTest ) {\n      #if defined( SHADOWMAP_TYPE_PCF )\n         vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n         float dx0 = - texelSize.x * shadowRadius;\n         float dy0 = - texelSize.y * shadowRadius;\n         float dx1 = + texelSize.x * shadowRadius;\n         float dy1 = + texelSize.y * shadowRadius;\n         return (\n              texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n             texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n             texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n             texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n             texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n             texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n             texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n             texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n           ) * ( 1.0 / 9.0 );\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n          vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n         float dx0 = - texelSize.x * shadowRadius;\n         float dy0 = - texelSize.y * shadowRadius;\n         float dx1 = + texelSize.x * shadowRadius;\n         float dy1 = + texelSize.y * shadowRadius;\n         return (\n              texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n              texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n               texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n         ) * ( 1.0 / 9.0 );\n        #else\n         return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n      #endif\n        }\n     return 1.0;\n   }\n vec2 cubeToUV( vec3 v, float texelSizeY ) {\n       vec3 absV = abs( v );\n     float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n       absV *= scaleToCube;\n      v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n        vec2 planar = v.xy;\n       float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n     if ( absV.z >= almostOne ) {\n          if ( v.z > 0.0 )\n              planar.x = 4.0 - v.x;\n     } else if ( absV.x >= almostOne ) {\n           float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n     } else if ( absV.y >= almostOne ) {\n           float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n           planar.y = v.z * signY - 2.0;\n     }\n     return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n    }\n float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n     vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n      vec3 lightToPosition = shadowCoord.xyz;\n       vec3 bd3D = normalize( lightToPosition );\n     float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n       #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n           vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n            return (\n              texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n               texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n               texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n         ) * ( 1.0 / 9.0 );\n        #else\n         return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n      #endif\n    }\n#endif\n",
fm.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n  #if NUM_DIR_LIGHTS > 0\n        uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n       varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n   #endif\n    #if NUM_SPOT_LIGHTS > 0\n       uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n     varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n #endif\n    #if NUM_POINT_LIGHTS > 0\n      uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n       varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n   #endif\n#endif\n",
fm.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n   #if NUM_DIR_LIGHTS > 0\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n     vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n  }\n #endif\n    #if NUM_SPOT_LIGHTS > 0\n   for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n        vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n    }\n #endif\n    #if NUM_POINT_LIGHTS > 0\n  for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n       vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n  }\n #endif\n#endif\n",
fm.ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n    float shadow = 1.0;\n   #ifdef USE_SHADOWMAP\n  #if NUM_DIR_LIGHTS > 0\n    DirectionalLight directionalLight;\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n     directionalLight = directionalLights[ i ];\n        shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n   }\n #endif\n    #if NUM_SPOT_LIGHTS > 0\n   SpotLight spotLight;\n  for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n        spotLight = spotLights[ i ];\n      shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n }\n #endif\n    #if NUM_POINT_LIGHTS > 0\n  PointLight pointLight;\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n       pointLight = pointLights[ i ];\n        shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n  }\n #endif\n    #endif\n    return shadow;\n}\n",
fm.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
fm.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n    uniform mat4 bindMatrix;\n  uniform mat4 bindMatrixInverse;\n   #ifdef BONE_TEXTURE\n       uniform sampler2D boneTexture;\n        uniform int boneTextureWidth;\n     uniform int boneTextureHeight;\n        mat4 getBoneMatrix( const in float i ) {\n          float j = i * 4.0;\n            float x = mod( j, float( boneTextureWidth ) );\n            float y = floor( j / float( boneTextureWidth ) );\n         float dx = 1.0 / float( boneTextureWidth );\n           float dy = 1.0 / float( boneTextureHeight );\n          y = dy * ( y + 0.5 );\n         vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n          vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n          vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n          vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n          mat4 bone = mat4( v1, v2, v3, v4 );\n           return bone;\n      }\n #else\n     uniform mat4 boneMatrices[ MAX_BONES ];\n       mat4 getBoneMatrix( const in float i ) {\n          mat4 bone = boneMatrices[ int(i) ];\n           return bone;\n      }\n #endif\n#endif\n",
fm.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n  vec4 skinned = vec4( 0.0 );\n   skinned += boneMatX * skinVertex * skinWeight.x;\n  skinned += boneMatY * skinVertex * skinWeight.y;\n  skinned += boneMatZ * skinVertex * skinWeight.z;\n  skinned += boneMatW * skinVertex * skinWeight.w;\n  skinned  = bindMatrixInverse * skinned;\n#endif\n",
fm.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n   mat4 skinMatrix = mat4( 0.0 );\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n    objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
fm.ShaderChunk.specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n    vec4 texelSpecular = texture2D( specularMap, vUv );\n   specularStrength = texelSpecular.r;\n#else\n    specularStrength = 1.0;\n#endif",
fm.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n    uniform sampler2D specularMap;\n#endif",
fm.ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
fm.ShaderChunk.tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
fm.ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n   varying vec2 vUv2;\n#endif",
fm.ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n attribute vec2 uv2;\n   varying vec2 vUv2;\n#endif",
fm.ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n  vUv2 = uv2;\n#endif",
fm.ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n  varying vec2 vUv;\n#endif",
fm.ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n    varying vec2 vUv;\n uniform vec4 offsetRepeat;\n#endif\n",
fm.ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
fm.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n #ifdef USE_SKINNING\n       vec4 worldPosition = modelMatrix * skinned;\n   #else\n     vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n  #endif\n#endif\n",
fm.ShaderChunk.cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n  #include <clipping_planes_fragment>\n   gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n #include <logdepthbuf_fragment>\n}\n",
fm.ShaderChunk.cube_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n    vWorldPosition = transformDirection( position, modelMatrix );\n #include <begin_vertex>\n   #include <project_vertex>\n #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n}\n",
fm.ShaderChunk.depth_frag = "#if DEPTH_PACKING == 3200\n    uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n    #include <clipping_planes_fragment>\n   vec4 diffuseColor = vec4( 1.0 );\n  #if DEPTH_PACKING == 3200\n     diffuseColor.a = opacity;\n #endif\n    #include <map_fragment>\n   #include <alphamap_fragment>\n  #include <alphatest_fragment>\n #include <logdepthbuf_fragment>\n   #if DEPTH_PACKING == 3200\n     gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n   #elif DEPTH_PACKING == 3201\n       gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n #endif\n}\n",
fm.ShaderChunk.depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n #include <uv_vertex>\n  #include <skinbase_vertex>\n    #include <begin_vertex>\n   #include <displacementmap_vertex>\n #include <morphtarget_vertex>\n #include <skinning_vertex>\n    #include <project_vertex>\n #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n}\n",
fm.ShaderChunk.distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n #include <clipping_planes_fragment>\n   gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
fm.ShaderChunk.distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n   #include <skinbase_vertex>\n    #include <begin_vertex>\n   #include <morphtarget_vertex>\n #include <skinning_vertex>\n    #include <project_vertex>\n #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n vWorldPosition = worldPosition;\n}\n",
fm.ShaderChunk.equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n    #include <clipping_planes_fragment>\n   vec3 direction = normalize( vWorldPosition );\n vec2 sampleUV;\n    sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n    sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n gl_FragColor = texture2D( tEquirect, sampleUV );\n  #include <logdepthbuf_fragment>\n}\n",
fm.ShaderChunk.equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n    vWorldPosition = transformDirection( position, modelMatrix );\n #include <begin_vertex>\n   #include <project_vertex>\n #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n}\n",
fm.ShaderChunk.linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n  #include <clipping_planes_fragment>\n   if ( mod( vLineDistance, totalSize ) > dashSize ) {\n       discard;\n  }\n vec3 outgoingLight = vec3( 0.0 );\n vec4 diffuseColor = vec4( diffuse, opacity );\n #include <logdepthbuf_fragment>\n   #include <color_fragment>\n outgoingLight = diffuseColor.rgb;\n gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n #include <premultiplied_alpha_fragment>\n   #include <tonemapping_fragment>\n   #include <encodings_fragment>\n #include <fog_fragment>\n}\n",
fm.ShaderChunk.linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n   #include <color_vertex>\n   vLineDistance = scale * lineDistance;\n vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n  #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n}\n",
fm.ShaderChunk.meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n   varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n  #include <clipping_planes_fragment>\n   vec4 diffuseColor = vec4( diffuse, opacity );\n #include <logdepthbuf_fragment>\n   #include <map_fragment>\n   #include <color_fragment>\n #include <alphamap_fragment>\n  #include <alphatest_fragment>\n #include <specularmap_fragment>\n   ReflectedLight reflectedLight;\n    reflectedLight.directDiffuse = vec3( 0.0 );\n   reflectedLight.directSpecular = vec3( 0.0 );\n  reflectedLight.indirectDiffuse = diffuseColor.rgb;\n    reflectedLight.indirectSpecular = vec3( 0.0 );\n    #include <aomap_fragment>\n vec3 outgoingLight = reflectedLight.indirectDiffuse;\n  #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n #include <premultiplied_alpha_fragment>\n   #include <tonemapping_fragment>\n   #include <encodings_fragment>\n #include <fog_fragment>\n}\n",
fm.ShaderChunk.meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n    #include <uv_vertex>\n  #include <uv2_vertex>\n #include <color_vertex>\n   #include <skinbase_vertex>\n    #ifdef USE_ENVMAP\n #include <beginnormal_vertex>\n #include <morphnormal_vertex>\n #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n   #endif\n    #include <begin_vertex>\n   #include <morphtarget_vertex>\n #include <skinning_vertex>\n    #include <project_vertex>\n #include <logdepthbuf_vertex>\n #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n #include <envmap_vertex>\n}\n",
fm.ShaderChunk.meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n  varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n   #include <clipping_planes_fragment>\n   vec4 diffuseColor = vec4( diffuse, opacity );\n ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n vec3 totalEmissiveRadiance = emissive;\n    #include <logdepthbuf_fragment>\n   #include <map_fragment>\n   #include <color_fragment>\n #include <alphamap_fragment>\n  #include <alphatest_fragment>\n #include <specularmap_fragment>\n   #include <emissivemap_fragment>\n   reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n  #include <lightmap_fragment>\n  reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n   #ifdef DOUBLE_SIDED\n       reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n #else\n     reflectedLight.directDiffuse = vLightFront;\n   #endif\n    reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n   #include <aomap_fragment>\n vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n   #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n #include <premultiplied_alpha_fragment>\n   #include <tonemapping_fragment>\n   #include <encodings_fragment>\n #include <fog_fragment>\n}\n",
fm.ShaderChunk.meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n    varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n   #include <uv_vertex>\n  #include <uv2_vertex>\n #include <color_vertex>\n   #include <beginnormal_vertex>\n #include <morphnormal_vertex>\n #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n   #include <begin_vertex>\n   #include <morphtarget_vertex>\n #include <skinning_vertex>\n    #include <project_vertex>\n #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n #include <worldpos_vertex>\n    #include <envmap_vertex>\n  #include <lights_lambert_vertex>\n  #include <shadowmap_vertex>\n}\n",
fm.ShaderChunk.meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n    #include <clipping_planes_fragment>\n   vec4 diffuseColor = vec4( diffuse, opacity );\n ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n vec3 totalEmissiveRadiance = emissive;\n    #include <logdepthbuf_fragment>\n   #include <map_fragment>\n   #include <color_fragment>\n #include <alphamap_fragment>\n  #include <alphatest_fragment>\n #include <specularmap_fragment>\n   #include <normal_fragment>\n    #include <emissivemap_fragment>\n   #include <lights_phong_fragment>\n  #include <lights_template>\n    #include <aomap_fragment>\n vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n #include <envmap_fragment>\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n #include <premultiplied_alpha_fragment>\n   #include <tonemapping_fragment>\n   #include <encodings_fragment>\n #include <fog_fragment>\n}\n",
fm.ShaderChunk.meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n    #include <uv_vertex>\n  #include <uv2_vertex>\n #include <color_vertex>\n   #include <beginnormal_vertex>\n #include <morphnormal_vertex>\n #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n  vNormal = normalize( transformedNormal );\n#endif\n #include <begin_vertex>\n   #include <displacementmap_vertex>\n #include <morphtarget_vertex>\n #include <skinning_vertex>\n    #include <project_vertex>\n #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n vViewPosition = - mvPosition.xyz;\n #include <worldpos_vertex>\n    #include <envmap_vertex>\n  #include <shadowmap_vertex>\n}\n",
fm.ShaderChunk.meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n   #include <clipping_planes_fragment>\n   vec4 diffuseColor = vec4( diffuse, opacity );\n ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n vec3 totalEmissiveRadiance = emissive;\n    #include <logdepthbuf_fragment>\n   #include <map_fragment>\n   #include <color_fragment>\n #include <alphamap_fragment>\n  #include <alphatest_fragment>\n #include <specularmap_fragment>\n   #include <roughnessmap_fragment>\n  #include <metalnessmap_fragment>\n  #include <normal_fragment>\n    #include <emissivemap_fragment>\n   #include <lights_physical_fragment>\n   #include <lights_template>\n    #include <aomap_fragment>\n vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n #include <premultiplied_alpha_fragment>\n   #include <tonemapping_fragment>\n   #include <encodings_fragment>\n #include <fog_fragment>\n}\n",
fm.ShaderChunk.meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n    varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n #include <uv_vertex>\n  #include <uv2_vertex>\n #include <color_vertex>\n   #include <beginnormal_vertex>\n #include <morphnormal_vertex>\n #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n  vNormal = normalize( transformedNormal );\n#endif\n #include <begin_vertex>\n   #include <displacementmap_vertex>\n #include <morphtarget_vertex>\n #include <skinning_vertex>\n    #include <project_vertex>\n #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n vViewPosition = - mvPosition.xyz;\n #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n}\n",
fm.ShaderChunk.normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n #include <clipping_planes_fragment>\n   gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n   #include <logdepthbuf_fragment>\n}\n",
fm.ShaderChunk.normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n vNormal = normalize( normalMatrix * normal );\n #include <begin_vertex>\n   #include <morphtarget_vertex>\n #include <project_vertex>\n #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n}\n",
fm.ShaderChunk.points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n    #include <clipping_planes_fragment>\n   vec3 outgoingLight = vec3( 0.0 );\n vec4 diffuseColor = vec4( diffuse, opacity );\n #include <logdepthbuf_fragment>\n   #include <map_particle_fragment>\n  #include <color_fragment>\n #include <alphatest_fragment>\n outgoingLight = diffuseColor.rgb;\n gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n #include <premultiplied_alpha_fragment>\n   #include <tonemapping_fragment>\n   #include <encodings_fragment>\n #include <fog_fragment>\n}\n",
fm.ShaderChunk.points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n #include <color_vertex>\n   #include <begin_vertex>\n   #include <project_vertex>\n #ifdef USE_SIZEATTENUATION\n        gl_PointSize = size * ( scale / - mvPosition.z );\n #else\n     gl_PointSize = size;\n  #endif\n    #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n}\n",
fm.ShaderLib = {
    basic: {
        uniforms: fm.UniformsUtils.merge([fm.UniformsLib.common, fm.UniformsLib.aomap, fm.UniformsLib.fog]),
        vertexShader: fm.ShaderChunk.meshbasic_vert,
        fragmentShader: fm.ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: fm.UniformsUtils.merge([fm.UniformsLib.common, fm.UniformsLib.aomap, fm.UniformsLib.lightmap, fm.UniformsLib.emissivemap, fm.UniformsLib.fog, fm.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new fm.Color(0)
            }
        }]),
        vertexShader: fm.ShaderChunk.meshlambert_vert,
        fragmentShader: fm.ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: fm.UniformsUtils.merge([fm.UniformsLib.common, fm.UniformsLib.aomap, fm.UniformsLib.lightmap, fm.UniformsLib.emissivemap, fm.UniformsLib.bumpmap, fm.UniformsLib.normalmap, fm.UniformsLib.displacementmap, fm.UniformsLib.fog, fm.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new fm.Color(0)
            },
            specular: {
                type: "c",
                value: new fm.Color(1118481)
            },
            shininess: {
                type: "1f",
                value: 30
            }
        }]),
        vertexShader: fm.ShaderChunk.meshphong_vert,
        fragmentShader: fm.ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: fm.UniformsUtils.merge([fm.UniformsLib.common, fm.UniformsLib.aomap, fm.UniformsLib.lightmap, fm.UniformsLib.emissivemap, fm.UniformsLib.bumpmap, fm.UniformsLib.normalmap, fm.UniformsLib.displacementmap, fm.UniformsLib.roughnessmap, fm.UniformsLib.metalnessmap, fm.UniformsLib.fog, fm.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new fm.Color(0)
            },
            roughness: {
                type: "1f",
                value: .5
            },
            metalness: {
                type: "1f",
                value: 0
            },
            envMapIntensity: {
                type: "1f",
                value: 1
            }
        }]),
        vertexShader: fm.ShaderChunk.meshphysical_vert,
        fragmentShader: fm.ShaderChunk.meshphysical_frag
    },
    points: {
        uniforms: fm.UniformsUtils.merge([fm.UniformsLib.points, fm.UniformsLib.fog]),
        vertexShader: fm.ShaderChunk.points_vert,
        fragmentShader: fm.ShaderChunk.points_frag
    },
    dashed: {
        uniforms: fm.UniformsUtils.merge([fm.UniformsLib.common, fm.UniformsLib.fog, {
            scale: {
                type: "1f",
                value: 1
            },
            dashSize: {
                type: "1f",
                value: 1
            },
            totalSize: {
                type: "1f",
                value: 2
            }
        }]),
        vertexShader: fm.ShaderChunk.linedashed_vert,
        fragmentShader: fm.ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: fm.UniformsUtils.merge([fm.UniformsLib.common, fm.UniformsLib.displacementmap]),
        vertexShader: fm.ShaderChunk.depth_vert,
        fragmentShader: fm.ShaderChunk.depth_frag
    },
    normal: {
        uniforms: {
            opacity: {
                type: "1f",
                value: 1
            }
        },
        vertexShader: fm.ShaderChunk.normal_vert,
        fragmentShader: fm.ShaderChunk.normal_frag
    },
    cube: {
        uniforms: {
            tCube: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "1f",
                value: -1
            }
        },
        vertexShader: fm.ShaderChunk.cube_vert,
        fragmentShader: fm.ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "1f",
                value: -1
            }
        },
        vertexShader: fm.ShaderChunk.equirect_vert,
        fragmentShader: fm.ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: {
            lightPos: {
                type: "v3",
                value: new fm.Vector3
            }
        },
        vertexShader: fm.ShaderChunk.distanceRGBA_vert,
        fragmentShader: fm.ShaderChunk.distanceRGBA_frag
    }
},
fm.ShaderLib.physical = {
    uniforms: fm.UniformsUtils.merge([fm.ShaderLib.standard.uniforms, {}]),
    vertexShader: fm.ShaderChunk.meshphysical_vert,
    fragmentShader: fm.ShaderChunk.meshphysical_frag
},
fm.WebGLBufferRenderer = function(a, b, c) {
    function d(a) {
        g = a
    }
    function e(b, d) {
        a.drawArrays(g, b, d),
        c.calls++,
        c.vertices += d,
        g === a.TRIANGLES && (c.faces += d / 3)
    }
    function f(d) {
        var e = b.get("ANGLE_instanced_arrays");
        if (null === e)
            return void console.error("fm.WebGLBufferRenderer: using fm.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        var f = d.attributes.position
          , h = 0;
        f instanceof fm.InterleavedBufferAttribute ? (h = f.data.count,
        e.drawArraysInstancedANGLE(g, 0, h, d.maxInstancedCount)) : (h = f.count,
        e.drawArraysInstancedANGLE(g, 0, h, d.maxInstancedCount)),
        c.calls++,
        c.vertices += h * d.maxInstancedCount,
        g === a.TRIANGLES && (c.faces += d.maxInstancedCount * h / 3)
    }
    var g;
    this.setMode = d,
    this.render = e,
    this.renderInstances = f
}
,
fm.WebGLCapabilities = function(a, b, c) {
    function d(b) {
        if ("highp" === b) {
            if (a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision > 0 && a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision > 0)
                return "highp";
            b = "mediump"
        }
        return "mediump" === b && a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision > 0 && a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    this.getMaxPrecision = d,
    this.precision = void 0 !== c.precision ? c.precision : "highp",
    this.logarithmicDepthBuffer = void 0 !== c.logarithmicDepthBuffer && c.logarithmicDepthBuffer,
    this.maxTextures = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
    this.maxVertexTextures = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE),
    this.maxCubemapSize = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),
    this.maxAttributes = a.getParameter(a.MAX_VERTEX_ATTRIBS),
    this.maxVertexUniforms = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),
    this.maxVaryings = a.getParameter(a.MAX_VARYING_VECTORS),
    this.maxFragmentUniforms = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),
    this.vertexTextures = this.maxVertexTextures > 0,
    this.floatFragmentTextures = !!b.get("OES_texture_float"),
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
    var e = d(this.precision);
    e !== this.precision && (console.warn("fm.WebGLRenderer:", this.precision, "not supported, using", e, "instead."),
    this.precision = e),
    this.logarithmicDepthBuffer && (this.logarithmicDepthBuffer = !!b.get("EXT_frag_depth"))
}
,
fm.WebGLExtensions = function(a) {
    var b = {};
    this.get = function(c) {
        if (void 0 !== b[c])
            return b[c];
        var d;
        switch (c) {
        case "WEBGL_depth_texture":
            d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
        case "EXT_texture_filter_anisotropic":
            d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        case "WEBGL_compressed_texture_etc1":
            d = a.getExtension("WEBGL_compressed_texture_etc1");
            break;
        default:
            d = a.getExtension(c)
        }
        return null === d && console.warn("fm.WebGLRenderer: " + c + " extension not supported."),
        b[c] = d,
        d
    }
}
,
fm.WebGLGeometries = function(a, b, c) {
    function d(a) {
        var b = a.geometry;
        if (void 0 !== j[b.id])
            return j[b.id];
        b.addEventListener("dispose", e);
        var d;
        return b instanceof fm.BufferGeometry ? d = b : b instanceof fm.Geometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new fm.BufferGeometry).setFromObject(a)),
        d = b._bufferGeometry),
        j[b.id] = d,
        c.memory.geometries++,
        d
    }
    function e(a) {
        var d = a.target
          , f = j[d.id];
        null !== f.index && g(f.index),
        h(f.attributes),
        d.removeEventListener("dispose", e),
        delete j[d.id];
        var i = b.get(d);
        i.wireframe && g(i.wireframe),
        b["delete"](d);
        var k = b.get(f);
        k.wireframe && g(k.wireframe),
        b["delete"](f),
        c.memory.geometries--
    }
    function f(a) {
        return a instanceof fm.InterleavedBufferAttribute ? b.get(a.data).__webglBuffer : b.get(a).__webglBuffer
    }
    function g(b) {
        var c = f(b);
        void 0 !== c && (a.deleteBuffer(c),
        i(b))
    }
    function h(a) {
        for (var b in a)
            g(a[b])
    }
    function i(a) {
        a instanceof fm.InterleavedBufferAttribute ? b["delete"](a.data) : b["delete"](a)
    }
    var j = {};
    this.get = d
}
,
fm.WebGLIndexedBufferRenderer = function(a, b, c) {
    function d(a) {
        h = a
    }
    function e(c) {
        c.array instanceof Uint32Array && b.get("OES_element_index_uint") ? (i = a.UNSIGNED_INT,
        j = 4) : (i = a.UNSIGNED_SHORT,
        j = 2)
    }
    function f(b, d) {
        a.drawElements(h, d, i, b * j),
        c.calls++,
        c.vertices += d,
        h === a.TRIANGLES && (c.faces += d / 3)
    }
    function g(d, e, f) {
        var g = b.get("ANGLE_instanced_arrays");
        return null === g ? void console.error("fm.WebGLBufferRenderer: using fm.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (g.drawElementsInstancedANGLE(h, f, i, e * j, d.maxInstancedCount),
        c.calls++,
        c.vertices += f * d.maxInstancedCount,
        void (h === a.TRIANGLES && (c.faces += d.maxInstancedCount * f / 3)))
    }
    var h, i, j;
    this.setMode = d,
    this.setIndex = e,
    this.render = f,
    this.renderInstances = g
}
,
fm.WebGLLights = function() {
    var a = {};
    this.get = function(b) {
        if (void 0 !== a[b.id])
            return a[b.id];
        var c;
        switch (b.type) {
        case "DirectionalLight":
            c = {
                direction: new fm.Vector3,
                color: new fm.Color,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new fm.Vector2
            };
            break;
        case "SpotLight":
            c = {
                position: new fm.Vector3,
                direction: new fm.Vector3,
                color: new fm.Color,
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new fm.Vector2
            };
            break;
        case "PointLight":
            c = {
                position: new fm.Vector3,
                color: new fm.Color,
                distance: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new fm.Vector2
            };
            break;
        case "HemisphereLight":
            c = {
                direction: new fm.Vector3,
                skyColor: new fm.Color,
                groundColor: new fm.Color
            }
        }
        return a[b.id] = c,
        c
    }
}
,
fm.WebGLObjects = function(a, b, c) {
    function d(b) {
        var c = k.get(b);
        b.geometry instanceof fm.Geometry && c.updateFromObject(b);
        var d = c.index
          , f = c.attributes;
        null !== d && e(d, a.ELEMENT_ARRAY_BUFFER);
        for (var g in f)
            e(f[g], a.ARRAY_BUFFER);
        var h = c.morphAttributes;
        for (var g in h)
            for (var i = h[g], j = 0, l = i.length; j < l; j++)
                e(i[j], a.ARRAY_BUFFER);
        return c
    }
    function e(a, c) {
        var d = a instanceof fm.InterleavedBufferAttribute ? a.data : a
          , e = b.get(d);
        void 0 === e.__webglBuffer ? f(e, d, c) : e.version !== d.version && g(e, d, c)
    }
    function f(b, c, d) {
        b.__webglBuffer = a.createBuffer(),
        a.bindBuffer(d, b.__webglBuffer);
        var e = c.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW;
        a.bufferData(d, c.array, e),
        b.version = c.version
    }
    function g(b, c, d) {
        a.bindBuffer(d, b.__webglBuffer),
        c.dynamic === !1 || c.updateRange.count === -1 ? a.bufferSubData(d, 0, c.array) : 0 === c.updateRange.count ? console.error("fm.WebGLObjects.updateBuffer: dynamic fm.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(d, c.updateRange.offset * c.array.BYTES_PER_ELEMENT, c.array.subarray(c.updateRange.offset, c.updateRange.offset + c.updateRange.count)),
        c.updateRange.count = 0),
        b.version = c.version
    }
    function h(a) {
        return a instanceof fm.InterleavedBufferAttribute ? b.get(a.data).__webglBuffer : b.get(a).__webglBuffer
    }
    function i(c) {
        var d = b.get(c);
        if (void 0 !== d.wireframe)
            return d.wireframe;
        var f = []
          , g = c.index
          , h = c.attributes
          , i = h.position;
        if (null !== g)
            for (var k = {}, l = g.array, m = 0, n = l.length; m < n; m += 3) {
                var o = l[m + 0]
                  , p = l[m + 1]
                  , q = l[m + 2];
                j(k, o, p) && f.push(o, p),
                j(k, p, q) && f.push(p, q),
                j(k, q, o) && f.push(q, o)
            }
        else
            for (var l = h.position.array, m = 0, n = l.length / 3 - 1; m < n; m += 3) {
                var o = m + 0
                  , p = m + 1
                  , q = m + 2;
                f.push(o, p, p, q, q, o)
            }
        var r = i.count > 65535 ? Uint32Array : Uint16Array
          , s = new fm.BufferAttribute(new r(f),1);
        return e(s, a.ELEMENT_ARRAY_BUFFER),
        d.wireframe = s,
        s
    }
    function j(a, b, c) {
        if (b > c) {
            var d = b;
            b = c,
            c = d
        }
        var e = a[b];
        return void 0 === e ? (a[b] = [c],
        !0) : e.indexOf(c) === -1 && (e.push(c),
        !0)
    }
    var k = new fm.WebGLGeometries(a,b,c);
    this.getAttributeBuffer = h,
    this.getWireframeAttribute = i,
    this.update = d
}
,
fm.WebGLProgram = function() {
    function a(a) {
        switch (a) {
        case fm.LinearEncoding:
            return ["Linear", "( value )"];
        case fm.sRGBEncoding:
            return ["sRGB", "( value )"];
        case fm.RGBEEncoding:
            return ["RGBE", "( value )"];
        case fm.RGBM7Encoding:
            return ["RGBM", "( value, 7.0 )"];
        case fm.RGBM16Encoding:
            return ["RGBM", "( value, 16.0 )"];
        case fm.RGBDEncoding:
            return ["RGBD", "( value, 256.0 )"];
        case fm.GammaEncoding:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw new Error("unsupported encoding: " + a)
        }
    }
    function b(b, c) {
        var d = a(c);
        return "vec4 " + b + "( vec4 value ) { return " + d[0] + "ToLinear" + d[1] + "; }"
    }
    function c(b, c) {
        var d = a(c);
        return "vec4 " + b + "( vec4 value ) { return LinearTo" + d[0] + d[1] + "; }"
    }
    function d(a, b) {
        var c;
        switch (b) {
        case fm.LinearToneMapping:
            c = "Linear";
            break;
        case fm.ReinhardToneMapping:
            c = "Reinhard";
            break;
        case fm.Uncharted2ToneMapping:
            c = "Uncharted2";
            break;
        case fm.CineonToneMapping:
            c = "OptimizedCineon";
            break;
        default:
            throw new Error("unsupported toneMapping: " + b)
        }
        return "vec3 " + a + "( vec3 color ) { return " + c + "ToneMapping( color ); }"
    }
    function e(a, b, c) {
        a = a || {};
        var d = [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
        return d.filter(h).join("\n")
    }
    function f(a) {
        var b = [];
        for (var c in a) {
            var d = a[c];
            d !== !1 && b.push("#define " + c + " " + d)
        }
        return b.join("\n")
    }
    function g(a, b, c) {
        for (var d = {}, e = a.getProgramParameter(b, a.ACTIVE_ATTRIBUTES), f = 0; f < e; f++) {
            var g = a.getActiveAttrib(b, f)
              , h = g.name;
            d[h] = a.getAttribLocation(b, h)
        }
        return d
    }
    function h(a) {
        return "" !== a
    }
    function i(a, b) {
        return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
    }
    function j(a) {
        function b(a, b) {
            var c = fm.ShaderChunk[b];
            if (void 0 === c)
                throw new Error("Can not resolve #include <" + b + ">");
            return j(c)
        }
        var c = /#include +<([\w\d.]+)>/g;
        return a.replace(c, b)
    }
    function k(a) {
        function b(a, b, c, d) {
            for (var e = "", f = parseInt(b); f < parseInt(c); f++)
                e += d.replace(/\[ i \]/g, "[ " + f + " ]");
            return e
        }
        var c = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        return a.replace(c, b)
    }
    var l = 0;
    return function(a, m, n, o) {
        var p = a.context
          , q = n.extensions
          , r = n.defines
          , s = n.__webglShader.vertexShader
          , t = n.__webglShader.fragmentShader
          , u = "SHADOWMAP_TYPE_BASIC";
        o.shadowMapType === fm.PCFShadowMap ? u = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === fm.PCFSoftShadowMap && (u = "SHADOWMAP_TYPE_PCF_SOFT");
        var v = "ENVMAP_TYPE_CUBE"
          , w = "ENVMAP_MODE_REFLECTION"
          , x = "ENVMAP_BLENDING_MULTIPLY";
        if (o.envMap) {
            switch (n.envMap.mapping) {
            case fm.CubeReflectionMapping:
            case fm.CubeRefractionMapping:
                v = "ENVMAP_TYPE_CUBE";
                break;
            case fm.CubeUVReflectionMapping:
            case fm.CubeUVRefractionMapping:
                v = "ENVMAP_TYPE_CUBE_UV";
                break;
            case fm.EquirectangularReflectionMapping:
            case fm.EquirectangularRefractionMapping:
                v = "ENVMAP_TYPE_EQUIREC";
                break;
            case fm.SphericalReflectionMapping:
                v = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
            case fm.CubeRefractionMapping:
            case fm.EquirectangularRefractionMapping:
                w = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
            case fm.MultiplyOperation:
                x = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case fm.MixOperation:
                x = "ENVMAP_BLENDING_MIX";
                break;
            case fm.AddOperation:
                x = "ENVMAP_BLENDING_ADD"
            }
        }
        var y, z, A = a.gammaFactor > 0 ? a.gammaFactor : 1, B = e(q, o, a.extensions), C = f(r), D = p.createProgram();
        n instanceof fm.RawShaderMaterial ? (y = "",
        z = "") : (y = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + n.__webglShader.name, C, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + A, "#define MAX_BONES " + o.maxBones, o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + w : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && o.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + o.numClippingPlanes, o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(h).join("\n"),
        z = [B, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + n.__webglShader.name, C, o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "", "#define GAMMA_FACTOR " + A, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + v : "", o.envMap ? "#define " + w : "", o.envMap ? "#define " + x : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + o.numClippingPlanes, o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && a.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== fm.NoToneMapping ? "#define TONE_MAPPING" : "", o.toneMapping !== fm.NoToneMapping ? fm.ShaderChunk.tonemapping_pars_fragment : "", o.toneMapping !== fm.NoToneMapping ? d("toneMapping", o.toneMapping) : "", o.outputEncoding || o.mapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? fm.ShaderChunk.encodings_pars_fragment : "", o.mapEncoding ? b("mapTexelToLinear", o.mapEncoding) : "", o.envMapEncoding ? b("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? b("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? c("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(h).join("\n")),
        s = j(s, o),
        s = i(s, o),
        t = j(t, o),
        t = i(t, o),
        n instanceof fm.ShaderMaterial == !1 && (s = k(s),
        t = k(t));
        var E = y + s
          , F = z + t
          , G = fm.WebGLShader(p, p.VERTEX_SHADER, E)
          , H = fm.WebGLShader(p, p.FRAGMENT_SHADER, F);
        p.attachShader(D, G),
        p.attachShader(D, H),
        void 0 !== n.index0AttributeName ? p.bindAttribLocation(D, 0, n.index0AttributeName) : o.morphTargets === !0 && p.bindAttribLocation(D, 0, "position"),
        p.linkProgram(D);
        var I = p.getProgramInfoLog(D)
          , J = p.getShaderInfoLog(G)
          , K = p.getShaderInfoLog(H)
          , L = !0
          , M = !0;
        p.getProgramParameter(D, p.LINK_STATUS) === !1 ? (L = !1,
        console.error("fm.WebGLProgram: shader error: ", p.getError(), "gl.VALIDATE_STATUS", p.getProgramParameter(D, p.VALIDATE_STATUS), "gl.getProgramInfoLog", I, J, K)) : "" !== I ? console.warn("fm.WebGLProgram: gl.getProgramInfoLog()", I) : "" !== J && "" !== K || (M = !1),
        M && (this.diagnostics = {
            runnable: L,
            material: n,
            programLog: I,
            vertexShader: {
                log: J,
                prefix: y
            },
            fragmentShader: {
                log: K,
                prefix: z
            }
        }),
        p.deleteShader(G),
        p.deleteShader(H);
        var N;
        this.getUniforms = function() {
            return void 0 === N && (N = new fm.WebGLUniforms(p,D,a)),
            N
        }
        ;
        var O;
        return this.getAttributes = function() {
            return void 0 === O && (O = g(p, D)),
            O
        }
        ,
        this.destroy = function() {
            p.deleteProgram(D),
            this.program = void 0
        }
        ,
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("fm.WebGLProgram: .uniforms is now .getUniforms()."),
                    this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("fm.WebGLProgram: .attributes is now .getAttributes()."),
                    this.getAttributes()
                }
            }
        }),
        this.id = l++,
        this.code = m,
        this.usedTimes = 1,
        this.program = D,
        this.vertexShader = G,
        this.fragmentShader = H,
        this
    }
}(),
fm.WebGLPrograms = function(a, b) {
    function c(a) {
        if (b.floatVertexTextures && a && a.skeleton && a.skeleton.useVertexTexture)
            return 1024;
        var c = b.maxVertexUniforms
          , d = Math.floor((c - 20) / 4)
          , e = d;
        return void 0 !== a && a instanceof fm.SkinnedMesh && (e = Math.min(a.skeleton.bones.length, e),
        e < a.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + a.skeleton.bones.length + ", this GPU supports just " + e + " (try OpenGL instead of ANGLE)")),
        e
    }
    function d(a, b) {
        var c;
        return a ? a instanceof fm.Texture ? c = a.encoding : a instanceof fm.WebGLRenderTarget && (c = a.texture.encoding) : c = fm.LinearEncoding,
        c === fm.LinearEncoding && b && (c = fm.GammaEncoding),
        c
    }
    var e = []
      , f = {
        MeshDepthMaterial: "depth",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points"
    }
      , g = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"];
    this.getParameters = function(e, g, h, i, j) {
        var k = f[e.type]
          , l = c(j)
          , m = a.getPrecision();
        null !== e.precision && (m = b.getMaxPrecision(e.precision),
        m !== e.precision && console.warn("fm.WebGLProgram.getParameters:", e.precision, "not supported, using", m, "instead."));
        var n = {
            shaderID: k,
            precision: m,
            supportsVertexTextures: b.vertexTextures,
            outputEncoding: d(a.getCurrentRenderTarget(), a.gammaOutput),
            map: !!e.map,
            mapEncoding: d(e.map, a.gammaInput),
            envMap: !!e.envMap,
            envMapMode: e.envMap && e.envMap.mapping,
            envMapEncoding: d(e.envMap, a.gammaInput),
            envMapCubeUV: !!e.envMap && (e.envMap.mapping === fm.CubeUVReflectionMapping || e.envMap.mapping === fm.CubeUVRefractionMapping),
            lightMap: !!e.lightMap,
            aoMap: !!e.aoMap,
            emissiveMap: !!e.emissiveMap,
            emissiveMapEncoding: d(e.emissiveMap, a.gammaInput),
            bumpMap: !!e.bumpMap,
            normalMap: !!e.normalMap,
            displacementMap: !!e.displacementMap,
            roughnessMap: !!e.roughnessMap,
            metalnessMap: !!e.metalnessMap,
            specularMap: !!e.specularMap,
            alphaMap: !!e.alphaMap,
            combine: e.combine,
            vertexColors: e.vertexColors,
            fog: h,
            useFog: e.fog,
            fogExp: h instanceof fm.FogExp2,
            flatShading: e.shading === fm.FlatShading,
            sizeAttenuation: e.sizeAttenuation,
            logarithmicDepthBuffer: b.logarithmicDepthBuffer,
            skinning: e.skinning,
            maxBones: l,
            useVertexTexture: b.floatVertexTextures && j && j.skeleton && j.skeleton.useVertexTexture,
            morphTargets: e.morphTargets,
            morphNormals: e.morphNormals,
            maxMorphTargets: a.maxMorphTargets,
            maxMorphNormals: a.maxMorphNormals,
            numDirLights: g.directional.length,
            numPointLights: g.point.length,
            numSpotLights: g.spot.length,
            numHemiLights: g.hemi.length,
            numClippingPlanes: i,
            shadowMapEnabled: a.shadowMap.enabled && j.receiveShadow && g.shadows.length > 0,
            shadowMapType: a.shadowMap.type,
            toneMapping: a.toneMapping,
            physicallyCorrectLights: a.physicallyCorrectLights,
            premultipliedAlpha: e.premultipliedAlpha,
            alphaTest: e.alphaTest,
            doubleSided: e.side === fm.DoubleSide,
            flipSided: e.side === fm.BackSide,
            depthPacking: void 0 !== e.depthPacking && e.depthPacking
        };
        return n
    }
    ,
    this.getProgramCode = function(a, b) {
        var c = [];
        if (b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader),
        c.push(a.vertexShader)),
        void 0 !== a.defines)
            for (var d in a.defines)
                c.push(d),
                c.push(a.defines[d]);
        for (var e = 0; e < g.length; e++)
            c.push(b[g[e]]);
        return c.join()
    }
    ,
    this.acquireProgram = function(b, c, d) {
        for (var f, g = 0, h = e.length; g < h; g++) {
            var i = e[g];
            if (i.code === d) {
                f = i,
                ++f.usedTimes;
                break
            }
        }
        return void 0 === f && (f = new fm.WebGLProgram(a,d,b,c),
        e.push(f)),
        f
    }
    ,
    this.releaseProgram = function(a) {
        if (0 === --a.usedTimes) {
            var b = e.indexOf(a);
            e[b] = e[e.length - 1],
            e.pop(),
            a.destroy()
        }
    }
    ,
    this.programs = e
}
,
fm.WebGLProperties = function() {
    var a = {};
    this.get = function(b) {
        var c = b.uuid
          , d = a[c];
        return void 0 === d && (d = {},
        a[c] = d),
        d
    }
    ,
    this["delete"] = function(b) {
        delete a[b.uuid]
    }
    ,
    this.clear = function() {
        a = {}
    }
}
,
fm.WebGLShader = function() {
    function a(a) {
        for (var b = a.split("\n"), c = 0; c < b.length; c++)
            b[c] = c + 1 + ": " + b[c];
        return b.join("\n")
    }
    return function(b, c, d) {
        var e = b.createShader(c);
        return b.shaderSource(e, d),
        b.compileShader(e),
        b.getShaderParameter(e, b.COMPILE_STATUS) === !1 && console.error("fm.WebGLShader: Shader couldn't compile."),
        "" !== b.getShaderInfoLog(e) && console.warn("fm.WebGLShader: gl.getShaderInfoLog()", c === b.VERTEX_SHADER ? "vertex" : "fragment", b.getShaderInfoLog(e), a(d)),
        e
    }
}(),
fm.WebGLShadowMap = function(a, b, c) {
    function d(b, c, d, e) {
        var f = b.geometry
          , g = null
          , h = r
          , i = b.customDepthMaterial;
        if (d && (h = s,
        i = b.customDistanceMaterial),
        i)
            g = i;
        else {
            var j = void 0 !== f.morphTargets && f.morphTargets.length > 0 && c.morphTargets
              , k = b instanceof fm.SkinnedMesh && c.skinning
              , l = 0;
            j && (l |= o),
            k && (l |= p),
            g = h[l]
        }
        if (a.localClippingEnabled && c.clipShadows === !0 && 0 !== c.clippingPlanes.length) {
            var m = g.uuid
              , n = c.uuid
              , q = t[m];
            void 0 === q && (q = {},
            t[m] = q);
            var u = q[n];
            void 0 === u && (u = g.clone(),
            q[n] = u),
            g = u
        }
        return g.visible = c.visible,
        g.wireframe = c.wireframe,
        g.side = c.side,
        g.clipShadows = c.clipShadows,
        g.clippingPlanes = c.clippingPlanes,
        g.wireframeLinewidth = c.wireframeLinewidth,
        g.linewidth = c.linewidth,
        d && void 0 !== g.uniforms.lightPos && g.uniforms.lightPos.value.copy(e),
        g
    }
    function e(a, b, c) {
        if (a.visible !== !1) {
            if (a.layers.test(b.layers) && (a instanceof fm.Mesh || a instanceof fm.Line || a instanceof fm.Points) && a.castShadow && (a.frustumCulled === !1 || h.intersectsObject(a) === !0)) {
                var d = a.material;
                d.visible === !0 && (a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld),
                n.push(a))
            }
            for (var f = a.children, g = 0, i = f.length; g < i; g++)
                e(f[g], b, c)
        }
    }
    var f = a.context
      , g = a.state
      , h = new fm.Frustum
      , i = new fm.Matrix4
      , j = b.shadows
      , k = new fm.Vector2
      , l = new fm.Vector3
      , m = new fm.Vector3
      , n = []
      , o = 1
      , p = 2
      , q = (o | p) + 1
      , r = new Array(q)
      , s = new Array(q)
      , t = {}
      , u = [new fm.Vector3(1,0,0), new fm.Vector3((-1),0,0), new fm.Vector3(0,0,1), new fm.Vector3(0,0,(-1)), new fm.Vector3(0,1,0), new fm.Vector3(0,(-1),0)]
      , v = [new fm.Vector3(0,1,0), new fm.Vector3(0,1,0), new fm.Vector3(0,1,0), new fm.Vector3(0,1,0), new fm.Vector3(0,0,1), new fm.Vector3(0,0,(-1))]
      , w = [new fm.Vector4, new fm.Vector4, new fm.Vector4, new fm.Vector4, new fm.Vector4, new fm.Vector4]
      , x = new fm.MeshDepthMaterial;
    x.depthPacking = fm.RGBADepthPacking,
    x.clipping = !0;
    for (var y = fm.ShaderLib.distanceRGBA, z = fm.UniformsUtils.clone(y.uniforms), A = 0; A !== q; ++A) {
        var B = 0 !== (A & o)
          , C = 0 !== (A & p)
          , D = x.clone();
        D.morphTargets = B,
        D.skinning = C,
        r[A] = D;
        var E = new fm.ShaderMaterial({
            defines: {
                USE_SHADOWMAP: ""
            },
            uniforms: z,
            vertexShader: y.vertexShader,
            fragmentShader: y.fragmentShader,
            morphTargets: B,
            skinning: C,
            clipping: !0
        });
        s[A] = E
    }
    var F = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = fm.PCFShadowMap,
    this.cullFace = fm.CullFaceFront,
    this.render = function(b, o) {
        if (F.enabled !== !1 && (F.autoUpdate !== !1 || F.needsUpdate !== !1) && 0 !== j.length) {
            g.clearColor(1, 1, 1, 1),
            g.disable(f.BLEND),
            g.enable(f.CULL_FACE),
            f.frontFace(f.CCW),
            f.cullFace(F.cullFace === fm.CullFaceFront ? f.FRONT : f.BACK),
            g.setDepthTest(!0),
            g.setScissorTest(!1);
            for (var p, q, r = 0, s = j.length; r < s; r++) {
                var t = j[r]
                  , x = t.shadow
                  , y = x.camera;
                if (k.copy(x.mapSize),
                t instanceof fm.PointLight) {
                    p = 6,
                    q = !0;
                    var z = k.x
                      , A = k.y;
                    w[0].set(2 * z, A, z, A),
                    w[1].set(0, A, z, A),
                    w[2].set(3 * z, A, z, A),
                    w[3].set(z, A, z, A),
                    w[4].set(3 * z, 0, z, A),
                    w[5].set(z, 0, z, A),
                    k.x *= 4,
                    k.y *= 2
                } else
                    p = 1,
                    q = !1;
                if (null === x.map) {
                    var B = {
                        minFilter: fm.NearestFilter,
                        magFilter: fm.NearestFilter,
                        format: fm.RGBAFormat
                    };
                    x.map = new fm.WebGLRenderTarget(k.x,k.y,B),
                    y.updateProjectionMatrix()
                }
                x instanceof fm.SpotLightShadow && x.update(t);
                var C = x.map
                  , D = x.matrix;
                m.setFromMatrixPosition(t.matrixWorld),
                y.position.copy(m),
                a.setRenderTarget(C),
                a.clear();
                for (var E = 0; E < p; E++) {
                    if (q) {
                        l.copy(y.position),
                        l.add(u[E]),
                        y.up.copy(v[E]),
                        y.lookAt(l);
                        var G = w[E];
                        g.viewport(G)
                    } else
                        l.setFromMatrixPosition(t.target.matrixWorld),
                        y.lookAt(l);
                    y.updateMatrixWorld(),
                    y.matrixWorldInverse.getInverse(y.matrixWorld),
                    D.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                    D.multiply(y.projectionMatrix),
                    D.multiply(y.matrixWorldInverse),
                    i.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse),
                    h.setFromMatrix(i),
                    n.length = 0,
                    e(b, o, y);
                    for (var H = 0, I = n.length; H < I; H++) {
                        var J = n[H]
                          , K = c.update(J)
                          , L = J.material;
                        if (L instanceof fm.MultiMaterial)
                            for (var M = K.groups, N = L.materials, O = 0, P = M.length; O < P; O++) {
                                var Q = M[O]
                                  , R = N[Q.materialIndex];
                                if (R.visible === !0) {
                                    var S = d(J, R, q, m);
                                    a.renderBufferDirect(y, null , K, S, J, Q)
                                }
                            }
                        else {
                            var S = d(J, L, q, m);
                            a.renderBufferDirect(y, null , K, S, J, null )
                        }
                    }
                }
            }
            var T = a.getClearColor()
              , U = a.getClearAlpha();
            a.setClearColor(T, U),
            g.enable(f.BLEND),
            F.cullFace === fm.CullFaceFront && f.cullFace(f.BACK),
            F.needsUpdate = !1
        }
    }
}
,
fm.WebGLState = function(a, b, c) {
    var d = this
      , e = new fm.Vector4
      , f = a.getParameter(a.MAX_VERTEX_ATTRIBS)
      , g = new Uint8Array(f)
      , h = new Uint8Array(f)
      , i = new Uint8Array(f)
      , j = {}
      , k = null
      , l = null
      , m = null
      , n = null
      , o = null
      , p = null
      , q = null
      , r = null
      , s = !1
      , t = null
      , u = null
      , v = null
      , w = null
      , x = null
      , y = null
      , z = null
      , A = null
      , B = null
      , C = null
      , D = null
      , E = null
      , F = null
      , G = null
      , H = null
      , I = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS)
      , J = void 0
      , K = {}
      , L = new fm.Vector4
      , M = null
      , N = null
      , O = new fm.Vector4
      , P = new fm.Vector4;
    this.init = function() {
        this.clearColor(0, 0, 0, 1),
        this.clearDepth(1),
        this.clearStencil(0),
        this.enable(a.DEPTH_TEST),
        a.depthFunc(a.LEQUAL),
        a.frontFace(a.CCW),
        a.cullFace(a.BACK),
        this.enable(a.CULL_FACE),
        this.enable(a.BLEND),
        a.blendEquation(a.FUNC_ADD),
        a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA)
    }
    ,
    this.initAttributes = function() {
        for (var a = 0, b = g.length; a < b; a++)
            g[a] = 0
    }
    ,
    this.enableAttribute = function(c) {
        if (g[c] = 1,
        0 === h[c] && (a.enableVertexAttribArray(c),
        h[c] = 1),
        0 !== i[c]) {
            var d = b.get("ANGLE_instanced_arrays");
            d.vertexAttribDivisorANGLE(c, 0),
            i[c] = 0
        }
    }
    ,
    this.enableAttributeAndDivisor = function(b, c, d) {
        g[b] = 1,
        0 === h[b] && (a.enableVertexAttribArray(b),
        h[b] = 1),
        i[b] !== c && (d.vertexAttribDivisorANGLE(b, c),
        i[b] = c)
    }
    ,
    this.disableUnusedAttributes = function() {
        for (var b = 0, c = h.length; b < c; b++)
            h[b] !== g[b] && (a.disableVertexAttribArray(b),
            h[b] = 0)
    }
    ,
    this.enable = function(b) {
        j[b] !== !0 && (a.enable(b),
        j[b] = !0)
    }
    ,
    this.disable = function(b) {
        j[b] !== !1 && (a.disable(b),
        j[b] = !1)
    }
    ,
    this.getCompressedTextureFormats = function() {
        if (null === k && (k = [],
        b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1")))
            for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++)
                k.push(c[d]);
        return k
    }
    ,
    this.setBlending = function(b, d, e, f, g, h, i, j) {
        b === fm.NoBlending ? this.disable(a.BLEND) : this.enable(a.BLEND),
        b === l && j === s || (b === fm.AdditiveBlending ? j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD),
        a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD),
        a.blendFunc(a.SRC_ALPHA, a.ONE)) : b === fm.SubtractiveBlending ? j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD),
        a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD),
        a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : b === fm.MultiplyBlending ? j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD),
        a.blendFuncSeparate(a.ZERO, a.ZERO, a.SRC_COLOR, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD),
        a.blendFunc(a.ZERO, a.SRC_COLOR)) : j ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD),
        a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD),
        a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)),
        l = b,
        s = j),
        b === fm.CustomBlending ? (g = g || d,
        h = h || e,
        i = i || f,
        d === m && g === p || (a.blendEquationSeparate(c(d), c(g)),
        m = d,
        p = g),
        e === n && f === o && h === q && i === r || (a.blendFuncSeparate(c(e), c(f), c(h), c(i)),
        n = e,
        o = f,
        q = h,
        r = i)) : (m = null ,
        n = null ,
        o = null ,
        p = null ,
        q = null ,
        r = null )
    }
    ,
    this.setDepthFunc = function(b) {
        if (t !== b) {
            if (b)
                switch (b) {
                case fm.NeverDepth:
                    a.depthFunc(a.NEVER);
                    break;
                case fm.AlwaysDepth:
                    a.depthFunc(a.ALWAYS);
                    break;
                case fm.LessDepth:
                    a.depthFunc(a.LESS);
                    break;
                case fm.LessEqualDepth:
                    a.depthFunc(a.LEQUAL);
                    break;
                case fm.EqualDepth:
                    a.depthFunc(a.EQUAL);
                    break;
                case fm.GreaterEqualDepth:
                    a.depthFunc(a.GEQUAL);
                    break;
                case fm.GreaterDepth:
                    a.depthFunc(a.GREATER);
                    break;
                case fm.NotEqualDepth:
                    a.depthFunc(a.NOTEQUAL);
                    break;
                default:
                    a.depthFunc(a.LEQUAL)
                }
            else
                a.depthFunc(a.LEQUAL);
            t = b
        }
    }
    ,
    this.setDepthTest = function(b) {
        b ? this.enable(a.DEPTH_TEST) : this.disable(a.DEPTH_TEST)
    }
    ,
    this.setDepthWrite = function(b) {
        u !== b && (a.depthMask(b),
        u = b)
    }
    ,
    this.setColorWrite = function(b) {
        v !== b && (a.colorMask(b, b, b, b),
        v = b)
    }
    ,
    this.setStencilFunc = function(b, c, d) {
        x === b && y === c && z === d || (a.stencilFunc(b, c, d),
        x = b,
        y = c,
        z = d)
    }
    ,
    this.setStencilOp = function(b, c, d) {
        A === b && B === c && C === d || (a.stencilOp(b, c, d),
        A = b,
        B = c,
        C = d)
    }
    ,
    this.setStencilTest = function(b) {
        b ? this.enable(a.STENCIL_TEST) : this.disable(a.STENCIL_TEST)
    }
    ,
    this.setStencilWrite = function(b) {
        w !== b && (a.stencilMask(b),
        w = b)
    }
    ,
    this.setFlipSided = function(b) {
        D !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW),
        D = b)
    }
    ,
    this.setLineWidth = function(b) {
        b !== E && (a.lineWidth(b),
        E = b)
    }
    ,
    this.setPolygonOffset = function(b, c, d) {
        b ? this.enable(a.POLYGON_OFFSET_FILL) : this.disable(a.POLYGON_OFFSET_FILL),
        !b || F === c && G === d || (a.polygonOffset(c, d),
        F = c,
        G = d)
    }
    ,
    this.getScissorTest = function() {
        return H
    }
    ,
    this.setScissorTest = function(b) {
        H = b,
        b ? this.enable(a.SCISSOR_TEST) : this.disable(a.SCISSOR_TEST)
    }
    ,
    this.activeTexture = function(b) {
        void 0 === b && (b = a.TEXTURE0 + I - 1),
        J !== b && (a.activeTexture(b),
        J = b)
    }
    ,
    this.bindTexture = function(b, c) {
        void 0 === J && d.activeTexture();
        var e = K[J];
        void 0 === e && (e = {
            type: void 0,
            texture: void 0
        },
        K[J] = e),
        e.type === b && e.texture === c || (a.bindTexture(b, c),
        e.type = b,
        e.texture = c)
    }
    ,
    this.compressedTexImage2D = function() {
        try {
            a.compressedTexImage2D.apply(a, arguments)
        } catch (b) {
            console.error(b)
        }
    }
    ,
    this.texImage2D = function() {
        try {
            a.texImage2D.apply(a, arguments)
        } catch (b) {
            console.error(b)
        }
    }
    ,
    this.clearColor = function(b, c, d, f) {
        e.set(b, c, d, f),
        L.equals(e) === !1 && (a.clearColor(b, c, d, f),
        L.copy(e))
    }
    ,
    this.clearDepth = function(b) {
        M !== b && (a.clearDepth(b),
        M = b)
    }
    ,
    this.clearStencil = function(b) {
        N !== b && (a.clearStencil(b),
        N = b)
    }
    ,
    this.scissor = function(b) {
        O.equals(b) === !1 && (a.scissor(b.x, b.y, b.z, b.w),
        O.copy(b))
    }
    ,
    this.viewport = function(b) {
        P.equals(b) === !1 && (a.viewport(b.x, b.y, b.z, b.w),
        P.copy(b))
    }
    ,
    this.reset = function() {
        for (var b = 0; b < h.length; b++)
            1 === h[b] && (a.disableVertexAttribArray(b),
            h[b] = 0);
        j = {},
        k = null ,
        J = void 0,
        K = {},
        l = null ,
        v = null ,
        u = null ,
        w = null ,
        D = null
    }
}
,
fm.WebGLUniforms = function() {
    var a = function() {
        this.seq = [],
        this.map = {}
    }
      , b = []
      , c = []
      , d = function(a, c, d) {
        var e = a[0];
        if (e <= 0 || e > 0)
            return a;
        var f = c * d
          , g = b[f];
        if (void 0 === g && (g = new Float32Array(f),
        b[f] = g),
        0 !== c) {
            e.toArray(g, 0);
            for (var h = 1, i = 0; h !== c; ++h)
                i += d,
                a[h].toArray(g, i)
        }
        return g
    }
      , e = function(a, b) {
        var d = c[b];
        void 0 === d && (d = new Int32Array(b),
        c[b] = d);
        for (var e = 0; e !== b; ++e)
            d[e] = a.allocTextureUnit();
        return d
    }
      , f = function(a, b) {
        a.uniform1f(this.addr, b)
    }
      , g = function(a, b) {
        a.uniform1i(this.addr, b)
    }
      , h = function(a, b) {
        void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y)
    }
      , i = function(a, b) {
        void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b)
    }
      , j = function(a, b) {
        void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w)
    }
      , k = function(a, b) {
        a.uniformMatrix2fv(this.addr, !1, b.elements || b)
    }
      , l = function(a, b) {
        a.uniformMatrix3fv(this.addr, !1, b.elements || b)
    }
      , m = function(a, b) {
        a.uniformMatrix4fv(this.addr, !1, b.elements || b)
    }
      , n = function(a, b, c) {
        var d = c.allocTextureUnit();
        a.uniform1i(this.addr, d),
        b && c.setTexture2D(b, d)
    }
      , o = function(a, b, c) {
        var d = c.allocTextureUnit();
        a.uniform1i(this.addr, d),
        b && c.setTextureCube(b, d)
    }
      , p = function(a, b) {
        a.uniform2iv(this.addr, b)
    }
      , q = function(a, b) {
        a.uniform3iv(this.addr, b)
    }
      , r = function(a, b) {
        a.uniform4iv(this.addr, b)
    }
      , s = function(a) {
        switch (a) {
        case 5126:
            return f;
        case 35664:
            return h;
        case 35665:
            return i;
        case 35666:
            return j;
        case 35674:
            return k;
        case 35675:
            return l;
        case 35676:
            return m;
        case 35678:
            return n;
        case 35680:
            return o;
        case 5124:
        case 35670:
            return g;
        case 35667:
        case 35671:
            return p;
        case 35668:
        case 35672:
            return q;
        case 35669:
        case 35673:
            return r
        }
    }
      , t = function(a, b) {
        a.uniform1fv(this.addr, b)
    }
      , u = function(a, b) {
        a.uniform1iv(this.addr, b)
    }
      , v = function(a, b) {
        a.uniform2fv(this.addr, d(b, this.size, 2))
    }
      , w = function(a, b) {
        a.uniform3fv(this.addr, d(b, this.size, 3))
    }
      , x = function(a, b) {
        a.uniform4fv(this.addr, d(b, this.size, 4))
    }
      , y = function(a, b) {
        a.uniformMatrix2fv(this.addr, !1, d(b, this.size, 4))
    }
      , z = function(a, b) {
        a.uniformMatrix3fv(this.addr, !1, d(b, this.size, 9))
    }
      , A = function(a, b) {
        a.uniformMatrix4fv(this.addr, !1, d(b, this.size, 16))
    }
      , B = function(a, b, c) {
        var d = b.length
          , f = e(c, d);
        a.uniform1iv(this.addr, f);
        for (var g = 0; g !== d; ++g) {
            var h = b[g];
            h && c.setTexture2D(h, f[g])
        }
    }
      , C = function(a, b, c) {
        var d = b.length
          , f = e(c, d);
        a.uniform1iv(this.addr, f);
        for (var g = 0; g !== d; ++g) {
            var h = b[g];
            h && c.setTextureCube(h, f[g])
        }
    }
      , D = function(a) {
        switch (a) {
        case 5126:
            return t;
        case 35664:
            return v;
        case 35665:
            return w;
        case 35666:
            return x;
        case 35674:
            return y;
        case 35675:
            return z;
        case 35676:
            return A;
        case 35678:
            return B;
        case 35680:
            return C;
        case 5124:
        case 35670:
            return u;
        case 35667:
        case 35671:
            return p;
        case 35668:
        case 35672:
            return q;
        case 35669:
        case 35673:
            return r
        }
    }
      , E = function(a, b, c) {
        this.id = a,
        this.addr = c,
        this.setValue = s(b.type)
    }
      , F = function(a, b, c) {
        this.id = a,
        this.addr = c,
        this.size = b.size,
        this.setValue = D(b.type)
    }
      , G = function(b) {
        this.id = b,
        a.call(this)
    }
    ;
    G.prototype.setValue = function(a, b) {
        for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) {
            var f = c[d];
            f.setValue(a, b[f.id])
        }
    }
    ;
    var H = /([\w\d_]+)(\])?(\[|\.)?/g
      , I = function(a, b) {
        a.seq.push(b),
        a.map[b.id] = b
    }
      , J = function(a, b, c) {
        var d = a.name
          , e = d.length;
        for (H.lastIndex = 0; ; ) {
            var f = H.exec(d)
              , g = H.lastIndex
              , h = f[1]
              , i = "]" === f[2]
              , j = f[3];
            if (i && (h = 0 | h),
            void 0 === j || "[" === j && g + 2 === e) {
                I(c, void 0 === j ? new E(h,a,b) : new F(h,a,b));
                break
            }
            var k = c.map
              , l = k[h];
            void 0 === l && (l = new G(h),
            I(c, l)),
            c = l
        }
    }
      , K = function(b, c, d) {
        a.call(this),
        this.renderer = d;
        for (var e = b.getProgramParameter(c, b.ACTIVE_UNIFORMS), f = 0; f !== e; ++f) {
            var g = b.getActiveUniform(c, f)
              , h = g.name
              , i = b.getUniformLocation(c, h);
            J(g, i, this)
        }
    }
    ;
    return K.prototype.setValue = function(a, b, c) {
        var d = this.map[b];
        void 0 !== d && d.setValue(a, c, this.renderer)
    }
    ,
    K.prototype.set = function(a, b, c) {
        var d = this.map[c];
        void 0 !== d && d.setValue(a, b[c], this.renderer)
    }
    ,
    K.prototype.setOptional = function(a, b, c) {
        var d = b[c];
        void 0 !== d && this.setValue(a, c, d)
    }
    ,
    K.upload = function(a, b, c, d) {
        for (var e = 0, f = b.length; e !== f; ++e) {
            var g = b[e]
              , h = c[g.id];
            h.needsUpdate !== !1 && g.setValue(a, h.value, d)
        }
    }
    ,
    K.seqWithValue = function(a, b) {
        for (var c = [], d = 0, e = a.length; d !== e; ++d) {
            var f = a[d];
            f.id in b && c.push(f)
        }
        return c
    }
    ,
    K.splitDynamic = function(a, b) {
        for (var c = null , d = a.length, e = 0, f = 0; f !== d; ++f) {
            var g = a[f]
              , h = b[g.id];
            h && h.dynamic === !0 ? (null === c && (c = []),
            c.push(g)) : (e < f && (a[e] = g),
            ++e)
        }
        return e < d && (a.length = e),
        c
    }
    ,
    K.evalDynamic = function(a, b, c, d) {
        for (var e = 0, f = a.length; e !== f; ++e) {
            var g = b[a[e].id]
              , h = g.onUpdateCallback;
            void 0 !== h && h.call(g, c, d)
        }
    }
    ,
    K
}(),
fm.LensFlarePlugin = function(a, b) {
    function c() {
        var a = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1])
          , b = new Uint16Array([0, 1, 2, 0, 2, 3]);
        e = m.createBuffer(),
        f = m.createBuffer(),
        m.bindBuffer(m.ARRAY_BUFFER, e),
        m.bufferData(m.ARRAY_BUFFER, a, m.STATIC_DRAW),
        m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f),
        m.bufferData(m.ELEMENT_ARRAY_BUFFER, b, m.STATIC_DRAW),
        k = m.createTexture(),
        l = m.createTexture(),
        n.bindTexture(m.TEXTURE_2D, k),
        m.texImage2D(m.TEXTURE_2D, 0, m.RGB, 16, 16, 0, m.RGB, m.UNSIGNED_BYTE, null ),
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE),
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE),
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
        n.bindTexture(m.TEXTURE_2D, l),
        m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, 16, 16, 0, m.RGBA, m.UNSIGNED_BYTE, null ),
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE),
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE),
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
        g = {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
        },
        h = d(g),
        i = {
            vertex: m.getAttribLocation(h, "position"),
            uv: m.getAttribLocation(h, "uv")
        },
        j = {
            renderType: m.getUniformLocation(h, "renderType"),
            map: m.getUniformLocation(h, "map"),
            occlusionMap: m.getUniformLocation(h, "occlusionMap"),
            opacity: m.getUniformLocation(h, "opacity"),
            color: m.getUniformLocation(h, "color"),
            scale: m.getUniformLocation(h, "scale"),
            rotation: m.getUniformLocation(h, "rotation"),
            screenPosition: m.getUniformLocation(h, "screenPosition")
        }
    }
    function d(b) {
        var c = m.createProgram()
          , d = m.createShader(m.FRAGMENT_SHADER)
          , e = m.createShader(m.VERTEX_SHADER)
          , f = "precision " + a.getPrecision() + " float;\n";
        return m.shaderSource(d, f + b.fragmentShader),
        m.shaderSource(e, f + b.vertexShader),
        m.compileShader(d),
        m.compileShader(e),
        m.attachShader(c, d),
        m.attachShader(c, e),
        m.linkProgram(c),
        c
    }
    var e, f, g, h, i, j, k, l, m = a.context, n = a.state;
    this.render = function(d, g, o) {
        if (0 !== b.length) {
            var p = new fm.Vector3
              , q = o.w / o.z
              , r = .5 * o.z
              , s = .5 * o.w
              , t = 16 / o.w
              , u = new fm.Vector2(t * q,t)
              , v = new fm.Vector3(1,1,0)
              , w = new fm.Vector2(1,1)
              , x = new fm.Box2;
            x.min.set(0, 0),
            x.max.set(o.z - 16, o.w - 16),
            void 0 === h && c(),
            m.useProgram(h),
            n.initAttributes(),
            n.enableAttribute(i.vertex),
            n.enableAttribute(i.uv),
            n.disableUnusedAttributes(),
            m.uniform1i(j.occlusionMap, 0),
            m.uniform1i(j.map, 1),
            m.bindBuffer(m.ARRAY_BUFFER, e),
            m.vertexAttribPointer(i.vertex, 2, m.FLOAT, !1, 16, 0),
            m.vertexAttribPointer(i.uv, 2, m.FLOAT, !1, 16, 8),
            m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f),
            n.disable(m.CULL_FACE),
            n.setDepthWrite(!1);
            for (var y = 0, z = b.length; y < z; y++) {
                t = 16 / o.w,
                u.set(t * q, t);
                var A = b[y];
                if (p.set(A.matrixWorld.elements[12], A.matrixWorld.elements[13], A.matrixWorld.elements[14]),
                p.applyMatrix4(g.matrixWorldInverse),
                p.applyProjection(g.projectionMatrix),
                v.copy(p),
                w.x = o.x + v.x * r + r - 8,
                w.y = o.y + v.y * s + s - 8,
                x.containsPoint(w) === !0) {
                    n.activeTexture(m.TEXTURE0),
                    n.bindTexture(m.TEXTURE_2D, null ),
                    n.activeTexture(m.TEXTURE1),
                    n.bindTexture(m.TEXTURE_2D, k),
                    m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGB, w.x, w.y, 16, 16, 0),
                    m.uniform1i(j.renderType, 0),
                    m.uniform2f(j.scale, u.x, u.y),
                    m.uniform3f(j.screenPosition, v.x, v.y, v.z),
                    n.disable(m.BLEND),
                    n.enable(m.DEPTH_TEST),
                    m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                    n.activeTexture(m.TEXTURE0),
                    n.bindTexture(m.TEXTURE_2D, l),
                    m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGBA, w.x, w.y, 16, 16, 0),
                    m.uniform1i(j.renderType, 1),
                    n.disable(m.DEPTH_TEST),
                    n.activeTexture(m.TEXTURE1),
                    n.bindTexture(m.TEXTURE_2D, k),
                    m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                    A.positionScreen.copy(v),
                    A.customUpdateCallback ? A.customUpdateCallback(A) : A.updateLensFlares(),
                    m.uniform1i(j.renderType, 2),
                    n.enable(m.BLEND);
                    for (var B = 0, C = A.lensFlares.length; B < C; B++) {
                        var D = A.lensFlares[B];
                        D.opacity > .001 && D.scale > .001 && (v.x = D.x,
                        v.y = D.y,
                        v.z = D.z,
                        t = D.size * D.scale / o.w,
                        u.x = t * q,
                        u.y = t,
                        m.uniform3f(j.screenPosition, v.x, v.y, v.z),
                        m.uniform2f(j.scale, u.x, u.y),
                        m.uniform1f(j.rotation, D.rotation),
                        m.uniform1f(j.opacity, D.opacity),
                        m.uniform3f(j.color, D.color.r, D.color.g, D.color.b),
                        n.setBlending(D.blending, D.blendEquation, D.blendSrc, D.blendDst),
                        a.setTexture2D(D.texture, 1),
                        m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0))
                    }
                }
            }
            n.enable(m.CULL_FACE),
            n.enable(m.DEPTH_TEST),
            n.setDepthWrite(!0),
            a.resetGLState()
        }
    }
}
,
fm.SpritePlugin = function(a, b) {
    function c() {
        var a = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1])
          , b = new Uint16Array([0, 1, 2, 0, 2, 3]);
        f = l.createBuffer(),
        g = l.createBuffer(),
        l.bindBuffer(l.ARRAY_BUFFER, f),
        l.bufferData(l.ARRAY_BUFFER, a, l.STATIC_DRAW),
        l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, g),
        l.bufferData(l.ELEMENT_ARRAY_BUFFER, b, l.STATIC_DRAW),
        h = d(),
        i = {
            position: l.getAttribLocation(h, "position"),
            uv: l.getAttribLocation(h, "uv")
        },
        j = {
            uvOffset: l.getUniformLocation(h, "uvOffset"),
            uvScale: l.getUniformLocation(h, "uvScale"),
            rotation: l.getUniformLocation(h, "rotation"),
            scale: l.getUniformLocation(h, "scale"),
            color: l.getUniformLocation(h, "color"),
            map: l.getUniformLocation(h, "map"),
            opacity: l.getUniformLocation(h, "opacity"),
            modelViewMatrix: l.getUniformLocation(h, "modelViewMatrix"),
            projectionMatrix: l.getUniformLocation(h, "projectionMatrix"),
            fogType: l.getUniformLocation(h, "fogType"),
            fogDensity: l.getUniformLocation(h, "fogDensity"),
            fogNear: l.getUniformLocation(h, "fogNear"),
            fogFar: l.getUniformLocation(h, "fogFar"),
            fogColor: l.getUniformLocation(h, "fogColor"),
            alphaTest: l.getUniformLocation(h, "alphaTest")
        };
        var c = document.createElement("canvas");
        c.width = 8,
        c.height = 8;
        var e = c.getContext("2d");
        e.fillStyle = "white",
        e.fillRect(0, 0, 8, 8),
        k = new fm.Texture(c),
        k.needsUpdate = !0
    }
    function d() {
        var b = l.createProgram()
          , c = l.createShader(l.VERTEX_SHADER)
          , d = l.createShader(l.FRAGMENT_SHADER);
        return l.shaderSource(c, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")),
        l.shaderSource(d, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")),
        l.compileShader(c),
        l.compileShader(d),
        l.attachShader(b, c),
        l.attachShader(b, d),
        l.linkProgram(b),
        b
    }
    function e(a, b) {
        return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id
    }
    var f, g, h, i, j, k, l = a.context, m = a.state, n = new fm.Vector3, o = new fm.Quaternion, p = new fm.Vector3;
    this.render = function(d, q) {
        if (0 !== b.length) {
            void 0 === h && c(),
            l.useProgram(h),
            m.initAttributes(),
            m.enableAttribute(i.position),
            m.enableAttribute(i.uv),
            m.disableUnusedAttributes(),
            m.disable(l.CULL_FACE),
            m.enable(l.BLEND),
            l.bindBuffer(l.ARRAY_BUFFER, f),
            l.vertexAttribPointer(i.position, 2, l.FLOAT, !1, 16, 0),
            l.vertexAttribPointer(i.uv, 2, l.FLOAT, !1, 16, 8),
            l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, g),
            l.uniformMatrix4fv(j.projectionMatrix, !1, q.projectionMatrix.elements),
            m.activeTexture(l.TEXTURE0),
            l.uniform1i(j.map, 0);
            var r = 0
              , s = 0
              , t = d.fog;
            t ? (l.uniform3f(j.fogColor, t.color.r, t.color.g, t.color.b),
            t instanceof fm.Fog ? (l.uniform1f(j.fogNear, t.near),
            l.uniform1f(j.fogFar, t.far),
            l.uniform1i(j.fogType, 1),
            r = 1,
            s = 1) : t instanceof fm.FogExp2 && (l.uniform1f(j.fogDensity, t.density),
            l.uniform1i(j.fogType, 2),
            r = 2,
            s = 2)) : (l.uniform1i(j.fogType, 0),
            r = 0,
            s = 0);
            for (var u = 0, v = b.length; u < v; u++) {
                var w = b[u];
                w.modelViewMatrix.multiplyMatrices(q.matrixWorldInverse, w.matrixWorld),
                w.z = -w.modelViewMatrix.elements[14]
            }
            b.sort(e);
            for (var x = [], u = 0, v = b.length; u < v; u++) {
                var w = b[u]
                  , y = w.material;
                l.uniform1f(j.alphaTest, y.alphaTest),
                l.uniformMatrix4fv(j.modelViewMatrix, !1, w.modelViewMatrix.elements),
                w.matrixWorld.decompose(n, o, p),
                x[0] = p.x,
                x[1] = p.y;
                var z = 0;
                d.fog && y.fog && (z = s),
                r !== z && (l.uniform1i(j.fogType, z),
                r = z),
                null !== y.map ? (l.uniform2f(j.uvOffset, y.map.offset.x, y.map.offset.y),
                l.uniform2f(j.uvScale, y.map.repeat.x, y.map.repeat.y)) : (l.uniform2f(j.uvOffset, 0, 0),
                l.uniform2f(j.uvScale, 1, 1)),
                l.uniform1f(j.opacity, y.opacity),
                l.uniform3f(j.color, y.color.r, y.color.g, y.color.b),
                l.uniform1f(j.rotation, y.rotation),
                l.uniform2fv(j.scale, x),
                m.setBlending(y.blending, y.blendEquation, y.blendSrc, y.blendDst),
                m.setDepthTest(y.depthTest),
                m.setDepthWrite(y.depthWrite),
                y.map ? a.setTexture2D(y.map, 0) : a.setTexture2D(k, 0),
                l.drawElements(l.TRIANGLES, 6, l.UNSIGNED_SHORT, 0)
            }
            m.enable(l.CULL_FACE),
            a.resetGLState()
        }
    }
}
,
fm.WebGLRenderTarget = function(a, b, c) {
    this.uuid = fm.Math.generateUUID(),
    this.width = a,
    this.height = b,
    this.scissor = new fm.Vector4(0,0,a,b),
    this.scissorTest = !1,
    this.viewport = new fm.Vector4(0,0,a,b),
    c = c || {},
    void 0 === c.minFilter && (c.minFilter = fm.LinearFilter),
    this.texture = new fm.Texture((void 0),(void 0),c.wrapS,c.wrapT,c.magFilter,c.minFilter,c.format,c.type,c.anisotropy,c.encoding),
    this.depthBuffer = void 0 === c.depthBuffer || c.depthBuffer,
    this.stencilBuffer = void 0 === c.stencilBuffer || c.stencilBuffer,
    this.depthTexture = null
}
,
fm.WebGLRenderTarget.prototype = {
    constructor: fm.WebGLRenderTarget,
    setSize: function(a, b) {
        this.width === a && this.height === b || (this.width = a,
        this.height = b,
        this.dispose()),
        this.viewport.set(0, 0, a, b),
        this.scissor.set(0, 0, a, b)
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(a) {
        return this.width = a.width,
        this.height = a.height,
        this.viewport.copy(a.viewport),
        this.texture = a.texture.clone(),
        this.depthBuffer = a.depthBuffer,
        this.stencilBuffer = a.stencilBuffer,
        this.depthTexture = a.depthTexture,
        this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
fm.EventDispatcher.prototype.apply(fm.WebGLRenderTarget.prototype),
fm.WebGLRenderTargetCube = function(a, b, c) {
    fm.WebGLRenderTarget.call(this, a, b, c),
    this.activeCubeFace = 0,
    this.activeMipMapLevel = 0
}
,
fm.WebGLRenderTargetCube.prototype = Object.create(fm.WebGLRenderTarget.prototype),
fm.WebGLRenderTargetCube.prototype.constructor = fm.WebGLRenderTargetCube,
fm.WebGLRenderer = function(a) {
    function b() {
        return null === xa ? Ka : 1
    }
    function c(a, b, c, d) {
        la === !0 && (a *= d,
        b *= d,
        c *= d),
        ib.clearColor(a, b, c, d)
    }
    function d() {
        ib.init(),
        ib.scissor(Ca.copy(La).multiplyScalar(Ka)),
        ib.viewport(Ea.copy(Na).multiplyScalar(Ka)),
        c(Ga.r, Ga.g, Ga.b, Ha)
    }
    function e() {
        wa = null ,
        Ba = null ,
        Aa = "",
        za = -1,
        ib.reset()
    }
    function f(a) {
        a.preventDefault(),
        e(),
        d(),
        jb.clear()
    }
    function g(a) {
        var b = a.target;
        b.removeEventListener("dispose", g),
        j(b),
        ab.textures--
    }
    function h(a) {
        var b = a.target;
        b.removeEventListener("dispose", h),
        k(b),
        ab.textures--
    }
    function i(a) {
        var b = a.target;
        b.removeEventListener("dispose", i),
        l(b)
    }
    function j(a) {
        var b = jb.get(a);
        if (a.image && b.__image__webglTextureCube)
            cb.deleteTexture(b.__image__webglTextureCube);
        else {
            if (void 0 === b.__webglInit)
                return;
            cb.deleteTexture(b.__webglTexture)
        }
        jb["delete"](a)
    }
    function k(a) {
        var b = jb.get(a)
          , c = jb.get(a.texture);
        if (a) {
            if (void 0 !== c.__webglTexture && cb.deleteTexture(c.__webglTexture),
            a.depthTexture && a.depthTexture.dispose(),
            a instanceof fm.WebGLRenderTargetCube)
                for (var d = 0; d < 6; d++)
                    cb.deleteFramebuffer(b.__webglFramebuffer[d]),
                    b.__webglDepthbuffer && cb.deleteRenderbuffer(b.__webglDepthbuffer[d]);
            else
                cb.deleteFramebuffer(b.__webglFramebuffer),
                b.__webglDepthbuffer && cb.deleteRenderbuffer(b.__webglDepthbuffer);
            jb["delete"](a.texture),
            jb["delete"](a)
        }
    }
    function l(a) {
        m(a),
        jb["delete"](a)
    }
    function m(a) {
        var b = jb.get(a).program;
        a.program = void 0,
        void 0 !== b && lb.releaseProgram(b)
    }
    function n(a, b, c, d) {
        var e;
        if (c instanceof fm.InstancedBufferGeometry && (e = gb.get("ANGLE_instanced_arrays"),
        null === e))
            return void console.error("fm.WebGLRenderer.setupVertexAttributes: using fm.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        void 0 === d && (d = 0),
        ib.initAttributes();
        var f = c.attributes
          , g = b.getAttributes()
          , h = a.defaultAttributeValues;
        for (var i in g) {
            var j = g[i];
            if (j >= 0) {
                var k = f[i];
                if (void 0 !== k) {
                    var l = cb.FLOAT
                      , m = k.array
                      , n = k.normalized;
                    m instanceof Float32Array ? l = cb.FLOAT : m instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : m instanceof Uint16Array ? l = cb.UNSIGNED_SHORT : m instanceof Int16Array ? l = cb.SHORT : m instanceof Uint32Array ? l = cb.UNSIGNED_INT : m instanceof Int32Array ? l = cb.INT : m instanceof Int8Array ? l = cb.BYTE : m instanceof Uint8Array && (l = cb.UNSIGNED_BYTE);
                    var o = k.itemSize
                      , p = kb.getAttributeBuffer(k);
                    if (k instanceof fm.InterleavedBufferAttribute) {
                        var q = k.data
                          , r = q.stride
                          , s = k.offset;
                        q instanceof fm.InstancedInterleavedBuffer ? (ib.enableAttributeAndDivisor(j, q.meshPerAttribute, e),
                        void 0 === c.maxInstancedCount && (c.maxInstancedCount = q.meshPerAttribute * q.count)) : ib.enableAttribute(j),
                        cb.bindBuffer(cb.ARRAY_BUFFER, p),
                        cb.vertexAttribPointer(j, o, l, n, r * q.array.BYTES_PER_ELEMENT, (d * r + s) * q.array.BYTES_PER_ELEMENT)
                    } else
                        k instanceof fm.InstancedBufferAttribute ? (ib.enableAttributeAndDivisor(j, k.meshPerAttribute, e),
                        void 0 === c.maxInstancedCount && (c.maxInstancedCount = k.meshPerAttribute * k.count)) : ib.enableAttribute(j),
                        cb.bindBuffer(cb.ARRAY_BUFFER, p),
                        cb.vertexAttribPointer(j, o, l, n, 0, d * o * k.array.BYTES_PER_ELEMENT)
                } else if (void 0 !== h) {
                    var t = h[i];
                    if (void 0 !== t)
                        switch (t.length) {
                        case 2:
                            cb.vertexAttrib2fv(j, t);
                            break;
                        case 3:
                            cb.vertexAttrib3fv(j, t);
                            break;
                        case 4:
                            cb.vertexAttrib4fv(j, t);
                            break;
                        default:
                            cb.vertexAttrib1fv(j, t)
                        }
                }
            }
        }
        ib.disableUnusedAttributes()
    }
    function o(a, b) {
        return Math.abs(b[0]) - Math.abs(a[0])
    }
    function p(a, b) {
        return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
    }
    function q(a, b) {
        return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
    }
    function r(a, b, c, d, e) {
        var f, g;
        c.transparent ? (f = qa,
        g = ++ra) : (f = oa,
        g = ++pa);
        var h = f[g];
        void 0 !== h ? (h.id = a.id,
        h.object = a,
        h.geometry = b,
        h.material = c,
        h.z = $a.z,
        h.group = e) : (h = {
            id: a.id,
            object: a,
            geometry: b,
            material: c,
            z: $a.z,
            group: e
        },
        f.push(h))
    }
    function s(a) {
        var b = a.geometry;
        null === b.boundingSphere && b.computeBoundingSphere();
        var c = Xa.copy(b.boundingSphere).applyMatrix4(a.matrixWorld);
        if (!Oa.intersectsSphere(c))
            return !1;
        if (0 === Sa)
            return !0;
        var d = va.clippingPlanes
          , e = c.center
          , f = -c.radius
          , g = 0;
        do
            if (d[g].distanceToPoint(e) < f)
                return !1;
        while (++g !== Sa);return !0
    }
    function t(a, b) {
        if (a.visible !== !1) {
            if (a.layers.test(b.layers))
                if (a instanceof fm.Light)
                    na.push(a);
                else if (a instanceof fm.Sprite)
                    a.frustumCulled !== !1 && s(a) !== !0 || ta.push(a);
                else if (a instanceof fm.LensFlare)
                    ua.push(a);
                else if (a instanceof fm.ImmediateRenderObject)
                    va.sortObjects === !0 && ($a.setFromMatrixPosition(a.matrixWorld),
                    $a.applyProjection(Za)),
                    r(a, null , a.material, $a.z, null );
                else if ((a instanceof fm.Mesh || a instanceof fm.Line || a instanceof fm.Points) && (a instanceof fm.SkinnedMesh && a.skeleton.update(),
                a.frustumCulled === !1 || s(a) === !0)) {
                    var c = a.material;
                    if (c.visible === !0) {
                        va.sortObjects === !0 && ($a.setFromMatrixPosition(a.matrixWorld),
                        $a.applyProjection(Za));
                        var d = kb.update(a);
                        if (c instanceof fm.MultiMaterial)
                            for (var e = d.groups, f = c.materials, g = 0, h = e.length; g < h; g++) {
                                var i = e[g]
                                  , j = f[i.materialIndex];
                                j.visible === !0 && r(a, d, j, $a.z, i)
                            }
                        else
                            r(a, d, c, $a.z, null )
                    }
                }
            for (var k = a.children, g = 0, h = k.length; g < h; g++)
                t(k[g], b)
        }
    }
    function u(a, b, c, d) {
        for (var e = 0, f = a.length; e < f; e++) {
            var g = a[e]
              , h = g.object
              , i = g.geometry
              , j = void 0 === d ? g.material : d
              , k = g.group;
            if (h.modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, h.matrixWorld),
            h.normalMatrix.getNormalMatrix(h.modelViewMatrix),
            h instanceof fm.ImmediateRenderObject) {
                w(j);
                var l = y(b, c, j, h);
                Aa = "",
                h.render(function(a) {
                    va.renderBufferImmediate(a, l, j)
                })
            } else
                va.renderBufferDirect(b, c, i, j, h, k)
        }
    }
    function v(a, b, c) {
        var d = jb.get(a)
          , e = lb.getParameters(a, _a, b, Sa, c)
          , f = lb.getProgramCode(a, e)
          , g = d.program
          , h = !0;
        if (void 0 === g)
            a.addEventListener("dispose", i);
        else if (g.code !== f)
            m(a);
        else {
            if (void 0 !== e.shaderID)
                return;
            h = !1
        }
        if (h) {
            if (e.shaderID) {
                var j = fm.ShaderLib[e.shaderID];
                d.__webglShader = {
                    name: a.type,
                    uniforms: fm.UniformsUtils.clone(j.uniforms),
                    vertexShader: j.vertexShader,
                    fragmentShader: j.fragmentShader
                }
            } else
                d.__webglShader = {
                    name: a.type,
                    uniforms: a.uniforms,
                    vertexShader: a.vertexShader,
                    fragmentShader: a.fragmentShader
                };
            a.__webglShader = d.__webglShader,
            g = lb.acquireProgram(a, e, f),
            d.program = g,
            a.program = g
        }
        var k = g.getAttributes();
        if (a.morphTargets) {
            a.numSupportedMorphTargets = 0;
            for (var l = 0; l < va.maxMorphTargets; l++)
                k["morphTarget" + l] >= 0 && a.numSupportedMorphTargets++
        }
        if (a.morphNormals) {
            a.numSupportedMorphNormals = 0;
            for (var l = 0; l < va.maxMorphNormals; l++)
                k["morphNormal" + l] >= 0 && a.numSupportedMorphNormals++
        }
        var n = d.__webglShader.uniforms;
        (a instanceof fm.ShaderMaterial || a instanceof fm.RawShaderMaterial) && a.clipping !== !0 || (d.numClippingPlanes = Sa,
        n.clippingPlanes = Ta),
        (a instanceof fm.MeshPhongMaterial || a instanceof fm.MeshLambertMaterial || a instanceof fm.MeshStandardMaterial || a.lights) && (d.lightsHash = _a.hash,
        n.ambientLightColor.value = _a.ambient,
        n.directionalLights.value = _a.directional,
        n.spotLights.value = _a.spot,
        n.pointLights.value = _a.point,
        n.hemisphereLights.value = _a.hemi,
        n.directionalShadowMap.value = _a.directionalShadowMap,
        n.directionalShadowMatrix.value = _a.directionalShadowMatrix,
        n.spotShadowMap.value = _a.spotShadowMap,
        n.spotShadowMatrix.value = _a.spotShadowMatrix,
        n.pointShadowMap.value = _a.pointShadowMap,
        n.pointShadowMatrix.value = _a.pointShadowMatrix);
        var o = d.program.getUniforms()
          , p = fm.WebGLUniforms.seqWithValue(o.seq, n);
        d.uniformsList = p,
        d.dynamicUniforms = fm.WebGLUniforms.splitDynamic(p, n)
    }
    function w(a) {
        x(a),
        a.transparent === !0 ? ib.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha) : ib.setBlending(fm.NoBlending),
        ib.setDepthFunc(a.depthFunc),
        ib.setDepthTest(a.depthTest),
        ib.setDepthWrite(a.depthWrite),
        ib.setColorWrite(a.colorWrite),
        ib.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
    }
    function x(a) {
        a.side !== fm.DoubleSide ? ib.enable(cb.CULL_FACE) : ib.disable(cb.CULL_FACE),
        ib.setFlipSided(a.side === fm.BackSide)
    }
    function y(a, b, c, d) {
        Fa = 0;
        var e = jb.get(c);
        if (Pa) {
            if (Qa || a !== Ba) {
                var f = a === Ba && c.id === za;
                O(c.clippingPlanes, c.clipShadows, a, e, f)
            }
            void 0 !== e.numClippingPlanes && e.numClippingPlanes !== Sa && (c.needsUpdate = !0)
        }
        void 0 === e.program && (c.needsUpdate = !0),
        void 0 !== e.lightsHash && e.lightsHash !== _a.hash && (c.needsUpdate = !0),
        c.needsUpdate && (v(c, b, d),
        c.needsUpdate = !1);
        var g = !1
          , h = !1
          , i = !1
          , j = e.program
          , k = j.getUniforms()
          , l = e.__webglShader.uniforms;
        if (j.id !== wa && (cb.useProgram(j.program),
        wa = j.id,
        g = !0,
        h = !0,
        i = !0),
        c.id !== za && (za = c.id,
        h = !0),
        g || a !== Ba) {
            if (k.set(cb, a, "projectionMatrix"),
            hb.logarithmicDepthBuffer && k.setValue(cb, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)),
            a !== Ba && (Ba = a,
            h = !0,
            i = !0),
            c instanceof fm.ShaderMaterial || c instanceof fm.MeshPhongMaterial || c instanceof fm.MeshStandardMaterial || c.envMap) {
                var m = k.map.cameraPosition;
                void 0 !== m && m.setValue(cb, $a.setFromMatrixPosition(a.matrixWorld))
            }
            (c instanceof fm.MeshPhongMaterial || c instanceof fm.MeshLambertMaterial || c instanceof fm.MeshBasicMaterial || c instanceof fm.MeshStandardMaterial || c instanceof fm.ShaderMaterial || c.skinning) && k.setValue(cb, "viewMatrix", a.matrixWorldInverse),
            k.set(cb, va, "toneMappingExposure"),
            k.set(cb, va, "toneMappingWhitePoint")
        }
        if (c.skinning) {
            k.setOptional(cb, d, "bindMatrix"),
            k.setOptional(cb, d, "bindMatrixInverse");
            var n = d.skeleton;
            n && (hb.floatVertexTextures && n.useVertexTexture ? (k.set(cb, n, "boneTexture"),
            k.set(cb, n, "boneTextureWidth"),
            k.set(cb, n, "boneTextureHeight")) : k.setOptional(cb, n, "boneMatrices"))
        }
        h && ((c instanceof fm.MeshPhongMaterial || c instanceof fm.MeshLambertMaterial || c instanceof fm.MeshStandardMaterial || c.lights) && I(l, i),
        b && c.fog && D(l, b),
        (c instanceof fm.MeshBasicMaterial || c instanceof fm.MeshLambertMaterial || c instanceof fm.MeshPhongMaterial || c instanceof fm.MeshStandardMaterial || c instanceof fm.MeshDepthMaterial) && z(l, c),
        c instanceof fm.LineBasicMaterial ? A(l, c) : c instanceof fm.LineDashedMaterial ? (A(l, c),
        B(l, c)) : c instanceof fm.PointsMaterial ? C(l, c) : c instanceof fm.MeshLambertMaterial ? E(l, c) : c instanceof fm.MeshPhongMaterial ? F(l, c) : c instanceof fm.MeshPhysicalMaterial ? H(l, c) : c instanceof fm.MeshStandardMaterial ? G(l, c) : c instanceof fm.MeshDepthMaterial ? c.displacementMap && (l.displacementMap.value = c.displacementMap,
        l.displacementScale.value = c.displacementScale,
        l.displacementBias.value = c.displacementBias) : c instanceof fm.MeshNormalMaterial && (l.opacity.value = c.opacity),
        fm.WebGLUniforms.upload(cb, e.uniformsList, l, va)),
        k.set(cb, d, "modelViewMatrix"),
        k.set(cb, d, "normalMatrix"),
        k.setValue(cb, "modelMatrix", d.matrixWorld);
        var o = e.dynamicUniforms;
        return null !== o && (fm.WebGLUniforms.evalDynamic(o, l, d, a),
        fm.WebGLUniforms.upload(cb, o, l, va)),
        j
    }
    function z(a, b) {
        a.opacity.value = b.opacity,
        a.diffuse.value = b.color,
        b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),
        a.map.value = b.map,
        a.specularMap.value = b.specularMap,
        a.alphaMap.value = b.alphaMap,
        b.aoMap && (a.aoMap.value = b.aoMap,
        a.aoMapIntensity.value = b.aoMapIntensity);
        var c;
        if (b.map ? c = b.map : b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap),
        void 0 !== c) {
            c instanceof fm.WebGLRenderTarget && (c = c.texture);
            var d = c.offset
              , e = c.repeat;
            a.offsetRepeat.value.set(d.x, d.y, e.x, e.y)
        }
        a.envMap.value = b.envMap,
        a.flipEnvMap.value = b.envMap instanceof fm.WebGLRenderTargetCube ? 1 : -1,
        a.reflectivity.value = b.reflectivity,
        a.refractionRatio.value = b.refractionRatio
    }
    function A(a, b) {
        a.diffuse.value = b.color,
        a.opacity.value = b.opacity
    }
    function B(a, b) {
        a.dashSize.value = b.dashSize,
        a.totalSize.value = b.dashSize + b.gapSize,
        a.scale.value = b.scale
    }
    function C(a, b) {
        if (a.diffuse.value = b.color,
        a.opacity.value = b.opacity,
        a.size.value = b.size * Ka,
        a.scale.value = .5 * fa.clientHeight,
        a.map.value = b.map,
        null !== b.map) {
            var c = b.map.offset
              , d = b.map.repeat;
            a.offsetRepeat.value.set(c.x, c.y, d.x, d.y)
        }
    }
    function D(a, b) {
        a.fogColor.value = b.color,
        b instanceof fm.Fog ? (a.fogNear.value = b.near,
        a.fogFar.value = b.far) : b instanceof fm.FogExp2 && (a.fogDensity.value = b.density)
    }
    function E(a, b) {
        b.lightMap && (a.lightMap.value = b.lightMap,
        a.lightMapIntensity.value = b.lightMapIntensity),
        b.emissiveMap && (a.emissiveMap.value = b.emissiveMap)
    }
    function F(a, b) {
        a.specular.value = b.specular,
        a.shininess.value = Math.max(b.shininess, 1e-4),
        b.lightMap && (a.lightMap.value = b.lightMap,
        a.lightMapIntensity.value = b.lightMapIntensity),
        b.emissiveMap && (a.emissiveMap.value = b.emissiveMap),
        b.bumpMap && (a.bumpMap.value = b.bumpMap,
        a.bumpScale.value = b.bumpScale),
        b.normalMap && (a.normalMap.value = b.normalMap,
        a.normalScale.value.copy(b.normalScale)),
        b.displacementMap && (a.displacementMap.value = b.displacementMap,
        a.displacementScale.value = b.displacementScale,
        a.displacementBias.value = b.displacementBias)
    }
    function G(a, b) {
        a.roughness.value = b.roughness,
        a.metalness.value = b.metalness,
        b.roughnessMap && (a.roughnessMap.value = b.roughnessMap),
        b.metalnessMap && (a.metalnessMap.value = b.metalnessMap),
        b.lightMap && (a.lightMap.value = b.lightMap,
        a.lightMapIntensity.value = b.lightMapIntensity),
        b.emissiveMap && (a.emissiveMap.value = b.emissiveMap),
        b.bumpMap && (a.bumpMap.value = b.bumpMap,
        a.bumpScale.value = b.bumpScale),
        b.normalMap && (a.normalMap.value = b.normalMap,
        a.normalScale.value.copy(b.normalScale)),
        b.displacementMap && (a.displacementMap.value = b.displacementMap,
        a.displacementScale.value = b.displacementScale,
        a.displacementBias.value = b.displacementBias),
        b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
    }
    function H(a, b) {
        G(a, b)
    }
    function I(a, b) {
        a.ambientLightColor.needsUpdate = b,
        a.directionalLights.needsUpdate = b,
        a.pointLights.needsUpdate = b,
        a.spotLights.needsUpdate = b,
        a.hemisphereLights.needsUpdate = b
    }
    function J(a) {
        for (var b = 0, c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            e.castShadow && (_a.shadows[b++] = e)
        }
        _a.shadows.length = b
    }
    function K(a, b) {
        var c, d, e, f, g, h, i = 0, j = 0, k = 0, l = b.matrixWorldInverse, m = 0, n = 0, o = 0, p = 0;
        for (c = 0,
        d = a.length; c < d; c++)
            if (e = a[c],
            f = e.color,
            g = e.intensity,
            h = e.distance,
            e instanceof fm.AmbientLight)
                i += f.r * g,
                j += f.g * g,
                k += f.b * g;
            else if (e instanceof fm.DirectionalLight) {
                var q = mb.get(e);
                q.color.copy(e.color).multiplyScalar(e.intensity),
                q.direction.setFromMatrixPosition(e.matrixWorld),
                $a.setFromMatrixPosition(e.target.matrixWorld),
                q.direction.sub($a),
                q.direction.transformDirection(l),
                q.shadow = e.castShadow,
                e.castShadow && (q.shadowBias = e.shadow.bias,
                q.shadowRadius = e.shadow.radius,
                q.shadowMapSize = e.shadow.mapSize),
                _a.directionalShadowMap[m] = e.shadow.map,
                _a.directionalShadowMatrix[m] = e.shadow.matrix,
                _a.directional[m++] = q
            } else if (e instanceof fm.SpotLight) {
                var q = mb.get(e);
                q.position.setFromMatrixPosition(e.matrixWorld),
                q.position.applyMatrix4(l),
                q.color.copy(f).multiplyScalar(g),
                q.distance = h,
                q.direction.setFromMatrixPosition(e.matrixWorld),
                $a.setFromMatrixPosition(e.target.matrixWorld),
                q.direction.sub($a),
                q.direction.transformDirection(l),
                q.coneCos = Math.cos(e.angle),
                q.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                q.decay = 0 === e.distance ? 0 : e.decay,
                q.shadow = e.castShadow,
                e.castShadow && (q.shadowBias = e.shadow.bias,
                q.shadowRadius = e.shadow.radius,
                q.shadowMapSize = e.shadow.mapSize),
                _a.spotShadowMap[o] = e.shadow.map,
                _a.spotShadowMatrix[o] = e.shadow.matrix,
                _a.spot[o++] = q
            } else if (e instanceof fm.PointLight) {
                var q = mb.get(e);
                q.position.setFromMatrixPosition(e.matrixWorld),
                q.position.applyMatrix4(l),
                q.color.copy(e.color).multiplyScalar(e.intensity),
                q.distance = e.distance,
                q.decay = 0 === e.distance ? 0 : e.decay,
                q.shadow = e.castShadow,
                e.castShadow && (q.shadowBias = e.shadow.bias,
                q.shadowRadius = e.shadow.radius,
                q.shadowMapSize = e.shadow.mapSize),
                _a.pointShadowMap[n] = e.shadow.map,
                void 0 === _a.pointShadowMatrix[n] && (_a.pointShadowMatrix[n] = new fm.Matrix4),
                $a.setFromMatrixPosition(e.matrixWorld).negate(),
                _a.pointShadowMatrix[n].identity().setPosition($a),
                _a.point[n++] = q
            } else if (e instanceof fm.HemisphereLight) {
                var q = mb.get(e);
                q.direction.setFromMatrixPosition(e.matrixWorld),
                q.direction.transformDirection(l),
                q.direction.normalize(),
                q.skyColor.copy(e.color).multiplyScalar(g),
                q.groundColor.copy(e.groundColor).multiplyScalar(g),
                _a.hemi[p++] = q
            }
        _a.ambient[0] = i,
        _a.ambient[1] = j,
        _a.ambient[2] = k,
        _a.directional.length = m,
        _a.spot.length = o,
        _a.point.length = n,
        _a.hemi.length = p,
        _a.hash = m + "," + n + "," + o + "," + p + "," + _a.shadows.length
    }
    function L(a, b) {
        Pa = 0 !== va.clippingPlanes.length || va.localClippingEnabled || 0 !== Va || Qa,
        Qa = va.localClippingEnabled,
        Ua = M(a, b, 0),
        Va = null !== a ? a.length : 0
    }
    function M(a, b, c, d) {
        var e = null !== a ? a.length : 0
          , f = null ;
        if (0 !== e) {
            if (f = Ta.value,
            d !== !0 || null === f) {
                var g = c + 4 * e
                  , h = b.matrixWorldInverse
                  , i = Wa.getNormalMatrix(h);
                (null === f || f.length < g) && (f = new Float32Array(g));
                for (var j = 0, k = c; j !== e; ++j,
                k += 4) {
                    var l = Ya.copy(a[j]).applyMatrix4(h, i);
                    l.normal.toArray(f, k),
                    f[k + 3] = l.constant
                }
            }
            Ta.value = f,
            Ta.needsUpdate = !0
        }
        return Sa = e,
        f
    }
    function N() {
        Ta.value !== Ua && (Ta.value = Ua,
        Ta.needsUpdate = Va > 0),
        Sa = Va
    }
    function O(a, b, c, d, e) {
        if (!Qa || null === a || 0 === a.length || Ra && !b)
            Ra ? M(null ) : N();
        else {
            var f = Ra ? 0 : Va
              , g = 4 * f
              , h = d.clippingState || null ;
            Ta.value = h,
            h = M(a, c, g, e);
            for (var i = 0; i !== g; ++i)
                h[i] = Ua[i];
            d.clippingState = h,
            Sa += f
        }
    }
    function P() {
        var a = Fa;
        return a >= hb.maxTextures && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + hb.maxTextures),
        Fa += 1,
        a
    }
    function Q(a, b, c) {
        var d;
        if (c ? (cb.texParameteri(a, cb.TEXTURE_WRAP_S, ea(b.wrapS)),
        cb.texParameteri(a, cb.TEXTURE_WRAP_T, ea(b.wrapT)),
        cb.texParameteri(a, cb.TEXTURE_MAG_FILTER, ea(b.magFilter)),
        cb.texParameteri(a, cb.TEXTURE_MIN_FILTER, ea(b.minFilter))) : (cb.texParameteri(a, cb.TEXTURE_WRAP_S, cb.CLAMP_TO_EDGE),
        cb.texParameteri(a, cb.TEXTURE_WRAP_T, cb.CLAMP_TO_EDGE),
        b.wrapS === fm.ClampToEdgeWrapping && b.wrapT === fm.ClampToEdgeWrapping || console.warn("fm.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to fm.ClampToEdgeWrapping.", b),
        cb.texParameteri(a, cb.TEXTURE_MAG_FILTER, da(b.magFilter)),
        cb.texParameteri(a, cb.TEXTURE_MIN_FILTER, da(b.minFilter)),
        b.minFilter !== fm.NearestFilter && b.minFilter !== fm.LinearFilter && console.warn("fm.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to fm.NearestFilter or fm.LinearFilter.", b)),
        d = gb.get("EXT_texture_filter_anisotropic")) {
            if (b.type === fm.FloatType && null === gb.get("OES_texture_float_linear"))
                return;
            if (b.type === fm.HalfFloatType && null === gb.get("OES_texture_half_float_linear"))
                return;
            (b.anisotropy > 1 || jb.get(b).__currentAnisotropy) && (cb.texParameterf(a, d.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, va.getMaxAnisotropy())),
            jb.get(b).__currentAnisotropy = b.anisotropy)
        }
    }
    function R(a, b, c) {
        void 0 === a.__webglInit && (a.__webglInit = !0,
        b.addEventListener("dispose", g),
        a.__webglTexture = cb.createTexture(),
        ab.textures++),
        ib.activeTexture(cb.TEXTURE0 + c),
        ib.bindTexture(cb.TEXTURE_2D, a.__webglTexture),
        cb.pixelStorei(cb.UNPACK_FLIP_Y_WEBGL, b.flipY),
        cb.pixelStorei(cb.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha),
        cb.pixelStorei(cb.UNPACK_ALIGNMENT, b.unpackAlignment);
        var d = T(b.image, hb.maxTextureSize);
        V(b) && U(d) === !1 && (d = W(d));
        var e = U(d)
          , f = ea(b.format)
          , h = ea(b.type);
        Q(cb.TEXTURE_2D, b, e);
        var i, j = b.mipmaps;
        if (b instanceof fm.DepthTexture) {
            var k = cb.DEPTH_COMPONENT;
            if (b.type === fm.FloatType) {
                if (!fb)
                    throw new Error("Float Depth Texture only supported in WebGL2.0");
                k = cb.DEPTH_COMPONENT32F
            } else
                fb && (k = cb.DEPTH_COMPONENT16);
            ib.texImage2D(cb.TEXTURE_2D, 0, k, d.width, d.height, 0, f, h, null )
        } else if (b instanceof fm.DataTexture)
            if (j.length > 0 && e) {
                for (var l = 0, m = j.length; l < m; l++)
                    i = j[l],
                    ib.texImage2D(cb.TEXTURE_2D, l, f, i.width, i.height, 0, f, h, i.data);
                b.generateMipmaps = !1
            } else
                ib.texImage2D(cb.TEXTURE_2D, 0, f, d.width, d.height, 0, f, h, d.data);
        else if (b instanceof fm.CompressedTexture)
            for (var l = 0, m = j.length; l < m; l++)
                i = j[l],
                b.format !== fm.RGBAFormat && b.format !== fm.RGBFormat ? ib.getCompressedTextureFormats().indexOf(f) > -1 ? ib.compressedTexImage2D(cb.TEXTURE_2D, l, f, i.width, i.height, 0, i.data) : console.warn("fm.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ib.texImage2D(cb.TEXTURE_2D, l, f, i.width, i.height, 0, f, h, i.data);
        else if (j.length > 0 && e) {
            for (var l = 0, m = j.length; l < m; l++)
                i = j[l],
                ib.texImage2D(cb.TEXTURE_2D, l, f, f, h, i);
            b.generateMipmaps = !1
        } else
            ib.texImage2D(cb.TEXTURE_2D, 0, f, f, h, d);
        b.generateMipmaps && e && cb.generateMipmap(cb.TEXTURE_2D),
        a.__version = b.version,
        b.onUpdate && b.onUpdate(b)
    }
    function S(a, b) {
        a instanceof fm.WebGLRenderTarget && (a = a.texture);
        var c = jb.get(a);
        if (a.version > 0 && c.__version !== a.version) {
            var d = a.image;
            return void 0 === d ? void console.warn("fm.WebGLRenderer: Texture marked for update but image is undefined", a) : d.complete === !1 ? void console.warn("fm.WebGLRenderer: Texture marked for update but image is incomplete", a) : void R(c, a, b)
        }
        ib.activeTexture(cb.TEXTURE0 + b),
        ib.bindTexture(cb.TEXTURE_2D, c.__webglTexture)
    }
    function T(a, b) {
        if (a.width > b || a.height > b) {
            var c = b / Math.max(a.width, a.height)
              , d = document.createElement("canvas");
            d.width = Math.floor(a.width * c),
            d.height = Math.floor(a.height * c);
            var e = d.getContext("2d");
            return e.drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height),
            console.warn("fm.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height, a),
            d
        }
        return a
    }
    function U(a) {
        return fm.Math.isPowerOfTwo(a.width) && fm.Math.isPowerOfTwo(a.height)
    }
    function V(a) {
        return a.wrapS !== fm.ClampToEdgeWrapping || a.wrapT !== fm.ClampToEdgeWrapping || a.minFilter !== fm.NearestFilter && a.minFilter !== fm.LinearFilter
    }
    function W(a) {
        if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) {
            var b = document.createElement("canvas");
            b.width = fm.Math.nearestPowerOfTwo(a.width),
            b.height = fm.Math.nearestPowerOfTwo(a.height);
            var c = b.getContext("2d");
            return c.drawImage(a, 0, 0, b.width, b.height),
            b
        }
        return a
    }
    function X(a, b) {
        var c = jb.get(a);
        if (6 === a.image.length)
            if (a.version > 0 && c.__version !== a.version) {
                c.__image__webglTextureCube || (a.addEventListener("dispose", g),
                c.__image__webglTextureCube = cb.createTexture(),
                ab.textures++),
                ib.activeTexture(cb.TEXTURE0 + b),
                ib.bindTexture(cb.TEXTURE_CUBE_MAP, c.__image__webglTextureCube),
                cb.pixelStorei(cb.UNPACK_FLIP_Y_WEBGL, a.flipY);
                for (var d = a instanceof fm.CompressedTexture, e = a.image[0]instanceof fm.DataTexture, f = [], h = 0; h < 6; h++)
                    !va.autoScaleCubemaps || d || e ? f[h] = e ? a.image[h].image : a.image[h] : f[h] = T(a.image[h], hb.maxCubemapSize);
                var i = f[0]
                  , j = U(i)
                  , k = ea(a.format)
                  , l = ea(a.type);
                Q(cb.TEXTURE_CUBE_MAP, a, j);
                for (var h = 0; h < 6; h++)
                    if (d)
                        for (var m, n = f[h].mipmaps, o = 0, p = n.length; o < p; o++)
                            m = n[o],
                            a.format !== fm.RGBAFormat && a.format !== fm.RGBFormat ? ib.getCompressedTextureFormats().indexOf(k) > -1 ? ib.compressedTexImage2D(cb.TEXTURE_CUBE_MAP_POSITIVE_X + h, o, k, m.width, m.height, 0, m.data) : console.warn("fm.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : ib.texImage2D(cb.TEXTURE_CUBE_MAP_POSITIVE_X + h, o, k, m.width, m.height, 0, k, l, m.data);
                    else
                        e ? ib.texImage2D(cb.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, k, f[h].width, f[h].height, 0, k, l, f[h].data) : ib.texImage2D(cb.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, k, k, l, f[h]);
                a.generateMipmaps && j && cb.generateMipmap(cb.TEXTURE_CUBE_MAP),
                c.__version = a.version,
                a.onUpdate && a.onUpdate(a)
            } else
                ib.activeTexture(cb.TEXTURE0 + b),
                ib.bindTexture(cb.TEXTURE_CUBE_MAP, c.__image__webglTextureCube)
    }
    function Y(a, b) {
        ib.activeTexture(cb.TEXTURE0 + b),
        ib.bindTexture(cb.TEXTURE_CUBE_MAP, jb.get(a).__webglTexture)
    }
    function Z(a, b, c, d) {
        var e = ea(b.texture.format)
          , f = ea(b.texture.type);
        ib.texImage2D(d, 0, e, b.width, b.height, 0, e, f, null ),
        cb.bindFramebuffer(cb.FRAMEBUFFER, a),
        cb.framebufferTexture2D(cb.FRAMEBUFFER, c, d, jb.get(b.texture).__webglTexture, 0),
        cb.bindFramebuffer(cb.FRAMEBUFFER, null )
    }
    function $(a, b) {
        cb.bindRenderbuffer(cb.RENDERBUFFER, a),
        b.depthBuffer && !b.stencilBuffer ? (cb.renderbufferStorage(cb.RENDERBUFFER, cb.DEPTH_COMPONENT16, b.width, b.height),
        cb.framebufferRenderbuffer(cb.FRAMEBUFFER, cb.DEPTH_ATTACHMENT, cb.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (cb.renderbufferStorage(cb.RENDERBUFFER, cb.DEPTH_STENCIL, b.width, b.height),
        cb.framebufferRenderbuffer(cb.FRAMEBUFFER, cb.DEPTH_STENCIL_ATTACHMENT, cb.RENDERBUFFER, a)) : cb.renderbufferStorage(cb.RENDERBUFFER, cb.RGBA4, b.width, b.height),
        cb.bindRenderbuffer(cb.RENDERBUFFER, null )
    }
    function _(a, b) {
        var c = b instanceof fm.WebGLRenderTargetCube;
        if (c)
            throw new Error("Depth Texture with cube render targets is not supported!");
        if (cb.bindFramebuffer(cb.FRAMEBUFFER, a),
        !(b.depthTexture instanceof fm.DepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of fm.DepthTexture");
        jb.get(b.depthTexture).__webglTexture && b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width,
        b.depthTexture.image.height = b.height,
        b.depthTexture.needsUpdate = !0),
        va.setTexture(b.depthTexture, 0);
        var d = jb.get(b.depthTexture).__webglTexture;
        cb.framebufferTexture2D(cb.FRAMEBUFFER, cb.DEPTH_ATTACHMENT, cb.TEXTURE_2D, d, 0)
    }
    function aa(a) {
        var b = jb.get(a)
          , c = a instanceof fm.WebGLRenderTargetCube;
        if (a.depthTexture) {
            if (c)
                throw new Error("target.depthTexture not supported in Cube render targets");
            _(b.__webglFramebuffer, a)
        } else if (c) {
            b.__webglDepthbuffer = [];
            for (var d = 0; d < 6; d++)
                cb.bindFramebuffer(cb.FRAMEBUFFER, b.__webglFramebuffer[d]),
                b.__webglDepthbuffer[d] = cb.createRenderbuffer(),
                $(b.__webglDepthbuffer[d], a)
        } else
            cb.bindFramebuffer(cb.FRAMEBUFFER, b.__webglFramebuffer),
            b.__webglDepthbuffer = cb.createRenderbuffer(),
            $(b.__webglDepthbuffer, a);
        cb.bindFramebuffer(cb.FRAMEBUFFER, null )
    }
    function ba(a) {
        var b = jb.get(a)
          , c = jb.get(a.texture);
        a.addEventListener("dispose", h),
        c.__webglTexture = cb.createTexture(),
        ab.textures++;
        var d = a instanceof fm.WebGLRenderTargetCube
          , e = fm.Math.isPowerOfTwo(a.width) && fm.Math.isPowerOfTwo(a.height);
        if (d) {
            b.__webglFramebuffer = [];
            for (var f = 0; f < 6; f++)
                b.__webglFramebuffer[f] = cb.createFramebuffer()
        } else
            b.__webglFramebuffer = cb.createFramebuffer();
        if (d) {
            ib.bindTexture(cb.TEXTURE_CUBE_MAP, c.__webglTexture),
            Q(cb.TEXTURE_CUBE_MAP, a.texture, e);
            for (var f = 0; f < 6; f++)
                Z(b.__webglFramebuffer[f], a, cb.COLOR_ATTACHMENT0, cb.TEXTURE_CUBE_MAP_POSITIVE_X + f);
            a.texture.generateMipmaps && e && cb.generateMipmap(cb.TEXTURE_CUBE_MAP),
            ib.bindTexture(cb.TEXTURE_CUBE_MAP, null )
        } else
            ib.bindTexture(cb.TEXTURE_2D, c.__webglTexture),
            Q(cb.TEXTURE_2D, a.texture, e),
            Z(b.__webglFramebuffer, a, cb.COLOR_ATTACHMENT0, cb.TEXTURE_2D),
            a.texture.generateMipmaps && e && cb.generateMipmap(cb.TEXTURE_2D),
            ib.bindTexture(cb.TEXTURE_2D, null );
        a.depthBuffer && aa(a)
    }
    function ca(a) {
        var b = a instanceof fm.WebGLRenderTargetCube ? cb.TEXTURE_CUBE_MAP : cb.TEXTURE_2D
          , c = jb.get(a.texture).__webglTexture;
        ib.bindTexture(b, c),
        cb.generateMipmap(b),
        ib.bindTexture(b, null )
    }
    function da(a) {
        return a === fm.NearestFilter || a === fm.NearestMipMapNearestFilter || a === fm.NearestMipMapLinearFilter ? cb.NEAREST : cb.LINEAR
    }
    function ea(a) {
        var b;
        if (a === fm.RepeatWrapping)
            return cb.REPEAT;
        if (a === fm.ClampToEdgeWrapping)
            return cb.CLAMP_TO_EDGE;
        if (a === fm.MirroredRepeatWrapping)
            return cb.MIRRORED_REPEAT;
        if (a === fm.NearestFilter)
            return cb.NEAREST;
        if (a === fm.NearestMipMapNearestFilter)
            return cb.NEAREST_MIPMAP_NEAREST;
        if (a === fm.NearestMipMapLinearFilter)
            return cb.NEAREST_MIPMAP_LINEAR;
        if (a === fm.LinearFilter)
            return cb.LINEAR;
        if (a === fm.LinearMipMapNearestFilter)
            return cb.LINEAR_MIPMAP_NEAREST;
        if (a === fm.LinearMipMapLinearFilter)
            return cb.LINEAR_MIPMAP_LINEAR;
        if (a === fm.UnsignedByteType)
            return cb.UNSIGNED_BYTE;
        if (a === fm.UnsignedShort4444Type)
            return cb.UNSIGNED_SHORT_4_4_4_4;
        if (a === fm.UnsignedShort5551Type)
            return cb.UNSIGNED_SHORT_5_5_5_1;
        if (a === fm.UnsignedShort565Type)
            return cb.UNSIGNED_SHORT_5_6_5;
        if (a === fm.ByteType)
            return cb.BYTE;
        if (a === fm.ShortType)
            return cb.SHORT;
        if (a === fm.UnsignedShortType)
            return cb.UNSIGNED_SHORT;
        if (a === fm.IntType)
            return cb.INT;
        if (a === fm.UnsignedIntType)
            return cb.UNSIGNED_INT;
        if (a === fm.FloatType)
            return cb.FLOAT;
        if (b = gb.get("OES_texture_half_float"),
        null !== b && a === fm.HalfFloatType)
            return b.HALF_FLOAT_OES;
        if (a === fm.AlphaFormat)
            return cb.ALPHA;
        if (a === fm.RGBFormat)
            return cb.RGB;
        if (a === fm.RGBAFormat)
            return cb.RGBA;
        if (a === fm.LuminanceFormat)
            return cb.LUMINANCE;
        if (a === fm.LuminanceAlphaFormat)
            return cb.LUMINANCE_ALPHA;
        if (a === fm.DepthFormat)
            return cb.DEPTH_COMPONENT;
        if (a === fm.AddEquation)
            return cb.FUNC_ADD;
        if (a === fm.SubtractEquation)
            return cb.FUNC_SUBTRACT;
        if (a === fm.ReverseSubtractEquation)
            return cb.FUNC_REVERSE_SUBTRACT;
        if (a === fm.ZeroFactor)
            return cb.ZERO;
        if (a === fm.OneFactor)
            return cb.ONE;
        if (a === fm.SrcColorFactor)
            return cb.SRC_COLOR;
        if (a === fm.OneMinusSrcColorFactor)
            return cb.ONE_MINUS_SRC_COLOR;
        if (a === fm.SrcAlphaFactor)
            return cb.SRC_ALPHA;
        if (a === fm.OneMinusSrcAlphaFactor)
            return cb.ONE_MINUS_SRC_ALPHA;
        if (a === fm.DstAlphaFactor)
            return cb.DST_ALPHA;
        if (a === fm.OneMinusDstAlphaFactor)
            return cb.ONE_MINUS_DST_ALPHA;
        if (a === fm.DstColorFactor)
            return cb.DST_COLOR;
        if (a === fm.OneMinusDstColorFactor)
            return cb.ONE_MINUS_DST_COLOR;
        if (a === fm.SrcAlphaSaturateFactor)
            return cb.SRC_ALPHA_SATURATE;
        if (b = gb.get("WEBGL_compressed_texture_s3tc"),
        null !== b) {
            if (a === fm.RGB_S3TC_DXT1_Format)
                return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (a === fm.RGBA_S3TC_DXT1_Format)
                return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (a === fm.RGBA_S3TC_DXT3_Format)
                return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (a === fm.RGBA_S3TC_DXT5_Format)
                return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
        if (b = gb.get("WEBGL_compressed_texture_pvrtc"),
        null !== b) {
            if (a === fm.RGB_PVRTC_4BPPV1_Format)
                return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (a === fm.RGB_PVRTC_2BPPV1_Format)
                return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (a === fm.RGBA_PVRTC_4BPPV1_Format)
                return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (a === fm.RGBA_PVRTC_2BPPV1_Format)
                return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        }
        if (b = gb.get("WEBGL_compressed_texture_etc1"),
        null !== b && a === fm.RGB_ETC1_Format)
            return b.COMPRESSED_RGB_ETC1_WEBGL;
        if (b = gb.get("EXT_blend_minmax"),
        null !== b) {
            if (a === fm.MinEquation)
                return b.MIN_EXT;
            if (a === fm.MaxEquation)
                return b.MAX_EXT
        }
        return 0
    }
    a = a || {};
    var fa = void 0 !== a.canvas ? a.canvas : document.createElement("canvas")
      , ga = void 0 !== a.context ? a.context : null
      , ha = void 0 !== a.alpha && a.alpha
      , ia = void 0 === a.depth || a.depth
      , ja = void 0 === a.stencil || a.stencil
      , ka = void 0 !== a.antialias && a.antialias
      , la = void 0 === a.premultipliedAlpha || a.premultipliedAlpha
      , ma = void 0 !== a.preserveDrawingBuffer && a.preserveDrawingBuffer
      , na = []
      , oa = []
      , pa = -1
      , qa = []
      , ra = -1
      , sa = new Float32Array(8)
      , ta = []
      , ua = [];
    this.domElement = fa,
    this.context = null ,
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.gammaFactor = 2,
    this.gammaInput = !1,
    this.gammaOutput = !1,
    this.physicallyCorrectLights = !1,
    this.toneMapping = fm.LinearToneMapping,
    this.toneMappingExposure = 1,
    this.toneMappingWhitePoint = 1,
    this.maxMorphTargets = 8,
    this.maxMorphNormals = 4,
    this.autoScaleCubemaps = !0;
    var va = this
      , wa = null
      , xa = null
      , ya = null
      , za = -1
      , Aa = ""
      , Ba = null
      , Ca = new fm.Vector4
      , Da = null
      , Ea = new fm.Vector4
      , Fa = 0
      , Ga = new fm.Color(0)
      , Ha = 0
      , Ia = fa.width
      , Ja = fa.height
      , Ka = 1
      , La = new fm.Vector4(0,0,Ia,Ja)
      , Ma = !1
      , Na = new fm.Vector4(0,0,Ia,Ja)
      , Oa = new fm.Frustum
      , Pa = !1
      , Qa = !1
      , Ra = !1
      , Sa = 0
      , Ta = {
        type: "4fv",
        value: null ,
        needsUpdate: !1
    }
      , Ua = null
      , Va = 0
      , Wa = new fm.Matrix3
      , Xa = new fm.Sphere
      , Ya = new fm.Plane
      , Za = new fm.Matrix4
      , $a = new fm.Vector3
      , _a = {
        hash: "",
        ambient: [0, 0, 0],
        directional: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        point: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        shadows: []
    }
      , ab = {
        geometries: 0,
        textures: 0
    }
      , bb = {
        calls: 0,
        vertices: 0,
        faces: 0,
        points: 0
    };
    this.info = {
        render: bb,
        memory: ab,
        programs: null
    };
    var cb;
    try {
        var db = {
            alpha: ha,
            depth: ia,
            stencil: ja,
            antialias: ka,
            premultipliedAlpha: la,
            preserveDrawingBuffer: ma
        };
        if (cb = ga || fa.getContext("webgl", db) || fa.getContext("experimental-webgl", db),
        null === cb)
            throw null !== fa.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
        void 0 === cb.getShaderPrecisionFormat && (cb.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        ),
        fa.addEventListener("webglcontextlost", f, !1)
    } catch (eb) {
        console.error("fm.WebGLRenderer: " + eb)
    }
    var fb = "undefined" != typeof WebGL2RenderingContext && cb instanceof WebGL2RenderingContext
      , gb = new fm.WebGLExtensions(cb);
    gb.get("WEBGL_depth_texture"),
    gb.get("OES_texture_float"),
    gb.get("OES_texture_float_linear"),
    gb.get("OES_texture_half_float"),
    gb.get("OES_texture_half_float_linear"),
    gb.get("OES_standard_derivatives"),
    gb.get("ANGLE_instanced_arrays"),
    gb.get("OES_element_index_uint") && (fm.BufferGeometry.MaxIndex = 4294967296);
    var hb = new fm.WebGLCapabilities(cb,gb,a)
      , ib = new fm.WebGLState(cb,gb,ea)
      , jb = new fm.WebGLProperties
      , kb = new fm.WebGLObjects(cb,jb,this.info)
      , lb = new fm.WebGLPrograms(this,hb)
      , mb = new fm.WebGLLights;
    this.info.programs = lb.programs;
    var nb = new fm.WebGLBufferRenderer(cb,gb,bb)
      , ob = new fm.WebGLIndexedBufferRenderer(cb,gb,bb);
    d(),
    this.context = cb,
    this.capabilities = hb,
    this.extensions = gb,
    this.properties = jb,
    this.state = ib;
    var pb = new fm.WebGLShadowMap(this,_a,kb);
    this.shadowMap = pb;
    var qb = new fm.SpritePlugin(this,ta)
      , rb = new fm.LensFlarePlugin(this,ua);
    this.getContext = function() {
        return cb
    }
    ,
    this.getContextAttributes = function() {
        return cb.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        gb.get("WEBGL_lose_context").loseContext()
    }
    ,
    this.getMaxAnisotropy = function() {
        var a;
        return function() {
            if (void 0 !== a)
                return a;
            var b = gb.get("EXT_texture_filter_anisotropic");
            return a = null !== b ? cb.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
        }
    }(),
    this.getPrecision = function() {
        return hb.precision
    }
    ,
    this.getPixelRatio = function() {
        return Ka
    }
    ,
    this.setPixelRatio = function(a) {
        void 0 !== a && (Ka = a,
        this.setSize(Na.z, Na.w, !1))
    }
    ,
    this.getSize = function() {
        return {
            width: Ia,
            height: Ja
        }
    }
    ,
    this.setSize = function(a, b, c) {
        Ia = a,
        Ja = b,
        fa.width = a * Ka,
        fa.height = b * Ka,
        c !== !1 && (fa.style.width = a + "px",
        fa.style.height = b + "px"),
        this.setViewport(0, 0, a, b)
    }
    ,
    this.setViewport = function(a, b, c, d) {
        ib.viewport(Na.set(a, b, c, d))
    }
    ,
    this.setScissor = function(a, b, c, d) {
        ib.scissor(La.set(a, b, c, d))
    }
    ,
    this.setScissorTest = function(a) {
        ib.setScissorTest(Ma = a)
    }
    ,
    this.getClearColor = function() {
        return Ga
    }
    ,
    this.setClearColor = function(a, b) {
        Ga.set(a),
        Ha = void 0 !== b ? b : 1,
        c(Ga.r, Ga.g, Ga.b, Ha)
    }
    ,
    this.getClearAlpha = function() {
        return Ha
    }
    ,
    this.setClearAlpha = function(a) {
        Ha = a,
        c(Ga.r, Ga.g, Ga.b, Ha)
    }
    ,
    this.clear = function(a, b, c) {
        var d = 0;
        (void 0 === a || a) && (d |= cb.COLOR_BUFFER_BIT),
        (void 0 === b || b) && (d |= cb.DEPTH_BUFFER_BIT),
        (void 0 === c || c) && (d |= cb.STENCIL_BUFFER_BIT),
        cb.clear(d)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.clearTarget = function(a, b, c, d) {
        this.setRenderTarget(a),
        this.clear(b, c, d)
    }
    ,
    this.resetGLState = e,
    this.dispose = function() {
        fa.removeEventListener("webglcontextlost", f, !1)
    }
    ,
    this.renderBufferImmediate = function(a, b, c) {
        ib.initAttributes();
        var d = jb.get(a);
        a.hasPositions && !d.position && (d.position = cb.createBuffer()),
        a.hasNormals && !d.normal && (d.normal = cb.createBuffer()),
        a.hasUvs && !d.uv && (d.uv = cb.createBuffer()),
        a.hasColors && !d.color && (d.color = cb.createBuffer());
        var e = b.getAttributes();
        if (a.hasPositions && (cb.bindBuffer(cb.ARRAY_BUFFER, d.position),
        cb.bufferData(cb.ARRAY_BUFFER, a.positionArray, cb.DYNAMIC_DRAW),
        ib.enableAttribute(e.position),
        cb.vertexAttribPointer(e.position, 3, cb.FLOAT, !1, 0, 0)),
        a.hasNormals) {
            if (cb.bindBuffer(cb.ARRAY_BUFFER, d.normal),
            "MeshPhongMaterial" !== c.type && "MeshStandardMaterial" !== c.type && "MeshPhysicalMaterial" !== c.type && c.shading === fm.FlatShading)
                for (var f = 0, g = 3 * a.count; f < g; f += 9) {
                    var h = a.normalArray
                      , i = (h[f + 0] + h[f + 3] + h[f + 6]) / 3
                      , j = (h[f + 1] + h[f + 4] + h[f + 7]) / 3
                      , k = (h[f + 2] + h[f + 5] + h[f + 8]) / 3;
                    h[f + 0] = i,
                    h[f + 1] = j,
                    h[f + 2] = k,
                    h[f + 3] = i,
                    h[f + 4] = j,
                    h[f + 5] = k,
                    h[f + 6] = i,
                    h[f + 7] = j,
                    h[f + 8] = k
                }
            cb.bufferData(cb.ARRAY_BUFFER, a.normalArray, cb.DYNAMIC_DRAW),
            ib.enableAttribute(e.normal),
            cb.vertexAttribPointer(e.normal, 3, cb.FLOAT, !1, 0, 0)
        }
        a.hasUvs && c.map && (cb.bindBuffer(cb.ARRAY_BUFFER, d.uv),
        cb.bufferData(cb.ARRAY_BUFFER, a.uvArray, cb.DYNAMIC_DRAW),
        ib.enableAttribute(e.uv),
        cb.vertexAttribPointer(e.uv, 2, cb.FLOAT, !1, 0, 0)),
        a.hasColors && c.vertexColors !== fm.NoColors && (cb.bindBuffer(cb.ARRAY_BUFFER, d.color),
        cb.bufferData(cb.ARRAY_BUFFER, a.colorArray, cb.DYNAMIC_DRAW),
        ib.enableAttribute(e.color),
        cb.vertexAttribPointer(e.color, 3, cb.FLOAT, !1, 0, 0)),
        ib.disableUnusedAttributes(),
        cb.drawArrays(cb.TRIANGLES, 0, a.count),
        a.count = 0
    }
    ,
    this.renderBufferDirect = function(a, c, d, e, f, g) {
        w(e);
        var h = y(a, c, e, f)
          , i = !1
          , j = d.id + "_" + h.id + "_" + e.wireframe;
        j !== Aa && (Aa = j,
        i = !0);
        var k = f.morphTargetInfluences;
        if (void 0 !== k) {
            for (var l = [], m = 0, p = k.length; m < p; m++) {
                var q = k[m];
                l.push([q, m])
            }
            l.sort(o),
            l.length > 8 && (l.length = 8);
            for (var r = d.morphAttributes, m = 0, p = l.length; m < p; m++) {
                var q = l[m];
                if (sa[m] = q[0],
                0 !== q[0]) {
                    var s = q[1];
                    e.morphTargets === !0 && r.position && d.addAttribute("morphTarget" + m, r.position[s]),
                    e.morphNormals === !0 && r.normal && d.addAttribute("morphNormal" + m, r.normal[s])
                } else
                    e.morphTargets === !0 && d.removeAttribute("morphTarget" + m),
                    e.morphNormals === !0 && d.removeAttribute("morphNormal" + m)
            }
            h.getUniforms().setValue(cb, "morphTargetInfluences", sa),
            i = !0
        }
        var s = d.index
          , t = d.attributes.position;
        e.wireframe === !0 && (s = kb.getWireframeAttribute(d));
        var u;
        null !== s ? (u = ob,
        u.setIndex(s)) : u = nb,
        i && (n(e, h, d),
        null !== s && cb.bindBuffer(cb.ELEMENT_ARRAY_BUFFER, kb.getAttributeBuffer(s)));
        var v = 0
          , x = 1 / 0;
        null !== s ? x = s.count : void 0 !== t && (x = t.count);
        var z = d.drawRange.start
          , A = d.drawRange.count
          , B = null !== g ? g.start : 0
          , C = null !== g ? g.count : 1 / 0
          , D = Math.max(v, z, B)
          , E = Math.min(v + x, z + A, B + C) - 1
          , F = Math.max(0, E - D + 1);
        if (f instanceof fm.Mesh)
            if (e.wireframe === !0)
                ib.setLineWidth(e.wireframeLinewidth * b()),
                u.setMode(cb.LINES);
            else
                switch (f.drawMode) {
                case fm.TrianglesDrawMode:
                    u.setMode(cb.TRIANGLES);
                    break;
                case fm.TriangleStripDrawMode:
                    u.setMode(cb.TRIANGLE_STRIP);
                    break;
                case fm.TriangleFanDrawMode:
                    u.setMode(cb.TRIANGLE_FAN)
                }
        else if (f instanceof fm.Line) {
            var G = e.linewidth;
            void 0 === G && (G = 1),
            ib.setLineWidth(G * b()),
            f instanceof fm.LineSegments ? u.setMode(cb.LINES) : u.setMode(cb.LINE_STRIP)
        } else
            f instanceof fm.Points && u.setMode(cb.POINTS);
        d instanceof fm.InstancedBufferGeometry ? d.maxInstancedCount > 0 && u.renderInstances(d, D, F) : u.render(D, F)
    }
    ,
    this.render = function(a, b, c, d) {
        if (b instanceof fm.Camera == !1)
            return void console.error("fm.WebGLRenderer.render: camera is not an instance of fm.Camera.");
        var e = a.fog;
        if (Aa = "",
        za = -1,
        Ba = null ,
        a.autoUpdate === !0 && a.updateMatrixWorld(),
        null === b.parent && b.updateMatrixWorld(),
        b.matrixWorldInverse.getInverse(b.matrixWorld),
        Za.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse),
        Oa.setFromMatrix(Za),
        na.length = 0,
        pa = -1,
        ra = -1,
        ta.length = 0,
        ua.length = 0,
        L(this.clippingPlanes, b),
        t(a, b),
        oa.length = pa + 1,
        qa.length = ra + 1,
        va.sortObjects === !0 && (oa.sort(p),
        qa.sort(q)),
        Pa && (Ra = !0,
        M(null )),
        J(na),
        pb.render(a, b),
        K(na, b),
        Pa && (Ra = !1,
        N()),
        bb.calls = 0,
        bb.vertices = 0,
        bb.faces = 0,
        bb.points = 0,
        void 0 === c && (c = null ),
        this.setRenderTarget(c),
        (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil),
        a.overrideMaterial) {
            var f = a.overrideMaterial;
            u(oa, b, e, f),
            u(qa, b, e, f)
        } else
            ib.setBlending(fm.NoBlending),
            u(oa, b, e),
            u(qa, b, e);
        if (qb.render(a, b),
        rb.render(a, b, Ea),
        c) {
            var g = c.texture;
            g.generateMipmaps && U(c) && g.minFilter !== fm.NearestFilter && g.minFilter !== fm.LinearFilter && ca(c)
        }
        ib.setDepthTest(!0),
        ib.setDepthWrite(!0),
        ib.setColorWrite(!0)
    }
    ,
    this.setFaceCulling = function(a, b) {
        a === fm.CullFaceNone ? ib.disable(cb.CULL_FACE) : (b === fm.FrontFaceDirectionCW ? cb.frontFace(cb.CW) : cb.frontFace(cb.CCW),
        a === fm.CullFaceBack ? cb.cullFace(cb.BACK) : a === fm.CullFaceFront ? cb.cullFace(cb.FRONT) : cb.cullFace(cb.FRONT_AND_BACK),
        ib.enable(cb.CULL_FACE))
    }
    ;
    var sb = !1;
    this.setTexture = function(a, b) {
        sb || (console.warn("fm.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
        sb = !0),
        S(a, b)
    }
    ,
    this.allocTextureUnit = P,
    this.setTexture2D = S,
    this.setTextureCube = function(a, b) {
        a instanceof fm.CubeTexture || Array.isArray(a.image) && 6 === a.image.length ? X(a, b) : Y(a.texture, b)
    }
    ,
    this.getCurrentRenderTarget = function() {
        return xa
    }
    ,
    this.setRenderTarget = function(a) {
        xa = a,
        a && void 0 === jb.get(a).__webglFramebuffer && ba(a);
        var b, c = a instanceof fm.WebGLRenderTargetCube;
        if (a) {
            var d = jb.get(a);
            b = c ? d.__webglFramebuffer[a.activeCubeFace] : d.__webglFramebuffer,
            Ca.copy(a.scissor),
            Da = a.scissorTest,
            Ea.copy(a.viewport)
        } else
            b = null ,
            Ca.copy(La).multiplyScalar(Ka),
            Da = Ma,
            Ea.copy(Na).multiplyScalar(Ka);
        if (ya !== b && (cb.bindFramebuffer(cb.FRAMEBUFFER, b),
        ya = b),
        ib.scissor(Ca),
        ib.setScissorTest(Da),
        ib.viewport(Ea),
        c) {
            var e = jb.get(a.texture);
            cb.framebufferTexture2D(cb.FRAMEBUFFER, cb.COLOR_ATTACHMENT0, cb.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, e.__webglTexture, a.activeMipMapLevel)
        }
    }
    ,
    this.readRenderTargetPixels = function(a, b, c, d, e, f) {
        if (a instanceof fm.WebGLRenderTarget == !1)
            return void console.error("fm.WebGLRenderer.readRenderTargetPixels: renderTarget is not fm.WebGLRenderTarget.");
        var g = jb.get(a).__webglFramebuffer;
        if (g) {
            var h = !1;
            g !== ya && (cb.bindFramebuffer(cb.FRAMEBUFFER, g),
            h = !0);
            try {
                var i = a.texture;
                if (i.format !== fm.RGBAFormat && ea(i.format) !== cb.getParameter(cb.IMPLEMENTATION_COLOR_READ_FORMAT))
                    return void console.error("fm.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                if (!(i.type === fm.UnsignedByteType || ea(i.type) === cb.getParameter(cb.IMPLEMENTATION_COLOR_READ_TYPE) || i.type === fm.FloatType && gb.get("WEBGL_color_buffer_float") || i.type === fm.HalfFloatType && gb.get("EXT_color_buffer_half_float")))
                    return void console.error("fm.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                cb.checkFramebufferStatus(cb.FRAMEBUFFER) === cb.FRAMEBUFFER_COMPLETE ? b > 0 && b <= a.width - d && c > 0 && c <= a.height - e && cb.readPixels(b, c, d, e, ea(i.format), ea(i.type), f) : console.error("fm.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
            } finally {
                h && cb.bindFramebuffer(cb.FRAMEBUFFER, ya)
            }
        }
    }
}
,
function() {
    function a(a, b) {
        this.object = a,
        this.map = b,
        this.target = new fm.Vector3,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -(1 / 0),
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .25,
        this.validRange_;
        var c = this
          , d = 1e-6;
        this.EPS = d;
        var e, f, g = 0, h = 0, i = 1, j = new fm.Vector3, k = !1;
        this.getPolarAngle = function() {
            return f
        }
        ,
        this.getAzimuthalAngle = function() {
            return e
        }
        ,
        this.rotateLeft = function(a) {
            h -= a
        }
        ,
        this.rotateUp = function(a) {
            g -= a
        }
        ,
        this.panLeft = function() {
            var a = new fm.Vector3;
            return function(b) {
                var c = this.object.matrix.elements;
                a.set(c[0], c[1], c[2]),
                a.multiplyScalar(-b),
                j.add(a)
            }
        }(),
        this.panUp = function() {
            var a = new fm.Vector3;
            return function(b) {
                var c = this.object.matrix.elements;
                a.set(c[4], 0, c[6]),
                a.normalize(),
                a.multiplyScalar(b),
                j.add(a)
            }
        }(),
        this.pan = function(a, b, d, e) {
            if (c.object instanceof fm.PerspectiveCamera) {
                var f = c.object.position
                  , g = f.clone().sub(c.target)
                  , h = g.length();
                h *= Math.tan(c.object.fov / 2 * Math.PI / 180),
                c.panLeft(2 * a * h / e),
                c.panUp(2 * b * h / e)
            } else
                c.object instanceof fm.OrthographicCamera ? (c.panLeft(a * (c.object.right - c.object.left) / d / c.object.zoom),
                c.panUp(b * (c.object.top - c.object.bottom) / e / c.object.zoom)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.")
        }
        ,
        this.dollyIn = function(a) {
            if (c.object instanceof fm.PerspectiveCamera)
                i /= a;
            else if (c.object instanceof fm.OrthographicCamera) {
                var b = this.object.zoom * a
                  , d = c.map.mapView.cameraTop.top
                  , e = d / b;
                e < c.orthoLimitSize.max && (c.object.zoom = b,
                c.object.updateProjectionMatrix(),
                k = !0)
            } else
                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
        }
        ,
        this.dollyOut = function(a) {
            if (c.object instanceof fm.PerspectiveCamera)
                i *= a;
            else if (c.object instanceof fm.OrthographicCamera) {
                var b = this.object.zoom / a
                  , d = c.map.mapView.cameraTop.top
                  , e = d / b;
                e > c.orthoLimitSize.min && (c.object.zoom = b,
                c.object.updateProjectionMatrix(),
                k = !0)
            } else
                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
        }
        ,
        this.initDistance_ = null ,
        this.initScaleLevel = function() {
            return this.initDistance_ || (c.initDistance_ = c.map.mapView.camera.position.clone().sub(c.target).length()),
            c.initDistance_
        }
        ,
        this.setScaleLevelValue = function(a) {
            var b = c.map.mapView.camera
              , d = (c.map.mapView.cameraTop,
            b.position.clone().sub(c.target).normalize());
            d.multiplyScalar(this.initDistance_ * a);
            var e = c.target.clone().add(d);
            if (c.object instanceof fm.PerspectiveCamera)
                b.position.copy(e);
            else if (c.object instanceof fm.OrthographicCamera) {
                var f = e.distanceTo(c.target)
                  , g = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(b, c, f)
                  , h = c.object.top / g.top;
                c.object.zoom = h,
                c.object.updateProjectionMatrix()
            }
        }
        ;
        var l, m, n, o, p, q = !0;
        this.begin_ = function(a) {
            q = !1,
            m = l * a.distance,
            p = c.object.zoom * (1 / a.distance),
            n = f + a.phi,
            o = e + a.theta
        }
        ,
        this.move_ = function(a, b, d) {
            if (l = m / a.distance,
            c.object instanceof fm.OrthographicCamera) {
                var g = p / (1 / a.distance)
                  , h = c.map.mapView.cameraTop.top
                  , i = h / g;
                i > c.orthoLimitSize.min && i < c.orthoLimitSize.max && (c.object.zoom = g,
                c.object.updateProjectionMatrix(),
                k = !0)
            }
            b && (f = n - a.phi);
            d && (e = o - a.theta)
        }
        ,
        this.end_ = function() {
            q = !0
        }
        ;
        var r = 0;
        this.pushPhi_ = function() {
            r = f,
            f = 0
        }
        ,
        this.popPhi_ = function() {
            return f = r
        }
        ,
        this.update = function(b) {
            var m = new fm.Vector3
              , n = (new fm.Quaternion).setFromUnitVectors(a.up, new fm.Vector3(0,1,0))
              , o = n.clone().inverse()
              , p = new fm.Vector3
              , r = new fm.Quaternion;
            return function(a) {
                var b = this.object.position;
                m.copy(b).sub(this.target),
                m.applyQuaternion(n),
                q && (e = Math.atan2(m.x, m.z),
                f = Math.atan2(Math.sqrt(m.x * m.x + m.z * m.z), m.y),
                e += h,
                f += g),
                e = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, e)),
                a && (a.hasOwnProperty("forcePhi") && (f = a.forcePhi,
                g = 0),
                a.hasOwnProperty("forceTheta") && (e = a.forceTheta,
                h = 0)),
                f = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, f)),
                f = Math.max(d, Math.min(Math.PI - d, f)),
                q && (l = m.length() * i),
                l = Math.max(this.minDistance, Math.min(this.maxDistance, l));
                var s = this.target.clone()
                  , t = this.map.mapView.camera.position.clone();
                q && (t.add(j),
                s.add(j),
                i = 1,
                j.set(0, 0, 0)),
                m.x = l * Math.sin(f) * Math.sin(e),
                m.y = l * Math.cos(f),
                m.z = l * Math.sin(f) * Math.cos(e),
                m.applyQuaternion(o);
                var u = m.add(s);
                return (void 0 === this.validRange_ || this.validRange_(u, s.clone())) && (c.object instanceof fm.OrthographicCamera ? (b.copy(u),
                this.target.copy(s),
                this.map.mapView.camera.position.copy(t),
                this.object.up = new fm.Vector3(Math.sin(e),0,Math.cos(e)),
                this.object.lookAt(this.target)) : (b.copy(u),
                this.target.copy(s),
                this.object.lookAt(this.target))),
                this.enableDamping === !0 ? (h *= 1 - this.dampingFactor,
                g *= 1 - this.dampingFactor) : (h = 0,
                g = 0),
                !!(k || p.distanceToSquared(this.object.position) > d || 8 * (1 - r.dot(this.object.quaternion)) > d) && (p.copy(this.object.position),
                r.copy(this.object.quaternion),
                k = !1,
                !0)
            }
        }()
    }
    fm.OrbitControls = function(b, c, d) {
        function e(a, b) {
            var c = s.domElement === document ? s.domElement.body : s.domElement;
            r.pan(a, b, c.clientWidth, c.clientHeight)
        }
        function f() {
            return 2 * Math.PI / 60 / 60 * s.autoRotateSpeed
        }
        function g(a) {
            return void 0 === a ? Math.pow(.95, s.zoomSpeed) : Math.pow(.95, s.zoomSpeed * a)
        }
        function h(a) {
            if (s.enabled !== !1) {
                if (a.preventDefault(),
                a.button === s.mouseButtons.ORBIT) {
                    if (s.enableRotate === !1)
                        return;
                    D = C.ROTATE,
                    t.set(a.clientX, a.clientY)
                } else if (a.button === s.mouseButtons.ZOOM) {
                    if (s.enableZoom === !1)
                        return;
                    D = C.DOLLY,
                    z.set(a.clientX, a.clientY)
                } else if (a.button === s.mouseButtons.PAN) {
                    if (s.enablePan === !1)
                        return;
                    D = C.PAN,
                    w.set(a.clientX, a.clientY)
                }
                D !== C.NONE && (document.addEventListener("mousemove", i, !1),
                document.addEventListener("mouseup", j, !1),
                s.dispatchEvent(F))
            }
        }
        function i(a) {
            if (s.enabled !== !1) {
                a.preventDefault();
                var b = s.domElement === document ? s.domElement.body : s.domElement;
                if (D === C.ROTATE) {
                    if (s.enableRotate === !1)
                        return;
                    u.set(a.clientX, a.clientY),
                    v.subVectors(u, t),
                    s.enableGestureRotate && r.rotateLeft(2 * Math.PI * v.x / b.clientWidth * s.rotateSpeed),
                    s.enableGestureIncline && r.rotateUp(2 * Math.PI * v.y / b.clientHeight * s.rotateSpeed),
                    t.copy(u)
                } else if (D === C.DOLLY) {
                    if (s.enableZoom === !1)
                        return;
                    A.set(a.clientX, a.clientY),
                    B.subVectors(A, z),
                    B.y > 0 ? r.dollyIn(g()) : B.y < 0 && r.dollyOut(g()),
                    z.copy(A)
                } else if (D === C.PAN) {
                    if (s.enablePan === !1)
                        return;
                    x.set(a.clientX, a.clientY),
                    y.subVectors(x, w),
                    e(y.x, y.y),
                    w.copy(x)
                }
                D !== C.NONE && s.update()
            }
        }
        function j() {
            s.enabled !== !1 && (document.removeEventListener("mousemove", i, !1),
            document.removeEventListener("mouseup", j, !1),
            s.dispatchEvent(G),
            D = C.NONE)
        }
        function k(a) {
            if (s.enabled !== !1 && s.enableZoom !== !1 && D === C.NONE) {
                a.preventDefault(),
                a.stopPropagation();
                var b = 0;
                void 0 !== a.wheelDelta ? b = a.wheelDelta : void 0 !== a.detail && (b = -a.detail),
                b > 0 ? r.dollyOut(g()) : b < 0 && r.dollyIn(g()),
                s.update(),
                s.dispatchEvent(F),
                s.dispatchEvent(G)
            }
        }
        function l(a) {
            if (s.enabled !== !1 && s.enableKeys !== !1 && s.enablePan !== !1)
                switch (a.keyCode) {
                case s.keys.UP:
                    e(0, s.keyPanSpeed),
                    s.update();
                    break;
                case s.keys.BOTTOM:
                    e(0, -s.keyPanSpeed),
                    s.update();
                    break;
                case s.keys.LEFT:
                    e(s.keyPanSpeed, 0),
                    s.update();
                    break;
                case s.keys.RIGHT:
                    e(-s.keyPanSpeed, 0),
                    s.update()
                }
        }
        function m(a) {
            if (s.enabled !== !1) {
                switch (a.touches.length) {
                case 1:
                    if (s.enablePan === !1)
                        return;
                    D = C.TOUCH_PAN,
                    w.set(a.touches[0].pageX, a.touches[0].pageY);
                    break;
                case 2:
                    if (s.enableZoom === !1 && s.enableRotate === !1)
                        return;
                    D = C.TOUCH_ROTATE_DOLLY;
                    var b = s.domElement === document ? s.domElement.body : s.domElement;
                    r.begin_(p(a.touches, b.clientWidth, b.clientHeight));
                    break;
                default:
                    D = C.NONE
                }
                D !== C.NONE && s.dispatchEvent(F)
            }
        }
        function n(a) {
            if (s.enabled !== !1) {
                a.preventDefault(),
                a.stopPropagation();
                var b = s.domElement === document ? s.domElement.body : s.domElement;
                switch (a.touches.length) {
                case 1:
                    if (s.enablePan === !1)
                        return;
                    if (D !== C.TOUCH_PAN)
                        return;
                    x.set(a.touches[0].pageX, a.touches[0].pageY),
                    y.subVectors(x, w),
                    e(y.x, y.y),
                    w.copy(x),
                    s.update();
                    break;
                case 2:
                    if (s.enableZoom === !1 && s.enableRotate === !1)
                        return;
                    if (D !== C.TOUCH_ROTATE_DOLLY)
                        return;
                    r.move_(p(a.touches, b.clientWidth, b.clientHeight), s.enableGestureIncline, s.enableGestureRotate),
                    s.update();
                    break;
                default:
                    D = C.NONE
                }
            }
        }
        function o() {
            s.enabled !== !1 && (s.dispatchEvent(G),
            D = C.NONE,
            r.end_())
        }
        function p(a, b, c) {
            var d = {}
              , e = new fm.Vector2(a[0].pageX,a[0].pageY)
              , f = new fm.Vector2(a[1].pageX,a[1].pageY)
              , g = f.clone().sub(e);
            d.distance = g.length(),
            d.phi = Math.PI * (e.y + f.y) / 2 / c;
            var h = new fm.Vector2(1,0)
              , i = g.x * h.y
              , j = h.x * g.y;
            return d.theta = Math.sign(i - j) * Math.acos(h.dot(g) / g.length()),
            d
        }
        function q(a) {
            a.preventDefault()
        }
        var r = new a(b,d);
        this.domElement = void 0 !== c ? c : document,
        this.map = d,
        this.constraint = r,
        this.getPolarAngle = function() {
            return r.getPolarAngle()
        }
        ,
        this.getAzimuthalAngle = function() {
            return r.getAzimuthalAngle()
        }
        ,
        this.enabled = !0,
        this.center = this.target,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enableGestureRotate = !0,
        this.enableGestureIncline = !0,
        this.enablePan = !0,
        this.keyPanSpeed = 7,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.enableKeys = !0,
        this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40
        },
        this.mouseButtons = {
            PAN: fm.MOUSE.LEFT,
            ZOOM: fm.MOUSE.MIDDLE,
            ORBIT: fm.MOUSE.RIGHT
        };
        var s = this
          , t = new fm.Vector2
          , u = new fm.Vector2
          , v = new fm.Vector2
          , w = (new fm.Vector2,
        new fm.Vector2,
        new fm.Vector2)
          , x = new fm.Vector2
          , y = new fm.Vector2
          , z = new fm.Vector2
          , A = new fm.Vector2
          , B = new fm.Vector2
          , C = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_DOLLY: 4,
            TOUCH_PAN: 5
        };
        C.TOUCH_ROTATE_DOLLY = 34;
        var D = C.NONE;
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom;
        var E = {
            type: "change"
        }
          , F = {
            type: "start"
        }
          , G = {
            type: "end"
        };
        this.update = function(a) {
            this.autoRotate && D === C.NONE && r.rotateLeft(f()),
            r.update(a) === !0 && (a && a.notChangeCompass || this.dispatchEvent(E))
        }
        ,
        this.initScaleLevel = function(a, b) {
            var c = this
              , d = r.initScaleLevel();
            c.minDistance = d * a,
            c.maxDistance = d * b;
            var e = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(c.map.mapView.camera, c, c.minDistance)
              , f = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(c.map.mapView.camera, c, c.maxDistance);
            r.orthoLimitSize = {
                min: e.top,
                max: f.top
            }
        }
        ,
        this.setScaleLevelValue = function(a) {
            r.setScaleLevelValue(a),
            this.update()
        }
        ,
        this.reset = function() {
            D = C.NONE,
            this.target.copy(this.target0),
            this.object.position.copy(this.position0),
            this.object.zoom = this.zoom0,
            this.object.updateProjectionMatrix(),
            this.dispatchEvent(E),
            this.update()
        }
        ,
        this.zoomIn_ = function() {
            r.dollyOut(g()),
            s.update()
        }
        ,
        this.zoomOut_ = function() {
            r.dollyIn(g()),
            s.update()
        }
        ,
        this.setValidRange_ = function(a) {
            r.validRange_ = a
        }
        ,
        this.dispose = function() {
            this.domElement.removeEventListener("contextmenu", q, !1),
            this.domElement.removeEventListener("mousedown", h, !1),
            this.domElement.removeEventListener("mousewheel", k, !1),
            this.domElement.removeEventListener("MozMousePixelScroll", k, !1),
            this.domElement.removeEventListener("touchstart", m, !1),
            this.domElement.removeEventListener("touchend", o, !1),
            this.domElement.removeEventListener("touchmove", n, !1),
            document.removeEventListener("mousemove", i, !1),
            document.removeEventListener("mouseup", j, !1),
            window.removeEventListener("keydown", l, !1)
        }
        ,
        this.domElement.addEventListener("contextmenu", q, !1),
        this.domElement.addEventListener("mousedown", h, !1),
        this.domElement.addEventListener("mousewheel", k, !1),
        this.domElement.addEventListener("MozMousePixelScroll", k, !1),
        this.domElement.addEventListener("touchstart", m, !1),
        this.domElement.addEventListener("touchend", o, !1),
        this.domElement.addEventListener("touchmove", n, !1),
        window.addEventListener("keydown", l, !1),
        this.update()
    }
    ,
    fm.OrbitControls.prototype = Object.create(fm.EventDispatcher.prototype),
    fm.OrbitControls.prototype.constructor = fm.OrbitControls,
    Object.defineProperties(fm.OrbitControls.prototype, {
        object: {
            get: function() {
                return this.constraint.object
            }
        },
        target: {
            get: function() {
                return this.constraint.target
            },
            set: function(a) {
                console.warn("fm.OrbitControls: target is now immutable. Use target.set() instead."),
                this.constraint.target.copy(a)
            }
        },
        minDistance: {
            get: function() {
                return this.constraint.minDistance
            },
            set: function(a) {
                this.constraint.minDistance = a
            }
        },
        maxDistance: {
            get: function() {
                return this.constraint.maxDistance
            },
            set: function(a) {
                this.constraint.maxDistance = a
            }
        },
        minZoom: {
            get: function() {
                return this.constraint.minZoom
            },
            set: function(a) {
                this.constraint.minZoom = a
            }
        },
        maxZoom: {
            get: function() {
                return this.constraint.maxZoom
            },
            set: function(a) {
                this.constraint.maxZoom = a
            }
        },
        minPolarAngle: {
            get: function() {
                return this.constraint.minPolarAngle
            },
            set: function(a) {
                this.constraint.minPolarAngle = a
            }
        },
        maxPolarAngle: {
            get: function() {
                return this.constraint.maxPolarAngle
            },
            set: function(a) {
                this.constraint.maxPolarAngle = a
            }
        },
        minAzimuthAngle: {
            get: function() {
                return this.constraint.minAzimuthAngle
            },
            set: function(a) {
                this.constraint.minAzimuthAngle = a
            }
        },
        maxAzimuthAngle: {
            get: function() {
                return this.constraint.maxAzimuthAngle
            },
            set: function(a) {
                this.constraint.maxAzimuthAngle = a
            }
        },
        enableDamping: {
            get: function() {
                return this.constraint.enableDamping
            },
            set: function(a) {
                this.constraint.enableDamping = a
            }
        },
        dampingFactor: {
            get: function() {
                return this.constraint.dampingFactor
            },
            set: function(a) {
                this.constraint.dampingFactor = a
            }
        },
        noZoom: {
            get: function() {
                return console.warn("fm.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
                !this.enableZoom
            },
            set: function(a) {
                console.warn("fm.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
                this.enableZoom = !a
            }
        },
        noRotate: {
            get: function() {
                return console.warn("fm.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
                !this.enableRotate
            },
            set: function(a) {
                console.warn("fm.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
                this.enableRotate = !a
            }
        },
        noPan: {
            get: function() {
                return console.warn("fm.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),
                !this.enablePan
            },
            set: function(a) {
                console.warn("fm.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),
                this.enablePan = !a
            }
        },
        noKeys: {
            get: function() {
                return console.warn("fm.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
                !this.enableKeys
            },
            set: function(a) {
                console.warn("fm.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
                this.enableKeys = !a
            }
        },
        staticMoving: {
            get: function() {
                return console.warn("fm.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
                !this.constraint.enableDamping
            },
            set: function(a) {
                console.warn("fm.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
                this.constraint.enableDamping = !a
            }
        },
        dynamicDampingFactor: {
            get: function() {
                return console.warn("fm.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
                this.constraint.dampingFactor
            },
            set: function(a) {
                console.warn("fm.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
                this.constraint.dampingFactor = a
            }
        }
    })
}(),
fm.Tween = {},
fm.Tween.easeInOutQuad = function(a) {
    a /= .5;
    var b = 0
      , c = 1;
    return a < 1 ? c / 2 * a * a + b : (a--,
    -c / 2 * (a * (a - 2) - 1) + b)
}
,
fm.Tween.easeInQuad = function(a) {
    var b = 0
      , c = 1;
    return c * a * a + b
}
,
fm.Tween.easeOutQuad = function(a) {
    var b = 0
      , c = 1;
    return -c * a * (a - 2) + b
}
,
fm.Tween.linear = function(a) {
    return a
}
,
fm.Tween.easeOutBack = function(a) {
    var b = a - 1;
    return b * b * (2.70158 * b + 1.70158) + 1
}
,
fm.Tween.kill = function(a) {
    clearInterval(a)
}
,
fm.Tween.fadeTo = function(a, b, c, d, e) {
    return null == c && (c = fm.Tween.easeOutQuad),
    function(a, b, c, d, e) {
        var f, g = 0, h = 0, i = lastTime = 0;
        return 0 == a ? (b(1),
        void 0 != e && e(1),
        void 0 != d && d()) : (lastTime = Date.now(),
        h = setInterval(function() {
            i = Date.now(),
            g += (i - lastTime) / 1e3,
            lastTime = i,
            g >= a && (g = a),
            f = g / a;
            var j = c(f);
            b(j),
            void 0 != e && e(j),
            1 == f && (clearInterval(h),
            null != d && d())
        }, 1)),
        h
    }(a, b, c, d, e)
}
,
fm.Tween.action = function(a, b, c, d, e, f) {
    var g = [];
    for (var h in c)
        g.push({
            prop: h,
            old: a[h],
            delta: c[h] - a[h]
        });
    var i = fm.Tween.fadeTo(b, function(b) {
        for (var c = 0; c < g.length; c++)
            a[g[c].prop] = g[c].old + b * g[c].delta
    }, d, e, f);
    return i
}
,
fm.Tween.actionArray = function(a, b, c, d, e, f) {
    var g = [];
    for (var h in c)
        for (var i in a)
            g.push({
                obj: i,
                prop: h,
                old: i[h],
                delta: c[h] - i[h]
            });
    var j = fm.Tween.fadeTo(b, function(a) {
        for (var b = 0; b < g.length; b++) {
            var c = g[b];
            c.obj[c.prop] = c.old + a * c.delta
        }
    }, d, e, f);
    return j
}
,
fm.Tween.actionArrayProps = function(a, b, c, d, e, f) {
    var g = [];
    for (var h in a) {
        var i = [];
        for (var j in c[h])
            i.push({
                prop: j,
                old: a[h][j],
                delta: c[h][j] - a[h][j]
            });
        g.push(i)
    }
    var k = fm.Tween.fadeTo(b, function(b) {
        for (var c in a)
            for (var d in g[c])
                a[c][g[c][d].prop] = g[c][d].old + b * g[c][d].delta
    }, d, e, f);
    return k
}
,
fm.Tween.transformTo = function(a, b, c, d, e, f) {
    d = d || fm.Tween.easeOutQuad;
    var g = new THREE.Quaternion
      , h = a.quaternion.clone()
      , i = b.quaternion;
    c = c || 1,
    fm.Tween.actionArrayProps([a.position], c, [{
        x: b.position.x,
        y: b.position.y,
        z: b.position.z
    }], d, function() {
        e && e()
    }, function(b) {
        THREE.Quaternion.slerp(h, i, g, b),
        a.quaternion.set(g.x, g.y, g.z, g.w),
        f && f(b)
    })
}
,
fengmap.MapLoading = function() {}
,
fengmap.MapLoading.prototype = {
    show: function(a) {
        var b = document.getElementById("fm-mapLoading");
        if (null == b) {
            var b = document.createElement("div");
            b.setAttribute("id", "fm-mapLoading"),
            b.style.zIndex = 100,
            b.style.position = "fixed",
            b.style.top = "50%",
            b.style.left = "50%",
            document.body.appendChild(b)
        }
        b.innerHTML = "...",
        a != document.body && (a.style.display = "none")
    },
    showLoadError: function(a) {
        var b = document.getElementById("fm-mapLoading");
        if (null == b) {
            var b = document.createElement("div");
            b.innerHTML = "",
            b.setAttribute("id", "fm-mapLoading"),
            b.style.zIndex = 100,
            b.style.position = "fixed",
            b.style.top = "50%",
            b.style.left = "50%",
            document.body.appendChild(b)
        } else
            b.innerHTML = ""
    },
    hide: function(a, b) {
        a != document.body && (a.style.display = "block");
        var c = document.getElementById("fm-mapLoading");
        document.body.removeChild(c)
    }
},
fengmap.MapError = function() {}
,
fengmap.MapError.prototype = {
    noWebGL: function(a) {
        var b = document.createElement("div");
        b.innerHTML = "<h5>WebGL!<h5><h5> &nbsp;</h5>",
        b.setAttribute("class", "noWebGL"),
        a.appendChild(b)
    }
},
window.onerror = function(a) {
    fengmap.FMMap = function(a) {
        var b;
        b = a && a.container ? a.container : document.body;
        var c = new fengmap.MapError;
        c.noWebGL(b)
    }
    ,
    window.onerror = null
}
,
console.log("FengMap Version:", fengmap.VERSION),
fengmap.Map = function(a) {
    if (this.options = new fengmap.MapOptions(a),
    fm.Evento.convert(this),
    this.mapView = new fengmap.MapView(this),
    this.mapView.init()) {
        this.controls = new fm.OrbitControls(this.mapView.camera,this.mapView.canvas_,this),
        this.controls.minPolarAngle = 0,
        this.controls.maxPolarAngle = Math.PI / 3,
        this.mapPicker = new fengmap.MapPicker,
        this.mapPickHighLight = !0,
        this.mapTheme = new fengmap.MapTheme(this.options),
        this.mapScene = new fengmap.MapScene(this,this.mapTheme),
        this.mapService = new fengmap.MapService(this),
        this.zonTempObj = new fengmap.MapService.fmbanana((!0),this.mapView.sceneOrtho,this.options),
        this.compass_ = new fengmap.MapCompass((!1),this.mapView.sceneOrtho,this.options),
        this.controls.addEventListener("change", this.controlsChange_.bind(this)),
        this.viewMode_ = "3d",
        this.currentCamera_ = this.mapView.camera,
        this.fullSceen_ = !1,
        this.requireUpdateCollide_ = !1,
        this.location_ = {
            sceneId: 0,
            groupId: 0,
            x: 0,
            y: 0
        },
        this.focusGroupId_ = -1,
        this.groupCenter_;
        this.controls.setValidRange_(this.validRange_.bind(this)),
        this.scaleLevels_ = [.5, 1, 2],
        this.scaleLevel_ = 1,
        this.groupIDs_ = [],
        this.timer = new fm.Clock,
        this.updates = [],
        this.mapAtlas = new fengmap.FMAtlas,
        this.visibleGroupIDs_ = [],
        fengmap.Map.instance || (fengmap.Map.instance = this,
        fengmap.Map.layerAlias = {
            extent: fengmap.FMExtentLayer,
            model: fengmap.FMModelLayer,
            label: fengmap.FMLabelLayer,
            facility: fengmap.FMFacilityLayer,
            line: fengmap.FMLineLayer,
            locationMarker: fengmap.FMLocationMarkerLayer,
            text: fengmap.FMTextLayer,
            textMarker: fengmap.FMTextMarkerLayer,
            imageMarker: fengmap.FMImageMarkerLayer
        }),
        this.updateSize(null , null , !0),
        this.update_(!0)
    }
}
,
fengmap.Map.tempFlipX_ = !0,
fengmap.Map.prototype = {
    openMap: function(a) {
        this.__isNewScene = this.sceneId_ != a,
        this.sceneId_ = a,
        this.mapView.scene.remove(this.mapScene.getO3dScene()),
        this.mapScene.clear();
        var b = this;
        fengmap.Map.IsThemeLoading || (fengmap.Map.IsThemeLoading = !0,
        this.prepare_(function() {
            fengmap.Map.IsThemeLoading = !1,
            fengmap.Map.IsMapLoading || (fengmap.Map.IsMapLoading = !0,
            b.openMap_(a))
        }))
    },
    queryModelInfo: function(a, b, c, d) {
        this.mapService.queryModelInfo(a, b, c, d)
    },
    queryModelCenterById: function(a, b, c, d) {
        this.mapService.queryModelCenterById(a, b, c, d)
    },
    set lineStyle(a) {
        a.hasOwnProperty("color") && (this.mapTheme.navigateStyle_.color = a.color),
        a.hasOwnProperty("lineWidth") && (this.mapTheme.navigateStyle_.lineWidth = a.lineWidth),
        a.hasOwnProperty("alpha") && (this.mapTheme.navigateStyle_.alpha = a.alpha),
        a.hasOwnProperty("alpha") && (this.mapTheme.navigateStyle_.alpha = a.alpha),
        a.hasOwnProperty("dash") && a.dash.hasOwnProperty("size") && (this.mapTheme.navigateStyle_.dash.size = a.dash.size),
        a.hasOwnProperty("dash") && a.dash.hasOwnProperty("gap") && (this.mapTheme.navigateStyle_.dash.gap = a.dash.gap)
    },
    get lineStyle() {
        return this.mapTheme.navigateStyle_
    },
    get minX() {
        return this.mapScene.minX_
    },
    get maxX() {
        return this.mapScene.maxX_
    },
    get minY() {
        return this.mapScene.minY_
    },
    get maxY() {
        return this.mapScene.maxY_
    },
    navigateTo: function(a) {
        this.navigateFromTo(this.location, a)
    },
    navigateFromTo: function(a, b) {
        var c = this;
        this.mapService.queryNavigation(a, b, function(a) {
            c.mapScene.drawNavigation(a)
        })
    },
    clearNavigation: function() {
        this.mapScene.clearNavigation()
    },
    drawLineMark: function(a) {
        this.mapScene.drawLineMark(a)
    },
    clearLineMark: function(a) {
        this.mapScene.clearLineMark(a)
    },
    get scaleLevel() {
        return this.scaleLevel_
    },
    set scaleLevel(a) {
        this.scaleLevel_ = Math.ceil(a),
        this.controls.setScaleLevelValue(this.scaleLevels_[this.scaleLevel_])
    },
    get minScaleLevel() {
        return this.minScaleLevel_
    },
    set minScaleLevel(a) {
        this.setScaleLevelLimit(a, this.maxScaleLevel_)
    },
    get maxScaleLevel() {
        return this.maxScaleLevel_
    },
    set maxScaleLevel(a) {
        this.setScaleLevelLimit(this.minScaleLevel_, a)
    },
    setScaleLevelLimit: function(a, b) {
        var c = this;
        a = fm.Math.clamp(a, 0, c.scaleLevels_.length - 1),
        b = fm.Math.clamp(b, 0, c.scaleLevels_.length - 1),
        c.minScaleLevel_ = a,
        c.maxScaleLevel_ = b,
        c.controls.initScaleLevel(c.scaleLevels_[a], c.scaleLevels_[b]),
        c.scaleLevel = c.scaleLevels_[Math.ceil((a + b) / 2)]
    },
    scaleLevelIn: function() {
        this.scaleLevel_ > 0 && (this.scaleLevel = this.scaleLevel_ - 1)
    },
    scaleLevelOut: function() {
        this.scaleLevel_ < this.maxScaleLevel - 1 && (this.scaleLevel = this.scaleLevel_ + 1)
    },
    zoomIn: function() {
        this.controls.zoomIn_()
    },
    zoomOut: function() {
        this.controls.zoomOut_()
    },
    __lastPhi: 0,
    set viewMode(a) {
        function b(b) {
            var c = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(g, b.controls);
            h.zoom = 1,
            h.left = -c.right,
            h.right = c.right,
            h.top = c.top,
            h.bottom = -c.top,
            h.updateProjectionMatrix(),
            a && (b.viewMode_ = a)
        }
        function c(b) {
            var c = h.zoom
              , d = b.controls.target.distanceTo(g.position)
              , e = g.position.clone().sub(b.controls.target).normalize();
            g.position.copy(b.controls.target.clone().add(e.multiplyScalar(d / c))),
            g.updateProjectionMatrix(),
            b.viewMode_ = a;
        }
        var d = null
          , e = null ;
        if ("object" == typeof a && (d = a.time,
        e = a.callback,
        a = a.mode),
        a != this.viewMode_) {
            var f = this
              , g = this.mapView.camera
              , h = this.mapView.cameraTop;
            "3d" == this.viewMode_ ? (__lastPhi = f.controls.constraint.getPolarAngle(),
            fm.Tween.fadeTo(void 0 != d ? d : f.options.viewModeAnimateMode ? f.options.viewModeAnimateTime : 0, function(a) {
                f.controls.constraint.update({
                    forcePhi: __lastPhi - __lastPhi * a
                }),
                f.requireUpdateCollide_ = !0
            }, null , function() {
                f.controls.constraint.object = f.mapView.cameraTop,
                f.controls.minPolarAngle = 0,
                f.controls.maxPolarAngle = 0,
                f.currentCamera_ = f.mapView.cameraTop,
                f.controls.update({
                    forceTheta: f.controls.constraint.getAzimuthalAngle() + Math.PI,
                    notChangeCompass: !0
                }),
                b(f),
                e && e(f.viewMode_)
            })) : (f.controls.constraint.object = f.mapView.camera,
            f.controls.minPolarAngle = 0,
            f.controls.maxPolarAngle = Math.PI / 3,
            f.currentCamera_ = f.mapView.camera,
            f.controls.update({
                forceTheta: f.controls.constraint.getAzimuthalAngle() + Math.PI,
                notChangeCompass: !0
            }),
            fm.Tween.fadeTo(void 0 != d ? d : f.options.viewModeAnimateMode ? f.options.viewModeAnimateTime : 0, function(a) {
                f.controls.constraint.update({
                    forcePhi: __lastPhi * a
                }),
                f.requireUpdateCollide_ = !0
            }, null , function() {
                e && e(f.viewMode_)
            }),
            c(f)),
            this.updateCountDown_ = 0
        }
    },
    get viewMode() {
        return this.viewMode_
    },
    set themeName(a) {
        var b = this;
        if (a != this.mapTheme.themeName_) {
            if (b.mapTheme.themeName_ = a,
            !b.sceneId_)
                return;
            b.mapService.queryThemeV2(a, function(a) {
                b.mapTheme.data = a,
                b.backgroundColor = b.mapTheme.clearColor_,
                b.mapAtlas.clear();
                var c = b.mapTheme.type2theme_;
                b.mapScene.o3dScene_.traverse(function(a) {
                    if (a.fm_) {
                        var d = c[a.fm_.typeID];
                        switch (a.fm_.nodeType) {
                        case fengmap.FMNodeType.LINE:
                            if (!d)
                                return;
                            a.material.color = new fm.Color(d.strokeColor_),
                            a.material.linewidth = d.strokeWidth;
                            break;
                        case fengmap.FMNodeType.FLOOR:
                            a.material.color = new fm.Color(b.mapTheme.floorColor_),
                            a.material.opacity = b.mapTheme.floorOpacity_;
                            break;
                        case fengmap.FMNodeType.MODEL:
                            if (!d)
                                return;
                            var e = d.color;
                            "string" == typeof e && (e = fengmap.MapUtil.toColor(d.color)),
                            a.material.color = new fm.Color(e),
                            a.material.opacity = d.alpha || 1;
                            break;
                        case fengmap.FMNodeType.FACILITY:
                            if (!d)
                                return;
                            a.material.map = d.material_.map,
                            a.material.opacity = d.alpha || 1;
                            break;
                        case fengmap.FMNodeType.LABEL:
                            a.updateStyle(b.mapTheme.labelStyle_);
                            break;
                        case fengmap.FMNodeType.TEXT_MARKER:
                            a.updateStyle(a.fm_.style_)
                        }
                    }
                }),
                b.focusGroupID = b.focusGroupId_
            })
        }
    },
    get themeName() {
        return this.mapTheme.themeName_
    },
    get listGroups() {
        return this.mapScene.scene_.scene_data.layerGroups
    },
    set focusGroupID(a) {
        var b = null ;
        "object" == typeof a && (b = a,
        a = a.gid),
        this.focusGroup_(a, b)
    },
    setFocusGroup: function(a, b) {
        this.focusGroup_(a, b)
    },
    get focusGroupID() {
        return this.focusGroupId_
    },
    set visibleGroupIDs(a) {
        if (a.length > 0) {
            this.visibleGroupIDs_ = a,
            (this.options.isSeparate || this.options.isDecodeByVisible) && this.loadGroups(a);
            for (var b in this.mapScene.o3dGroups_) {
                var c = this.mapScene.o3dGroups_[b];
                c.visible = a.indexOf(c.meta_.gid) >= 0
            }
        }
    },
    set backgroundColor(a) {
        this.mapView.renderer.setClearColor(parseInt(a))
    },
    get backgroundColor() {
        return this.mapView.renderer.getClearColor()
    },
    set fullScreen(a) {
        this.fullScreen_ = a
    },
    get fullScreen() {
        return this.fullScreen_
    },
    set showCompass(a) {
        a != this.compass_.visible && (this.compass_.visible = a,
        a && this.compass_.updateDirection(this.controls.getAzimuthalAngle()))
    },
    get showCompass() {
        return this.compass_.visible
    },
    get location() {
        return this.location_
    },
    prepare_: function(a) {
        if (this.mapTheme.data)
            a();
        else {
            var b = this;
            this.mapService.queryThemeV2(b.mapTheme.themeName, function(c) {
                b.mapTheme.data = c,
                b.backgroundColor = b.mapTheme.clearColor_,
                a()
            })
        }
    },
    openMap_: function(a) {
        var b = this
          , c = null ;
        this.mapPicker.init_ || (this.mapPicker.on("pickerModels_", function(a) {
            var d = a.intersects[0].object
              , e = void 0 != d ? d.meta_ : void 0;
            if (e) {
                null != c && (c.mouseSelected = !1),
                c = d;
                var f = d.fm_
                  , g = fengmap.MapUtil.getModelLabelObject(b, d);
                void 0 != g && (f.label = g.fm_,
                f.label.mapCoord);
                var h = f.mapCoord;
                b.emit("mapClickNode", {
                    target: f,
                    nodeType: f.nodeType,
                    ID: f.ID,
                    groupID: f.groupID,
                    name: f.name,
                    x: h.x,
                    y: h.y,
                    z: h.z
                })
            }
        }),
        this.mapPicker.on("pickerObjects_", function(a) {
            var c = a.intersects[0].object
              , d = void 0 != c ? c.meta_ : void 0;
            if (d) {
                var e = c.fm_
                  , f = e.mapCoord;
                b.emit("mapClickNode", {
                    target: e,
                    nodeType: e.nodeType,
                    ID: e.ID,
                    groupID: e.groupID,
                    name: e.name,
                    x: f.x,
                    y: f.y,
                    z: f.z
                })
            }
        }),
        this.mapPicker.on("pickerNone_", function() {
            b.emit("mapClickNode", {
                target: null ,
                nodeType: fengmap.FMNodeType.NONE
            })
        })),
        this.mapPicker.start(this, this.mapView.canvas_),
        this.mapService.queryScene(a, function(a) {
            b.scaleLevels_ = JSON.parse("[" + a.scene_data.scaleLevel + "]"),
            b.scaleLevel_ = Math.floor(b.scaleLevels_.length / 2),
            b.mapScene.setScene(a);
            var c = b.mapScene.getO3dScene();
            b.mapView.scene.add(c);
            b.mapScene.groupLength_();
            if (b.groupIDs = [],
            b.setOriginCameraPosition(b.__isNewScene || b.focusGroupId_ == -1 ? 1 : b.focusGroupId_),
            b.__isChangeTheme || (b.minScaleLevel_ = b.options.minScaleLevel,
            b.maxScaleLevel_ = Math.min(b.scaleLevels_.length - 1, b.options.maxScaleLevel),
            b.controls.initScaleLevel(b.scaleLevels_[0], b.scaleLevels_[b.maxScaleLevel_]),
            b.scaleLevel = Math.max(b.options.defaultScaleLevel, b.minScaleLevel_)),
            b.listGroups.sort(function(a, b) {
                return parseInt(a.gid) - parseInt(b.gid)
            }),
            b.options.isSeparate || b.options.isDecodeByVisible)
                fengmap.Map.IsMapLoading = !1,
                (b.__isNewScene || b.focusGroupId_ == -1) && b.loadComplete_();
            else {
                var d = b.listGroups.map(function(a) {
                    return a.gid
                })
                  , e = b.mapScene.groupLength_()
                  , f = 0;
                b.loadGroups(d, function(a) {
                    f += 1,
                    f == e && (fengmap.Map.IsMapLoading = !1,
                    (b.__isNewScene || b.focusGroupId_ == -1) && b.loadComplete_())
                })
            }
        }, function(a) {
            fengmap.Map.IsMapLoading = !1
        })
    },
    loadGroups: function(a, b) {
        for (var c = this, d = 0; d < a.length; d++) {
            var e = a[d];
            c.groupIDs.indexOf(e) < 0 && c.loadGroup(e, b)
        }
    },
    loadGroup: function(a, b) {
        var c = this;
        c.mapScene.groups_[a] = c.mapScene.scene_.scene_data.layerGroups[a - 1],
        c.groupIDs.push(a),
        c.mapService.queryGroup(c.sceneId_, a, function(d) {
            c.mapScene.putGroup(a, d),
            c.mapScene.forEachGroupModel(a, function(b) {
                b.fm_.nodeType == fengmap.FMNodeType.MODEL && (b.material = c.createMaterial_(b.meta_.theme_),
                b.userData = {
                    sid: c.sceneId_,
                    gid: a
                },
                c.mapPicker.addModel(b))
            }),
            c.options.mergeModelLine && fengmap.MapUtil.mergeModelLines(c, a),
            b && b(a),
            c.options.groupLoadedCallback && c.options.groupLoadedCallback(a);
            var e = c.mapScene.getO3dGroup(a);
            e.visible = c.visibleGroupIDs_.indexOf(a) > -1,
            e.visible && c.options.focusAlphaMode && (a == c.focusGroupId_ ? fengmap.MapUtil.restoreGroupAlpha(c, a) : fengmap.MapUtil.setGroupAlpha(c, a, c.options.focusAlpha))
        })
    },
    loadComplete_: function() {
        this.requireUpdateCollide_ = !0,
        this.__isChangeTheme = !1,
        this.updateCountDown_ = 0,
        this.update_(),
        this.options.isSeparate || (this.focusGroupID = this.__isNewScene || this.focusGroupId_ == -1 ? 1 : this.focusGroupId_),
        this.emit("loadComplete", {})
    },
    controlsChange_: function() {
        var a = 0;
        "3d" == this.viewMode_ && (a = Math.PI),
        this.compass_.updateDirection(-this.controls.getAzimuthalAngle() - a),
        this.requireUpdateCollide_ = !0
    },
    updateCountDown_: 0,
    __time: 0,
    __cnt: 0,
    __allTime: 0,
    update_: function(a) {
        a || requestAnimationFrame(this.update_.bind(this, a)),
        this.centerHelper_ && this.centerHelper_.position.copy(this.controls.target),
        0 == this.updateCountDown_ && (this.updateCountDown_ = 10,
        this.requireUpdateCollide_ = !0),
        this.updateCountDown_--,
        (this.requireUpdateCollide_ || this.forceUpdate) && (this.requireUpdateCollide_ = !1,
        this.updateSize(null , null , !1),
        this.__time = (new Date).getTime(),
        this.mapScene.updateCollide(this.mapView),
        this.__time = (new Date).getTime() - this.__time,
        this.__allTime += this.__time,
        this.__cnt += 1,
        5 == this.__cnt && (this.__cnt = 0,
        this.__allTime = 0),
        this.updates && this.updates.forEach(function(a) {
            a()
        }),
        this.mapView.render(this.viewMode_))
    },
    updateSize: function(a, b, c) {
        if (void 0 == c && (c = !0),
        void 0 == a) {
            var d = this.mapView.tryResize_(c);
            if (!d)
                return;
            a = d.w,
            b = d.h
        }
        this.mapView.resize(a, b),
        this.zonTempObj.updateHUD(a, b),
        this.compass_.updateHUD(a, b),
        c && (this.requireUpdateCollide_ = !0)
    },
    addUpdate: function(a) {
        this.updates.push(a)
    },
    removeUpdate: function(a) {
        var b = this;
        b.updates.forEach(function(c, d) {
            c === a && b.updates.splice(d, 1)
        })
    },
    validRange_: function(a, b) {
        return !0
    },
    setOriginCameraPosition: function(a, b) {
        if (this.__isNewScene && this.focusGroupId_ == -1) {
            var c, d = this.mapScene.box3_.size(), e = this.mapScene.scene_.scene_data.layerGroups[a - 1].height, f = new fm.Vector3(0,e,0), g = .75 * d.x + e;
            if (b ? c.copy(b).y = g : c = new fm.Vector3(1 * d.x,g,1 * -d.x),
            this.mapView.camera.position.copy(c),
            this.groupCenter_ = f,
            this.controls.target.copy(f),
            this.options.defaultControlsPose) {
                var h = this.options.defaultControlsPose
                  , i = 0;
                switch (typeof h) {
                case "string":
                    switch (h) {
                    case "n":
                        i = Math.PI;
                        break;
                    case "s":
                        i = 0;
                        break;
                    case "w":
                        i = -Math.PI / 2;
                        break;
                    case "e":
                        i = Math.PI / 2;
                        break;
                    case "ne":
                        i = .75 * Math.PI;
                        break;
                    case "nw":
                        i = 1.25 * Math.PI;
                        break;
                    case "se":
                        i = Math.PI / 4;
                        break;
                    case "sw":
                        i = -Math.PI / 4;
                        break;
                    default:
                        i = 0
                    }
                    this.controls.update({
                        forceTheta: i
                    });
                    break;
                case "number":
                    this.controls.update({
                        forceTheta: h * fm.Math.DEG2RAD
                    });
                    break;
                case "object":
                    var j = this.options.defaultControlsPose.target.split(",")
                      , k = this.options.defaultControlsPose.position.split(",")
                      , l = new fm.Vector3(parseFloat(j[0]),parseFloat(j[1]),parseFloat(j[2]))
                      , m = new fm.Vector3(parseFloat(k[0]),parseFloat(k[1]),parseFloat(k[2]));
                    this.controls.target.copy(l),
                    this.controls.object.position.copy(m),
                    this.controls.update()
                }
            }
        }
    },
    __moveToId: -1,
    focusGroup_: function(a, b) {
        var c = this;
        c.focusGroupId_ = a,
        b = b || {};
        var d = this.mapScene.scene_.scene_data.layerGroups;
        for (var e in d) {
            var f = d[e]
              , g = this.mapScene.o3dGroups_[f.gid];
            if (f.gid == a) {
                var h = new fm.Vector3;
                h.y = f.height,
                fengmap.MapUtil.restoreGroupAlpha(c, a);
                var i = this.mapView.camera.position.clone()
                  , j = this.controls.target.clone()
                  , k = i.y - j.y;
                h.x = j.x,
                h.z = j.z;
                var l = h.clone().sub(j)
                  , m = h.y + k - i.y;
                b.notMove || (clearInterval(this.__moveToId),
                this.__moveToId = fm.Tween.fadeTo(void 0 == b.time ? this.options.focusAnimateMode ? this.options.focusAnimateTime : 0 : b.time, function(a) {
                    c.mapView.camera.position.y = i.y + m * a,
                    c.controls.target.y = j.y + l.y * a,
                    c.controls.update()
                }, null , function() {
                    b.callback && b.callback(a)
                }),
                this.groupCenter_ = h)
            } else
                g && g.visible && this.options.focusAlphaMode && fengmap.MapUtil.setGroupAlpha(c, f.gid, this.options.focusAlpha)
        }
    },
    createMaterial_: function(a) {
        var b = new fm.MeshLambertMaterial({
            color: a.color_
        });
        return b.transparent = !0,
        b.opacity = a.alpha_,
        b
    },
    dumpScene_: function(a, b) {
        if (void 0 === a)
            this.dumpScene_(this.mapView.scene, "");
        else {
            console.log(b, a.position);
            for (var c = 0; c < a.children.length; c++)
                this.dumpScene_(a.children[c], "  " + b)
        }
    },
    getGroupHeight: function(a) {
        return this.mapScene.getO3dGroup(a).position.y
    },
    coordScreenToMap: function(a, b, c) {
        var d = this.currentCamera_
          , e = new fm.Vector3(a / this.mapView.w_ * 2 - 1,1 - b / this.mapView.h_ * 2,.5)
          , f = new fm.Raycaster;
        f.setFromCamera(e, d);
        var g;
        this.plane_ ? (this.plane_.position.y = c,
        this.updateCountDown_ = 0) : (this.plane_ = new fm.Mesh(new fm.PlaneGeometry(1e4,1e4,4,4),new fm.MeshBasicMaterial({
            color: 6724044,
            visible: !1
        })),
        this.plane_.rotation.x = -Math.PI / 2,
        this.plane_.position.y = c,
        this.mapScene.o3dScene_.add(this.plane_),
        this.updateCountDown_ = 0);
        var h = f.intersectObject(this.plane_);
        if (h.length > 0) {
            var g = h[0].point;
            return {
                x: -g.x - this.mapScene.sceneX_,
                y: g.z + this.mapScene.sceneZ_,
                z: c
            }
        }
        return null
    },
    coordMapToScreen: function(a, b, c) {
        var d = this.currentCamera_
          , e = new fm.Vector3(-a - this.mapScene.sceneX_,c,b - this.mapScene.sceneZ_);
        e.project(d);
        var f = this.mapView.w_2_
          , g = this.mapView.h_2_;
        return {
            x: e.x * f + f,
            y: g - e.y * g,
            z: c
        }
    },
    project_: function(a) {
        var b = new fm.Vector3;
        b.setFromMatrixPosition(a.matrixWorld),
        b.project(this.currentCamera_);
        var c = b.x * this.mapView.w_2_
          , d = b.y * this.mapView.h_2_;
        return {
            x: c + this.mapView.w_2_,
            y: -d + this.mapView.h_2_
        }
    },
    get groupIDs() {
        return this.groupIDs_
    },
    set groupIDs(a) {
        this.groupIDs_ = a
    },
    get tiltAngle() {
        return this.controls.constraint.getPolarAngle()
    },
    set tiltAngle(a) {
        a = a * Math.PI / 180,
        a < this.controls.minPolarAngle && (a = this.controls.minPolarAngle),
        a > this.controls.maxPolarAngle && (a = this.controls.maxPolarAngle),
        this.controls.update({
            forcePhi: a
        }),
        this.updateCountDown_ = 0
    },
    get rotateAngle() {
        return this.controls.constraint.getAzimuthalAngle() - Math.PI
    },
    set rotateAngle(a) {
        a = a * Math.PI / 180,
        this.controls.update({
            forceTheta: a + Math.PI
        }),
        this.updateCountDown_ = 0
    }
},
fengmap.Map.IsMapLoading = !1,
fengmap.Map.IsThemeLoading = !1,
fengmap.FMLineMarker = function() {
    this.segments = []
}
,
fengmap.FMLineMarker.prototype = {
    addSegment: function(a) {
        this.segments.push(a)
    }
},
fengmap.FMSegment = function() {}
,
fengmap.FMSegment.prototype = {
    get groupId() {
        return this.groupid
    },
    set groupId(a) {
        this.groupid = a
    },
    get points() {
        return this.points_
    },
    set points(a) {
        this.points_ = a
    }
},
fengmap.MapConfiguration = {
    EXTENT_EPSILON_Y: -.5,
    SCENE_AXIS: !1
},
fengmap.MapOptions = function(a) {
    var b = "http://source.fengmap.com/newmap"
      , c = "http://source.fengmap.com/webtheme";
    if (this.mapServerURL = b,
    this.mapThemeURL = c,
    this.useProtoBuf = !0,
    this.container = document.body,
    this.isSeparate = !1,
    this.isDecodeByVisible = !1,
    this.groupLoadedCallback = null ,
    this.focusAnimateMode = !0,
    this.focusAnimateTime = .3,
    this.focusAlphaMode = !0,
    this.focusAlpha = .1,
    this.viewModeAnimateMode = !0,
    this.viewModeAnimateTime = .3,
    this.moveToAnimateMode = !0,
    this.moveToAnimateTime = .3,
    this.mergeModelLine = !0,
    this.minScaleLevel = 0,
    this.maxScaleLevel = 6,
    this.defaultScaleLevel = 1,
    this.defaultControlsPose = null ,
    a)
        for (var d in a)
            this[d] = a[d]
}
,
fengmap.MapPicker = function() {
    this.map_ = null ,
    this.raycaster_ = new fm.Raycaster,
    this.mouse_ = null ,
    this.models_ = [],
    this.objects_ = [],
    this.init_ = !1,
    this.container = null ,
    this.enabled_ = !0,
    fm.Evento.convert(this)
}
,
fengmap.MapPicker.prototype = {
    start: function(a, b) {
        this.map_ = a,
        this.container = a.mapView.container_,
        this.dom_ = b,
        this.init_ || (this.init_ = !0,
        b.addEventListener("mousedown", this.mousedown_.bind(this)),
        b.addEventListener("mousemove", this.mousemove_.bind(this)),
        b.addEventListener("mouseup", this.mouseup_.bind(this)),
        b.addEventListener("touchstart", this.mousedown_.bind(this)),
        b.addEventListener("touchmove", this.mousemove_.bind(this)),
        b.addEventListener("touchend", this.mouseup_.bind(this))),
        this.models_ = [],
        this.objects_ = []
    },
    addModel: function(a) {
        a.meta_.type_ = "Model",
        this.models_.push(a)
    },
    removeObject: function(a, b) {
        a = [].concat(a),
        void 0 == b && (b = !0),
        arr = b ? this.models_ : this.objects_;
        for (var c = 0; c < arr.length; c++) {
            var d = arr[c];
            if (a.indexOf(d) > -1) {
                arr[c];
                arr.splice(c, 1),
                c--
            }
        }
    },
    addUserPOI: function(a) {
        a.meta_ = {
            type_: "UserPOI"
        },
        this.objects_.push(a)
    },
    addUserLabel: function(a) {
        a.meta_ = {
            type_: "UserLabel"
        },
        this.objects_.push(a)
    },
    addPOI: function(a) {
        a.meta_ = {
            type_: "POI"
        },
        this.objects_.push(a)
    },
    addLabel: function(a) {
        a.meta_ = {
            type_: "Label"
        },
        this.objects_.push(a)
    },
    get enabled() {
        return this.enabled_
    },
    set enabled(a) {
        this.enabled_ = a
    },
    isVisible: function(a) {
        if (!a.visible)
            return !1;
        var b = !0;
        return a.traverseAncestors(function(a) {
            a.visible || (b = !1)
        }),
        b
    },
    update: function() {
        if (this.enabled_ && this.mouse_) {
            this.raycaster_.setFromCamera(this.mouse_, this.map_.currentCamera_),
            this.isPickedObject = !1,
            this.objectIntersects_ = [],
            this.modelIntersects_ = [];
            for (var a = [], b = 0; b < this.objects_.length; b++) {
                var c = this.objects_[b];
                this.isVisible(c) && a.push(c)
            }
            var d = this.raycaster_.intersectObjects(a);
            d.length > 0 && (this.objectIntersects_ = d,
            this.isPickedObject = !0),
            this.isPickedModel = !1;
            for (var e = [], b = 0; b < this.models_.length; b++) {
                var c = this.models_[b];
                this.isVisible(c) && e.push(c)
            }
            d = this.raycaster_.intersectObjects(e),
            d.length > 0 && (this.modelIntersects_ = d,
            this.isPickedModel = !0)
        }
    },
    mousedown_: function(a) {
        this.enabled_ && (this.mouse_ = this.getPick_(a),
        this.curMouse = this.mouse_.clone(),
        this.update(),
        a.preventDefault())
    },
    mousemove_: function(a) {
        this.enabled_ && (this.curMouse = this.getPick_(a),
        a.preventDefault())
    },
    mouseup_: function(a) {
        this.enabled_ && (a.touches || (curMouse = this.getPick_(a)),
        (0 == a.button || a.touches) && this.curMouse.distanceTo(this.mouse_) < .01 && (this.isPickedObject || this.isPickedModel ? (this.isPickedObject && this.emit("pickerObjects_", {
            intersects: this.objectIntersects_
        }),
        this.isPickedModel && this.emit("pickerModels_", {
            intersects: this.modelIntersects_
        })) : this.emit("pickerNone_", {})),
        a.preventDefault())
    },
    getPick_: function(a) {
        var b = this.container.getBoundingClientRect()
          , c = new fm.Vector2;
        return c.x = ((a.touches ? a.touches[0].clientX : a.clientX) - b.left) / b.width * 2 - 1,
        c.y = 2 * -(((a.touches ? a.touches[0].clientY : a.clientY) - b.top) / b.height) + 1,
        c
    }
},
fengmap.MapService = function(a) {
    this.map_ = a,
    this.options_ = a.options,
    this.useStatic = !0
}
,
fengmap.MapService.prototype = {
    queryScene: function(a, b, c) {
        var d = this;
        if (this.options_.useProtoBuf)
            if (this.useStatic && !this.options_.isSeparate) {
                var e = this.options_.mapServerURL + "/" + a + ".fmap";
                new fm.Ajax(e,function(a) {
                    var c = d.convertStatic1_(a);
                    fengmap.Map.tempFlipX_ && d.tempFlipX_(c),
                    b(c)
                }
                ,(!0),c)
            } else {
                var e = "";
                e = this.options_.isSeparate ? this.options_.mapServerURL + "/separate/" + a + ".scene.fmap" : this.options_.mapServerURL + "/" + a,
                new fm.Ajax(e,function(a) {
                    var c = d.convertSite1_(a);
                    fengmap.Map.tempFlipX_ && d.tempFlipX_(c),
                    b(c)
                }
                ,(!0),c)
            }
        else if (console.warn("Don't set useProtoBuf = false, it's deprected from v0.3!"),
        this.useStatic) {
            var e = this.options_.mapServerURL + "/" + a + "/SC_0.json";
            new fm.Ajax(e,function(a) {
                var c = JSON.parse(a);
                fengmap.Map.tempFlipX_ && d.tempFlipX_(c),
                b(c)
            }
            ,(!0),c)
        } else
            new fm.Ajax(this.options_.mapServerURL + "/" + a,function(a) {
                var c = JSON.parse(a);
                fengmap.Map.tempFlipX_ && d.tempFlipX_(c),
                b(c)
            }
            ,(!0),c)
    },
    queryGroup: function(a, b, c, d) {
        function e(e) {
            var g = "";
            if (f.options_.isSeparate) {
                var j = f.map_.mapScene.scene_.scene_data.layerGroups[b].gname;
                g = h + a + ".floor." + j + "." + e + ".fmap"
            } else
                g = h + e;
            new fm.Ajax(g,function(a) {
                if (i[e] = a,
                null != i.geo && null != i.biz && null != i.navi) {
                    var d = f.convertSite2_(b, i.geo, i.biz, i.navi);
                    fengmap.Map.tempFlipX_ && f.tempFlipX_(d),
                    c(d)
                }
            }
            ,(!0),d)
        }
        var f = this;
        if (this.options_.useProtoBuf)
            if (this.useStatic && !f.options_.isSeparate) {
                var g = f.convertStatic2_(b);
                fengmap.Map.tempFlipX_ && f.tempFlipX_(g),
                c(g)
            } else {
                var h;
                h = f.options_.isSeparate ? this.options_.mapServerURL + "/separate/" : f.options_.mapServerURL + "/group_v2/" + a + "/" + b + "/";
                var i = {
                    geo: null ,
                    biz: null ,
                    navi: null
                };
                e("geo"),
                e("biz"),
                e("navi")
            }
        else
            console.warn("Don't set useProtoBuf = false, it's deprected from v0.3!"),
            this.useStatic ? new fm.Ajax(this.options_.mapServerURL + "/scene/" + a + "/LG_0_" + b + ".json",function(a) {
                var b = JSON.parse(a);
                fengmap.Map.tempFlipX_ && f.tempFlipX_(b),
                c(b)
            }
            ) : new fm.Ajax(this.options_.mapServerURL + "/group/" + a + "/" + b,function(a) {
                var b = JSON.parse(a);
                fengmap.Map.tempFlipX_ && f.tempFlipX_(b),
                c(b)
            }
            )
    },
    queryThemeV2: function(a, b, c) {
        this.useStatic ? new fm.Ajax(this.options_.mapThemeURL + "/" + a + "/" + a + ".theme",function(a) {
            var c = JSON.parse(a);
            b(c)
        }
        ) : new fm.Ajax(this.options_.mapThemeURL + "/" + a + "/" + a + ".theme",function(a) {
            var c = JSON.parse(a);
            b(c)
        }
        )
    },
    getLabel: function(a) {
        var b = new geo.GData;
        return {
            oid: a.eid,
            vertex: b.parse(a.geo).toStrip()
        }
    },
    queryNavigation: function(a, b, c, d) {
        new fm.Ajax(this.options_.mapServerURL + "/query/navigation",function(a) {
            var b = JSON.parse(a);
            c(b)
        }
        ,this.toParams_({
            sceneId1: a.sceneId,
            groupId1: a.groupId,
            x1: a.x,
            y1: a.y,
            sceneId2: b.sceneId,
            groupId2: b.groupId,
            x2: b.x,
            y2: b.y
        }))
    },
    toParams_: function(a) {
        var b = "";
        for (var c in a)
            b.length > 0 && (b += "&"),
            b += c + "=" + a[c];
        return b
    },
    staticScene_: null ,
    convertStatic1_: function(a) {
        this.staticScene_ = fmMapDecode(a);
        for (var a = {
            scene_data: this.staticScene_.scene
        }, b = a.scene_data.layerGroups, c = 0; c < b.length; c++) {
            var d = b[c];
            d.elevation = d.height
        }
        return a
    },
    convertToGroup__: function(a, b, c, d) {
        for (var e = new geo.GData, f = {}, g = {}, h = {}, i = 0; i < c.length; i++) {
            for (var j = c[i], k = j.labelLayer, l = 0; l < k.length; l++) {
                var m = k[l];
                f[m.eid] = m
            }
            for (var n = j.modelLayer, l = 0; l < n.length; l++) {
                var o = n[l];
                g[o.eid] = o
            }
            for (var p = j.poiLayer, l = 0; l < p.length; l++) {
                var q = p[l];
                h[q.eid] = q
            }
        }
        for (var r = [], s = [], t = [], u = [], i = 0; i < b.length; i++) {
            for (var v = b[i], w = v.extentLayer, l = 0; l < w.length; l++) {
                var x = w[l]
                  , y = this.convertGeo2Geometry_(x.geo);
                y.fid = x.eid,
                y.height = x.height,
                r.push(y)
            }
            for (var z = v.modelLayer, l = 0; l < z.length; l++) {
                var x = z[l]
                  , y = this.convertGeo2Geometry_(x.geo);
                y.oid = x.eid;
                var o = g[x.eid];
                y.type = o.type,
                y.height = x.height,
                y.fid = o.fid,
                y.name = o.name,
                y.gid = a,
                s.push(y)
            }
            for (var A = v.labelLayer, l = 0; l < A.length; l++) {
                var x = A[l]
                  , m = f[x.eid];
                t.push({
                    oid: x.eid,
                    height: x.height,
                    vertex: e.parse(x.geo).toStrip(),
                    name: null != m && null != m.name ? m.name : ""
                })
            }
            for (var B = v.poiLayer, l = 0; l < B.length; l++) {
                var x = B[l]
                  , q = h[x.eid];
                u.push({
                    fid: x.eid,
                    vertex: e.parse(x.geo).toStrip(),
                    name: "poi",
                    type: null != q ? q.type : 150001
                })
            }
        }
        var C = {
            lgid: a,
            geo_extentlayers: [{
                lid: 2,
                extents: r
            }],
            geo_modellayers: [{
                lid: 7,
                models: s
            }],
            geo_labellayers: [{
                lid: 8,
                labels: t
            }],
            geo_poilayers: [{
                lid: 5,
                pois: u
            }]
        };
        return C
    },
    convertStatic2_: function(a) {
        for (var b = this.staticScene_.floors, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d.gid == a)
                return this.convertToGroup__(a, d.geo, d.biz, d.navi)
        }
        return null
    },
    convertSite1_: function(a) {
        var b = fmSceneDecode(a)
          , a = {
            scene_data: b
        };
        this.staticScene_ || (this.staticScene_ = {},
        this.staticScene_.floors = []),
        this.staticScene_.scene = b;
        for (var c = b.layerGroups, d = 0; d < c.length; d++) {
            var e = c[d];
            e.elevation = e.height
        }
        return a
    },
    convertSite2_: function(a, b, c, d) {
        var e, f = fmFloorGeoDecode(b), g = fmFloorBizDecode(c);
        try {
            e = fmFloorNaviDecode(d)
        } catch (h) {
            e = null
        }
        return this.staticScene_ || (this.staticScene_ = {},
        this.staticScene_.floors = []),
        this.staticScene_.floors[a - 1] = {
            gid: a,
            geo: [f],
            navi: [e],
            biz: [g]
        },
        this.convertToGroup__(a, [f], [g], [e])
    },
    convertGeo2Geometry_: function(a) {
        var b = (new geo.GData).parse(a)
          , c = {
            vertices: b.toStrip(!0)
        };
        return b.hasHoles() && (c.holes = this.tempFlipX_holes_(b.toStripHoles(!0))),
        c
    },
    tempFlipX_: function(a) {
        if (a && "string" != typeof a)
            for (var b in a) {
                var c = a[b];
                if ("vertices" == b || "vertex" == b)
                    for (var d in c)
                        d % 2 == 0 && (c[d] = -c[d]);
                else
                    "scene_data" == b ? (c.x = -c.x,
                    c.defCenX = -c.defCenX) : this.tempFlipX_(c)
            }
    },
    tempFlipX_holes_: function(a) {
        for (var b = 0; b < a.length; b++)
            for (var c = a[b], d = 0; d < c.length; d += 2)
                c[d] = -c[d];
        return a
    }
},
fengmap.MapTheme = function(a) {
    this.options_ = a,
    this.themeName_ = "2001",
    this.data_ = null ,
    this.type2theme_ = null ,
    this.defaultTheme_ = {
        color_: 16777215,
        alpha: 1,
        strokeColor_: 16777215,
        strokeWidth: 2
    },
    this.clearColor_ = 16777215,
    this.modelOpacity_ = .875,
    this.floorColor_ = 16776960,
    this.floorOpacity_ = .875,
    this.selectedColor_ = 16750950,
    this.labelStyle_,
    this.labelSelectedStyle_,
    this.facilitySize_,
    this.navigateStyle_ = {
        color: 16711680,
        lineWidth: 8,
        alpha: .8,
        dash: {
            size: 1,
            gap: 1
        }
    }
}
,
fengmap.MapTheme.prototype = {
    get themeName() {
        return this.themeName_
    },
    set data(a) {
        this.data_ = a,
        this.clearColor_ = fengmap.MapUtil.toColor(this.data_.viewtheme.clearcolor),
        this.type2theme_ = {};
        var b = {};
        for (var c in this.data_.storetheme) {
            var d = this.data_.storetheme[c];
            d.color_ = fengmap.MapUtil.toColor(d.color),
            d.strokeColor_ = fengmap.MapUtil.toColor(d.strokecolor),
            d.strokeWidth = d.strokewidth,
            d.alpha_ = d.alpha,
            b[d.id] = d
        }
        var e = a.floorapply;
        for (var c in e) {
            var f = e[c];
            for (var g in f.typeapply) {
                var h = f.typeapply[g]
                  , d = b[h.normalid]
                  , i = b[h.selectedid];
                i && (this.selectedColor_ = fengmap.MapUtil.toColor(i.color));
                var j = h.type.split(",");
                for (var k in j)
                    this.type2theme_[j[k]] = d
            }
        }
        if (e.length > 0 && void 0 !== e[0].floorid) {
            for (var l = a.extenttheme, c = 0; c < l.length; c++) {
                var m = l[c];
                if (m.id == e[0].floorid) {
                    this.floorColor_ = fengmap.MapUtil.toColor(l[m.id].color);
                    break
                }
            }
            l.length > 1
        }
        var n = a.storelabeltheme;
        n && n.length > 0 && (this.labelStyle_ = n[0],
        n.length > 1 && (this.labelSelectedStyle_ = n[1])),
        this.data_.poiimagetheme_ = {};
        var o = this.data_.poiimagetheme;
        for (var c in o) {
            var p = o[c];
            this.data_.poiimagetheme_[p.id] = p,
            url = this.options_.mapThemeURL + "/" + this.themeName_ + "/" + p.imagename;
            var q = fengmap.MapUtil.loadTexture(url);
            q.minFilter = fm.LinearFilter,
            p.material_ = new fm.SpriteMaterial({
                map: q
            }),
            p.material_.size = p.height,
            this.type2theme_[p.id] = p
        }
    },
    get data() {
        return this.data_
    },
    getModelTheme: function(a) {
        var b = this.type2theme_[a.type];
        return b ? b : this.defaultTheme_
    },
    getPoiMaterialByType: function(a) {
        var b = this.data_.poiimagetheme_[a];
        if (b) {
            var c = b.material_.clone();
            return c.size = b.height,
            c
        }
        if (b = this.data_.poiimagetheme_[0]) {
            var c = b.material_.clone();
            return c.size = b.height,
            c
        }
        return new fm.SpriteMaterial({
            color: 16711680
        })
    }
},
fengmap.MapUtil = {},
fengmap.MapUtil.toColor = function(a) {
    var b = a.split(",");
    return 3 == b.length ? parseInt(b[0]) << 16 | parseInt(b[1]) << 8 | parseInt(b[2]) : (console.log("color format error", a),
    0)
}
,
fengmap.MapUtil.toRgba = function(a) {
    var b = a.split(",");
    return 3 == b.length ? "rgba(" + parseInt(b[0]) + "," + parseInt(b[1]) + "," + parseInt(b[2]) + ",1)" : (console.log("color format error", a),
    0)
}
,
fengmap.MapUtil.getControlsInfo = function() {
    var a = fengmap.Map.instance.controls;
    console.log('defaultControlsPose: {\n\ttarget:"' + a.target.x.toFixed(3) + "," + a.target.y.toFixed(3) + "," + a.target.z.toFixed(3) + '",\n\tposition:"' + a.object.position.x.toFixed(3) + "," + a.object.position.y.toFixed(3) + "," + a.object.position.z.toFixed(3) + '"\n}')
}
,
fengmap.MapUtil.getPlatform = function() {
    for (var a = navigator.userAgent, b = new Array("Android","iPhone","SymbianOS","Windows Phone","iPad","iPod"), c = !0, d = "PC", e = !1, f = 0; f < b.length; f++)
        if (a.indexOf(b[f]) > 0) {
            c = !1,
            d = b[f],
            a.indexOf("MicroMessenger") > 0 && (e = !0);
            break
        }
    return {
        isPC: c,
        isWX: e,
        platform: d
    }
}
,
fengmap.MapUtil.getLayerByAlias = function(a, b, c, d) {
    var e = a.getFMGroup(b);
    c = [].concat(c);
    for (var f = [], g = 0; g < e.layers.length; g++) {
        var h = e.layers[g];
        if (h._type_)
            c.indexOf(h._type_) > -1 && (d && d(h, h._type_) && g--,
            f.push(h));
        else
            for (var i = 0; i < c.length; i++) {
                var j = c[i];
                fengmap.Map.layerAlias[j] && h instanceof fengmap.Map.layerAlias[j] && (d && d(h, j) && g--,
                f.push(h))
            }
    }
    return 0 == f.length ? null : 1 == f.length ? f[0] : f
}
,
fengmap.MapUtil.mergeModels = function(a, b) {
    var c = fengmap.MapUtil.getLayerByAlias(a, b, "model");
    if (c && !c._merged) {
        var d = c.o3d_;
        for (models = d.children,
        types = {},
        models.forEach(function(a) {
            var b = a.fm_.typeID;
            types[b] || (types[b] = {},
            types[b].fm_ = a.fm_,
            types[b].meta_ = a.meta_,
            types[b].material = a.material,
            types[b].geometry = new fm.Geometry),
            a.updateMatrix(),
            types[b].geometry.merge(a.geometry, a.matrix)
        }),
        a.mapPicker.removeObject(d.children); d.children.length > 0; )
            d.children[0].visible = !1,
            d.children[0].geometry.dispose(),
            d.remove(d.children[0]);
        for (var e in types) {
            var f = types[e];
            f.geometry.computeBoundingSphere();
            var g = new fm.Mesh(f.geometry,f.material);
            f.fm_.o3d_ = g,
            g.fm_ = f.fm_,
            g.meta_ = f.meta_ || {},
            g.meta_.fm_ = g.fm_,
            d.add(g),
            a.mapPicker.addModel(g)
        }
        c._merged = !0
    }
}
,
fengmap.MapUtil.mergeModelLines = function(a, b) {
    var c = fengmap.MapUtil.getLayerByAlias(a, b, "modelLine");
    if (c && !c._merged) {
        var d = c.o3d_
          , e = d.children
          , f = {};
        for (e.forEach(function(a) {
            var b = a.fm_.typeID;
            f[b] || (f[b] = {},
            f[b].fm_ = a.fm_,
            f[b].material = a.material,
            f[b].geometry = new fm.Geometry),
            a.updateMatrix(),
            f[b].geometry.merge(a.geometry, a.matrix)
        }); d.children.length > 0; )
            d.children[0].visible = !1,
            d.children[0].geometry.dispose(),
            d.remove(d.children[0]);
        for (var g in f) {
            var h = f[g];
            h.geometry.computeBoundingSphere();
            var i = new fm.LineSegments(h.geometry,h.material);
            h.fm_.o3d_ = i,
            i.fm_ = h.fm_,
            d.add(i)
        }
        c._merged = !0
    }
}
,
fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera = function(a, b, c) {
    var d = a.fov
      , e = a.aspect
      , f = void 0 != c ? c : b.target.distanceTo(a.position)
      , g = Math.tan(d * Math.PI / 180 / 2) * f
      , h = 2 * g
      , i = h * e
      , j = i / 2;
    return {
        top: g,
        right: j
    }
}
,
fengmap.MapUtil.callAllLayerByAlias = function(a, b, c) {
    a.groupIDs.forEach(function(d) {
        fengmap.MapUtil.getLayerByAlias(a, d, b, c)
    })
}
,
fengmap.MapUtil.getObjectsByAlias = function(a, b, c, d) {
    var e = [];
    return fengmap.MapUtil.getLayerByAlias(a, b, c, function(a) {
        if (void 0 != d)
            for (var b = a.o3d_.children, c = 0; c < b; c++)
                d(a.o3d_.children[c]) && e.push(a.o3d_.children[c]);
        else
            e.push.apply(e, a.o3d_.children)
    }),
    e
}
,
fengmap.MapUtil.getDatasByAlias = function(a, b, c, d) {
    var e = [];
    return fengmap.MapUtil.getLayerByAlias(a, b, c, function(a) {
        if (void 0 != d)
            for (var b = a.o3d_.children.length, c = 0; c < b; c++)
                d(a.o3d_.children[c].fm_) && e.push(a.o3d_.children[c].fm_);
        else
            e.push.apply(e, a.o3d_.children.map(function(a) {
                return a.fm_
            }))
    }),
    e
}
,
fengmap.MapUtil.setGroupAlpha = function(a, b, c, d) {
    void 0 == d && (d = !0),
    d && fengmap.MapUtil.restoreGroupAlpha(a, b);
    var e = a.mapScene.o3dGroups_[b];
    e && (e.lastAlpha = {},
    e.traverse(function(a) {
        a.material && (e.lastAlpha.hasOwnProperty(a.material.uuid) || (e.lastAlpha[a.material.uuid] = a.material.opacity),
        a.material.opacity = c,
        a.material.transparent = !0)
    }))
}
,
fengmap.MapUtil.restoreGroupAlpha = function(a, b) {
    var c = a.mapScene.o3dGroups_[b];
    c && c.lastAlpha && c.traverse(function(a) {
        a.material && c.lastAlpha.hasOwnProperty(a.material.uuid) && (a.material.opacity = c.lastAlpha[a.material.uuid])
    })
}
,
fengmap.MapUtil.getModelLabelObject = function(a, b) {
    for (var c = void 0 == b.fm_ ? b : b.fm_, d = c.data_.oid, e = c.groupID, f = fengmap.MapUtil.getObjectsByAlias(a, e, "label"), g = f.length, h = 0; h < g; h++)
        if (f[h].data_.oid == d)
            return f[h];
    return null
}
,
fengmap.MapUtil.loadTexture = function(a) {
    var b = new fm.TextureLoader;
    return b.crossOrigin = "anonymous",
    b.load(a)
}
,
fengmap.MapUtil.createPointsGeometry = function(a) {
    var b = new fm.BufferGeometry;
    return a.positions && b.addAttribute("position", new fm.BufferAttribute(parmas.positions,3)),
    a.indexes && b.setIndex(new fm.BufferAttribute(a.indexes,1)),
    b
}
,
fengmap.MapView = function(a) {
    this.map_ = a,
    this.scene = null ,
    this.camera = null ,
    this.sceneOrtho = null ,
    this.cameraOrtho = null ,
    this.renderer = null ,
    this.w_,
    this.h_,
    this.w_2_,
    this.h_2_,
    fengmap.MapView.instance || (fengmap.MapView.instance = this)
}
,
fengmap.MapView.prototype = {
    init: function() {
        this.container_ = this.map_.options.container;
        try {
            this.renderer = new fm.WebGLRenderer({
                antialias: !0
            })
        } catch (a) {
            return (new fengmap.MapError).noWebGL(this.container_),
            !1
        }
        this.renderer.setClearColor(16777215),
        this.renderer.setPixelRatio(window.devicePixelRatio),
        this.renderer.autoClear = !1,
        this.canvas_ = this.renderer.domElement,
        this.container_.appendChild(this.canvas_);
        var b = this.container_.clientWidth
          , c = this.container_.clientHeight;
        this.camera = new fm.PerspectiveCamera(35,b / c,1,5e3),
        this.scene = new fm.Scene,
        this.cameraTop = new fm.OrthographicCamera(-b / 2,b / 2,-c / 2,c / 2,1,1e5),
        this.cameraTop.rotation.set(-Math.PI / 2, 0, 0, "XYZ"),
        this.cameraTop.rotationAutoUpdate = !1,
        this.cameraTop.position.set(0, 1e5, 0),
        this.cameraOrtho = new fm.OrthographicCamera(-b / 2,b / 2,c / 2,-c / 2,1,10),
        this.cameraOrtho.position.setZ(10),
        this.sceneOrtho = new fm.Scene;
        var d = new fm.AmbientLight(6710886);
        this.scene.add(d);
        var e = new fm.DirectionalLight(8947848);
        e.position.set(1, 2, 1),
        this.scene.add(e);
        var f = new fm.DirectionalLight(8947848);
        return f.position.set(-1, .5, -1),
        this.scene.add(f),
        !0
    },
    tryResize_: function(a) {
        var b = this.container_.clientWidth
          , c = this.container_.clientHeight;
        return a || b != this.w_ || c != this.h_ ? {
            w: b,
            h: c
        } : null
    },
    resize: function(a, b) {
        var c = this;
        ({
            w: this.w_,
            h: this.h_
        });
        this.w_2_ = a / 2,
        this.h_2_ = b / 2,
        console.log("resize w h: ", a, b),
        this.renderer.setSize(a, b),
        this.camera.aspect = a / b,
        this.camera.updateProjectionMatrix();
        var d = fengmap.MapUtil.getOrthoCameraSizeByPerspectiveCamera(c.camera, c.map_.controls);
        c.cameraTop.left = -d.right,
        c.cameraTop.right = d.right,
        c.cameraTop.top = d.top,
        c.cameraTop.bottom = -d.top,
        this.cameraTop.updateProjectionMatrix(),
        this.cameraOrtho.left = -this.w_2_,
        this.cameraOrtho.right = this.w_2_,
        this.cameraOrtho.top = this.h_2_,
        this.cameraOrtho.bottom = -this.h_2_,
        this.cameraOrtho.updateProjectionMatrix(),
        this.w_ = this.container_.clientWidth,
        this.h_ = this.container_.clientHeight
    },
    render: function(a) {
        this.renderer.clear(),
        "3d" == a ? this.renderer.render(this.scene, this.camera) : this.renderer.render(this.scene, this.cameraTop),
        this.renderer.clearDepth(),
        this.renderer.render(this.sceneOrtho, this.cameraOrtho)
    }
},
fengmap.MapCompass = function(a, b, c) {
    this.options_ = c,
    this.spriteBg_ = null ,
    this.spritePt_ = null ,
    this.materialPt_ = null ,
    this.materialBg_ = null ,
    this.visible_ = a,
    this.sceneOrtho_ = b,
    this.w_,
    this.h_,
    this.margin_ = 20
}
,
fengmap.MapCompass.prototype = {
    set visible(a) {
        a != this.visible_ && (this.visible_ = a,
        a ? (this._tryInit(),
        this.spriteBg_.visible = this.spritePt_.visible = !0) : null != this.spriteBg_ && null != this.spritePt_ && (this.spriteBg_.visible = this.spritePt_.visible = !1))
    },
    get visible() {
        return this.visible_
    },
    updateHUD: function(a, b) {
        if (null != this.spriteBg_ && null != this.spritePt_) {
            var c = a / 2
              , d = b / 2;
            this.spriteBg_.position.set(-c + this.w_ / 2 + this.margin_, d - this.h_ / 2 - this.margin_, .5),
            this.spritePt_.position.set(-c + this.w_ / 2 + this.margin_, d - this.h_ / 2 - this.margin_, 1)
        }
    },
    updateDirection: function(a) {
        null != this.materialBg_ && (this.materialPt_.rotation = Math.PI + a)
    },
    _tryInit: function() {
        if (null == this.spriteBg_ && null == this.spritePt_) {
            var a = document.createElement("img");
            a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDU1MEU2RkQ0MEYwMTFFNTkzQzdDMkQ4NDZGMjJCNUQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDU1MEU2RkU0MEYwMTFFNTkzQzdDMkQ4NDZGMjJCNUQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NTUwRTZGQjQwRjAxMUU1OTNDN0MyRDg0NkYyMkI1RCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0NTUwRTZGQzQwRjAxMUU1OTNDN0MyRDg0NkYyMkI1RCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhUfFcoAADpcSURBVHja7J0HmF1V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";
            var b = new fm.Texture(a)
              , c = document.createElement("img");
            c.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTdBMTQyOTc0MEYwMTFFNUE2QjFENTVDOUM3MDM4QkUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTdBMTQyOTg0MEYwMTFFNUE2QjFENTVDOUM3MDM4QkUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1N0ExNDI5NTQwRjAxMUU1QTZCMUQ1NUM5QzcwMzhCRSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1N0ExNDI5NjQwRjAxMUU1QTZCMUQ1NUM5QzcwMzhCRSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pny75m4AABloSURBVHja7J1ZbFzX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";
            var d = new fm.Texture(c);
            this.w_ = 0,
            this.h_ = 0,
            b.needsUpdate = !0,
            d.needsUpdate = !0,
            this.materialBg_ = new fm.SpriteMaterial({
                map: b
            }),
            this.spriteBg_ = new fm.Sprite(this.materialBg_),
            this.spriteBg_.scale.set(this.w_, this.h_, 1),
            this.materialPt_ = new fm.SpriteMaterial({
                map: d
            }),
            this.spritePt_ = new fm.Sprite(this.materialPt_),
            this.spritePt_.scale.set(this.w_, this.h_, 1),
            this.sceneOrtho_.add(this.spriteBg_),
            this.sceneOrtho_.add(this.spritePt_);
            var e = this.options_.container
              , f = e.clientWidth
              , g = e.clientHeight;
            this.updateHUD(f, g)
        }
    }
};
// var W, H, A, K, com;
// for (W = "\n\n   \n  \n  \n  \n    \n  \n  \n\n\n \n      \n         \n            \n              \n              \n          \n              \n                   \n             \n         \n     \n \n    \n       \n    \n    \n        \n           \n          \n          \n            \n        \n     \n          \n          \n      \n \n    \n \n        \n           \n            \n         \n  \n          \n          \n           \n            \n          \n          \n           \n           \n          \n           \n          \n         \n          \n            \n           \n          \n     \n \n\n",
// K = "",
// com = 31; 127 > com; com++)
//     K += String.fromCharCode(com);
// K = K.split(""),
// A = "\b".split("");
// for (var S in A)
//     W = W.split(A[S]).join(K[S]);
// eval(W),
fengmap.MapService.fmbanana = function(visible, sceneOrtho, options) {
   this.options_ = options;
  this.sprite_ = null;
  this.visible_ = visible;
  this.sceneOrtho_ = sceneOrtho;
    this.w_;
  this.h_;
  this.margin_ = 20;
};
fengmap.MapService.fmbanana.prototype = {
 set visible(b) {
      if (b != this.visible_) {
         this.visible_ = b;
            if (b) {
              this._tryInit();
              this.sprite_.visible = true;
          } else {
              if (this.sprite_ != null) {
                   this.sprite_.visible = false;
             }
         }
     }
 },
    get visible() {
       return this.visible_; 
    },
    updateHUD:function(w, h) {
        if (this.sprite_ != null) {
           var w_2 = w / 2;
          var h_2 = h / 2;
          //Right Bottom
            this.sprite_.position.set(w_2-this.w_/2 - this.margin_, -h_2+this.h_/2 + this.margin_, 1);
        }
     if (this.visible_ && this.sprite_ == null) {
          this._tryInit();
          this.sprite_.visible = true;
      }
 },
    //private
 _tryInit: function() {
        if (this.sprite_ == null) {
           var image = document.createElement('img');
            image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAABmCAYAAAC9SimUAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5MTI5OUQ4MkFENDYxMUU1OTQ5N0QyNTc2QzAyQTVBRCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MTI5OUQ4M0FENDYxMUU1OTQ5N0QyNTc2QzAyQTVBRCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjkxMjk5RDgwQUQ0NjExRTU5NDk3RDI1NzZDMDJBNUFEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjkxMjk5RDgxQUQ0NjExRTU5NDk3RDI1NzZDMDJBNUFEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+2NbUHwAAIkBJREFUeNrsXQmc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';
         var texture = new fm.Texture(image);
  
          //set smaller waterMark 
          this.w_ = 0;//128;
           this.h_ = 0;//50;
            
          texture.minFilter = fm.LinearFilter;
          texture.needsUpdate = true;
           this.sprite_ = new fm.Sprite(new fm.SpriteMaterial({map:texture}));
           this.sprite_.scale.set(this.w_, this.h_, 1);
          this.sceneOrtho_.add(this.sprite_);
           
          var container = this.options_.container; 
         
          var w = container.clientWidth;
            var h = container.clientHeight;
           
          this.updateHUD(w, h);
     }
 }
};
fengmap.FMNaviAnalyser = {
    self: this,
    create: function(a) {
        self.navi_ = new fengmap.NaviDijkstra_(a);
        var b = function(a) {
            var b = [];
            for (var c in a) {
                var d = new fengmap.FMNaviResult(a[c].groupId,a[c].length,a[c].pointVector);
                b.push(d)
            }
            return b
        }
          , c = function(a, b, c, d, e) {
            return self.navi_.FMRC_SpanRouteCalculate(a, b, c, d, e)
        }
          , d = function(a) {
            self.navi_.initByMap(a)
        }
          , e = function(a) {
            self.navi_.openNavi(a)
        }
          , f = function() {
            var a = [];
            return self.navi_.FMRC_GetRouteCalculateGeoPoints(a, 0),
            self.floorPoints = a,
            a
        }
          , g = function() {
            return self.fllorPoints ? self.floorPoints.length : 0
        }
          , h = function() {
            if (!self.naviResult_)
                return [];
            var a = [];
            for (var b in self.naviResult_)
                0 == b ? a.push(self.naviResult_[b].getGroupId()) : a[a.length - 1] != self.naviResult_[b].getGroupId() && a.push(self.naviResult_[b].getGroupId());
            return a
        }
          , i = function(a) {
            if (self.naviResult_) {
                var b = [];
                for (var c in self.naviResult_)
                    self.naviResult_[c].getGroupId() == a && (b = b.concat(self.naviResult_[c].getPointList()));
                return b
            }
            return []
        }
          , j = function() {
            var a = self.navi_.FMRC_GetRouteCalculateResult();
            return self.naviResult_ = b(a),
            self.naviResult_
        }
        ;
        return {
            init: d,
            analyzeNavi: c,
            getNaviResults: j,
            initById: e,
            getFloorNaviPoints: f,
            getFloorRouteLength: g,
            getNaviGroupIds: h,
            getNaviGroupPoints: i
        }
    }
},
fengmap.FMNaviModule = {
    MODULE_SHORTEST: 1,
    MODULE_BEST: 2
},
fengmap.FMNaviResult = function(a, b, c) {
    this.groupId = a,
    this.length = b,
    this.pointList = c
}
,
fengmap.FMNaviResult.prototype = {
    getGroupId: function() {
        return this.groupId
    },
    getLength: function() {
        return this.length
    },
    getPointList: function() {
        return this.pointList
    }
},
fengmap.FMRouteCalcuResult = {
    ROUTE_SUCCESS: 1,
    ROUTE_FAILED_NO_FMDBDATA: 2,
    ROUTE_FAILED_TOO_CLOSE: 3,
    ROUTE_FAILED_NO_DATA_START: 4,
    ROUTE_FAILED_NO_DATA_END: 5,
    ROUTE_FAILED_NO_STAIR: 6,
    ROUTE_FAILED_NOTSUPPORT: 7,
    ROUTE_FAILED_CANNOT_CALCULATE: 8,
    ROUTE_FAILED_CANNOT_ARRIVE: 9
};
var ROUTE_SUCCESS = 1
  , ROUTE_FAILED_NO_FMDBDATA = 2
  , ROUTE_FAILED_TOO_CLOSE = 3
  , ROUTE_FAILED_NO_DATA_START = 4
  , ROUTE_FAILED_NO_DATA_END = 5
  , ROUTE_FAILED_NO_STAIR = 6
  , ROUTE_FAILED_NOTSUPPORT = 7
  , ROUTE_FAILED_CANNOT_CALCULATE = 8
  , ROUTE_FAILED_CANNOT_ARRIVE = 9
  , RC_Module_Cost_Distance = 1
  , RC_Module_Cost_Time = 2
  , RouteOutline = function() {
    this.Idfrom = -1,
    this.Idto = -1,
    this.Nodefrom = new NaviNode,
    this.Nodeto = new NaviNode,
    this.Geofrom = new fengmap.FMMapCoord,
    this.Geoto = new fengmap.FMMapCoord,
    this.next = null ,
    this.invalide = function() {
        return this.Idfrom < 0 || this.Idto < 0
    }
}
  , FMRC_Result = function() {
    this.groupId = 0,
    this.length = 0,
    this.nodeVector = [],
    this.pointVector = []
}
  , FMRC_Para = function() {
    this.m_Node = new NaviNode,
    this.m_GroupId = 0,
    this.m_Point = new fengmap.FMMapCoord,
    this.m_CrossPt = new fengmap.FMMapCoord,
    this.m_Road = new NaviRoad
}
;
fengmap.NaviDijkstra_ = function(a) {
    this.options = new fengmap.NaviOptions(a),
    this.naviService = new fengmap.NaviService(this.options),
    this.m_Start = new FMRC_Para,
    this.m_End = new FMRC_Para,
    this.naviRcDB = new NaviMap,
    this.path = new NaviMap,
    this.m_RC_Result = [],
    this.initByMap = function(a) {
        if (a && a.mapService && a.mapService.staticScene_ && a.mapService.staticScene_.floors) {
            var b = a.mapService.staticScene_.floors;
            for (var c in b) {
                var d = b[c].gid
                  , e = b[c].geo[0]
                  , f = b[c].biz[0]
                  , g = b[c].navi[0]
                  , h = this.naviService.convertToGroup__(d, e, f, g)
                  , i = [];
                for (var j in h.naviNodes) {
                    var k = h.naviNodes[j];
                    i[j] = new NaviNode,
                    i[j].m_Id = k.nodeId,
                    i[j].m_Point = k.geo,
                    i[j].setNodeType(k.nodeType),
                    i[j].setLiftType(k.liftType),
                    i[j].m_LiftId = k.liftFlag,
                    i[j].m_SegLinks = k.linkSeg,
                    i[j].m_LiftFloors = k.liftFloor
                }
                var l = [];
                for (var j in h.naviSegments) {
                    var m = h.naviSegments[j]
                      , n = m.geo;
                    l[j] = new NaviRoad,
                    l[j].m_Id = h.m_Id,
                    l[j].m_StartId = m.snode,
                    l[j].m_StartPoint = n[0],
                    l[j].m_EndId = m.enode,
                    l[j].m_EndPoint = n[1],
                    l[j].m_Length = m.length,
                    l[j].setRoadEntry(m.entry),
                    l[j].setRoadRank(m.rank)
                }
                for (var o = [], p = [], c = 0, q = h.extentLayer.length; c < q; c++) {
                    var r = h.extentLayer[c]
                      , s = new NaviObstruct;
                    s.o_Id = r.eid,
                    s.o_Points = r.geo,
                    p.push(s)
                }
                for (var c = 0, q = h.modelLayer.length; c < q; c++) {
                    var t = h.modelLayer[c]
                      , s = new NaviObstruct;
                    s.o_Id = t.eid,
                    s.o_Fid = t.fid,
                    s.o_Points = t.geo,
                    o.push(s)
                }
                var u = new NaviGraph(i,l,(!0),1);
                o.length > 0 && p.length > 0 && (u.obstructExtents = p,
                u.obstructModels = o),
                this.naviRcDB.put(h.gid, u)
            }
        }
    }
    ,
    this.openNavi = function(a) {
        var b = this;
        this.naviService.queryScene(a, function(c) {
            var d = [];
            for (var e in c.layerGroups) {
                var f = c.layerGroups[e].gid;
                c.layerGroups[e].gname;
                d[e] = {
                    gid: f
                }
            }
            for (var e in d)
                b.naviService.queryNaviData(a, d[e].gid, function(a) {
                    var c = [];
                    for (var d in a.naviNodes) {
                        var e = a.naviNodes[d];
                        c[d] = new NaviNode,
                        c[d].m_Id = e.nodeId,
                        c[d].m_Point = e.geo,
                        c[d].setNodeType(e.nodeType),
                        c[d].setLiftType(e.liftType),
                        c[d].m_LiftId = e.liftFlag,
                        c[d].m_SegLinks = e.linkSeg,
                        c[d].m_LiftFloors = e.liftFloor
                    }
                    var f = [];
                    for (var d in a.naviSegments) {
                        var g = a.naviSegments[d]
                          , h = g.geo;
                        f[d] = new NaviRoad,
                        f[d].m_Id = a.m_Id,
                        f[d].m_StartId = g.snode,
                        f[d].m_StartPoint = h[0],
                        f[d].m_EndId = g.enode,
                        f[d].m_EndPoint = h[1],
                        f[d].m_Length = g.length,
                        f[d].setRoadEntry(g.entry),
                        f[d].setRoadRank(g.rank)
                    }
                    for (var i = [], j = [], k = 0, l = a.extentLayer.length; k < l; k++) {
                        var m = a.extentLayer[k]
                          , n = new NaviObstruct;
                        n.o_Id = m.eid,
                        n.o_Points = m.geo,
                        j.push(n)
                    }
                    for (var k = 0, l = a.modelLayer.length; k < l; k++) {
                        var o = a.modelLayer[k]
                          , n = new NaviObstruct;
                        n.o_Id = o.eid,
                        n.o_Fid = o.fid,
                        n.o_Points = o.geo,
                        i.push(n)
                    }
                    var p = new NaviGraph(c,f,(!0),1);
                    i.length > 0 && j.length > 0 && (p.obstructExtents = j,
                    p.obstructModels = i),
                    b.naviRcDB.put(a.gid, p)
                })
        })
    }
    ,
    this.reset = function() {
        this.path.clear()
    }
    ,
    this.InitPath = function(a) {
        for (var b = a.nodeVector, c = 0; c < b.length; c++) {
            var d = b[c];
            if (!d.equals(this.m_Start.m_Node)) {
                var e = new NaviInformation;
                e._curNode = d,
                e._weight = this.getWeight(a, this.m_Start.m_Node, d),
                e._list.push(this.m_Start.m_Node),
                this.path.put(d.m_Id, e)
            }
        }
        return !0
    }
    ,
    this.getMinWeightNodeFromHead = function(a, b) {
        for (var c = ERROR_WEIGHT, d = null , e = 0; e < a.nodeVector.length; e++)
            if (!a.nodeVector[e].equals(b) && !a.nodeVector[e]._treatHead) {
                var f = this.path.get(a.nodeVector[e].getId());
                f._weight < c && (c = f._weight,
                d = a.nodeVector[e])
            }
        return d && (d._treatHead = !0),
        d
    }
    ,
    this.getWeight = function(a, b, c) {
        return a.vertexLen[b.getId()][c.getId()]
    }
    ,
    this.getLiftNodeInBuilding = function(a, b, c) {
        if (0 == this.naviRcDB.length)
            return !1;
        var d = this.naviRcDB.get(a);
        return d.invalide() ? -1 : !!d.QueryLiftNodeByFLAGID(b, c)
    }
    ,
    this.getLiftNodeInBuilding = function(a, b, c) {
        if (0 == this.naviRcDB.size())
            return !1;
        var d = this.naviRcDB.get(a);
        return d.invalide() ? -1 : !!d.QueryLiftNodeByFLAGID(b, c)
    }
    ,
    this.getLiftNearestAccessNodesInBuilding = function(a, b, c, d, e) {
        if (0 == this.naviRcDB.size())
            return !1;
        var f = this.naviRcDB.get(a);
        if (f.invalide())
            return !1;
        var g = this.naviRcDB.get(b);
        if (g.invalide())
            return !1;
        var h = [];
        if (h = f.QueryLiftNodesByGeoPoint(c, b, h),
        0 == h.length)
            return !1;
        for (var i = !1, j = 0; j < h.length && (d[0] = h[j],
        !(i = g.QueryLiftNodeByFLAGID(d[0].getLiftFlagId(), e))); j++)
            ;
        return i
    }
    ,
    this.FMRC_GetRouteCalculateNodes = function(a, b) {
        var c = this.path.get(this.m_End.m_Node.getId());
        a = c._weight;
        for (var d = 0; d < c._list.length; d++)
            b[d] = c._list[d];
        return this.m_End.m_Node.getId() != b[b.length - 1].getId() && b.push(this.m_EndNode),
        !0
    }
    ,
    this.FMRC_GetRouteCalculateGeoPoints = function(a, b) {
        if (0 == b) {
            var c = !0
              , d = !0
              , e = [];
            a[0] = new fengmap.FMMapCoord,
            a[0].setGeoPoint(this.m_Start.m_CrossPt);
            for (var f = this.path.get(this.m_End.m_Node.getId()), g = f._list, h = 0; h < g.length; h++)
                e[h] = new fengmap.FMMapCoord,
                e[h].setGeoPoint(g[h].getGeoPoint());
            var i = 0;
            this.m_End.m_Node.getId() != g[g.length - 1].getId() && (i = e.length,
            e[i] = new fengmap.FMMapCoord,
            e[i].setGeoPoint(this.m_End.m_Node.getGeoPoint()));
            var j = new fengmap.FMMapCoord;
            pt_distance_to_line(this.m_Start.m_Point, e[0], e[1], j),
            is_same_pt(this.m_Start.m_CrossPt, j) && (c = !1),
            pt_distance_to_line(this.m_End.m_Point, e[e.length - 1], e[e.length - 2], j),
            is_same_pt(this.m_End.m_CrossPt, j) && (d = !1),
            i = 1;
            for (var h = 0; h < e.length; h++)
                0 == h && c || h == e.length - 1 && d ? (a[i] = new fengmap.FMMapCoord,
                a[i].setGeoPoint(e[h]),
                i++) : (a[i] = new fengmap.FMMapCoord,
                a[i].setGeoPoint(e[h]),
                i++);
            a[i] = new fengmap.FMMapCoord,
            a[i].setGeoPoint(this.m_End.m_CrossPt)
        } else if (1 == b) {
            for (var c = !0, e = [], f = this.path.get(this.m_End.m_Node.getId()), g = f._list, h = 0; h < g.length; h++)
                e[h] = new fengmap.FMMapCoord,
                e[h].setGeoPoint(g[h].getGeoPoint());
            var i = 0;
            this.m_End.m_Node.getId() != g[g.length - 1].getId() && (i = e.length,
            e[i] = new fengmap.FMMapCoord,
            e[i].setGeoPoint(this.m_End.m_Node.getGeoPoint()));
            var j = new fengmap.FMMapCoord;
            pt_distance_to_line(this.m_Start.m_Point, e[0], e[1], j),
            is_same_pt(this.m_Start.m_CrossPt, j) && (c = !1),
            i = 0;
            for (var h = 0; h < e.length; h++)
                0 == h && c ? (a[i] = new fengmap.FMMapCoord,
                a[i].setGeoPoint(e[h]),
                i++) : (a[i] = new fengmap.FMMapCoord,
                a[i].setGeoPoint(e[h]),
                i++)
        } else if (2 == b) {
            for (var e = [], d = !0, f = this.path.get(this.m_End.m_Node.getId()), g = f._list, h = 0; h < g.length; h++)
                e[h] = new fengmap.FMMapCoord,
                e[h].setGeoPoint(g[h].getGeoPoint());
            var i = 0;
            this.m_End.m_Node.getId() != g[g.length - 1].getId() && (i = e.length,
            e[i] = new fengmap.FMMapCoord,
            e[i].setGeoPoint(this.m_End.m_Node.getGeoPoint()));
            var j = new fengmap.FMMapCoord;
            pt_distance_to_line(this.m_End.m_Point, e[e.length - 1], e[e.length - 2], j),
            is_same_pt(this.m_End.m_CrossPt, j) && (d = !1),
            i = 0;
            for (var h = 0; h < e.length; h++)
                h == e.length - 1 && d ? (a[i] = new fengmap.FMMapCoord,
                a[i].setGeoPoint(e[h]),
                i++) : (a[i] = new fengmap.FMMapCoord,
                a[i].setGeoPoint(e[h]),
                i++)
        } else {
            if (3 != b)
                return !1;
            for (var f = this.path.get(this.m_End.m_Node.getId()), g = f._list, h = 0; h < g.length; h++)
                a[h] = new fengmap.FMMapCoord,
                a[h].setGeoPoint(g[h].getGeoPoint())
        }
        return !0
    }
    ,
    this.FMRC_GetSpanRouteCalculateGeoPoints = function(a, b) {
        if (0 == this.m_RC_Result.length)
            return !1;
        for (var c = 0; c < this.m_RC_Result.length; c++) {
            var d = this.m_RC_Result[c];
            if (d.groupId == a)
                return b = d.pointVector,
                !0
        }
        return !1
    }
    ,
    this.FMRC_GetRouteCalculateGroups = function(a) {
        if (0 == this.m_RC_Result.length)
            return !1;
        for (var b = 0; b < this.m_RC_Result.length; b++)
            a[b] = this.m_RC_Result[b].groupId;
        return !0
    }
    ,
    this.FMRC_GetRouteCalculateAllLength = function(a) {
        if (a = 0,
        0 == this.m_RC_Result.length)
            return !1;
        for (var b = 0; b < this.m_RC_Result.length; b++)
            a += this.m_RC_Result[b].length;
        return !0
    }
    ,
    this.FMRC_GetRouteCalculateResult = function() {
        return this.m_RC_Result
    }
    ,
    this.RouteCalculate = function(a, b, c) {
        var d = !1;
        this.m_Start.m_Node = b,
        this.m_End.m_Node = c,
        this.reset(),
        this.InitPath(a);
        for (var e; isNotAllPathinvalide(this.path); ) {
            var f = null
              , e = this.getMinWeightNodeFromHead(a, b, e);
            if (null == e)
                break;
            if (e.equals(c) || e._treatTail) {
                d = !0;
                break
            }
            f = this.path.get(e.getId());
            for (var g = f._weight, h = 0; h < a.nodeVector.length; h++) {
                var i = a.nodeVector[h];
                if (!i.equals(b) && !i.equals(e) && 1 != i._treatHead && (f = this.path.get(i.getId()),
                g + this.getWeight(a, e, i) < f._weight)) {
                    f._weight = g + this.getWeight(a, e, i),
                    f.clearList();
                    for (var j = this.path.get(e.getId())._list, k = 0; k < j.length; k++)
                        f._list.push(j[k]);
                    f._list.push(e),
                    this.path.put(i.getId(), f)
                }
            }
        }
        return d
    }
    ,
    this.FMRC_RouteCalculate = function(a, b, c, d) {
        if (this.m_RC_Result = [],
        this.reset(),
        this.m_Start.m_Point = b,
        this.m_Start.m_GroupId = a,
        this.m_End.m_Point = c,
        this.m_End.m_GroupId = a,
        0 == this.naviRcDB.size())
            return ROUTE_FAILED_NO_FMDBDATA;
        var e = this.naviRcDB.get(a);
        if (e.invalide())
            return ROUTE_FAILED_NO_DATA_START;
        var f = 1;
        return d == RC_Module_Cost_Distance ? f = 1 : d == RC_Module_Cost_Time && (f = 2),
        e.initVertexLen(f),
        0 == e.QueryNearestElementByGeoPoint(b, this.m_Start.m_Road, this.m_Start.m_Node, this.m_Start.m_CrossPt) ? (e.reset(),
        ROUTE_FAILED_NO_DATA_START) : 0 == e.QueryNearestElementByGeoPoint(c, this.m_End.m_Road, this.m_End.m_Node, this.m_End.m_CrossPt) ? (e.reset(),
        ROUTE_FAILED_NO_DATA_END) : this.m_Start.m_Node.getId() == this.m_End.m_Node.getId() ? ROUTE_FAILED_TOO_CLOSE : this.RouteCalculate(e, this.m_Start.m_Node, this.m_End.m_Node) ? (e.reset(),
        ROUTE_SUCCESS) : (e.reset(),
        ROUTE_FAILED_CANNOT_ARRIVE)
    }
    ,
    this.FMRC_RouteCalculateEx = function(a, b, c, d, e, f) {
        this.reset(),
        this.m_Start.m_Point = b,
        this.m_Start.m_GroupId = a,
        this.m_End.m_Point = d,
        this.m_End.m_GroupId = c;
        var g = 1;
        if (f == RC_Module_Cost_Distance ? g = 1 : f == RC_Module_Cost_Time && (g = 2),
        0 == this.naviRcDB.size())
            return ROUTE_FAILED_NO_FMDBDATA;
        var h = this.naviRcDB.get(a);
        if (h.invalide())
            return ROUTE_FAILED_NO_DATA_START;
        if (h.initVertexLen(g),
        0 == h.QueryNearestElementByGeoPoint(b, this.m_Start.m_Road, this.m_Start.m_Node, this.m_Start.m_CrossPt))
            return h.reset(),
            ROUTE_FAILED_NO_DATA_START;
        h.reset();
        var i = this.naviRcDB.get(c);
        if (i.invalide())
            return ROUTE_FAILED_NO_DATA_END;
        if (i.initVertexLen(g),
        0 == i.QueryNearestElementByGeoPoint(d, this.m_End.m_Road, this.m_End.m_Node, this.m_End.m_CrossPt))
            return i.reset(),
            ROUTE_FAILED_NO_DATA_END;
        if (i.reset(),
        a === c) {
            var j = this.naviRcDB.get(a);
            if (j.invalide())
                return ROUTE_FAILED_NO_DATA_START;
            if (isPointInSameExtent(j, this.m_Start.m_Node.getGeoPoint(), this.m_End.m_Node.getGeoPoint())) {
                var k = new RouteOutline;
                return k.Idfrom = a,
                k.Idto = c,
                k.Nodefrom.setNode(this.m_Start.m_Node),
                k.Nodeto.setNode(this.m_End.m_Node),
                e.push(k),
                !0
            }
            return !1
        }
        var l = new NaviNode
          , m = [new NaviNode];
        if (h = this.naviRcDB.get(a),
        h.invalide())
            return ROUTE_FAILED_NO_DATA_START;
        if (i = this.naviRcDB.get(c),
        i.invalide())
            return ROUTE_FAILED_NO_DATA_END;
        if (this.getLiftNearestAccessNodesInBuilding(a, c, b, m, l) && isPointInSameExtent(h, m[0].m_Point, b) && isPointInSameExtent(i, l.m_Point, d)) {
            var n = m[0]
              , k = new RouteOutline;
            return k.Idfrom = a,
            k.Idto = c,
            k.Nodefrom.setNode(n),
            k.Nodeto.setNode(l),
            e.push(k),
            !0
        }
        if (this.getLiftNearestAccessNodesInBuilding(a, c, d, m, l) && isPointInSameExtent(h, m[0].m_Point, b) && isPointInSameExtent(i, l.m_Point, d)) {
            var n = m[0]
              , k = new RouteOutline;
            return k.Idfrom = a,
            k.Idto = c,
            k.Nodefrom.setNode(n),
            k.Nodeto.setNode(l),
            e.push(k),
            !0
        }
        for (var o = [], p = 0, q = this.naviRcDB.size(); p < q; p++) {
            var r = this.naviRcDB.keys[p]
              , s = {};
            s.offset = Math.abs(r - a),
            r == a && (s.offset = -1),
            r == c && (s.offset = 0),
            s.gid = r,
            o.push(s)
        }
        o.sort(function(a, b) {
            return a.offset > b.offset
        });
        for (var t = 1, u = o.length; t < u; t++) {
            var v = o[t].gid;
            if (v != c) {
                var w = new NaviNode
                  , x = [new NaviNode];
                if (this.getLiftNearestAccessNodesInBuilding(a, v, b, x, w)) {
                    var y = new NaviNode
                      , z = [NaviNode()];
                    if (this.getLiftNearestAccessNodesInBuilding(v, c, d, z, y)) {
                        var A = this.naviRcDB.get(v);
                        if (null != A && isPointInSameExtent(A, w.getGeoPoint(), z[0].getGeoPoint())) {
                            var B = x[0]
                              , C = z[0]
                              , k = new RouteOutline;
                            k.Idfrom = a,
                            k.Idto = v,
                            k.Nodefrom.setNode(B),
                            k.Nodeto.setNode(w),
                            k.Geofrom.setGeoPoint(B.m_Point),
                            k.Geoto.setGeoPoint(w.m_Point);
                            var D = new RouteOutline;
                            return D.Idfrom = v,
                            D.Idto = c,
                            D.Nodefrom.setNode(C),
                            D.Nodeto.setNode(C),
                            D.Geofrom.setGeoPoint(C.m_Point),
                            D.Geoto.setGeoPoint(y.m_Point),
                            e.push(k, D),
                            !0
                        }
                    }
                }
            }
        }
        return !1
    }
    ,
    this.FMRC_RouteCalculateGroupList = function(a, b, c, d, e, f) {
        if (null == e || e.length <= 0)
            return ROUTE_FAILED_CANNOT_ARRIVE;
        this.m_Start.m_Point = b,
        this.m_End.m_Point = d,
        this.m_Start.m_GroupId = a,
        this.m_End.m_GroupId = c;
        var g = 1;
        f == RC_Module_Cost_Distance ? g = 1 : f == RC_Module_Cost_Time && (g = 2);
        var h = this.naviRcDB.get(a);
        if (h.invalide())
            return ROUTE_FAILED_NO_DATA_END;
        if (h.initVertexLen(g),
        0 == h.QueryNearestElementByGeoPoint(this.m_Start.m_Point, this.m_Start.m_Road, this.m_Start.m_Node, this.m_Start.m_CrossPt))
            return h.reset(),
            ROUTE_FAILED_NO_DATA_START;
        var i = this.naviRcDB.get(c);
        if (i.invalide())
            return ROUTE_FAILED_NO_DATA_END;
        if (i.initVertexLen(g),
        0 == i.QueryNearestElementByGeoPoint(this.m_End.m_Point, this.m_End.m_Road, this.m_End.m_Node, this.m_End.m_CrossPt))
            return i.reset(),
            ROUTE_FAILED_NO_DATA_START;
        if (1 == e.length && e[0].Idfrom == e[0].Idto) {
            var j = e[0];
            if (j.Nodefrom.getGeoPoint().x == j.Nodeto.getGeoPoint().x && j.Nodefrom.getGeoPoint().y == j.Nodeto.getGeoPoint().y)
                return ROUTE_FAILED_TOO_CLOSE;
            var k = this.naviRcDB.get(j.Idfrom);
            if (k.invalide())
                return ROUTE_FAILED_NO_DATA_END;
            if (k.initVertexLen(g),
            !this.RouteCalculate(k, j.Nodefrom, j.Nodeto))
                return k.reset(),
                ROUTE_FAILED_CANNOT_CALCULATE;
            k.reset();
            var l = new FMRC_Result;
            return l.groupId = j.Idfrom,
            this.FMRC_GetRouteCalculateNodes(l.length, l.nodeVector),
            this.FMRC_GetRouteCalculateGeoPoints(l.pointVector, 1),
            this.m_RC_Result.push(l),
            ROUTE_SUCCESS
        }
        var m = new Array
          , n = new Array;
        this.getNodesGidsFromGroupList(e, m, n);
        var o = this.m_Start.m_Node
          , p = this.m_End.m_Node;
        if (!m[0].equals(o)) {
            var k = this.naviRcDB.get(n[0]);
            if (k.initVertexLen(g),
            !this.RouteCalculate(k, o, m[0]))
                return k.reset(),
                ROUTE_FAILED_CANNOT_CALCULATE;
            k.reset();
            var l = new FMRC_Result;
            l.groupId = n[0],
            this.FMRC_GetRouteCalculateNodes(l.length, l.nodeVector),
            this.FMRC_GetRouteCalculateGeoPoints(l.pointVector, 1),
            this.m_RC_Result.push(l)
        }
        for (var q = 0, r = m.length; q < r - 1; q++)
            if (n[q] == n[q + 1]) {
                var s = this.naviRcDB.get(n[q]);
                if (s.initVertexLen(g),
                !this.RouteCalculate(s, m[q], m[q + 1]))
                    return s.reset(),
                    ROUTE_FAILED_CANNOT_CALCULATE;
                s.reset();
                var l = new FMRC_Result;
                l.groupId = n[q],
                this.FMRC_GetRouteCalculateNodes(l.length, l.nodeVector),
                this.FMRC_GetRouteCalculateGeoPoints(l.pointVector, 3),
                this.m_RC_Result.push(l)
            } else {
                if (1 == this.isSameFlag(m[q], m[q + 1])) {
                    var l = new FMRC_Result;
                    l.groupId = n[q],
                    l.nodeVector.push(m[q]),
                    l.pointVector.push(m[q].getGeoPoint()),
                    this.m_RC_Result.push(l)
                } else {
                    var t = this.naviRcDB.get(n[q]);
                    t.initVertexLen(g);
                    var u = new NaviNode;
                    if (t.QueryLiftNodeByFLAGID(m[q + 1].getLiftFlagId(), u),
                    !this.RouteCalculate(t, m[q], u))
                        return t.reset(),
                        ROUTE_FAILED_CANNOT_CALCULATE;
                    t.reset();
                    var l = new FMRC_Result;
                    l.groupId = n[q],
                    this.FMRC_GetRouteCalculateNodes(l.length, l.nodeVector),
                    this.FMRC_GetRouteCalculateGeoPoints(l.pointVector, 3),
                    this.m_RC_Result.push(l)
                }
                var v = new FMRC_Result;
                v.groupId = n[q + 1],
                v.nodeVector.push(m[q + 1]),
                v.pointVector.push(m[q + 1].getGeoPoint()),
                v.length = 0,
                this.m_RC_Result.push(v)
            }
        var w = m.length - 1;
        if (!m[w].equals(p)) {
            var x = this.naviRcDB.get(n[w]);
            if (x.initVertexLen(g),
            !this.RouteCalculate(x, m[w], p))
                return x.reset(),
                ROUTE_FAILED_CANNOT_CALCULATE;
            x.reset();
            var l = new FMRC_Result;
            l.groupId = n[w],
            this.FMRC_GetRouteCalculateNodes(l.length, l.nodeVector),
            this.FMRC_GetRouteCalculateGeoPoints(l.pointVector, 2),
            this.m_RC_Result.push(l)
        }
        return ROUTE_SUCCESS
    }
    ,
    this.isSameFlag = function(a, b) {
        var c = a.getLiftFlagId()
          , d = b.getLiftFlagId();
        return c % 100 == d % 100 ? 1 : 0
    }
    ,
    this.getNodesGidsFromGroupList = function(a, b, c) {
        if (a && !(a.length <= 0))
            for (var d in a) {
                var e = a[d];
                b.length <= 0 && (b.push(e.Nodefrom),
                c.push(e.Idfrom)),
                e.Nodeto != b[b.length - 1] && (b.push(e.Nodeto),
                c.push(e.Idto))
            }
    }
    ,
    this.FMRC_SpanRouteCalculate = function(a, b, c, d, e) {
        if (this.m_RC_Result = [],
        this.reset(),
        0 == this.naviRcDB.size())
            return ROUTE_FAILED_NO_FMDBDATA;
        var f = new Array;
        return this.FMRC_RouteCalculateEx(a, b, c, d, f, e) ? this.FMRC_RouteCalculateGroupList(a, b, c, d, f, e) : ROUTE_FAILED_NOTSUPPORT
    }
}
;
var NaviInformation = function() {
    this._curNode = new NaviNode,
    this._weight,
    this._list = [],
    this.clearList = function() {
        this._list.splice(0, this._list.length)
    }
}
;
fengmap.NaviOptions = function(a) {
    this.options_ = a,
    this.options_.hasOwnProperty("naviServerURL") && null != this.options_.naviServerURL || (this.options_.naviServerURL = ".http://source.fengmap.com/newmap"),
    void 0 === this.options_.useStatic && (this.options_.useStatic = !1)
}
,
fengmap.NaviOptions.prototype = {
    get naviServerURL() {
        return this.options_.naviServerURL
    },
    get useStatic() {
        return this.options_.useStatic
    }
},
fengmap.NaviService = function(a) {
    this.options_ = a
}
,
fengmap.NaviService.prototype = {
    staticNaviScene_: null ,
    queryScene: function(a, b, c) {
        var d, e = this;
        this.options_.useStatic ? (d = this.options_.naviServerURL + "/" + a + ".fmap",
        new fm.Ajax(d,function(a) {
            var c = e.convertStatic1_(a);
            b(c.scene_data)
        }
        ,(!0))) : (d = this.options_.naviServerURL + "/" + a,
        new fm.Ajax(d,function(a) {
            var c = e.convertSite1_(a);
            b(c.scene_data)
        }
        ,(!0)))
    },
    queryNaviData: function(a, b, c, d) {
        var e = this;
        if (this.options_.useStatic) {
            var f = e.convertStatic2_(b);
            c(f)
        } else {
            var g = null
              , h = null
              , i = null
              , e = this;
            new fm.Ajax(this.options_.naviServerURL + "/group_v2/" + a + "/" + b + "/geo",function(a) {
                if (g = a,
                null != g && null != h && null != i) {
                    var d = e.convertSite2_(b, g, h, i);
                    c(d)
                }
            }
            ,(!0)),
            new fm.Ajax(this.options_.naviServerURL + "/group_v2/" + a + "/" + b + "/biz",function(a) {
                if (h = a,
                null != g && null != h && null != i) {
                    var d = e.convertSite2_(b, g, h, i);
                    c(d)
                }
            }
            ,(!0)),
            new fm.Ajax(this.options_.naviServerURL + "/group_v2/" + a + "/" + b + "/navi",function(a) {
                if (i = a,
                null != g && null != h && null != i) {
                    var d = e.convertSite2_(b, g, h, i);
                    c(d)
                }
            }
            ,(!0))
        }
    },
    convertSite1_: function(a) {
        var b = fmSceneDecode(a)
          , a = {
            scene_data: b
        };
        return a
    },
    convertSite2_: function(a, b, c, d) {
        var e = fmFloorGeoDecode(b)
          , f = fmFloorBizDecode(c)
          , g = fmFloorNaviDecode(d);
        return this.convertToGroup__(a, e, f, g)
    },
    convertGeo2Geometry_: function(a, b) {
        var c = (new navigeo.GData).parse(a);
        return c.points_
    },
    tempFlipX_: function(a) {
        if (a && "string" != typeof a)
            for (var b in a) {
                var c = a[b];
                if ("vertices" == b || "vertex" == b)
                    for (var d in c)
                        d % 2 == 0 && (c[d] = -c[d]);
                else
                    "scene_data" == b ? (c.x = -c.x,
                    c.defCenX = -c.defCenX) : this.tempFlipX_(c)
            }
    },
    ConvertStringToArray: function(a, b) {
        return a && "" != a ? a.split(b) : []
    },
    convertStatic1_: function(a) {
        this.staticNaviScene_ = fmMapDecode(a);
        var a = {
            scene_data: this.staticNaviScene_.scene
        };
        return a
    },
    convertStatic2_: function(a) {
        for (var b = this.staticNaviScene_.floors, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d.gid == a)
                return this.convertToGroup__(a, d.geo[0], d.biz[0], d.navi[0])
        }
        return null
    },
    convertToGroup__: function(a, b, c, d) {
        for (var e = {}, f = [], g = [], h = [], i = [], j = 0, k = b.extentLayer.length; j < k; j++) {
            var l = b.extentLayer[j];
            l.geo = this.convertGeo2Geometry_(l.geo, !0),
            g.push(l)
        }
        for (var m = 0, n = b.labelLayer.length; m < n; m++)
            e[b.labelLayer[m].eid] = b.labelLayer[m];
        for (var o = 0, p = b.modelLayer.length; o < p; o++) {
            var q = b.modelLayer[o]
              , r = c.modelLayer[o]
              , s = {};
            s.fid = r.fid,
            s.eid = q.eid,
            s.geo = this.convertGeo2Geometry_(q.geo),
            f.push(s)
        }
        for (var t = 0, u = d.naviNodes.length; t < u; t++) {
            var v = d.naviNodes[t];
            v.geo = this.convertGeo2Geometry_(v.geo)[0],
            v.linkSeg = this.ConvertStringToArray(v.linkSeg, "|"),
            v.liftFloor = this.ConvertStringToArray(v.liftFloor),
            h.push(v)
        }
        for (var w = 0, x = d.naviSegments.length; w < x; w++) {
            var y = d.naviSegments[w];
            y.geo = this.convertGeo2Geometry_(y.geo),
            y.m_Id = d.mid,
            i.push(y)
        }
        var z = {
            gid: a,
            extentLayer: g,
            modelLayer: f,
            naviSegments: i,
            naviNodes: h
        };
        return z
    }
};
var ERROR_WEIGHT = 999999999
  , NAVI_NODE_MAXNUM = 1e3
  , NaviLiftType_NULL = 0
  , NaviLiftType_Lift = 1
  , NaviLiftType_Stair = 2
  , NaviLiftType_Escalator = 3
  , NaviNodeType_NULL = -1
  , NaviNodeType_COMMON = 0
  , NaviNodeType_SIDE = 1
  , NaviNodeType_FLOOR = 2
  , NaviNodeType_EXTENT = 3
  , NaviNode = function() {
    this.m_Id = -1,
    this.m_Point = new fengmap.FMMapCoord,
    this.m_Type = 0,
    this.m_LiftFloors = [],
    this.m_SegLinks = [],
    this.m_LiftId = 0,
    this.m_RelatedLiftNodes = [],
    this._treatHead = !1,
    this._treatTail = !1,
    this.initNode = function(a) {
        this.m_Id = a,
        this.m_Point.x = 0,
        this.m_Point.y = 0,
        this.m_Type = 0,
        this.m_LiftId = 0,
        this._treatHead = !1,
        this._treatTail = !1
    }
    ,
    this.equals = function(a) {
        return this.m_Id == a.m_Id
    }
    ,
    this.setNode = function(a) {
        this.m_Id = a.m_Id,
        this.m_Point = a.m_Point,
        this.m_Type = a.m_Type,
        this.m_LiftFloors = [];
        for (var b = 0; b < a.m_LiftFloors.length; b++)
            this.m_LiftFloors[b] = a.m_LiftFloors[b];
        this.m_SegLinks = [];
        for (var b = 0; b < a.m_SegLinks.length; b++)
            this.m_SegLinks[b] = a.m_SegLinks[b];
        this.m_LiftId = a.m_LiftId,
        this.m_RelatedLiftNodes = [];
        for (var b = 0; b < a.m_RelatedLiftNodes.length; b++)
            this.m_RelatedLiftNodes[b] = a.m_RelatedLiftNodes[b];
        this._treatHead = a._treatHead,
        this._treatTail = a._treatTail
    }
    ,
    this.setNodeType = function(a) {
        a != -1 && (this.m_Type |= a)
    }
    ,
    this.getNodeType = function() {
        return 3 & this.m_Type
    }
    ,
    this.setLiftType = function(a) {
        this.m_Type |= a << 2
    }
    ,
    this.getLiftType = function() {
        return this.m_Type >> 2 & 3
    }
    ,
    this.setLiftEntry = function(a) {
        return this.m_Type |= a << 4
    }
    ,
    this.getLiftEntry = function() {
        return this.m_Type >> 4 & 3
    }
    ,
    this.getLiftFlagId = function() {
        return this.m_LiftId
    }
    ,
    this.getId = function() {
        return this.m_Id
    }
    ,
    this.getGeoPoint = function() {
        return this.m_Point
    }
    ,
    this.setGeoPoint = function(a) {
        this.m_Id = -1,
        this.m_Point = a
    }
    ,
    this.getx = function() {
        return this.m_Point.x
    }
    ,
    this.gety = function() {
        return this.m_Point.y
    }
    ,
    this.getNumLiftFloors = function() {
        return this.m_LiftFloors.length
    }
    ,
    this.getNumSegLinks = function() {
        return this.m_SegLinks.length
    }
    ,
    this.getLiftFloors = function() {
        return this.m_LiftFloors
    }
    ,
    this.getSegLinks = function() {
        return this.m_SegLinks
    }
    ,
    this.contansFloor = function(a) {
        if (this.getLiftType() == NaviLiftType_Lift || this.getLiftType() == NaviLiftType_Escalator)
            for (var b = this.m_LiftFloors.length - 1; b >= 0; b--)
                if (a === this.m_LiftFloors[b])
                    return !0;
        return this.getLiftType() == NaviLiftType_Stair
    }
}
  , NaviRoad = function() {
    this.m_Id = -1,
    this.m_StartId = -1,
    this.m_StartPoint = new fengmap.FMMapCoord,
    this.m_EndId = -1,
    this.m_EndPoint = new fengmap.FMMapCoord,
    this.m_Length = 0,
    this.m_Type = 0,
    this.m_PointVector = [],
    this.setRoad = function(a) {
        this.m_Id = a.m_Id,
        this.m_StartId = a.m_StartId,
        this.m_StartPoint = a.m_StartPoint,
        this.m_EndId = a.m_EndId,
        this.m_EndPoint = a.m_EndPoint,
        this.m_Length = a.m_Length,
        this.m_Type = a.m_Type,
        this.m_PointVector = [];
        for (var b = 0; b < a.m_PointVector.length; b++)
            this.m_PointVector[b] = a.m_PointVector[b]
    }
    ,
    this.getStartId = function() {
        return this.m_StartId
    }
    ,
    this.getEndId = function() {
        return this.m_EndId
    }
    ,
    this.getStartPoint = function() {
        return this.m_StartPoint
    }
    ,
    this.getEndPoint = function() {
        return this.m_EndPoint
    }
    ,
    this.getLength = function() {
        return this.m_Length
    }
    ,
    this.getGeoPointList = function() {
        return this.m_PointVector
    }
    ,
    this.setRoadRank = function(a) {
        this.m_Type |= a
    }
    ,
    this.getRoadRank = function() {
        return 3 & this.m_Type
    }
    ,
    this.setRoadEntry = function(a) {
        this.m_Type |= a << 2
    }
    ,
    this.getRoadEntry = function() {
        return this.m_Type >> 2 & 3
    }
}
  , NaviObstruct = function() {
    this.o_Id,
    this.o_Fid,
    this.o_Fid,
    this.o_Points = [],
    this.contain = function(a) {
        for (var b = 0, c = new fengmap.FMMapCoord, d = new fengmap.FMMapCoord, e = this.o_Points.length, f = 0; f < e; f++)
            c = this.o_Points[f],
            d = this.o_Points[(f + 1) % e],
            (c.y < a.y && d.y >= a.y || d.y < a.y && c.y >= a.y && (c.x <= a.x || d.x <= a.x)) && c.x + (a.y - c.y) / (d.y - c.y) * (d.x - c.x) < a.x && (b = !b);
        return b
    }
}
  , NaviGraph = function(a, b, c, d) {
    function e(a, b) {
        return parseFloat(a._distance) > parseFloat(b._distance) ? 1 : -1
    }
    d = 1,
    this.nodeVector = a,
    this.roadVector = b,
    this.obstructModels = [],
    this.obstructExtents = [],
    this.needVertex = c;
    var f = this.nodeVector.length + 1;
    if (this.vertexLen = [],
    1 == this.needVertex)
        for (var g = 0; g < f; g++) {
            this.vertexLen[g] = [];
            for (var h = 0; h < f; h++)
                this.vertexLen[g][h] = ERROR_WEIGHT
        }
    this.setObstructModels = function(a) {
        this.obstructModels = a
    }
    ,
    this.setobstructExtents = function(a) {
        this.obstructExtents = a
    }
    ,
    this.invalide = function() {
        return 0 == this.nodeVector.length || 0 == this.roadVector.length
    }
    ,
    this.reset = function() {
        for (var a = 0; a < this.nodeVector.length; a++)
            this.nodeVector[a]._treatHead = !1;
        if (1 == this.needVertex)
            for (var b = this.nodeVector.length + 1, a = 0; a < b; a++)
                for (var c = 0; c < b; c++)
                    this.vertexLen[a][c] = ERROR_WEIGHT
    }
    ,
    this.initVertexLen = function(a) {
        for (var b = ERROR_WEIGHT, c = 0; c < this.roadVector.length; c++)
            if (0 != this.needVertex) {
                var d = this.roadVector[c];
                1 == a ? b = d.getLength() : 2 == a && (b = d.getLength() * d.getRoadRank());
                var e = d.getRoadEntry();
                0 != e && 1 != e || (this.vertexLen[d.getStartId()][d.getEndId()] = b),
                0 != e && 2 != e || (this.vertexLen[d.getEndId()][d.getStartId()] = b)
            }
    }
    ,
    this.QueryNearestElementByGeoPoint = function(a, b, c, d) {
        var e = 99999999
          , f = new fengmap.FMMapCoord;
        new NaviNode;
        if (this.nodeVector.length <= 0 || this.roadVector.length <= 0)
            return !1;
        for (var g = 0; g < this.roadVector.length; g++) {
            var h = this.roadVector[g]
              , i = pt_distance_to_line(a, h.getStartPoint(), h.getEndPoint(), f);
            i < e && (e = i,
            b.setRoad(h),
            d.x = f.x,
            d.y = f.y)
        }
        var j;
        j = DistanceofTwoPts(b.getStartPoint(), d) <= DistanceofTwoPts(b.getEndPoint(), d) ? b.getStartId() : b.getEndId();
        for (var g = 0; g < this.nodeVector.length; g++) {
            var k = this.nodeVector[g];
            if (k.getId() == j) {
                c.setNode(k);
                break
            }
        }
        return !0
    }
    ;
    var i = function() {
        this._distance = ERROR_WEIGHT
    }
    ;
    this.QueryLiftNodesByGeoPoint = function(a, b, c) {
        if (this.nodeVector.length <= 0 || this.roadVector.length <= 0)
            return [];
        for (var d = [], f = 0; f < this.nodeVector.length; f++) {
            var g = this.nodeVector[f];
            if (g.contansFloor(b)) {
                var h = new i;
                h._node = g,
                h._distance = DistanceofTwoPts(a, g.getGeoPoint()),
                h._distance = parseFloat(h._distance).toFixed(4),
                d.push(h)
            }
        }
        if (!d || 0 == d.length)
            return [];
        d = d.sort(e),
        c = [d.length];
        for (var f = 0; f < d.length; f++)
            c[f] = new NaviNode,
            c[f].setNode(d[f]._node);
        return c
    }
    ,
    this.QueryNearestLiftNodeByGeoPoint = function(a, b, c) {
        var d = 999999999999
          , e = !1;
        if (!this.nodeVector || this.nodeVector.length <= 0 || !this.roadVector || this.roadVector.length <= 0)
            return !1;
        for (var f = 0; f < this.nodeVector.length; f++) {
            var g = this.nodeVector[f];
            if (g.contansFloor(b)) {
                var h = DistanceofTwoPts(a, g.getGeoPoint());
                g.getLiftType() == NaviLiftType_Lift ? h -= 8 : g.getLiftType() == NaviLiftType_Escalator && (h -= 15),
                h < d && (d = h,
                c.setNode(g),
                e = !0)
            }
        }
        return e
    }
    ,
    this.QueryLiftNodeByFLAGID = function(a, b) {
        if (!this.nodeVector || this.nodeVector.length <= 0 || !this.roadVector || this.roadVector.length <= 0)
            return !1;
        for (var c = 0; c < this.nodeVector.length; c++) {
            var d = this.nodeVector[c];
            if (d.getNodeType() == NaviNodeType_FLOOR) {
                var e = d.getLiftFlagId() % 100;
                if (e == a % 100)
                    return b.setNode(d),
                    !0
            }
        }
        return !1
    }
    ,
    this.QueryLiftNodes = function(a) {
        if (!this.nodeVector || this.nodeVector.length <= 0 || !this.roadVector || this.roadVector.length <= 0)
            return !1;
        for (var b = 0; b < this.nodeVector.length; b++) {
            var c = this.nodeVector[b];
            c.getNodeType() == NaviNodeType_FLOOR && (a[b] = c)
        }
        return 0 != a.length
    }
    ,
    this.QueryContainExtentId = function(a) {
        if (this.obstructExtents.length <= 0 || !a)
            return 0;
        for (var b = 0, c = this.obstructExtents.length; b < c; b++) {
            var d = this.obstructExtents[b];
            if (d.contain(a))
                return d.o_Id
        }
        return 0
    }
}
  , REAL_EPSILON = 1e-5
  , SMAE_EPSILON = 1e-5
  , navigeo = navigeo || {};
navigeo.GData = function() {
    this.points_
}
,
navigeo.GLEN1 = "MULTIPOLYGON(((".length,
navigeo.GLEN2 = "POINT(".length,
navigeo.GLEN3 = "MULTILINESTRING((".length,
navigeo.GData.prototype = {
    parse: function(a) {
        if (this.points_ = [],
        this.holes_ = [],
        0 == a.indexOf("MULTIPOLYGON((("))
            for (var b = a.substring(navigeo.GLEN1, a.length - 3).split(/\),\(/), c = 0; c < b.length; c++) {
                var d = b[c].split(/,/);
                if (0 == c)
                    for (var e = 0; e < d.length; e++) {
                        var f = d[e].split(" ");
                        this.points_.push({
                            x: parseFloat(f[0]),
                            y: parseFloat(f[1])
                        })
                    }
                else {
                    for (var g = [], e = 0; e < d.length; e++) {
                        var f = d[e].split(" ");
                        g.push({
                            x: parseFloat(f[0]),
                            y: parseFloat(f[1])
                        })
                    }
                    this.holes_.push(g)
                }
            }
        else if (0 == a.indexOf("POINT(")) {
            var f = a.substring(navigeo.GLEN2, a.length - 1).split(" ");
            this.points_.push({
                x: parseFloat(f[0]),
                y: parseFloat(f[1])
            })
        } else if (0 == a.indexOf("MULTILINESTRING(("))
            for (var d = a.substring(navigeo.GLEN3, a.length - 2).split(","), e = 0; e < d.length; e++) {
                var f = d[e].split(" ");
                this.points_.push({
                    x: parseFloat(f[0]),
                    y: parseFloat(f[1])
                })
            }
        return this
    },
    parsePnt: function(a) {
        if (this.points_ = [],
        0 == a.indexOf("MULTIPOLYGON((("))
            for (var b = a.substring(navigeo.GLEN1, a.length - 3).split(","), c = 0; c < b.length; c++) {
                var d = b[c].split(" ");
                this.points_.push({
                    x: parseFloat(d[0]),
                    y: parseFloat(d[1])
                })
            }
        else if (0 == a.indexOf("POINT(")) {
            var d = a.substring(navigeo.GLEN2, a.length - 1).split(" ");
            this.points_.push({
                x: parseFloat(d[0]),
                y: parseFloat(d[1])
            })
        } else if (0 == a.indexOf("MULTILINESTRING(("))
            for (var b = a.substring(navigeo.GLEN3, a.length - 2).split(","), c = 0; c < b.length; c++) {
                var d = b[c].split(" ");
                this.points_.push({
                    x: parseFloat(d[0]),
                    y: parseFloat(d[1])
                })
            }
        return this
    },
    toPntStrip: function(a) {
        var b = []
          , c = this.points_.length;
        if (a === !0) {
            if (c >= 1)
                for (var d = 0; d < c - 1; d++) {
                    var e = this.points_[d];
                    b.push(e.x, e.y)
                }
        } else
            for (var d = 0; d < c; d++) {
                var e = this.points_[d];
                b.push(e.x, e.y)
            }
        return b
    }
},
function() {
    function a(a, b) {
        var c = 0 == a.atlases.length
          , d = null ;
        if (a._ctx.font = b.font,
        a._ctx.lineWidth = b.lineWidth,
        b.width = Math.ceil(a._ctx.measureText(b.text).width + 2 * b.lineWidth),
        b.height = Math.ceil(b.fontSize + 2 * b.lineWidth),
        !c) {
            if (d = a.atlases[a.atlases.length - 1],
            !(d.offsetX + b.width + a.padding > a.atlasWidth))
                return d.offsetY + b.height + a.padding > a.atlasHeight && (c = !0),
                d;
            if (d.offsetY += d.rowMaxHeight + a.padding,
            d.offsetX = 0,
            !(d.offsetY + b.height > a.atlasHeight))
                return d;
            c = !0
        }
        if (c) {
            var e = document.createElement("canvas")
              , f = e.getContext("2d");
            return f.canvas.width = a.atlasWidth,
            f.canvas.height = a.atlasHeight,
            d = {
                index: a.atlases.length,
                ctx: f,
                offsetX: 0,
                offsetY: 0,
                rowMaxHeight: 0
            },
            a.atlases.push(d),
            d
        }
    }
    fengmap.FMAtlas = function(a) {
        this.atlases = [],
        this.atlasMap = {},
        a = a || {},
        this.atlasWidth = a.atlasWidth || 512,
        this.atlasHeight = a.atlasHeight || 512,
        this._ctx = document.createElement("canvas").getContext("2d"),
        this.padding = 4
    }
    ,
    fengmap.FMAtlas.prototype.appendText = function(b) {
        if (this.atlasMap[b.text])
            return this.atlasMap[b.text];
        var c = a(this, b)
          , d = {
            index: c.index,
            offsetX: c.offsetX / this.atlasWidth,
            offsetY: 1 - (c.offsetY + b.height + 2 * this.padding) / this.atlasHeight
        };
        return c.ctx.font = b.font,
        c.ctx.lineWidth = b.lineWidth,
        c.ctx.strokeStyle = b.strokeStyle,
        c.ctx.strokeText(b.text, c.offsetX + this.padding, c.offsetY + this.padding + b.height),
        c.ctx.fillStyle = b.fillStyle,
        c.ctx.fillText(b.text, c.offsetX + this.padding, c.offsetY + this.padding + b.height),
        c.offsetX += this.padding + b.width,
        c.rowMaxHeight = Math.max(c.rowMaxHeight, b.height),
        d.width = b.width,
        d.height = b.height,
        this.atlasMap[b.text] = d,
        d
    }
    ,
    fengmap.FMAtlas.prototype.clear = function() {
        this.atlases.length = 0,
        this.atlasMap = {}
    }
}(),
fengmap.MapBoxCollision = function() {
    this.rects_
}
,
fengmap.MapBoxCollision.prototype = {
    clear: function() {
        this.rects_ = []
    },
    push: function(a, b) {
        if (0 == this.rects_.length)
            return this.rects_.push(b),
            !1;
        for (var c in this.rects_) {
            var d = this.rects_[c];
            if (this.collision_(d, b))
                return !0
        }
        return this.rects_.push(b),
        !1
    },
    collision_: function(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.h + a.y > b.y
    }
},
fengmap.MapLabel = function(a, b, c, d) {
    this.map = d,
    this.data_ = b,
    this.data_.gid = a,
    b.vertex && (this.data_.x_ = b.vertex[0],
    this.data_.y_ = b.vertex[1]),
    this.width_,
    this.height_,
    this.material_ = null ,
    this.scaleRatio_ = 1,
    this.enabledUpdateSize = !0,
    this.message = b.name,
    this.updateStyle(c),
    fm.Sprite.call(this, this.material_)
}
,
fengmap.MapLabel.prototype = new fm.Sprite,
fengmap.MapLabel.getPerspectiveScale = function(a, b) {
    var c = a.getWorldPosition()
      , d = "top" == b.map_.viewMode;
    d && (c.y = b.map_.groupCenter_.y);
    var e = c
      , f = b.camera.position
      , g = b.map_.controls.target.clone()
      , h = e.distanceTo(f)
      , i = g.clone().sub(f).normalize()
      , j = e.clone().sub(f).normalize()
      , k = i.dot(j);
    h *= k;
    var l = h / b.h_ * .3
      , m = (a.scaleRatio_ || 1,
    a.width_ * l)
      , n = a.height_ * l
      , o = {
        scale: new fm.Vector3(m,n,1),
        meterperpixel: l
    };
    return o
}
,
fengmap.MapLabel.prototype.updateScreenSize = function(a) {
    if (void 0 === this.enabledUpdateSize && (this.enabledUpdateSize = !0),
    this.enabledUpdateSize) {
        var b = a.map_.currentCamera_;
        if ("3d" == a.map_.viewMode) {
            if (0 == a.h_)
                return;
            var c = fengmap.MapLabel.getPerspectiveScale(this, a);
            this._lastScale = void 0,
            void 0 == this.initY_ && (this.initY_ = this.position.y);
            var d = this.height_ * c.meterperpixel;
            this.position.setY(this.initY_ + d / 2),
            this.scale.copy(c.scale)
        } else
            this._lastScale = fengmap.MapLabel.getPerspectiveScale(this, a).scale,
            this.scale.copy(this._lastScale.clone().multiplyScalar(1 / b.zoom))
    }
}
,
fengmap.MapLabel.prototype.makeTextSprite_ = function(a, b) {
    void 0 === b && (b = {});
    var c = b.hasOwnProperty("fontface") ? b.fontface : '"Microsoft Yahei","",Tahoma,Arial'
      , d = b.hasOwnProperty("fontsize") ? b.fontsize : 36;
    d = Math.ceil(d * this.scaleRatio_);
    var e = b.hasOwnProperty("color") ? b.color : "rgba(0,0,0,1)"
      , f = b.hasOwnProperty("borderThickness") ? b.borderThickness : 2
      , g = b.hasOwnProperty("borderColor") ? b.borderColor : "rgba(150,150,150,1)"
      , h = fengmap.MapUtil.getPlatform().isPC;
    f *= h ? 3 : 2;
    var i = d * (h && d <= 36 ? 1.1 : 1);
    _font = i + "px " + c;
    var j = document.createElement("canvas")
      , k = j.getContext("2d");
    k.font = _font;
    var l = k.measureText(a);
    j.width = Math.ceil(l.width + 2 * f),
    j.height = Math.ceil(i + 4 * f),
    k.font = _font,
    k.imageSmoothingEnabled = !0,
    k.strokeStyle = g,
    k.lineWidth = f,
    k.strokeText(a, f, i + 2 * f),
    k.fillStyle = e,
    k.fillText(a, f, i + 2 * f),
    this.width_ = j.width,
    this.height_ = j.height;
    var m = new fm.Texture(j);
    m.minFilter = fm.LinearFilter,
    m.anisotropy = fengmap.MapView.instance.renderer.getMaxAnisotropy(),
    m.generateMipmaps = !1,
    m.needsUpdate = !0,
    this.material_ ? this.material_.map = m : this.material_ = new fm.SpriteMaterial({
        map: m
    })
}
,
fengmap.MapLabel.prototype.updateStyle = function(a) {
    this.makeTextSprite_(this.message, {
        fontsize: 2 * a.fontsize,
        borderThickness: 2,
        color: fengmap.MapUtil.toRgba(a.fillcolor),
        borderColor: fengmap.MapUtil.toRgba(a.strokecolor)
    })
}
,
function() {
    function a(a) {
        for (var b, c = [], g = 2 * Math.PI / a.segments, j = 0; j < a.segments; j++) {
            var k = new fm.Vector3(0,a.radius * Math.sin(g * j),a.radius * Math.cos(g * j));
            c.push(k),
            0 == j && (b = k)
        }
        c.push(b);
        var l, m, n, o, p = a.pathVertices.length, q = d(a.pathVertices);
        a.length = q.length,
        a.center = q.center,
        e(a.pathVertices, a.center),
        a.perimeter = 2 * Math.PI * a.radius;
        var r, s = 0, t = 0;
        uvY_delta = a.perimeter / a.segments,
        h = [];
        for (var j = (new fm.Vector3(0,1,0),
        0); j < p; j++) {
            l = 0 == j ? null : a.pathVertices[j - 1],
            n = j == p - 1 ? null : a.pathVertices[j + 1],
            m = a.pathVertices[j],
            o = f(l, m, n),
            j > 0 && (s += m.distanceTo(l)),
            t = 0,
            i[j] = [];
            for (var u = 0; u < c.length; u++)
                r = c[u].clone().applyMatrix4(o),
                a.vertices.push(r),
                i[j].push(r),
                h.push(new fm.Vector2(s / a.length,1 - t / a.perimeter)),
                t += uvY_delta
        }
    }
    function b(a) {
        for (var b, c = a.pathVertices.length, d = a.segments + 1, e = 0; e < c - 1; e++) {
            b = e * d;
            for (var f = 0; f < d - 1; f++)
                a.faces.push(new fm.Face3(b + f + 1,b + f,b + d + f)),
                a.faces.push(new fm.Face3(b + f + 1,b + f + d,b + d + f + 1))
        }
    }
    function c(a) {
        for (var b = a.faces.length, c = 0; c < b; c++) {
            var d = a.faces[c];
            a.faceVertexUvs[0].push([h[d.a], h[d.b], h[d.c]])
        }
        a.uvsNeedUpdate = !0
    }
    function d(a) {
        for (var b = 0, c = new fm.Vector3, d = 1; d < a.length; d++)
            b += a[d].distanceTo(a[d - 1]),
            c.add(a[d]);
        return {
            length: b,
            center: c.divideScalar(a.length)
        }
    }
    function e(a, b) {
        a.forEach(function(a) {
            a.sub(b)
        })
    }
    function f(a, b, c) {
        var d, e = a && a.clone(), f = b.clone(), g = c && c.clone();
        d = a ? c ? f.clone().sub(e).normalize().add(g.sub(f).normalize()).normalize() : f.sub(e).normalize() : g.sub(f).normalize();
        var h = j || new fm.Vector3(0,1,0)
          , i = (new fm.Vector3).crossVectors(d, h).normalize()
          , k = (new fm.Vector3).crossVectors(i, d).normalize();
        return j = k.clone(),
        (new fm.Matrix4).makeBasis(d, k, i).setPosition(b)
    }
    fengmap.MapNavLineGeometry = function(a) {
        var b = this;
        if (fm.Geometry.call(this),
        b.pathVertices = null ,
        b.radius = 1,
        b.segments = 6,
        b.uvBaseLen = 1,
        a) {
            var c = Object.keys(a);
            c.forEach(function(c) {
                b[c] = a[c]
            })
        }
        g(b)
    }
    ,
    fengmap.MapNavLineGeometry.prototype = Object.create(fm.Geometry.prototype),
    fengmap.MapNavLineGeometry.prototype.constructor = fengmap.MapNavLineGeometry,
    fengmap.MapNavLineGeometry.prototype.setRadius = function(a) {
        for (var b = this, c = 0, d = 0; d < i.length; d++) {
            var e = i[d]
              , f = b.pathVertices[d];
            if (f)
                for (var g = 0; g < e.length; g++) {
                    var h = e[g]
                      , j = f.clone().add(h.clone().sub(f).normalize().multiplyScalar(a));
                    b.vertices[c].copy(j),
                    c++
                }
        }
        a < .1 && (a = .1),
        b.radius = a,
        b.verticesNeedUpdate = !0
    }
    ;
    var g = function(d) {
        return !d.pathVertices || d.pathVertices.length < 2 ? void console.warn("MapNavLineGeometry: The pathVertices parameter is null!") : (a(d),
        b(d),
        c(d),
        void d.computeFaceNormals())
    }
      , h = []
      , i = []
      , j = null
}(),
fengmap.MapPoi = function(a, b, c) {
    this.data_ = b,
    this.data_.gid = a,
    b.vertex && (this.data_.x_ = b.vertex[0],
    this.data_.y_ = b.vertex[1]);
    var d;
    fengmap.MapPoi._mats = fengmap.MapPoi._mats || {},
    d = fengmap.MapPoi._mats[a + "_" + b.type],
    d || (d = c.getPoiMaterialByType(b.type),
    fengmap.MapPoi._mats[a + "_" + b.type] = d),
    fm.Sprite.call(this, d),
    this.scale.set(10, 10, 10),
    this.width_ = d.size,
    this.height_ = d.size
}
,
fengmap.MapPoi.prototype = new fm.Sprite,
fengmap.MapPoi.prototype.updateScreenSize = function(a) {
    fengmap.MapLabel.prototype.updateScreenSize.call(this, a)
}
,
fengmap.MapPoi2 = function(a, b, c) {
    this.data_ = b,
    this.data_.gid = a;
    var d = fengmap.MapUtil.loadTexture(c)
      , e = new fm.SpriteMaterial({
        map: d
    })
      , f = b.size_ / 32;
    fm.Sprite.call(this, e);
    var g = 10 * f;
    this.scale.set(g, g, g),
    this.width_ = 32 * f,
    this.height_ = 32 * f
}
,
fengmap.MapPoi2.prototype = new fm.Sprite,
fengmap.MapPoi2.prototype.updateScreenSize = function(a) {
    fengmap.MapLabel.prototype.updateScreenSize.call(this, a)
}
,
fengmap.MapPoi3 = function(a, b, c) {
    this.data_ = b,
    this.data_.gid = a;
    var d = fengmap.MapUtil.loadTexture(c)
      , e = new fm.MeshLambertMaterial({
        map: d,
        transparent: !0
    });
    e.doubleSided = !0,
    e.alphaTest = .5,
    e.depthWrite = !1;
    var f = b.size_ / 32
      , g = new fm.PlaneGeometry(1,1,1,1);
    fm.Mesh.call(this, g, e),
    this.scale.set(10 * f, 10 * f, 10 * f),
    this.rotation.set(-Math.PI / 2, 0, Math.PI, "XYZ"),
    this.width_ = 32 * f,
    this.height_ = 32 * f
}
,
fengmap.MapPoi3.prototype = Object.create(fm.Mesh.prototype),
fengmap.MapPoi3.prototype.constructor = fengmap.MapPoi3,
Object.assign(fengmap.MapPoi3.prototype, {
    updateScreenSize: function(a) {
        fengmap.MapLabel.prototype.updateScreenSize.call(this, a)
    }
}),
fengmap.appendMapPoi__ = {
    setUrl: function(a) {
        this.material = new fm.SpriteMaterial({
            map: fengmap.MapUtil.loadTexture(a)
        })
    }
},
Object.assign(fengmap.MapPoi2.prototype, fengmap.appendMapPoi__),
Object.assign(fengmap.MapPoi3.prototype, fengmap.appendMapPoi__),
fengmap.MapScene = function(a, b) {
    this.map_ = a,
    this.mapTheme_ = b,
    this.scene_ = null ,
    this.sceneX_ = 0,
    this.sceneZ_ = 0,
    this.groups_ = {},
    this.o3dScene_ = null ,
    this.o3dGroups_ = {},
    this.userGroups_ = {},
    this.o3dNavigation_ = null ,
    this.box3_ = null ,
    this.minX_ = 0,
    this.minY_ = 0,
    this.maxX_ = 0,
    this.maxY_ = 0
}
,
fengmap.MapScene.prototype = {
    clear: function() {},
    setScene: function(a) {
        this.scene_ = a,
        this.sceneX_ = this.scene_.scene_data.defCenX,
        this.sceneZ_ = this.scene_.scene_data.defCenY,
        this.o3dScene_ = new fm.Object3D,
        this.o3dNavigation_ = new fm.Object3D,
        this.o3dScene_.add(this.o3dNavigation_),
        this.box3_ = fengmap.MapSceneUtil.calcSceneBox3(this.scene_.scene_data),
        this.minX_ = this.scene_.scene_data.minX,
        this.maxX_ = this.scene_.scene_data.maxX,
        this.minY_ = this.scene_.scene_data.minY,
        this.maxY_ = this.scene_.scene_data.maxY
    },
    calcInitCamera: function() {
        return fengmap.MapSceneUtil.calcInitCamera(this.box3_)
    },
    getO3dScene: function() {
        return this.o3dScene_
    },
    forEachGroups: function(a) {
        var b = this.scene_.scene_data.layerGroups;
        for (var c in b) {
            var d = b[c];
            this.groups_[d.gid] = d,
            a(d)
        }
    },
    groupLength_: function() {
        return this.scene_.scene_data.layerGroups.length
    },
    putGroup: function(a, b) {
        var c = this.groups_[a];
        c.a_ = b;
        var d = new fengmap.FMGroup(this,c)
          , e = d.o3d_;
        e.visible = !1,
        e.meta_ = c,
        e.position.set(0, c.elevation, 0),
        this.o3dGroups_[a] = e,
        this.o3dScene_.add(e)
    },
    setGroupLabelVisible: function(a, b) {
        console.warn("Deprecated!")
    },
    setGroupPoiVisible: function(a, b) {
        console.warn("Deprecated!")
    },
    getO3dGroup: function(a) {
        return this.o3dGroups_[a]
    },
    forEachGroupModel: function(a, b) {
        var c = this.getO3dGroup(a)
          , d = this.groups_[a].a_
          , e = d.geo_extentlayers;
        for (var f in e) {
            var g = e[f]
              , h = new fengmap.FMExtentLayer(g);
            c.add(h.o3d_);
            var i = g.extents;
            for (var j in i) {
                var k = i[j]
                  , l = 1;
                k.hasOwnProperty("height") && null != k.height && k.height > 0 && (l = k.height);
                var m = this.createGeometry_(k, l);
                if (m) {
                    var n = new fm.Mesh(m.geometry);
                    n.rotation.set(Math.PI / 2, 0, 0, "XYZ"),
                    n.position.setY(fengmap.MapConfiguration.EXTENT_EPSILON_Y),
                    n.fm_ = {
                        nodeType: fengmap.FMNodeType.FLOOR
                    },
                    h.o3d_.add(n),
                    n.material = new fm.MeshLambertMaterial({
                        color: this.mapTheme_.floorColor_
                    }),
                    n.material.transparent = !0,
                    n.material.opacity = this.mapTheme_.floorOpacity_
                }
            }
        }
        var o = null ;
        for (var f in d.geo_modellayers) {
            var p = d.geo_modellayers[f]
              , q = new fengmap.FMModelLayer(p);
            c.add(q.o3d_);
            var r = new fengmap.FMLayer(p,fengmap.FMLayerType.MODEL_LINE);
            c.add(r.o3d_);
            var s = null
              , i = p.models;
            for (var j in i) {
                var k = i[j]
                  , l = 5;
                k.hasOwnProperty("height") && null != k.height && k.height > 0 && (l = k.height);
                var m = this.createGeometry_(k, l);
                if (m) {
                    var t = this.mapTheme_.getModelTheme(k)
                      , n = new fengmap.ModelMesh(m.geometry,this.mapTheme_);
                    n.rotation.set(Math.PI / 2, 0, 0, "XYZ"),
                    n.position.setY(l),
                    n.meta_ = k,
                    n.meta_.theme_ = t,
                    n.meta_.type_ = "Model",
                    q.o3d_.add(n);
                    var u = new fengmap.FMModel(k,n,this);
                    b(n);
                    var v = m.shape.createPointsGeometry();
                    v && v.vertices.length > 0 && v.vertices.push(v.vertices[0]);
                    for (var w = [], x = v.vertices.length, f = 0; f < x; f++)
                        0 == f || f == x - 1 ? w.push(v.vertices[f]) : w.push(v.vertices[f], v.vertices[f]);
                    v.vertices = w;
                    var y = {
                        color: t.strokeColor_,
                        linewidth: t.strokeWidth
                    };
                    o && s == k.type || (s = k.type,
                    o = new fm.LineBasicMaterial(y));
                    var z = new fm.LineSegments(v,o);
                    z.fm_ = {
                        nodeType: fengmap.FMNodeType.LINE,
                        typeID: u.typeID
                    },
                    z.rotation.set(Math.PI / 2, 0, 0, "XYZ"),
                    z.position.setY(l + .005 * l),
                    r.o3d_.add(z)
                }
            }
        }
        for (var f in d.geo_labellayers) {
            var A = d.geo_labellayers[f]
              , B = new fengmap.FMLabelLayer(A);
            c.add(B.o3d_),
            B.o3d_.boxCollision_ = new fengmap.MapBoxCollision;
            var C = A.labels;
            for (var j in C) {
                var D = C[j];
                if ("" != D.name) {
                    var E = D.height >= 0 ? D.height : 6
                      , F = new fengmap.MapLabel(a,D,this.mapTheme_.labelStyle_,this.map_);
                    new fengmap.FMLabel(D,F,this);
                    F.visible = !1,
                    B.o3d_.add(F),
                    F.position.set(D.vertex[0] - this.sceneX_, E, D.vertex[1] - this.sceneZ_),
                    this.map_.mapPicker.addLabel(F)
                }
            }
        }
        for (var f in d.geo_poilayers) {
            var G = d.geo_poilayers[f]
              , H = new fengmap.FMFacilityLayer(G);
            c.add(H.o3d_),
            H.o3d_.boxCollision_ = new fengmap.MapBoxCollision;
            var I = G.pois;
            for (var j in I) {
                var J = I[j]
                  , K = new fengmap.MapPoi(a,J,this.mapTheme_);
                new fengmap.FMFacility(J,K,this);
                H.o3d_.add(K),
                K.position.set(J.vertex[0] - this.sceneX_, 6, J.vertex[1] - this.sceneZ_),
                this.map_.mapPicker.addPOI(K)
            }
        }
    },
    collideLabel_: function(a, b) {
        var c = b.boxCollision_
          , d = b.fm_.requireCollide_;
        c.clear();
        for (var e in b.children) {
            var f = b.children[e];
            if (f.forceVisible_) {
                var g = this.map_.project_(f)
                  , h = f.width_ / 2
                  , i = f.height_ / 2;
                d && c.push(f, {
                    x: g.x - h / 2,
                    y: g.y - i / 2,
                    w: h,
                    h: i
                }) ? f.visible = !1 : (f.visible = !0,
                f.updateScreenSize(a))
            }
        }
    },
    updateCollide: function(a) {
        for (var b in this.o3dGroups_) {
            var c = this.o3dGroups_[b];
            if (c.visible)
                for (var d = 0; d < c.children.length; d++) {
                    var e = c.children[d]
                      , f = e.fm_;
                    f && f.visible && (f instanceof fengmap.FMLabelLayer || f instanceof fengmap.FMTextMarkerLayer ? this.collideLabel_(a, e) : (f instanceof fengmap.FMFacilityLayer || f instanceof fengmap.FMImageMarkerLayer || f instanceof fengmap.FMLocationMarkerLayer) && this.collideLabel_(a, e))
                }
        }
    },
    drawNavigation: function(a) {
        function b() {
            x.material.map.offset.x -= c.map_.timer.getDelta() * (o.dash.speed || 1);
            var a = c.map_.mapView
              , b = a.camera
              , d = x.localToWorld(new fm.Vector3(0,0,0)).distanceTo(b.position)
              , e = d / a.h_ * .3;
            if ("3d" == a.map_.viewMode_) {
                if (0 == a.h_)
                    return;
                u.setRadius(e * o.lineWidth * .7),
                x.material.map.repeat.x = Math.ceil(v * Math.pow(1 - e, 1))
            } else
                u.setRadius(e * o.lineWidth * .7 / a.map_.currentCamera_.zoom)
        }
        this.clearNavigation();
        var c = this
          , d = []
          , e = null
          , f = a.results;
        for (var g in f) {
            var h = f[g]
              , i = this.o3dGroups_[h.groupid]
              , j = 0;
            i && (j = i.position.y + 3);
            var k = h.points;
            for (var l in k) {
                var m = k[l]
                  , n = new fm.Vector3(-m.x - this.sceneX_,j,m.y - this.sceneZ_);
                null != e && e.equals(n) || d.push(n),
                e = n
            }
        }
        d = fengmap.MapSceneUtil.buildCurvePoints(d);
        var o = this.mapTheme_.navigateStyle_
          , p = document.createElement("canvas")
          , q = p.getContext("2d");
        p.width = 128,
        p.height = 128,
        q.fillStyle = "string" == typeof o.color ? o.color : "#" + o.color.toString(16);
        var r = 1
          , s = p.width;
        o.dash || (o.dash = {
            size: 2,
            gap: 1
        }),
        o.dash && (r = o.dash.size + o.dash.gap,
        s = p.width * o.dash.size / r),
        q.fillRect(0, 0, s, 128);
        var t = new fm.Texture(p);
        t.minFilter = fm.NearestFilter,
        t.needsUpdate = !0;
        var u = new fengmap.MapNavLineGeometry({
            radius: o.lineWidth,
            pathVertices: d,
            uvBaseLen: r
        });
        t.wrapS = t.wrapT = fm.RepeatWrapping;
        var v = Math.ceil(u.length / u.uvBaseLen);
        t.repeat.x = v,
        t.repeat.y = 1,
        t.needsUpdate = !0;
        var w = new fm.MeshBasicMaterial({
            color: o.color,
            opacity: o.alpha
        });
        w.transparent = !0,
        w.map = t,
        w.depthTest = !1;
        var x = new fm.Mesh(u,w);
        x.position.copy(u.center),
        x.renderOrder = 1,
        this.o3dNavigation_.add(x),
        o.dash && (c.map_.addUpdate(b),
        x._beforeDead = function() {
            c.map_.removeUpdate(b)
        }
        )
    },
    clearNavigation: function() {
        for (var a = this.o3dNavigation_.children, b = a.length - 1; b >= 0; b--)
            a[b]._beforeDead && a[b]._beforeDead(),
            this.o3dNavigation_.remove(a[b])
    },
    drawLineMark: function(a) {
        var b = {
            results: a.segments
        };
        this.drawNavigation(b)
    },
    clearLineMark: function(a) {
        this.clearNavigation()
    },
    createGeometry_: function(a, b) {
        var c = a.vertices;
        if (c.length >= 6) {
            var d, e = new fm.Shape, f = this.sceneX_, g = this.sceneZ_;
            if (a.holes && a.holes.length > 0) {
                var h = {};
                for (var i in a.holes)
                    for (var j = a.holes[i], k = 0; k < j.length; k += 2) {
                        var l = "" + j[k] + "-" + j[k + 1];
                        h[l] = !0
                    }
                this.forEachVertForShape_(c, function(a, b, c) {
                    a ? e.moveTo(b - f, c - g) : h["" + b + "-" + c] || e.lineTo(b - f, c - g)
                });
                for (var i in a.holes) {
                    var j = a.holes[i]
                      , m = new fm.Path;
                    this.forEachVertForShape_(j, function(a, b, c) {
                        a ? m.moveTo(b - f, c - g) : m.lineTo(b - f, c - g)
                    }),
                    e.holes.push(m)
                }
            } else
                this.forEachVertForShape_(c, function(a, b, c) {
                    a ? e.moveTo(b - f, c - g) : e.lineTo(b - f, c - g)
                });
            return d = new fm.ExtrudeGeometry(e,{
                amount: b,
                bevelEnabled: !1
            }),
            {
                geometry: d,
                shape: e
            }
        }
        return null
    },
    forEachVertForShape_: function(a, b) {
        var c = 0;
        for (b(!0, a[c], a[c + 1]),
        c = 2; c < a.length; c += 2)
            b(!1, a[c], a[c + 1]);
        c = 0,
        b(!1, a[c], a[c + 1])
    }
},
fengmap.MapSceneUtil = {},
fengmap.MapSceneUtil.calcSceneBox3 = function(a) {
    var b = Number.POSITIVE_INFINITY
      , c = Number.NEGATIVE_INFINITY
      , d = a.layerGroups;
    for (var e in d) {
        var f = d[e].elevation;
        b = Math.min(b, f),
        c = Math.max(c, f)
    }
    return new fm.Box3(new fm.Vector3(a.minX,b,a.minY),new fm.Vector3(a.maxX,c,a.maxY))
}
,
fengmap.MapSceneUtil.calcInitCamera = function(a) {
    var b = a.center()
      , c = a.size();
    return {
        target: new fm.Vector3(0,b.y,0),
        position: new fm.Vector3(1 * c.x,b.y + .75 * c.x,1 * -c.x)
    }
}
,
fengmap.MapSceneUtil.buildCurvePoints = function(a) {
    if (a.length >= 3) {
        for (var b = Math.PI / 90, c = Math.PI - b, d = 1, e = 8, f = 1 / e, g = [], h = 0; h < a.length - 2; ) {
            var i = a[h].clone()
              , j = a[h + 1].clone()
              , k = a[h + 2].clone()
              , l = i.clone().sub(j)
              , m = k.clone().sub(j)
              , n = l.angleTo(m)
              , o = l.length()
              , p = m.length();
            if (g.push(i),
            n > b && n < c && o > d && p > d) {
                var q = j.clone().lerp(i, d / o)
                  , r = j.clone().lerp(k, d / p);
                g.push(q);
                for (var s = f; s < .999999; s += f) {
                    var t = s / d
                      , u = q.clone().lerp(j, t)
                      , v = j.clone().lerp(r, t);
                    g.push(u.lerp(v, t))
                }
                a[h + 1] = r,
                h++
            } else
                h++;
            h == a.length - 2 && g.push(k)
        }
        return g
    }
    return a
}
,
fengmap.ModelMesh = function(a, b) {
    fm.Mesh.call(this, a),
    this.mapTheme_ = b,
    this.mouseSelected_ = !1,
    this.selected_ = !1,
    this.defaultMaterial_ = null ,
    this.selectedMaterial_ = null
}
,
fengmap.ModelMesh.prototype = Object.create(fm.Mesh.prototype),
fengmap.ModelMesh.prototype.constructor = fengmap.ModelMesh,
fengmap.ModelMesh.prototype.setDefaultTheme_ = function() {
    this.material.color = new fm.Color(this.meta_.theme_.color_)
}
,
fengmap.ModelMesh.prototype.setSelectedTheme_ = function(a) {
    var b = void 0 == a ? this.mapTheme_.selectedColor_ : a;
    this.material.color = new fm.Color(b)
}
,
Object.defineProperty(fengmap.ModelMesh.prototype, "mouseSelected", {
    set: function(a) {
        a != this.mouseSelected_ && (this.mouseSelected_ = a,
        this.selected_ || this.mouseSelected_ ? this.setSelectedTheme_() : this.setDefaultTheme_())
    },
    get: function() {
        return this.mouseSelected_
    }
}),
Object.defineProperty(fengmap.ModelMesh.prototype, "selected", {
    set: function(a) {
        a != this.selected_ && (this.selected_ = a,
        this.selected_ || this.mouseSelected_ ? this.setSelectedTheme_() : this.setDefaultTheme_())
    },
    get: function() {
        return this.selected_
    }
}),
Object.defineProperty(fengmap.ModelMesh.prototype, "selectedColor", {
    set: function(a) {
        a = new fm.Color(a),
        this.setSelectedTheme_(a)
    },
    get: function() {
        return this.selectedMaterial_ ? this.selectedMaterial_.color : this.mapTheme_.selectedColor_
    }
}),
Long.__isLong__,
Object.defineProperty(Long.prototype, "__isLong__", {
    value: !0,
    enumerable: !1,
    configurable: !1
}),
Long.isLong = isLong;
var INT_CACHE = {}
  , UINT_CACHE = {};
Long.fromInt = fromInt,
Long.fromNumber = fromNumber,
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
Long.fromString = fromString,
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 65536
  , TWO_PWR_24_DBL = 1 << 24
  , TWO_PWR_32_DBL = 4294967296
  , TWO_PWR_64_DBL = 0x10000000000000000
  , TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2
  , TWO_PWR_24 = fromInt(TWO_PWR_24_DBL)
  , ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, !0);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, !0);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(-1, 2147483647, !1);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, -2147483648, !1);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function() {
    return this.unsigned ? this.low >>> 0 : this.low
}
,
LongPrototype.toNumber = function() {
    return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0)
}
,
LongPrototype.toString = function(a) {
    if (a = a || 10,
    a < 2 || 36 < a)
        throw RangeError("radix");
    if (this.isZero())
        return "0";
    if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
            var b = fromNumber(a)
              , c = this.div(b)
              , d = c.mul(b).sub(this);
            return c.toString(a) + d.toInt().toString(a)
        }
        return "-" + this.neg().toString(a)
    }
    for (var e = fromNumber(pow_dbl(a, 6), this.unsigned), f = this, g = ""; ; ) {
        var h = f.div(e)
          , i = f.sub(h.mul(e)).toInt() >>> 0
          , j = i.toString(a);
        if (f = h,
        f.isZero())
            return j + g;
        for (; j.length < 6; )
            j = "0" + j;
        g = "" + j + g
    }
}
,
LongPrototype.getHighBits = function() {
    return this.high
}
,
LongPrototype.getHighBitsUnsigned = function() {
    return this.high >>> 0
}
,
LongPrototype.getLowBits = function() {
    return this.low
}
,
LongPrototype.getLowBitsUnsigned = function() {
    return this.low >>> 0
}
,
LongPrototype.getNumBitsAbs = function() {
    if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    for (var a = 0 != this.high ? this.high : this.low, b = 31; b > 0 && 0 == (a & 1 << b); b--)
        ;
    return 0 != this.high ? b + 33 : b + 1
}
,
LongPrototype.isZero = function() {
    return 0 === this.high && 0 === this.low
}
,
LongPrototype.isNegative = function() {
    return !this.unsigned && this.high < 0
}
,
LongPrototype.isPositive = function() {
    return this.unsigned || this.high >= 0
}
,
LongPrototype.isOdd = function() {
    return 1 === (1 & this.low)
}
,
LongPrototype.isEven = function() {
    return 0 === (1 & this.low)
}
,
LongPrototype.equals = function(a) {
    return isLong(a) || (a = fromValue(a)),
    (this.unsigned === a.unsigned || this.high >>> 31 !== 1 || a.high >>> 31 !== 1) && (this.high === a.high && this.low === a.low)
}
,
LongPrototype.eq = LongPrototype.equals,
LongPrototype.notEquals = function(a) {
    return !this.eq(a)
}
,
LongPrototype.neq = LongPrototype.notEquals,
LongPrototype.lessThan = function(a) {
    return this.comp(a) < 0
}
,
LongPrototype.lt = LongPrototype.lessThan,
LongPrototype.lessThanOrEqual = function(a) {
    return this.comp(a) <= 0
}
,
LongPrototype.lte = LongPrototype.lessThanOrEqual,
LongPrototype.greaterThan = function(a) {
    return this.comp(a) > 0
}
,
LongPrototype.gt = LongPrototype.greaterThan,
LongPrototype.greaterThanOrEqual = function(a) {
    return this.comp(a) >= 0
}
,
LongPrototype.gte = LongPrototype.greaterThanOrEqual,
LongPrototype.compare = function(a) {
    if (isLong(a) || (a = fromValue(a)),
    this.eq(a))
        return 0;
    var b = this.isNegative()
      , c = a.isNegative();
    return b && !c ? -1 : !b && c ? 1 : this.unsigned ? a.high >>> 0 > this.high >>> 0 || a.high === this.high && a.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(a).isNegative() ? -1 : 1
}
,
LongPrototype.comp = LongPrototype.compare,
LongPrototype.negate = function() {
    return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE)
}
,
LongPrototype.neg = LongPrototype.negate,
LongPrototype.add = function(a) {
    isLong(a) || (a = fromValue(a));
    var b = this.high >>> 16
      , c = 65535 & this.high
      , d = this.low >>> 16
      , e = 65535 & this.low
      , f = a.high >>> 16
      , g = 65535 & a.high
      , h = a.low >>> 16
      , i = 65535 & a.low
      , j = 0
      , k = 0
      , l = 0
      , m = 0;
    return m += e + i,
    l += m >>> 16,
    m &= 65535,
    l += d + h,
    k += l >>> 16,
    l &= 65535,
    k += c + g,
    j += k >>> 16,
    k &= 65535,
    j += b + f,
    j &= 65535,
    fromBits(l << 16 | m, j << 16 | k, this.unsigned)
}
,
LongPrototype.subtract = function(a) {
    return isLong(a) || (a = fromValue(a)),
    this.add(a.neg())
}
,
LongPrototype.sub = LongPrototype.subtract,
LongPrototype.multiply = function(a) {
    if (this.isZero())
        return ZERO;
    if (isLong(a) || (a = fromValue(a)),
    a.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return a.isOdd() ? MIN_VALUE : ZERO;
    if (a.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative())
        return a.isNegative() ? this.neg().mul(a.neg()) : this.neg().mul(a).neg();
    if (a.isNegative())
        return this.mul(a.neg()).neg();
    if (this.lt(TWO_PWR_24) && a.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * a.toNumber(), this.unsigned);
    var b = this.high >>> 16
      , c = 65535 & this.high
      , d = this.low >>> 16
      , e = 65535 & this.low
      , f = a.high >>> 16
      , g = 65535 & a.high
      , h = a.low >>> 16
      , i = 65535 & a.low
      , j = 0
      , k = 0
      , l = 0
      , m = 0;
    return m += e * i,
    l += m >>> 16,
    m &= 65535,
    l += d * i,
    k += l >>> 16,
    l &= 65535,
    l += e * h,
    k += l >>> 16,
    l &= 65535,
    k += c * i,
    j += k >>> 16,
    k &= 65535,
    k += d * h,
    j += k >>> 16,
    k &= 65535,
    k += e * g,
    j += k >>> 16,
    k &= 65535,
    j += b * i + c * h + d * g + e * f,
    j &= 65535,
    fromBits(l << 16 | m, j << 16 | k, this.unsigned)
}
,
LongPrototype.mul = LongPrototype.multiply,
LongPrototype.divide = function(a) {
    if (isLong(a) || (a = fromValue(a)),
    a.isZero())
        throw Error("division by zero");
    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var b, c, d;
    if (this.eq(MIN_VALUE)) {
        if (a.eq(ONE) || a.eq(NEG_ONE))
            return MIN_VALUE;
        if (a.eq(MIN_VALUE))
            return ONE;
        var e = this.shr(1);
        return b = e.div(a).shl(1),
        b.eq(ZERO) ? a.isNegative() ? ONE : NEG_ONE : (c = this.sub(a.mul(b)),
        d = b.add(c.div(a)))
    }
    if (a.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO;
    if (this.isNegative())
        return a.isNegative() ? this.neg().div(a.neg()) : this.neg().div(a).neg();
    if (a.isNegative())
        return this.div(a.neg()).neg();
    for (d = ZERO,
    c = this; c.gte(a); ) {
        b = Math.max(1, Math.floor(c.toNumber() / a.toNumber()));
        for (var f = Math.ceil(Math.log(b) / Math.LN2), g = f <= 48 ? 1 : pow_dbl(2, f - 48), h = fromNumber(b), i = h.mul(a); i.isNegative() || i.gt(c); )
            b -= g,
            h = fromNumber(b, this.unsigned),
            i = h.mul(a);
        h.isZero() && (h = ONE),
        d = d.add(h),
        c = c.sub(i)
    }
    return d
}
,
LongPrototype.div = LongPrototype.divide,
LongPrototype.modulo = function(a) {
    return isLong(a) || (a = fromValue(a)),
    this.sub(this.div(a).mul(a))
}
,
LongPrototype.mod = LongPrototype.modulo,
LongPrototype.not = function() {
    return fromBits(~this.low, ~this.high, this.unsigned)
}
,
LongPrototype.and = function(a) {
    return isLong(a) || (a = fromValue(a)),
    fromBits(this.low & a.low, this.high & a.high, this.unsigned)
}
,
LongPrototype.or = function(a) {
    return isLong(a) || (a = fromValue(a)),
    fromBits(this.low | a.low, this.high | a.high, this.unsigned)
}
,
LongPrototype.xor = function(a) {
    return isLong(a) || (a = fromValue(a)),
    fromBits(this.low ^ a.low, this.high ^ a.high, this.unsigned)
}
,
LongPrototype.shiftLeft = function(a) {
    return isLong(a) && (a = a.toInt()),
    0 === (a &= 63) ? this : a < 32 ? fromBits(this.low << a, this.high << a | this.low >>> 32 - a, this.unsigned) : fromBits(0, this.low << a - 32, this.unsigned)
}
,
LongPrototype.shl = LongPrototype.shiftLeft,
LongPrototype.shiftRight = function(a) {
    return isLong(a) && (a = a.toInt()),
    0 === (a &= 63) ? this : a < 32 ? fromBits(this.low >>> a | this.high << 32 - a, this.high >> a, this.unsigned) : fromBits(this.high >> a - 32, this.high >= 0 ? 0 : -1, this.unsigned)
}
,
LongPrototype.shr = LongPrototype.shiftRight,
LongPrototype.shiftRightUnsigned = function(a) {
    if (isLong(a) && (a = a.toInt()),
    a &= 63,
    0 === a)
        return this;
    var b = this.high;
    if (a < 32) {
        var c = this.low;
        return fromBits(c >>> a | b << 32 - a, b >>> a, this.unsigned)
    }
    return 32 === a ? fromBits(b, 0, this.unsigned) : fromBits(b >>> a - 32, 0, this.unsigned)
}
,
LongPrototype.shru = LongPrototype.shiftRightUnsigned,
LongPrototype.toSigned = function() {
    return this.unsigned ? fromBits(this.low, this.high, !1) : this
}
,
LongPrototype.toUnsigned = function() {
    return this.unsigned ? this : fromBits(this.low, this.high, !0)
}
;
var ByteBuffer = function(a, b, c) {
    if ("undefined" == typeof a && (a = ByteBuffer.DEFAULT_CAPACITY),
    "undefined" == typeof b && (b = ByteBuffer.DEFAULT_ENDIAN),
    "undefined" == typeof c && (c = ByteBuffer.DEFAULT_NOASSERT),
    !c) {
        if (a = 0 | a,
        a < 0)
            throw RangeError("Illegal capacity");
        b = !!b,
        c = !!c
    }
    this.buffer = 0 === a ? EMPTY_BUFFER : new ArrayBuffer(a),
    this.view = 0 === a ? null : new Uint8Array(this.buffer),
    this.offset = 0,
    this.markedOffset = -1,
    this.limit = a,
    this.littleEndian = b,
    this.noAssert = c
}
;
ByteBuffer.VERSION = "5.0.1",
ByteBuffer.LITTLE_ENDIAN = !0,
ByteBuffer.BIG_ENDIAN = !1,
ByteBuffer.DEFAULT_CAPACITY = 16,
ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN,
ByteBuffer.DEFAULT_NOASSERT = !1,
ByteBuffer.Long = Long || null ;
var ByteBufferPrototype = ByteBuffer.prototype;
ByteBufferPrototype.__isByteBuffer__,
Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
    value: !0,
    enumerable: !1,
    configurable: !1
});
var EMPTY_BUFFER = new ArrayBuffer(0)
  , stringFromCharCode = String.fromCharCode;
ByteBuffer.accessor = function() {
    return Uint8Array
}
,
ByteBuffer.allocate = function(a, b, c) {
    return new ByteBuffer(a,b,c)
}
,
ByteBuffer.concat = function(a, b, c, d) {
    "boolean" != typeof b && "string" == typeof b || (d = c,
    c = b,
    b = void 0);
    for (var e, f = 0, g = 0, h = a.length; g < h; ++g)
        ByteBuffer.isByteBuffer(a[g]) || (a[g] = ByteBuffer.wrap(a[g], b)),
        e = a[g].limit - a[g].offset,
        e > 0 && (f += e);
    if (0 === f)
        return new ByteBuffer(0,c,d);
    var i, j = new ByteBuffer(f,c,d);
    for (g = 0; g < h; )
        i = a[g++],
        e = i.limit - i.offset,
        e <= 0 || (j.view.set(i.view.subarray(i.offset, i.limit), j.offset),
        j.offset += e);
    return j.limit = j.offset,
    j.offset = 0,
    j
}
,
ByteBuffer.isByteBuffer = function(a) {
    return (a && a.__isByteBuffer__) === !0
}
,
ByteBuffer.type = function() {
    return ArrayBuffer
}
,
ByteBuffer.wrap = function(a, b, c, d) {
    if ("string" != typeof b && (d = c,
    c = b,
    b = void 0),
    "string" == typeof a)
        switch ("undefined" == typeof b && (b = "utf8"),
        b) {
        case "base64":
            return ByteBuffer.fromBase64(a, c);
        case "hex":
            return ByteBuffer.fromHex(a, c);
        case "binary":
            return ByteBuffer.fromBinary(a, c);
        case "utf8":
            return ByteBuffer.fromUTF8(a, c);
        case "debug":
            return ByteBuffer.fromDebug(a, c);
        default:
            throw Error("Unsupported encoding: " + b)
        }
    if (null === a || "object" != typeof a)
        throw TypeError("Illegal buffer");
    var e;
    if (ByteBuffer.isByteBuffer(a))
        return e = ByteBufferPrototype.clone.call(a),
        e.markedOffset = -1,
        e;
    if (a instanceof Uint8Array)
        e = new ByteBuffer(0,c,d),
        a.length > 0 && (e.buffer = a.buffer,
        e.offset = a.byteOffset,
        e.limit = a.byteOffset + a.byteLength,
        e.view = new Uint8Array(a.buffer));
    else if (a instanceof ArrayBuffer)
        e = new ByteBuffer(0,c,d),
        a.byteLength > 0 && (e.buffer = a,
        e.offset = 0,
        e.limit = a.byteLength,
        e.view = a.byteLength > 0 ? new Uint8Array(a) : null );
    else {
        if ("[object Array]" !== Object.prototype.toString.call(a))
            throw TypeError("Illegal buffer");
        e = new ByteBuffer(a.length,c,d),
        e.limit = a.length;
        for (var f = 0; f < a.length; ++f)
            e.view[f] = a[f]
    }
    return e
}
,
ByteBufferPrototype.writeBitSet = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if (!(a instanceof Array))
            throw TypeError("Illegal BitSet: Not an array");
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    var d, e = b, f = a.length, g = f >> 3, h = 0;
    for (b += this.writeVarint32(f, b); g--; )
        d = 1 & !!a[h++] | (1 & !!a[h++]) << 1 | (1 & !!a[h++]) << 2 | (1 & !!a[h++]) << 3 | (1 & !!a[h++]) << 4 | (1 & !!a[h++]) << 5 | (1 & !!a[h++]) << 6 | (1 & !!a[h++]) << 7,
        this.writeByte(d, b++);
    if (h < f) {
        var i = 0;
        for (d = 0; h < f; )
            d |= (1 & !!a[h++]) << i++;
        this.writeByte(d, b++)
    }
    return c ? (this.offset = b,
    this) : b - e
}
,
ByteBufferPrototype.readBitSet = function(a) {
    var b = "undefined" == typeof a;
    b && (a = this.offset);
    var c, d = this.readVarint32(a), e = d.value, f = e >> 3, g = 0, h = [];
    for (a += d.length; f--; )
        c = this.readByte(a++),
        h[g++] = !!(1 & c),
        h[g++] = !!(2 & c),
        h[g++] = !!(4 & c),
        h[g++] = !!(8 & c),
        h[g++] = !!(16 & c),
        h[g++] = !!(32 & c),
        h[g++] = !!(64 & c),
        h[g++] = !!(128 & c);
    if (g < e) {
        var i = 0;
        for (c = this.readByte(a++); g < e; )
            h[g++] = !!(c >> i++ & 1)
    }
    return b && (this.offset = a),
    h
}
,
ByteBufferPrototype.readBytes = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + a > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+" + a + ") <= " + this.buffer.byteLength)
    }
    var d = this.slice(b, b + a);
    return c && (this.offset += a),
    d
}
,
ByteBufferPrototype.writeBytes = ByteBufferPrototype.append,
ByteBufferPrototype.writeInt8 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal value: " + a + " (not an integer)");
        if (a |= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    b += 1;
    var d = this.buffer.byteLength;
    return b > d && this.resize((d *= 2) > b ? d : b),
    b -= 1,
    this.view[b] = a,
    c && (this.offset += 1),
    this
}
,
ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8,
ByteBufferPrototype.readInt8 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 1 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength)
    }
    var c = this.view[a];
    return 128 === (128 & c) && (c = -(255 - c + 1)),
    b && (this.offset += 1),
    c
}
,
ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8,
ByteBufferPrototype.writeUint8 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal value: " + a + " (not an integer)");
        if (a >>>= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    b += 1;
    var d = this.buffer.byteLength;
    return b > d && this.resize((d *= 2) > b ? d : b),
    b -= 1,
    this.view[b] = a,
    c && (this.offset += 1),
    this
}
,
ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8,
ByteBufferPrototype.readUint8 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 1 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength)
    }
    var c = this.view[a];
    return b && (this.offset += 1),
    c
}
,
ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8,
ByteBufferPrototype.writeInt16 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal value: " + a + " (not an integer)");
        if (a |= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    b += 2;
    var d = this.buffer.byteLength;
    return b > d && this.resize((d *= 2) > b ? d : b),
    b -= 2,
    this.littleEndian ? (this.view[b + 1] = (65280 & a) >>> 8,
    this.view[b] = 255 & a) : (this.view[b] = (65280 & a) >>> 8,
    this.view[b + 1] = 255 & a),
    c && (this.offset += 2),
    this
}
,
ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16,
ByteBufferPrototype.readInt16 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 2 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength)
    }
    var c = 0;
    return this.littleEndian ? (c = this.view[a],
    c |= this.view[a + 1] << 8) : (c = this.view[a] << 8,
    c |= this.view[a + 1]),
    32768 === (32768 & c) && (c = -(65535 - c + 1)),
    b && (this.offset += 2),
    c
}
,
ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16,
ByteBufferPrototype.writeUint16 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal value: " + a + " (not an integer)");
        if (a >>>= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    b += 2;
    var d = this.buffer.byteLength;
    return b > d && this.resize((d *= 2) > b ? d : b),
    b -= 2,
    this.littleEndian ? (this.view[b + 1] = (65280 & a) >>> 8,
    this.view[b] = 255 & a) : (this.view[b] = (65280 & a) >>> 8,
    this.view[b + 1] = 255 & a),
    c && (this.offset += 2),
    this
}
,
ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16,
ByteBufferPrototype.readUint16 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 2 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+2) <= " + this.buffer.byteLength)
    }
    var c = 0;
    return this.littleEndian ? (c = this.view[a],
    c |= this.view[a + 1] << 8) : (c = this.view[a] << 8,
    c |= this.view[a + 1]),
    b && (this.offset += 2),
    c
}
,
ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16,
ByteBufferPrototype.writeInt32 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal value: " + a + " (not an integer)");
        if (a |= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    b += 4;
    var d = this.buffer.byteLength;
    return b > d && this.resize((d *= 2) > b ? d : b),
    b -= 4,
    this.littleEndian ? (this.view[b + 3] = a >>> 24 & 255,
    this.view[b + 2] = a >>> 16 & 255,
    this.view[b + 1] = a >>> 8 & 255,
    this.view[b] = 255 & a) : (this.view[b] = a >>> 24 & 255,
    this.view[b + 1] = a >>> 16 & 255,
    this.view[b + 2] = a >>> 8 & 255,
    this.view[b + 3] = 255 & a),
    c && (this.offset += 4),
    this
}
,
ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32,
ByteBufferPrototype.readInt32 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 4 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength)
    }
    var c = 0;
    return this.littleEndian ? (c = this.view[a + 2] << 16,
    c |= this.view[a + 1] << 8,
    c |= this.view[a],
    c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16,
    c |= this.view[a + 2] << 8,
    c |= this.view[a + 3],
    c += this.view[a] << 24 >>> 0),
    c |= 0,
    b && (this.offset += 4),
    c
}
,
ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32,
ByteBufferPrototype.writeUint32 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal value: " + a + " (not an integer)");
        if (a >>>= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    b += 4;
    var d = this.buffer.byteLength;
    return b > d && this.resize((d *= 2) > b ? d : b),
    b -= 4,
    this.littleEndian ? (this.view[b + 3] = a >>> 24 & 255,
    this.view[b + 2] = a >>> 16 & 255,
    this.view[b + 1] = a >>> 8 & 255,
    this.view[b] = 255 & a) : (this.view[b] = a >>> 24 & 255,
    this.view[b + 1] = a >>> 16 & 255,
    this.view[b + 2] = a >>> 8 & 255,
    this.view[b + 3] = 255 & a),
    c && (this.offset += 4),
    this
}
,
ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32,
ByteBufferPrototype.readUint32 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 4 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength)
    }
    var c = 0;
    return this.littleEndian ? (c = this.view[a + 2] << 16,
    c |= this.view[a + 1] << 8,
    c |= this.view[a],
    c += this.view[a + 3] << 24 >>> 0) : (c = this.view[a + 1] << 16,
    c |= this.view[a + 2] << 8,
    c |= this.view[a + 3],
    c += this.view[a] << 24 >>> 0),
    b && (this.offset += 4),
    c
}
,
ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32,
Long && (ByteBufferPrototype.writeInt64 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" == typeof a)
            a = Long.fromNumber(a);
        else if ("string" == typeof a)
            a = Long.fromString(a);
        else if (!(a && a instanceof Long))
            throw TypeError("Illegal value: " + a + " (not an integer or Long)");
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    "number" == typeof a ? a = Long.fromNumber(a) : "string" == typeof a && (a = Long.fromString(a)),
    b += 8;
    var d = this.buffer.byteLength;
    b > d && this.resize((d *= 2) > b ? d : b),
    b -= 8;
    var e = a.low
      , f = a.high;
    return this.littleEndian ? (this.view[b + 3] = e >>> 24 & 255,
    this.view[b + 2] = e >>> 16 & 255,
    this.view[b + 1] = e >>> 8 & 255,
    this.view[b] = 255 & e,
    b += 4,
    this.view[b + 3] = f >>> 24 & 255,
    this.view[b + 2] = f >>> 16 & 255,
    this.view[b + 1] = f >>> 8 & 255,
    this.view[b] = 255 & f) : (this.view[b] = f >>> 24 & 255,
    this.view[b + 1] = f >>> 16 & 255,
    this.view[b + 2] = f >>> 8 & 255,
    this.view[b + 3] = 255 & f,
    b += 4,
    this.view[b] = e >>> 24 & 255,
    this.view[b + 1] = e >>> 16 & 255,
    this.view[b + 2] = e >>> 8 & 255,
    this.view[b + 3] = 255 & e),
    c && (this.offset += 8),
    this
}
,
ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64,
ByteBufferPrototype.readInt64 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 8 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength)
    }
    var c = 0
      , d = 0;
    this.littleEndian ? (c = this.view[a + 2] << 16,
    c |= this.view[a + 1] << 8,
    c |= this.view[a],
    c += this.view[a + 3] << 24 >>> 0,
    a += 4,
    d = this.view[a + 2] << 16,
    d |= this.view[a + 1] << 8,
    d |= this.view[a],
    d += this.view[a + 3] << 24 >>> 0) : (d = this.view[a + 1] << 16,
    d |= this.view[a + 2] << 8,
    d |= this.view[a + 3],
    d += this.view[a] << 24 >>> 0,
    a += 4,
    c = this.view[a + 1] << 16,
    c |= this.view[a + 2] << 8,
    c |= this.view[a + 3],
    c += this.view[a] << 24 >>> 0);
    var e = new Long(c,d,(!1));
    return b && (this.offset += 8),
    e
}
,
ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64,
ByteBufferPrototype.writeUint64 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" == typeof a)
            a = Long.fromNumber(a);
        else if ("string" == typeof a)
            a = Long.fromString(a);
        else if (!(a && a instanceof Long))
            throw TypeError("Illegal value: " + a + " (not an integer or Long)");
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    "number" == typeof a ? a = Long.fromNumber(a) : "string" == typeof a && (a = Long.fromString(a)),
    b += 8;
    var d = this.buffer.byteLength;
    b > d && this.resize((d *= 2) > b ? d : b),
    b -= 8;
    var e = a.low
      , f = a.high;
    return this.littleEndian ? (this.view[b + 3] = e >>> 24 & 255,
    this.view[b + 2] = e >>> 16 & 255,
    this.view[b + 1] = e >>> 8 & 255,
    this.view[b] = 255 & e,
    b += 4,
    this.view[b + 3] = f >>> 24 & 255,
    this.view[b + 2] = f >>> 16 & 255,
    this.view[b + 1] = f >>> 8 & 255,
    this.view[b] = 255 & f) : (this.view[b] = f >>> 24 & 255,
    this.view[b + 1] = f >>> 16 & 255,
    this.view[b + 2] = f >>> 8 & 255,
    this.view[b + 3] = 255 & f,
    b += 4,
    this.view[b] = e >>> 24 & 255,
    this.view[b + 1] = e >>> 16 & 255,
    this.view[b + 2] = e >>> 8 & 255,
    this.view[b + 3] = 255 & e),
    c && (this.offset += 8),
    this
}
,
ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64,
ByteBufferPrototype.readUint64 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 8 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength)
    }
    var c = 0
      , d = 0;
    this.littleEndian ? (c = this.view[a + 2] << 16,
    c |= this.view[a + 1] << 8,
    c |= this.view[a],
    c += this.view[a + 3] << 24 >>> 0,
    a += 4,
    d = this.view[a + 2] << 16,
    d |= this.view[a + 1] << 8,
    d |= this.view[a],
    d += this.view[a + 3] << 24 >>> 0) : (d = this.view[a + 1] << 16,
    d |= this.view[a + 2] << 8,
    d |= this.view[a + 3],
    d += this.view[a] << 24 >>> 0,
    a += 4,
    c = this.view[a + 1] << 16,
    c |= this.view[a + 2] << 8,
    c |= this.view[a + 3],
    c += this.view[a] << 24 >>> 0);
    var e = new Long(c,d,(!0));
    return b && (this.offset += 8),
    e
}
,
ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64),
ByteBufferPrototype.writeFloat32 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof a)
            throw TypeError("Illegal value: " + a + " (not a number)");
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    b += 4;
    var d = this.buffer.byteLength;
    return b > d && this.resize((d *= 2) > b ? d : b),
    b -= 4,
    ieee754_write(this.view, a, b, this.littleEndian, 23, 4),
    c && (this.offset += 4),
    this
}
,
ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32,
ByteBufferPrototype.readFloat32 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 4 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength)
    }
    var c = ieee754_read(this.view, a, this.littleEndian, 23, 4);
    return b && (this.offset += 4),
    c
}
,
ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32,
ByteBufferPrototype.writeFloat64 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof a)
            throw TypeError("Illegal value: " + a + " (not a number)");
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    b += 8;
    var d = this.buffer.byteLength;
    return b > d && this.resize((d *= 2) > b ? d : b),
    b -= 8,
    ieee754_write(this.view, a, b, this.littleEndian, 52, 8),
    c && (this.offset += 8),
    this
}
,
ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64,
ByteBufferPrototype.readFloat64 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 8 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+8) <= " + this.buffer.byteLength)
    }
    var c = ieee754_read(this.view, a, this.littleEndian, 52, 8);
    return b && (this.offset += 8),
    c
}
,
ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64,
ByteBuffer.MAX_VARINT32_BYTES = 5,
ByteBuffer.calculateVarint32 = function(a) {
    return a >>>= 0,
    a < 128 ? 1 : a < 16384 ? 2 : a < 1 << 21 ? 3 : a < 1 << 28 ? 4 : 5
}
,
ByteBuffer.zigZagEncode32 = function(a) {
    return ((a |= 0) << 1 ^ a >> 31) >>> 0
}
,
ByteBuffer.zigZagDecode32 = function(a) {
    return a >>> 1 ^ -(1 & a) | 0
}
,
ByteBufferPrototype.writeVarint32 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal value: " + a + " (not an integer)");
        if (a |= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    var d, e = ByteBuffer.calculateVarint32(a);
    b += e;
    var f = this.buffer.byteLength;
    for (b > f && this.resize((f *= 2) > b ? f : b),
    b -= e,
    a >>>= 0; a >= 128; )
        d = 127 & a | 128,
        this.view[b++] = d,
        a >>>= 7;
    return this.view[b++] = a,
    c ? (this.offset = b,
    this) : e
}
,
ByteBufferPrototype.writeVarint32ZigZag = function(a, b) {
    return this.writeVarint32(ByteBuffer.zigZagEncode32(a), b)
}
,
ByteBufferPrototype.readVarint32 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 1 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength)
    }
    var c, d = 0, e = 0;
    do {
        if (!this.noAssert && a > this.limit) {
            var f = Error("Truncated");
            throw f.truncated = !0,
            f
        }
        c = this.view[a++],
        d < 5 && (e |= (127 & c) << 7 * d),
        ++d
    } while (0 !== (128 & c));return e |= 0,
    b ? (this.offset = a,
    e) : {
        value: e,
        length: d
    }
}
,
ByteBufferPrototype.readVarint32ZigZag = function(a) {
    var b = this.readVarint32(a);
    return "object" == typeof b ? b.value = ByteBuffer.zigZagDecode32(b.value) : b = ByteBuffer.zigZagDecode32(b),
    b
}
,
Long && (ByteBuffer.MAX_VARINT64_BYTES = 10,
ByteBuffer.calculateVarint64 = function(a) {
    "number" == typeof a ? a = Long.fromNumber(a) : "string" == typeof a && (a = Long.fromString(a));
    var b = a.toInt() >>> 0
      , c = a.shiftRightUnsigned(28).toInt() >>> 0
      , d = a.shiftRightUnsigned(56).toInt() >>> 0;
    return 0 == d ? 0 == c ? b < 16384 ? b < 128 ? 1 : 2 : b < 1 << 21 ? 3 : 4 : c < 16384 ? c < 128 ? 5 : 6 : c < 1 << 21 ? 7 : 8 : d < 128 ? 9 : 10
}
,
ByteBuffer.zigZagEncode64 = function(a) {
    return "number" == typeof a ? a = Long.fromNumber(a, !1) : "string" == typeof a ? a = Long.fromString(a, !1) : a.unsigned !== !1 && (a = a.toSigned()),
    a.shiftLeft(1).xor(a.shiftRight(63)).toUnsigned()
}
,
ByteBuffer.zigZagDecode64 = function(a) {
    return "number" == typeof a ? a = Long.fromNumber(a, !1) : "string" == typeof a ? a = Long.fromString(a, !1) : a.unsigned !== !1 && (a = a.toSigned()),
    a.shiftRightUnsigned(1).xor(a.and(Long.ONE).toSigned().negate()).toSigned()
}
,
ByteBufferPrototype.writeVarint64 = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" == typeof a)
            a = Long.fromNumber(a);
        else if ("string" == typeof a)
            a = Long.fromString(a);
        else if (!(a && a instanceof Long))
            throw TypeError("Illegal value: " + a + " (not an integer or Long)");
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    "number" == typeof a ? a = Long.fromNumber(a, !1) : "string" == typeof a ? a = Long.fromString(a, !1) : a.unsigned !== !1 && (a = a.toSigned());
    var d = ByteBuffer.calculateVarint64(a)
      , e = a.toInt() >>> 0
      , f = a.shiftRightUnsigned(28).toInt() >>> 0
      , g = a.shiftRightUnsigned(56).toInt() >>> 0;
    b += d;
    var h = this.buffer.byteLength;
    switch (b > h && this.resize((h *= 2) > b ? h : b),
    b -= d,
    d) {
    case 10:
        this.view[b + 9] = g >>> 7 & 1;
    case 9:
        this.view[b + 8] = 9 !== d ? 128 | g : 127 & g;
    case 8:
        this.view[b + 7] = 8 !== d ? f >>> 21 | 128 : f >>> 21 & 127;
    case 7:
        this.view[b + 6] = 7 !== d ? f >>> 14 | 128 : f >>> 14 & 127;
    case 6:
        this.view[b + 5] = 6 !== d ? f >>> 7 | 128 : f >>> 7 & 127;
    case 5:
        this.view[b + 4] = 5 !== d ? 128 | f : 127 & f;
    case 4:
        this.view[b + 3] = 4 !== d ? e >>> 21 | 128 : e >>> 21 & 127;
    case 3:
        this.view[b + 2] = 3 !== d ? e >>> 14 | 128 : e >>> 14 & 127;
    case 2:
        this.view[b + 1] = 2 !== d ? e >>> 7 | 128 : e >>> 7 & 127;
    case 1:
        this.view[b] = 1 !== d ? 128 | e : 127 & e
    }
    return c ? (this.offset += d,
    this) : d
}
,
ByteBufferPrototype.writeVarint64ZigZag = function(a, b) {
    return this.writeVarint64(ByteBuffer.zigZagEncode64(a), b)
}
,
ByteBufferPrototype.readVarint64 = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 1 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength)
    }
    var c = a
      , d = 0
      , e = 0
      , f = 0
      , g = 0;
    if (g = this.view[a++],
    d = 127 & g,
    128 & g && (g = this.view[a++],
    d |= (127 & g) << 7,
    (128 & g || this.noAssert && "undefined" == typeof g) && (g = this.view[a++],
    d |= (127 & g) << 14,
    (128 & g || this.noAssert && "undefined" == typeof g) && (g = this.view[a++],
    d |= (127 & g) << 21,
    (128 & g || this.noAssert && "undefined" == typeof g) && (g = this.view[a++],
    e = 127 & g,
    (128 & g || this.noAssert && "undefined" == typeof g) && (g = this.view[a++],
    e |= (127 & g) << 7,
    (128 & g || this.noAssert && "undefined" == typeof g) && (g = this.view[a++],
    e |= (127 & g) << 14,
    (128 & g || this.noAssert && "undefined" == typeof g) && (g = this.view[a++],
    e |= (127 & g) << 21,
    (128 & g || this.noAssert && "undefined" == typeof g) && (g = this.view[a++],
    f = 127 & g,
    (128 & g || this.noAssert && "undefined" == typeof g) && (g = this.view[a++],
    f |= (127 & g) << 7,
    128 & g || this.noAssert && "undefined" == typeof g))))))))))
        throw Error("Buffer overrun");
    var h = Long.fromBits(d | e << 28, e >>> 4 | f << 24, !1);
    return b ? (this.offset = a,
    h) : {
        value: h,
        length: a - c
    }
}
,
ByteBufferPrototype.readVarint64ZigZag = function(a) {
    var b = this.readVarint64(a);
    return b && b.value instanceof Long ? b.value = ByteBuffer.zigZagDecode64(b.value) : b = ByteBuffer.zigZagDecode64(b),
    b
}
),
ByteBufferPrototype.writeCString = function(a, b) {
    var c = "undefined" == typeof b;
    c && (b = this.offset);
    var d, e = a.length;
    if (!this.noAssert) {
        if ("string" != typeof a)
            throw TypeError("Illegal str: Not a string");
        for (d = 0; d < e; ++d)
            if (0 === a.charCodeAt(d))
                throw RangeError("Illegal str: Contains NULL-characters");
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    e = utfx.calculateUTF16asUTF8(stringSource(a))[1],
    b += e + 1;
    var f = this.buffer.byteLength;
    return b > f && this.resize((f *= 2) > b ? f : b),
    b -= e + 1,
    utfx.encodeUTF16toUTF8(stringSource(a), function(a) {
        this.view[b++] = a
    }
    .bind(this)),
    this.view[b++] = 0,
    c ? (this.offset = b,
    this) : e
}
,
ByteBufferPrototype.readCString = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 1 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength)
    }
    var c, d = a, e = -1;
    return utfx.decodeUTF8toUTF16(function() {
        if (0 === e)
            return null ;
        if (a >= this.limit)
            throw RangeError("Illegal range: Truncated data, " + a + " < " + this.limit);
        return e = this.view[a++],
        0 === e ? null : e
    }
    .bind(this), c = stringDestination(), !0),
    b ? (this.offset = a,
    c()) : {
        string: c(),
        length: a - d
    }
}
,
ByteBufferPrototype.writeIString = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("string" != typeof a)
            throw TypeError("Illegal str: Not a string");
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    var d, e = b;
    d = utfx.calculateUTF16asUTF8(stringSource(a), this.noAssert)[1],
    b += 4 + d;
    var f = this.buffer.byteLength;
    if (b > f && this.resize((f *= 2) > b ? f : b),
    b -= 4 + d,
    this.littleEndian ? (this.view[b + 3] = d >>> 24 & 255,
    this.view[b + 2] = d >>> 16 & 255,
    this.view[b + 1] = d >>> 8 & 255,
    this.view[b] = 255 & d) : (this.view[b] = d >>> 24 & 255,
    this.view[b + 1] = d >>> 16 & 255,
    this.view[b + 2] = d >>> 8 & 255,
    this.view[b + 3] = 255 & d),
    b += 4,
    utfx.encodeUTF16toUTF8(stringSource(a), function(a) {
        this.view[b++] = a
    }
    .bind(this)),
    b !== e + 4 + d)
        throw RangeError("Illegal range: Truncated data, " + b + " == " + (b + 4 + d));
    return c ? (this.offset = b,
    this) : b - e
}
,
ByteBufferPrototype.readIString = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 4 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+4) <= " + this.buffer.byteLength)
    }
    var c = a
      , d = this.readUint32(a)
      , e = this.readUTF8String(d, ByteBuffer.METRICS_BYTES, a += 4);
    return a += e.length,
    b ? (this.offset = a,
    e.string) : {
        string: e.string,
        length: a - c
    }
}
,
ByteBuffer.METRICS_CHARS = "c",
ByteBuffer.METRICS_BYTES = "b",
ByteBufferPrototype.writeUTF8String = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    var d, e = b;
    d = utfx.calculateUTF16asUTF8(stringSource(a))[1],
    b += d;
    var f = this.buffer.byteLength;
    return b > f && this.resize((f *= 2) > b ? f : b),
    b -= d,
    utfx.encodeUTF16toUTF8(stringSource(a), function(a) {
        this.view[b++] = a
    }
    .bind(this)),
    c ? (this.offset = b,
    this) : b - e
}
,
ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String,
ByteBuffer.calculateUTF8Chars = function(a) {
    return utfx.calculateUTF16asUTF8(stringSource(a))[0]
}
,
ByteBuffer.calculateUTF8Bytes = function(a) {
    return utfx.calculateUTF16asUTF8(stringSource(a))[1]
}
,
ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes,
ByteBufferPrototype.readUTF8String = function(a, b, c) {
    "number" == typeof b && (c = b,
    b = void 0);
    var d = "undefined" == typeof c;
    if (d && (c = this.offset),
    "undefined" == typeof b && (b = ByteBuffer.METRICS_CHARS),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal length: " + a + " (not an integer)");
        if (a |= 0,
        "number" != typeof c || c % 1 !== 0)
            throw TypeError("Illegal offset: " + c + " (not an integer)");
        if (c >>>= 0,
        c < 0 || c + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength)
    }
    var e, f = 0, g = c;
    if (b === ByteBuffer.METRICS_CHARS) {
        if (e = stringDestination(),
        utfx.decodeUTF8(function() {
            return f < a && c < this.limit ? this.view[c++] : null
        }
        .bind(this), function(a) {
            ++f,
            utfx.UTF8toUTF16(a, e)
        }),
        f !== a)
            throw RangeError("Illegal range: Truncated data, " + f + " == " + a);
        return d ? (this.offset = c,
        e()) : {
            string: e(),
            length: c - g
        }
    }
    if (b === ByteBuffer.METRICS_BYTES) {
        if (!this.noAssert) {
            if ("number" != typeof c || c % 1 !== 0)
                throw TypeError("Illegal offset: " + c + " (not an integer)");
            if (c >>>= 0,
            c < 0 || c + a > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= " + c + " (+" + a + ") <= " + this.buffer.byteLength)
        }
        var h = c + a;
        if (utfx.decodeUTF8toUTF16(function() {
            return c < h ? this.view[c++] : null
        }
        .bind(this), e = stringDestination(), this.noAssert),
        c !== h)
            throw RangeError("Illegal range: Truncated data, " + c + " == " + h);
        return d ? (this.offset = c,
        e()) : {
            string: e(),
            length: c - g
        }
    }
    throw TypeError("Unsupported metrics: " + b)
}
,
ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String,
ByteBufferPrototype.writeVString = function(a, b) {
    var c = "undefined" == typeof b;
    if (c && (b = this.offset),
    !this.noAssert) {
        if ("string" != typeof a)
            throw TypeError("Illegal str: Not a string");
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: " + b + " (not an integer)");
        if (b >>>= 0,
        b < 0 || b + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + b + " (+0) <= " + this.buffer.byteLength)
    }
    var d, e, f = b;
    d = utfx.calculateUTF16asUTF8(stringSource(a), this.noAssert)[1],
    e = ByteBuffer.calculateVarint32(d),
    b += e + d;
    var g = this.buffer.byteLength;
    if (b > g && this.resize((g *= 2) > b ? g : b),
    b -= e + d,
    b += this.writeVarint32(d, b),
    utfx.encodeUTF16toUTF8(stringSource(a), function(a) {
        this.view[b++] = a
    }
    .bind(this)),
    b !== f + d + e)
        throw RangeError("Illegal range: Truncated data, " + b + " == " + (b + d + e));
    return c ? (this.offset = b,
    this) : b - f
}
,
ByteBufferPrototype.readVString = function(a) {
    var b = "undefined" == typeof a;
    if (b && (a = this.offset),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 1 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+1) <= " + this.buffer.byteLength)
    }
    var c = a
      , d = this.readVarint32(a)
      , e = this.readUTF8String(d.value, ByteBuffer.METRICS_BYTES, a += d.length);
    return a += e.length,
    b ? (this.offset = a,
    e.string) : {
        string: e.string,
        length: a - c
    }
}
,
ByteBufferPrototype.append = function(a, b, c) {
    "number" != typeof b && "string" == typeof b || (c = b,
    b = void 0);
    var d = "undefined" == typeof c;
    if (d && (c = this.offset),
    !this.noAssert) {
        if ("number" != typeof c || c % 1 !== 0)
            throw TypeError("Illegal offset: " + c + " (not an integer)");
        if (c >>>= 0,
        c < 0 || c + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength)
    }
    a instanceof ByteBuffer || (a = ByteBuffer.wrap(a, b));
    var e = a.limit - a.offset;
    if (e <= 0)
        return this;
    c += e;
    var f = this.buffer.byteLength;
    return c > f && this.resize((f *= 2) > c ? f : c),
    c -= e,
    this.view.set(a.view.subarray(a.offset, a.limit), c),
    a.offset += e,
    d && (this.offset += e),
    this
}
,
ByteBufferPrototype.appendTo = function(a, b) {
    return a.append(this, b),
    this
}
,
ByteBufferPrototype.assert = function(a) {
    return this.noAssert = !a,
    this
}
,
ByteBufferPrototype.capacity = function() {
    return this.buffer.byteLength
}
,
ByteBufferPrototype.clear = function() {
    return this.offset = 0,
    this.limit = this.buffer.byteLength,
    this.markedOffset = -1,
    this
}
,
ByteBufferPrototype.clone = function(a) {
    var b = new ByteBuffer(0,this.littleEndian,this.noAssert);
    return a ? (b.buffer = new ArrayBuffer(this.buffer.byteLength),
    b.view = new Uint8Array(b.buffer)) : (b.buffer = this.buffer,
    b.view = this.view),
    b.offset = this.offset,
    b.markedOffset = this.markedOffset,
    b.limit = this.limit,
    b
}
,
ByteBufferPrototype.compact = function(a, b) {
    if ("undefined" == typeof a && (a = this.offset),
    "undefined" == typeof b && (b = this.limit),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        if (a >>>= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        if (b >>>= 0,
        a < 0 || a > b || b > this.buffer.byteLength)
            throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength)
    }
    if (0 === a && b === this.buffer.byteLength)
        return this;
    var c = b - a;
    if (0 === c)
        return this.buffer = EMPTY_BUFFER,
        this.view = null ,
        this.markedOffset >= 0 && (this.markedOffset -= a),
        this.offset = 0,
        this.limit = 0,
        this;
    var d = new ArrayBuffer(c)
      , e = new Uint8Array(d);
    return e.set(this.view.subarray(a, b)),
    this.buffer = d,
    this.view = e,
    this.markedOffset >= 0 && (this.markedOffset -= a),
    this.offset = 0,
    this.limit = c,
    this
}
,
ByteBufferPrototype.copy = function(a, b) {
    if ("undefined" == typeof a && (a = this.offset),
    "undefined" == typeof b && (b = this.limit),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        if (a >>>= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        if (b >>>= 0,
        a < 0 || a > b || b > this.buffer.byteLength)
            throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength)
    }
    if (a === b)
        return new ByteBuffer(0,this.littleEndian,this.noAssert);
    var c = b - a
      , d = new ByteBuffer(c,this.littleEndian,this.noAssert);
    return d.offset = 0,
    d.limit = c,
    d.markedOffset >= 0 && (d.markedOffset -= a),
    this.copyTo(d, 0, a, b),
    d
}
,
ByteBufferPrototype.copyTo = function(a, b, c, d) {
    var e, f;
    if (!this.noAssert && !ByteBuffer.isByteBuffer(a))
        throw TypeError("Illegal target: Not a ByteBuffer");
    if (b = (f = "undefined" == typeof b) ? a.offset : 0 | b,
    c = (e = "undefined" == typeof c) ? this.offset : 0 | c,
    d = "undefined" == typeof d ? this.limit : 0 | d,
    b < 0 || b > a.buffer.byteLength)
        throw RangeError("Illegal target range: 0 <= " + b + " <= " + a.buffer.byteLength);
    if (c < 0 || d > this.buffer.byteLength)
        throw RangeError("Illegal source range: 0 <= " + c + " <= " + this.buffer.byteLength);
    var g = d - c;
    return 0 === g ? a : (a.ensureCapacity(b + g),
    a.view.set(this.view.subarray(c, d), b),
    e && (this.offset += g),
    f && (a.offset += g),
    this)
}
,
ByteBufferPrototype.ensureCapacity = function(a) {
    var b = this.buffer.byteLength;
    return b < a ? this.resize((b *= 2) > a ? b : a) : this
}
,
ByteBufferPrototype.fill = function(a, b, c) {
    var d = "undefined" == typeof b;
    if (d && (b = this.offset),
    "string" == typeof a && a.length > 0 && (a = a.charCodeAt(0)),
    "undefined" == typeof b && (b = this.offset),
    "undefined" == typeof c && (c = this.limit),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal value: " + a + " (not an integer)");
        if (a |= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        if (b >>>= 0,
        "number" != typeof c || c % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        if (c >>>= 0,
        b < 0 || b > c || c > this.buffer.byteLength)
            throw RangeError("Illegal range: 0 <= " + b + " <= " + c + " <= " + this.buffer.byteLength)
    }
    if (b >= c)
        return this;
    for (; b < c; )
        this.view[b++] = a;
    return d && (this.offset = b),
    this
}
,
ByteBufferPrototype.flip = function() {
    return this.limit = this.offset,
    this.offset = 0,
    this
}
,
ByteBufferPrototype.mark = function(a) {
    if (a = "undefined" == typeof a ? this.offset : a,
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal offset: " + a + " (not an integer)");
        if (a >>>= 0,
        a < 0 || a + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + a + " (+0) <= " + this.buffer.byteLength)
    }
    return this.markedOffset = a,
    this
}
,
ByteBufferPrototype.order = function(a) {
    if (!this.noAssert && "boolean" != typeof a)
        throw TypeError("Illegal littleEndian: Not a boolean");
    return this.littleEndian = !!a,
    this
}
,
ByteBufferPrototype.LE = function(a) {
    return this.littleEndian = "undefined" == typeof a || !!a,
    this
}
,
ByteBufferPrototype.BE = function(a) {
    return this.littleEndian = "undefined" != typeof a && !a,
    this
}
,
ByteBufferPrototype.prepend = function(a, b, c) {
    "number" != typeof b && "string" == typeof b || (c = b,
    b = void 0);
    var d = "undefined" == typeof c;
    if (d && (c = this.offset),
    !this.noAssert) {
        if ("number" != typeof c || c % 1 !== 0)
            throw TypeError("Illegal offset: " + c + " (not an integer)");
        if (c >>>= 0,
        c < 0 || c + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= " + c + " (+0) <= " + this.buffer.byteLength)
    }
    a instanceof ByteBuffer || (a = ByteBuffer.wrap(a, b));
    var e = a.limit - a.offset;
    if (e <= 0)
        return this;
    var f = e - c;
    if (f > 0) {
        var g = new ArrayBuffer(this.buffer.byteLength + f)
          , h = new Uint8Array(g);
        h.set(this.view.subarray(c, this.buffer.byteLength), e),
        this.buffer = g,
        this.view = h,
        this.offset += f,
        this.markedOffset >= 0 && (this.markedOffset += f),
        this.limit += f,
        c += f
    } else {
        new Uint8Array(this.buffer)
    }
    return this.view.set(a.view.subarray(a.offset, a.limit), c - e),
    a.offset = a.limit,
    d && (this.offset -= e),
    this
}
,
ByteBufferPrototype.prependTo = function(a, b) {
    return a.prepend(this, b),
    this
}
,
ByteBufferPrototype.printDebug = function(a) {
    "function" != typeof a && (a = console.log.bind(console)),
    a(this.toString() + "\n-------------------------------------------------------------------\n" + this.toDebug(!0))
}
,
ByteBufferPrototype.remaining = function() {
    return this.limit - this.offset
}
,
ByteBufferPrototype.reset = function() {
    return this.markedOffset >= 0 ? (this.offset = this.markedOffset,
    this.markedOffset = -1) : this.offset = 0,
    this
}
,
ByteBufferPrototype.resize = function(a) {
    if (!this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal capacity: " + a + " (not an integer)");
        if (a |= 0,
        a < 0)
            throw RangeError("Illegal capacity: 0 <= " + a)
    }
    if (this.buffer.byteLength < a) {
        var b = new ArrayBuffer(a)
          , c = new Uint8Array(b);
        c.set(this.view),
        this.buffer = b,
        this.view = c
    }
    return this
}
,
ByteBufferPrototype.reverse = function(a, b) {
    if ("undefined" == typeof a && (a = this.offset),
    "undefined" == typeof b && (b = this.limit),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        if (a >>>= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        if (b >>>= 0,
        a < 0 || a > b || b > this.buffer.byteLength)
            throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength)
    }
    return a === b ? this : (Array.prototype.reverse.call(this.view.subarray(a, b)),
    this)
}
,
ByteBufferPrototype.skip = function(a) {
    if (!this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal length: " + a + " (not an integer)");
        a |= 0
    }
    var b = this.offset + a;
    if (!this.noAssert && (b < 0 || b > this.buffer.byteLength))
        throw RangeError("Illegal length: 0 <= " + this.offset + " + " + a + " <= " + this.buffer.byteLength);
    return this.offset = b,
    this
}
,
ByteBufferPrototype.slice = function(a, b) {
    if ("undefined" == typeof a && (a = this.offset),
    "undefined" == typeof b && (b = this.limit),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        if (a >>>= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        if (b >>>= 0,
        a < 0 || a > b || b > this.buffer.byteLength)
            throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength)
    }
    var c = this.clone();
    return c.offset = a,
    c.limit = b,
    c
}
,
ByteBufferPrototype.toBuffer = function(a) {
    var b = this.offset
      , c = this.limit;
    if (!this.noAssert) {
        if ("number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal offset: Not an integer");
        if (b >>>= 0,
        "number" != typeof c || c % 1 !== 0)
            throw TypeError("Illegal limit: Not an integer");
        if (c >>>= 0,
        b < 0 || b > c || c > this.buffer.byteLength)
            throw RangeError("Illegal range: 0 <= " + b + " <= " + c + " <= " + this.buffer.byteLength)
    }
    if (!a && 0 === b && c === this.buffer.byteLength)
        return this.buffer;
    if (b === c)
        return EMPTY_BUFFER;
    var d = new ArrayBuffer(c - b);
    return new Uint8Array(d).set(new Uint8Array(this.buffer).subarray(b, c), 0),
    d
}
,
ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer,
ByteBufferPrototype.toString = function(a, b, c) {
    if ("undefined" == typeof a)
        return "ByteBufferAB(offset=" + this.offset + ",markedOffset=" + this.markedOffset + ",limit=" + this.limit + ",capacity=" + this.capacity() + ")";
    switch ("number" == typeof a && (a = "utf8",
    b = a,
    c = b),
    a) {
    case "utf8":
        return this.toUTF8(b, c);
    case "base64":
        return this.toBase64(b, c);
    case "hex":
        return this.toHex(b, c);
    case "binary":
        return this.toBinary(b, c);
    case "debug":
        return this.toDebug();
    case "columns":
        return this.toColumns();
    default:
        throw Error("Unsupported encoding: " + a)
    }
}
;
var lxiv = function() {
    "use strict";
    for (var a = {}, b = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47], c = [], d = 0, e = b.length; d < e; ++d)
        c[b[d]] = d;
    return a.encode = function(a, c) {
        for (var d, e; null !== (d = a()); )
            c(b[d >> 2 & 63]),
            e = (3 & d) << 4,
            null !== (d = a()) ? (e |= d >> 4 & 15,
            c(b[63 & (e | d >> 4 & 15)]),
            e = (15 & d) << 2,
            null !== (d = a()) ? (c(b[63 & (e | d >> 6 & 3)]),
            c(b[63 & d])) : (c(b[63 & e]),
            c(61))) : (c(b[63 & e]),
            c(61),
            c(61))
    }
    ,
    a.decode = function(a, b) {
        function d(a) {
            throw Error("Illegal character code: " + a)
        }
        for (var e, f, g; null !== (e = a()); )
            if (f = c[e],
            "undefined" == typeof f && d(e),
            null !== (e = a()) && (g = c[e],
            "undefined" == typeof g && d(e),
            b(f << 2 >>> 0 | (48 & g) >> 4),
            null !== (e = a()))) {
                if (f = c[e],
                "undefined" == typeof f) {
                    if (61 === e)
                        break;
                    d(e)
                }
                if (b((15 & g) << 4 >>> 0 | (60 & f) >> 2),
                null !== (e = a())) {
                    if (g = c[e],
                    "undefined" == typeof g) {
                        if (61 === e)
                            break;
                        d(e)
                    }
                    b((3 & f) << 6 >>> 0 | g)
                }
            }
    }
    ,
    a.test = function(a) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a)
    }
    ,
    a
}();
ByteBufferPrototype.toBase64 = function(a, b) {
    if ("undefined" == typeof a && (a = this.offset),
    "undefined" == typeof b && (b = this.limit),
    a = 0 | a,
    b = 0 | b,
    a < 0 || b > this.capacity || a > b)
        throw RangeError("begin, end");
    var c;
    return lxiv.encode(function() {
        return a < b ? this.view[a++] : null
    }
    .bind(this), c = stringDestination()),
    c()
}
,
ByteBuffer.fromBase64 = function(a, b) {
    if ("string" != typeof a)
        throw TypeError("str");
    var c = new ByteBuffer(a.length / 4 * 3,b)
      , d = 0;
    return lxiv.decode(stringSource(a), function(a) {
        c.view[d++] = a
    }),
    c.limit = d,
    c
}
,
ByteBuffer.btoa = function(a) {
    return ByteBuffer.fromBinary(a).toBase64()
}
,
ByteBuffer.atob = function(a) {
    return ByteBuffer.fromBase64(a).toBinary()
}
,
ByteBufferPrototype.toBinary = function(a, b) {
    if ("undefined" == typeof a && (a = this.offset),
    "undefined" == typeof b && (b = this.limit),
    a |= 0,
    b |= 0,
    a < 0 || b > this.capacity() || a > b)
        throw RangeError("begin, end");
    if (a === b)
        return "";
    for (var c = [], d = []; a < b; )
        c.push(this.view[a++]),
        c.length >= 1024 && (d.push(String.fromCharCode.apply(String, c)),
        c = []);
    return d.join("") + String.fromCharCode.apply(String, c)
}
,
ByteBuffer.fromBinary = function(a, b) {
    if ("string" != typeof a)
        throw TypeError("str");
    for (var c, d = 0, e = a.length, f = new ByteBuffer(e,b); d < e; ) {
        if (c = a.charCodeAt(d),
        c > 255)
            throw RangeError("illegal char code: " + c);
        f.view[d++] = c
    }
    return f.limit = e,
    f
}
,
ByteBufferPrototype.toDebug = function(a) {
    for (var b, c = -1, d = this.buffer.byteLength, e = "", f = "", g = ""; c < d; ) {
        if (c !== -1 && (b = this.view[c],
        e += b < 16 ? "0" + b.toString(16).toUpperCase() : b.toString(16).toUpperCase(),
        a && (f += b > 32 && b < 127 ? String.fromCharCode(b) : ".")),
        ++c,
        a && c > 0 && c % 16 === 0 && c !== d) {
            for (; e.length < 51; )
                e += " ";
            g += e + f + "\n",
            e = f = ""
        }
        e += c === this.offset && c === this.limit ? c === this.markedOffset ? "!" : "|" : c === this.offset ? c === this.markedOffset ? "[" : "<" : c === this.limit ? c === this.markedOffset ? "]" : ">" : c === this.markedOffset ? "'" : a || 0 !== c && c !== d ? " " : ""
    }
    if (a && " " !== e) {
        for (; e.length < 51; )
            e += " ";
        g += e + f + "\n"
    }
    return a ? g : e
}
,
ByteBuffer.fromDebug = function(a, b, c) {
    for (var d, e, f = a.length, g = new ByteBuffer((f + 1) / 3 | 0,b,c), h = 0, i = 0, j = !1, k = !1, l = !1, m = !1, n = !1; h < f; ) {
        switch (d = a.charAt(h++)) {
        case "!":
            if (!c) {
                if (k || l || m) {
                    n = !0;
                    break
                }
                k = l = m = !0
            }
            g.offset = g.markedOffset = g.limit = i,
            j = !1;
            break;
        case "|":
            if (!c) {
                if (k || m) {
                    n = !0;
                    break
                }
                k = m = !0
            }
            g.offset = g.limit = i,
            j = !1;
            break;
        case "[":
            if (!c) {
                if (k || l) {
                    n = !0;
                    break
                }
                k = l = !0
            }
            g.offset = g.markedOffset = i,
            j = !1;
            break;
        case "<":
            if (!c) {
                if (k) {
                    n = !0;
                    break
                }
                k = !0
            }
            g.offset = i,
            j = !1;
            break;
        case "]":
            if (!c) {
                if (m || l) {
                    n = !0;
                    break
                }
                m = l = !0
            }
            g.limit = g.markedOffset = i,
            j = !1;
            break;
        case ">":
            if (!c) {
                if (m) {
                    n = !0;
                    break
                }
                m = !0
            }
            g.limit = i,
            j = !1;
            break;
        case "'":
            if (!c) {
                if (l) {
                    n = !0;
                    break
                }
                l = !0
            }
            g.markedOffset = i,
            j = !1;
            break;
        case " ":
            j = !1;
            break;
        default:
            if (!c && j) {
                n = !0;
                break
            }
            if (e = parseInt(d + a.charAt(h++), 16),
            !c && (isNaN(e) || e < 0 || e > 255))
                throw TypeError("Illegal str: Not a debug encoded string");
            g.view[i++] = e,
            j = !0
        }
        if (n)
            throw TypeError("Illegal str: Invalid symbol at " + h)
    }
    if (!c) {
        if (!k || !m)
            throw TypeError("Illegal str: Missing offset or limit");
        if (i < g.buffer.byteLength)
            throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " + i + " < " + f)
    }
    return g
}
,
ByteBufferPrototype.toHex = function(a, b) {
    if (a = "undefined" == typeof a ? this.offset : a,
    b = "undefined" == typeof b ? this.limit : b,
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        if (a >>>= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        if (b >>>= 0,
        a < 0 || a > b || b > this.buffer.byteLength)
            throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength)
    }
    for (var c, d = new Array(b - a); a < b; )
        c = this.view[a++],
        c < 16 ? d.push("0", c.toString(16)) : d.push(c.toString(16));
    return d.join("")
}
,
ByteBuffer.fromHex = function(a, b, c) {
    if (!c) {
        if ("string" != typeof a)
            throw TypeError("Illegal str: Not a string");
        if (a.length % 2 !== 0)
            throw TypeError("Illegal str: Length not a multiple of 2")
    }
    for (var d, e = a.length, f = new ByteBuffer(e / 2 | 0,b), g = 0, h = 0; g < e; g += 2) {
        if (d = parseInt(a.substring(g, g + 2), 16),
        !c && (!isFinite(d) || d < 0 || d > 255))
            throw TypeError("Illegal str: Contains non-hex characters");
        f.view[h++] = d
    }
    return f.limit = h,
    f
}
;
var utfx = function() {
    "use strict";
    var a = {};
    return a.MAX_CODEPOINT = 1114111,
    a.encodeUTF8 = function(a, b) {
        var c = null ;
        for ("number" == typeof a && (c = a,
        a = function() {
            return null
        }
        ); null !== c || null !== (c = a()); )
            c < 128 ? b(127 & c) : c < 2048 ? (b(c >> 6 & 31 | 192),
            b(63 & c | 128)) : c < 65536 ? (b(c >> 12 & 15 | 224),
            b(c >> 6 & 63 | 128),
            b(63 & c | 128)) : (b(c >> 18 & 7 | 240),
            b(c >> 12 & 63 | 128),
            b(c >> 6 & 63 | 128),
            b(63 & c | 128)),
            c = null
    }
    ,
    a.decodeUTF8 = function(a, b) {
        for (var c, d, e, f, g = function(a) {
            a = a.slice(0, a.indexOf(null ));
            var b = Error(a.toString());
            throw b.name = "TruncatedError",
            b.bytes = a,
            b
        }
        ; null !== (c = a()); )
            if (0 === (128 & c))
                b(c);
            else if (192 === (224 & c))
                null === (d = a()) && g([c, d]),
                b((31 & c) << 6 | 63 & d);
            else if (224 === (240 & c))
                (null === (d = a()) || null === (e = a())) && g([c, d, e]),
                b((15 & c) << 12 | (63 & d) << 6 | 63 & e);
            else {
                if (240 !== (248 & c))
                    throw RangeError("Illegal starting byte: " + c);
                (null === (d = a()) || null === (e = a()) || null === (f = a())) && g([c, d, e, f]),
                b((7 & c) << 18 | (63 & d) << 12 | (63 & e) << 6 | 63 & f)
            }
    }
    ,
    a.UTF16toUTF8 = function(a, b) {
        for (var c, d = null ; ; ) {
            if (null === (c = null !== d ? d : a()))
                break;
            c >= 55296 && c <= 57343 && null !== (d = a()) && d >= 56320 && d <= 57343 ? (b(1024 * (c - 55296) + d - 56320 + 65536),
            d = null ) : b(c)
        }
        null !== d && b(d)
    }
    ,
    a.UTF8toUTF16 = function(a, b) {
        var c = null ;
        for ("number" == typeof a && (c = a,
        a = function() {
            return null
        }
        ); null !== c || null !== (c = a()); )
            c <= 65535 ? b(c) : (c -= 65536,
            b((c >> 10) + 55296),
            b(c % 1024 + 56320)),
            c = null
    }
    ,
    a.encodeUTF16toUTF8 = function(b, c) {
        a.UTF16toUTF8(b, function(b) {
            a.encodeUTF8(b, c)
        })
    }
    ,
    a.decodeUTF8toUTF16 = function(b, c) {
        a.decodeUTF8(b, function(b) {
            a.UTF8toUTF16(b, c)
        })
    }
    ,
    a.calculateCodePoint = function(a) {
        return a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4
    }
    ,
    a.calculateUTF8 = function(a) {
        for (var b, c = 0; null !== (b = a()); )
            c += b < 128 ? 1 : b < 2048 ? 2 : b < 65536 ? 3 : 4;
        return c
    }
    ,
    a.calculateUTF16asUTF8 = function(b) {
        var c = 0
          , d = 0;
        return a.UTF16toUTF8(b, function(a) {
            ++c,
            d += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4
        }),
        [c, d]
    }
    ,
    a
}();
ByteBufferPrototype.toUTF8 = function(a, b) {
    if ("undefined" == typeof a && (a = this.offset),
    "undefined" == typeof b && (b = this.limit),
    !this.noAssert) {
        if ("number" != typeof a || a % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        if (a >>>= 0,
        "number" != typeof b || b % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        if (b >>>= 0,
        a < 0 || a > b || b > this.buffer.byteLength)
            throw RangeError("Illegal range: 0 <= " + a + " <= " + b + " <= " + this.buffer.byteLength)
    }
    var c;
    try {
        utfx.decodeUTF8toUTF16(function() {
            return a < b ? this.view[a++] : null
        }
        .bind(this), c = stringDestination())
    } catch (d) {
        if (a !== b)
            throw RangeError("Illegal range: Truncated data, " + a + " != " + b)
    }
    return c()
}
,
ByteBuffer.fromUTF8 = function(a, b, c) {
    if (!c && "string" != typeof a)
        throw TypeError("Illegal str: Not a string");
    var d = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(a), !0)[1],b,c)
      , e = 0;
    return utfx.encodeUTF16toUTF8(stringSource(a), function(a) {
        d.view[e++] = a
    }),
    d.limit = e,
    d
}
;
var ProtoBuf = {};
ProtoBuf.ByteBuffer = ByteBuffer,
ProtoBuf.Long = ByteBuffer.Long || null ,
ProtoBuf.VERSION = "5.0.1",
ProtoBuf.WIRE_TYPES = {},
ProtoBuf.WIRE_TYPES.VARINT = 0,
ProtoBuf.WIRE_TYPES.BITS64 = 1,
ProtoBuf.WIRE_TYPES.LDELIM = 2,
ProtoBuf.WIRE_TYPES.STARTGROUP = 3,
ProtoBuf.WIRE_TYPES.ENDGROUP = 4,
ProtoBuf.WIRE_TYPES.BITS32 = 5,
ProtoBuf.PACKABLE_WIRE_TYPES = [ProtoBuf.WIRE_TYPES.VARINT, ProtoBuf.WIRE_TYPES.BITS64, ProtoBuf.WIRE_TYPES.BITS32],
ProtoBuf.TYPES = {
    int32: {
        name: "int32",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: 0
    },
    uint32: {
        name: "uint32",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: 0
    },
    sint32: {
        name: "sint32",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: 0
    },
    int64: {
        name: "int64",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : void 0
    },
    uint64: {
        name: "uint64",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : void 0
    },
    sint64: {
        name: "sint64",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : void 0
    },
    bool: {
        name: "bool",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: !1
    },
    "double": {
        name: "double",
        wireType: ProtoBuf.WIRE_TYPES.BITS64,
        defaultValue: 0
    },
    string: {
        name: "string",
        wireType: ProtoBuf.WIRE_TYPES.LDELIM,
        defaultValue: ""
    },
    bytes: {
        name: "bytes",
        wireType: ProtoBuf.WIRE_TYPES.LDELIM,
        defaultValue: null
    },
    fixed32: {
        name: "fixed32",
        wireType: ProtoBuf.WIRE_TYPES.BITS32,
        defaultValue: 0
    },
    sfixed32: {
        name: "sfixed32",
        wireType: ProtoBuf.WIRE_TYPES.BITS32,
        defaultValue: 0
    },
    fixed64: {
        name: "fixed64",
        wireType: ProtoBuf.WIRE_TYPES.BITS64,
        defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : void 0
    },
    sfixed64: {
        name: "sfixed64",
        wireType: ProtoBuf.WIRE_TYPES.BITS64,
        defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : void 0
    },
    "float": {
        name: "float",
        wireType: ProtoBuf.WIRE_TYPES.BITS32,
        defaultValue: 0
    },
    "enum": {
        name: "enum",
        wireType: ProtoBuf.WIRE_TYPES.VARINT,
        defaultValue: 0
    },
    message: {
        name: "message",
        wireType: ProtoBuf.WIRE_TYPES.LDELIM,
        defaultValue: null
    },
    group: {
        name: "group",
        wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,
        defaultValue: null
    }
},
ProtoBuf.MAP_KEY_TYPES = [ProtoBuf.TYPES.int32, ProtoBuf.TYPES.sint32, ProtoBuf.TYPES.sfixed32, ProtoBuf.TYPES.uint32, ProtoBuf.TYPES.fixed32, ProtoBuf.TYPES.int64, ProtoBuf.TYPES.sint64, ProtoBuf.TYPES.sfixed64, ProtoBuf.TYPES.uint64, ProtoBuf.TYPES.fixed64, ProtoBuf.TYPES.bool, ProtoBuf.TYPES.string, ProtoBuf.TYPES.bytes],
ProtoBuf.ID_MIN = 1,
ProtoBuf.ID_MAX = 536870911,
ProtoBuf.convertFieldsToCamelCase = !1,
ProtoBuf.populateAccessors = !0,
ProtoBuf.populateDefaults = !0,
ProtoBuf.Util = function() {
    "use strict";
    var a = {};
    return a.IS_NODE = !("object" != typeof process || process + "" != "[object process]" || process.browser),
    a.XHR = function() {
        for (var a = [function() {
            return new XMLHttpRequest
        }
        , function() {
            return new ActiveXObject("Msxml2.XMLHTTP")
        }
        , function() {
            return new ActiveXObject("Msxml3.XMLHTTP")
        }
        , function() {
            return new ActiveXObject("Microsoft.XMLHTTP")
        }
        ], b = null , c = 0; c < a.length; c++) {
            try {
                b = a[c]()
            } catch (d) {
                continue
            }
            break
        }
        if (!b)
            throw Error("XMLHttpRequest is not supported");
        return b
    }
    ,
    a.fetch = function(b, c) {
        if (c && "function" != typeof c && (c = null ),
        a.IS_NODE) {
            var d = require("fs");
            if (c)
                d.readFile(b, function(a, b) {
                    c(a ? null : "" + b)
                });
            else
                try {
                    return d.readFileSync(b)
                } catch (e) {
                    return null
                }
        } else {
            var f = a.XHR();
            if (f.open("GET", b, !!c),
            f.setRequestHeader("Accept", "text/plain"),
            "function" == typeof f.overrideMimeType && f.overrideMimeType("text/plain"),
            !c)
                return f.send(null ),
                200 == f.status || 0 == f.status && "string" == typeof f.responseText ? f.responseText : null ;
            if (f.onreadystatechange = function() {
                4 == f.readyState && c(200 == f.status || 0 == f.status && "string" == typeof f.responseText ? f.responseText : null )
            }
            ,
            4 == f.readyState)
                return;
            f.send(null )
        }
    }
    ,
    a.toCamelCase = function(a) {
        return a.replace(/_([a-zA-Z])/g, function(a, b) {
            return b.toUpperCase()
        })
    }
    ,
    a
}(),
ProtoBuf.Lang = {
    DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,
    RULE: /^(?:required|optional|repeated|map)$/,
    TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
    NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
    TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
    FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
    NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,
    NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
    NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,
    NUMBER_OCT: /^0[0-7]+$/,
    NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,
    BOOL: /^(?:true|false)$/i,
    ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
    NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
    WHITESPACE: /\s/,
    STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
    STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
},
ProtoBuf.DotProto = function(a, b) {
    "use strict";
    function c(a, c) {
        var d = -1
          , e = 1;
        if ("-" == a.charAt(0) && (e = -1,
        a = a.substring(1)),
        b.NUMBER_DEC.test(a))
            d = parseInt(a);
        else if (b.NUMBER_HEX.test(a))
            d = parseInt(a.substring(2), 16);
        else {
            if (!b.NUMBER_OCT.test(a))
                throw Error("illegal id value: " + (e < 0 ? "-" : "") + a);
            d = parseInt(a.substring(1), 8)
        }
        if (d = e * d | 0,
        !c && d < 0)
            throw Error("illegal id value: " + (e < 0 ? "-" : "") + a);
        return d
    }
    function d(a) {
        var c = 1;
        if ("-" == a.charAt(0) && (c = -1,
        a = a.substring(1)),
        b.NUMBER_DEC.test(a))
            return c * parseInt(a, 10);
        if (b.NUMBER_HEX.test(a))
            return c * parseInt(a.substring(2), 16);
        if (b.NUMBER_OCT.test(a))
            return c * parseInt(a.substring(1), 8);
        if ("inf" === a)
            return c * (1 / 0);
        if ("nan" === a)
            return NaN;
        if (b.NUMBER_FLT.test(a))
            return c * parseFloat(a);
        throw Error("illegal number value: " + (c < 0 ? "-" : "") + a)
    }
    function e(a, b, c) {
        "undefined" == typeof a[b] ? a[b] = c : (Array.isArray(a[b]) || (a[b] = [a[b]]),
        a[b].push(c))
    }
    var f = {}
      , g = function(a) {
        this.source = a + "",
        this.index = 0,
        this.line = 1,
        this.stack = [],
        this._stringOpen = null
    }
      , h = g.prototype;
    h._readString = function() {
        var a = '"' === this._stringOpen ? b.STRING_DQ : b.STRING_SQ;
        a.lastIndex = this.index - 1;
        var c = a.exec(this.source);
        if (!c)
            throw Error("unterminated string");
        return this.index = a.lastIndex,
        this.stack.push(this._stringOpen),
        this._stringOpen = null ,
        c[1]
    }
    ,
    h.next = function() {
        if (this.stack.length > 0)
            return this.stack.shift();
        if (this.index >= this.source.length)
            return null ;
        if (null !== this._stringOpen)
            return this._readString();
        var a, c, d;
        do {
            for (a = !1; b.WHITESPACE.test(d = this.source.charAt(this.index)); )
                if ("\n" === d && ++this.line,
                ++this.index === this.source.length)
                    return null ;
            if ("/" === this.source.charAt(this.index))
                if (++this.index,
                "/" === this.source.charAt(this.index)) {
                    for (; "\n" !== this.source.charAt(++this.index); )
                        if (this.index == this.source.length)
                            return null ;
                    ++this.index,
                    ++this.line,
                    a = !0
                } else {
                    if ("*" !== (d = this.source.charAt(this.index)))
                        return "/";
                    do {
                        if ("\n" === d && ++this.line,
                        ++this.index === this.source.length)
                            return null ;
                        c = d,
                        d = this.source.charAt(this.index)
                    } while ("*" !== c || "/" !== d);++this.index,
                    a = !0
                }
        } while (a);if (this.index === this.source.length)
            return null ;
        var e = this.index;
        b.DELIM.lastIndex = 0;
        var f = b.DELIM.test(this.source.charAt(e++));
        if (!f)
            for (; e < this.source.length && !b.DELIM.test(this.source.charAt(e)); )
                ++e;
        var g = this.source.substring(this.index, this.index = e);
        return '"' !== g && "'" !== g || (this._stringOpen = g),
        g
    }
    ,
    h.peek = function() {
        if (0 === this.stack.length) {
            var a = this.next();
            if (null === a)
                return null ;
            this.stack.push(a)
        }
        return this.stack[0]
    }
    ,
    h.skip = function(a) {
        var b = this.next();
        if (b !== a)
            throw Error("illegal '" + b + "', '" + a + "' expected")
    }
    ,
    h.omit = function(a) {
        return this.peek() === a && (this.next(),
        !0)
    }
    ,
    h.toString = function() {
        return "Tokenizer (" + this.index + "/" + this.source.length + " at line " + this.line + ")"
    }
    ,
    f.Tokenizer = g;
    var i = function(a) {
        this.tn = new g(a),
        this.proto3 = !1
    }
      , j = i.prototype;
    return j.parse = function() {
        var a, c, d = {
            name: "[ROOT]",
            "package": null ,
            messages: [],
            enums: [],
            imports: [],
            options: {},
            services: []
        }, e = !0;
        try {
            for (; a = this.tn.next(); )
                switch (a) {
                case "package":
                    if (!e || null !== d["package"])
                        throw Error("unexpected 'package'");
                    if (a = this.tn.next(),
                    !b.TYPEREF.test(a))
                        throw Error("illegal package name: " + a);
                    this.tn.skip(";"),
                    d["package"] = a;
                    break;
                case "import":
                    if (!e)
                        throw Error("unexpected 'import'");
                    a = this.tn.peek(),
                    ("public" === a || (c = "weak" === a)) && this.tn.next(),
                    a = this._readString(),
                    this.tn.skip(";"),
                    c || d.imports.push(a);
                    break;
                case "syntax":
                    if (!e)
                        throw Error("unexpected 'syntax'");
                    this.tn.skip("="),
                    "proto3" === (d.syntax = this._readString()) && (this.proto3 = !0),
                    this.tn.skip(";");
                    break;
                case "message":
                    this._parseMessage(d, null ),
                    e = !1;
                    break;
                case "enum":
                    this._parseEnum(d),
                    e = !1;
                    break;
                case "option":
                    this._parseOption(d);
                    break;
                case "service":
                    this._parseService(d);
                    break;
                case "extend":
                    this._parseExtend(d);
                    break;
                default:
                    throw Error("unexpected '" + a + "'")
                }
        } catch (f) {
            throw f.message = "Parse error at line " + this.tn.line + ": " + f.message,
            f
        }
        return delete d.name,
        d
    }
    ,
    i.parse = function(a) {
        return new i(a).parse()
    }
    ,
    j._readString = function() {
        var a, b, c = "";
        do {
            if (b = this.tn.next(),
            "'" !== b && '"' !== b)
                throw Error("illegal string delimiter: " + b);
            c += this.tn.next(),
            this.tn.skip(b),
            a = this.tn.peek()
        } while ('"' === a || '"' === a);return c
    }
    ,
    j._readValue = function(a) {
        var c = this.tn.peek();
        if ('"' === c || "'" === c)
            return this._readString();
        if (this.tn.next(),
        b.NUMBER.test(c))
            return d(c);
        if (b.BOOL.test(c))
            return "true" === c.toLowerCase();
        if (a && b.TYPEREF.test(c))
            return c;
        throw Error("illegal value: " + c)
    }
    ,
    j._parseOption = function(a, c) {
        var d = this.tn.next()
          , e = !1;
        if ("(" === d && (e = !0,
        d = this.tn.next()),
        !b.TYPEREF.test(d))
            throw Error("illegal option name: " + d);
        var f = d;
        e && (this.tn.skip(")"),
        f = "(" + f + ")",
        d = this.tn.peek(),
        b.FQTYPEREF.test(d) && (f += d,
        this.tn.next())),
        this.tn.skip("="),
        this._parseOptionValue(a, f),
        c || this.tn.skip(";")
    }
    ,
    j._parseOptionValue = function(a, c) {
        var d = this.tn.peek();
        if ("{" !== d)
            e(a.options, c, this._readValue(!0));
        else
            for (this.tn.skip("{"); "}" !== (d = this.tn.next()); ) {
                if (!b.NAME.test(d))
                    throw Error("illegal option name: " + c + "." + d);
                this.tn.omit(":") ? e(a.options, c + "." + d, this._readValue(!0)) : this._parseOptionValue(a, c + "." + d)
            }
    }
    ,
    j._parseService = function(a) {
        var c = this.tn.next();
        if (!b.NAME.test(c))
            throw Error("illegal service name at line " + this.tn.line + ": " + c);
        var d = c
          , e = {
            name: d,
            rpc: {},
            options: {}
        };
        for (this.tn.skip("{"); "}" !== (c = this.tn.next()); )
            if ("option" === c)
                this._parseOption(e);
            else {
                if ("rpc" !== c)
                    throw Error("illegal service token: " + c);
                this._parseServiceRPC(e)
            }
        this.tn.omit(";"),
        a.services.push(e)
    }
    ,
    j._parseServiceRPC = function(a) {
        var c = "rpc"
          , d = this.tn.next();
        if (!b.NAME.test(d))
            throw Error("illegal rpc service method name: " + d);
        var e = d
          , f = {
            request: null ,
            response: null ,
            request_stream: !1,
            response_stream: !1,
            options: {}
        };
        if (this.tn.skip("("),
        d = this.tn.next(),
        "stream" === d.toLowerCase() && (f.request_stream = !0,
        d = this.tn.next()),
        !b.TYPEREF.test(d))
            throw Error("illegal rpc service request type: " + d);
        if (f.request = d,
        this.tn.skip(")"),
        d = this.tn.next(),
        "returns" !== d.toLowerCase())
            throw Error("illegal rpc service request type delimiter: " + d);
        if (this.tn.skip("("),
        d = this.tn.next(),
        "stream" === d.toLowerCase() && (f.response_stream = !0,
        d = this.tn.next()),
        f.response = d,
        this.tn.skip(")"),
        d = this.tn.peek(),
        "{" === d) {
            for (this.tn.next(); "}" !== (d = this.tn.next()); ) {
                if ("option" !== d)
                    throw Error("illegal rpc service token: " + d);
                this._parseOption(f)
            }
            this.tn.omit(";")
        } else
            this.tn.skip(";");
        "undefined" == typeof a[c] && (a[c] = {}),
        a[c][e] = f
    }
    ,
    j._parseMessage = function(a, d) {
        var e = !!d
          , f = this.tn.next()
          , g = {
            name: "",
            fields: [],
            enums: [],
            messages: [],
            options: {},
            services: [],
            oneofs: {}
        };
        if (!b.NAME.test(f))
            throw Error("illegal " + (e ? "group" : "message") + " name: " + f);
        for (g.name = f,
        e && (this.tn.skip("="),
        d.id = c(this.tn.next()),
        g.isGroup = !0),
        f = this.tn.peek(),
        "[" === f && d && this._parseFieldOptions(d),
        this.tn.skip("{"); "}" !== (f = this.tn.next()); )
            if (b.RULE.test(f))
                this._parseMessageField(g, f);
            else if ("oneof" === f)
                this._parseMessageOneOf(g);
            else if ("enum" === f)
                this._parseEnum(g);
            else if ("message" === f)
                this._parseMessage(g);
            else if ("option" === f)
                this._parseOption(g);
            else if ("service" === f)
                this._parseService(g);
            else if ("extensions" === f)
                g.extensions = this._parseExtensionRanges();
            else if ("reserved" === f)
                this._parseIgnored();
            else if ("extend" === f)
                this._parseExtend(g);
            else {
                if (!b.TYPEREF.test(f))
                    throw Error("illegal message token: " + f);
                if (!this.proto3)
                    throw Error("illegal field rule: " + f);
                this._parseMessageField(g, "optional", f)
            }
        return this.tn.omit(";"),
        a.messages.push(g),
        g
    }
    ,
    j._parseIgnored = function() {
        for (; ";" !== this.tn.peek(); )
            this.tn.next();
        this.tn.skip(";")
    }
    ,
    j._parseMessageField = function(a, d, e) {
        if (!b.RULE.test(d))
            throw Error("illegal message field rule: " + d);
        var f, g = {
            rule: d,
            type: "",
            name: "",
            options: {},
            id: 0
        };
        if ("map" === d) {
            if (e)
                throw Error("illegal type: " + e);
            if (this.tn.skip("<"),
            f = this.tn.next(),
            !b.TYPE.test(f) && !b.TYPEREF.test(f))
                throw Error("illegal message field type: " + f);
            if (g.keytype = f,
            this.tn.skip(","),
            f = this.tn.next(),
            !b.TYPE.test(f) && !b.TYPEREF.test(f))
                throw Error("illegal message field: " + f);
            if (g.type = f,
            this.tn.skip(">"),
            f = this.tn.next(),
            !b.NAME.test(f))
                throw Error("illegal message field name: " + f);
            g.name = f,
            this.tn.skip("="),
            g.id = c(this.tn.next()),
            f = this.tn.peek(),
            "[" === f && this._parseFieldOptions(g),
            this.tn.skip(";")
        } else if (e = "undefined" != typeof e ? e : this.tn.next(),
        "group" === e) {
            var h = this._parseMessage(a, g);
            if (!/^[A-Z]/.test(h.name))
                throw Error("illegal group name: " + h.name);
            g.type = h.name,
            g.name = h.name.toLowerCase(),
            this.tn.omit(";")
        } else {
            if (!b.TYPE.test(e) && !b.TYPEREF.test(e))
                throw Error("illegal message field type: " + e);
            if (g.type = e,
            f = this.tn.next(),
            !b.NAME.test(f))
                throw Error("illegal message field name: " + f);
            g.name = f,
            this.tn.skip("="),
            g.id = c(this.tn.next()),
            f = this.tn.peek(),
            "[" === f && this._parseFieldOptions(g),
            this.tn.skip(";")
        }
        return a.fields.push(g),
        g
    }
    ,
    j._parseMessageOneOf = function(a) {
        var c = this.tn.next();
        if (!b.NAME.test(c))
            throw Error("illegal oneof name: " + c);
        var d, e = c, f = [];
        for (this.tn.skip("{"); "}" !== (c = this.tn.next()); )
            d = this._parseMessageField(a, "optional", c),
            d.oneof = e,
            f.push(d.id);
        this.tn.omit(";"),
        a.oneofs[e] = f
    }
    ,
    j._parseFieldOptions = function(a) {
        this.tn.skip("[");
        for (var b, c = !0; "]" !== (b = this.tn.peek()); )
            c || this.tn.skip(","),
            this._parseOption(a, !0),
            c = !1;
        this.tn.next()
    }
    ,
    j._parseEnum = function(a) {
        var d = {
            name: "",
            values: [],
            options: {}
        }
          , e = this.tn.next();
        if (!b.NAME.test(e))
            throw Error("illegal name: " + e);
        for (d.name = e,
        this.tn.skip("{"); "}" !== (e = this.tn.next()); )
            if ("option" === e)
                this._parseOption(d);
            else {
                if (!b.NAME.test(e))
                    throw Error("illegal name: " + e);
                this.tn.skip("=");
                var f = {
                    name: e,
                    id: c(this.tn.next(), !0)
                };
                e = this.tn.peek(),
                "[" === e && this._parseFieldOptions({
                    options: {}
                }),
                this.tn.skip(";"),
                d.values.push(f)
            }
        this.tn.omit(";"),
        a.enums.push(d)
    }
    ,
    j._parseExtensionRanges = function() {
        var b, c, e, f = [];
        do {
            for (c = []; ; ) {
                switch (b = this.tn.next()) {
                case "min":
                    e = a.ID_MIN;
                    break;
                case "max":
                    e = a.ID_MAX;
                    break;
                default:
                    e = d(b)
                }
                if (c.push(e),
                2 === c.length)
                    break;
                if ("to" !== this.tn.peek()) {
                    c.push(e);
                    break
                }
                this.tn.next()
            }
            f.push(c)
        } while (this.tn.omit(","));return this.tn.skip(";"),
        f
    }
    ,
    j._parseExtend = function(a) {
        var c = this.tn.next();
        if (!b.TYPEREF.test(c))
            throw Error("illegal extend reference: " + c);
        var d = {
            ref: c,
            fields: []
        };
        for (this.tn.skip("{"); "}" !== (c = this.tn.next()); )
            if (b.RULE.test(c))
                this._parseMessageField(d, c);
            else {
                if (!b.TYPEREF.test(c))
                    throw Error("illegal extend token: " + c);
                if (!this.proto3)
                    throw Error("illegal field rule: " + c);
                this._parseMessageField(d, "optional", c)
            }
        return this.tn.omit(";"),
        a.messages.push(d),
        d
    }
    ,
    j.toString = function() {
        return "Parser at line " + this.tn.line
    }
    ,
    f.Parser = i,
    f
}(ProtoBuf, ProtoBuf.Lang),
ProtoBuf.Reflect = function(a) {
    "use strict";
    function b(b) {
        if ("string" == typeof b && (b = a.TYPES[b]),
        "undefined" == typeof b.defaultValue)
            throw Error("default value for type " + b.name + " is not supported");
        return b == a.TYPES.bytes ? new ByteBuffer(0) : b.defaultValue
    }
    function c(b, c) {
        if (b && "number" == typeof b.low && "number" == typeof b.high && "boolean" == typeof b.unsigned && b.low === b.low && b.high === b.high)
            return new a.Long(b.low,b.high,"undefined" == typeof c ? b.unsigned : c);
        if ("string" == typeof b)
            return a.Long.fromString(b, c || !1, 10);
        if ("number" == typeof b)
            return a.Long.fromNumber(b, c || !1);
        throw Error("not convertible to Long")
    }
    function d(b, c) {
        var e = c.readVarint32()
          , f = 7 & e
          , g = e >>> 3;
        switch (f) {
        case a.WIRE_TYPES.VARINT:
            do
                e = c.readUint8();
            while (128 === (128 & e));break;
        case a.WIRE_TYPES.BITS64:
            c.offset += 8;
            break;
        case a.WIRE_TYPES.LDELIM:
            e = c.readVarint32(),
            c.offset += e;
            break;
        case a.WIRE_TYPES.STARTGROUP:
            d(g, c);
            break;
        case a.WIRE_TYPES.ENDGROUP:
            if (g === b)
                return !1;
            throw Error("Illegal GROUPEND after unknown group: " + g + " (" + b + " expected)");
        case a.WIRE_TYPES.BITS32:
            c.offset += 4;
            break;
        default:
            throw Error("Illegal wire type in unknown group " + b + ": " + f)
        }
        return !0
    }
    var e = {}
      , f = function(a, b, c) {
        this.builder = a,
        this.parent = b,
        this.name = c,
        this.className
    }
      , g = f.prototype;
    g.fqn = function() {
        for (var a = this.name, b = this; ; ) {
            if (b = b.parent,
            null == b)
                break;
            a = b.name + "." + a
        }
        return a
    }
    ,
    g.toString = function(a) {
        return (a ? this.className + " " : "") + this.fqn()
    }
    ,
    g.build = function() {
        throw Error(this.toString(!0) + " cannot be built directly")
    }
    ,
    e.T = f;
    var h = function(a, b, c, d, e) {
        f.call(this, a, b, c),
        this.className = "Namespace",
        this.children = [],
        this.options = d || {},
        this.syntax = e || "proto2"
    }
      , i = h.prototype = Object.create(f.prototype);
    i.getChildren = function(a) {
        if (a = a || null ,
        null == a)
            return this.children.slice();
        for (var b = [], c = 0, d = this.children.length; c < d; ++c)
            this.children[c]instanceof a && b.push(this.children[c]);
        return b
    }
    ,
    i.addChild = function(a) {
        var b;
        if (b = this.getChild(a.name))
            if (b instanceof l.Field && b.name !== b.originalName && null === this.getChild(b.originalName))
                b.name = b.originalName;
            else {
                if (!(a instanceof l.Field && a.name !== a.originalName && null === this.getChild(a.originalName)))
                    throw Error("Duplicate name in namespace " + this.toString(!0) + ": " + a.name);
                a.name = a.originalName
            }
        this.children.push(a)
    }
    ,
    i.getChild = function(a) {
        for (var b = "number" == typeof a ? "id" : "name", c = 0, d = this.children.length; c < d; ++c)
            if (this.children[c][b] === a)
                return this.children[c];
        return null
    }
    ,
    i.resolve = function(a, b) {
        var c = "string" == typeof a ? a.split(".") : a
          , d = this
          , f = 0;
        if ("" === c[f]) {
            for (; null !== d.parent; )
                d = d.parent;
            f++
        }
        var g;
        do {
            do {
                if (!(d instanceof e.Namespace)) {
                    d = null ;
                    break
                }
                if (g = d.getChild(c[f]),
                !g || !(g instanceof e.T) || b && !(g instanceof e.Namespace)) {
                    d = null ;
                    break
                }
                d = g,
                f++
            } while (f < c.length);if (null != d)
                break;
            if (null !== this.parent)
                return this.parent.resolve(a, b)
        } while (null != d);return d
    }
    ,
    i.qn = function(a) {
        var b = []
          , c = a;
        do
            b.unshift(c.name),
            c = c.parent;
        while (null !== c);for (var d = 1; d <= b.length; d++) {
            var f = b.slice(b.length - d);
            if (a === this.resolve(f, a instanceof e.Namespace))
                return f.join(".")
        }
        return a.fqn()
    }
    ,
    i.build = function() {
        for (var a, b = {}, c = this.children, d = 0, e = c.length; d < e; ++d)
            a = c[d],
            a instanceof h && (b[a.name] = a.build());
        return Object.defineProperty && Object.defineProperty(b, "$options", {
            value: this.buildOpt()
        }),
        b
    }
    ,
    i.buildOpt = function() {
        for (var a = {}, b = Object.keys(this.options), c = 0, d = b.length; c < d; ++c) {
            var e = b[c]
              , f = this.options[b[c]];
            a[e] = f
        }
        return a
    }
    ,
    i.getOption = function(a) {
        return "undefined" == typeof a ? this.options : "undefined" != typeof this.options[a] ? this.options[a] : null
    }
    ,
    e.Namespace = h;
    var j = function(b, c, d, e) {
        if (this.type = b,
        this.resolvedType = c,
        this.isMapKey = d,
        this.syntax = e,
        d && a.MAP_KEY_TYPES.indexOf(b) < 0)
            throw Error("Invalid map key type: " + b.name)
    }
      , k = j.prototype;
    j.defaultFieldValue = b,
    k.verifyValue = function(b) {
        function d(a, b) {
            throw Error("Illegal value for " + e.toString(!0) + " of type " + e.type.name + ": " + a + " (" + b + ")")
        }
        var e = this;
        switch (this.type) {
        case a.TYPES.int32:
        case a.TYPES.sint32:
        case a.TYPES.sfixed32:
            return ("number" != typeof b || b === b && b % 1 !== 0) && d(typeof b, "not an integer"),
            b > 4294967295 ? 0 | b : b;
        case a.TYPES.uint32:
        case a.TYPES.fixed32:
            return ("number" != typeof b || b === b && b % 1 !== 0) && d(typeof b, "not an integer"),
            b < 0 ? b >>> 0 : b;
        case a.TYPES.int64:
        case a.TYPES.sint64:
        case a.TYPES.sfixed64:
            if (a.Long)
                try {
                    return c(b, !1)
                } catch (f) {
                    d(typeof b, f.message)
                }
            else
                d(typeof b, "requires Long.js");
        case a.TYPES.uint64:
        case a.TYPES.fixed64:
            if (a.Long)
                try {
                    return c(b, !0)
                } catch (f) {
                    d(typeof b, f.message)
                }
            else
                d(typeof b, "requires Long.js");
        case a.TYPES.bool:
            return "boolean" != typeof b && d(typeof b, "not a boolean"),
            b;
        case a.TYPES["float"]:
        case a.TYPES["double"]:
            return "number" != typeof b && d(typeof b, "not a number"),
            b;
        case a.TYPES.string:
            return "string" == typeof b || b && b instanceof String || d(typeof b, "not a string"),
            "" + b;
        case a.TYPES.bytes:
            return ByteBuffer.isByteBuffer(b) ? b : ByteBuffer.wrap(b, "base64");
        case a.TYPES["enum"]:
            var g = this.resolvedType.getChildren(a.Reflect.Enum.Value);
            for (i = 0; i < g.length; i++) {
                if (g[i].name == b)
                    return g[i].id;
                if (g[i].id == b)
                    return g[i].id
            }
            if ("proto3" === this.syntax)
                return ("number" != typeof b || b === b && b % 1 !== 0) && d(typeof b, "not an integer"),
                (b > 4294967295 || b < 0) && d(typeof b, "not in range for uint32"),
                b;
            d(b, "not a valid enum value");
        case a.TYPES.group:
        case a.TYPES.message:
            if (b && "object" == typeof b || d(typeof b, "object expected"),
            b instanceof this.resolvedType.clazz)
                return b;
            if (b instanceof a.Builder.Message) {
                var h = {};
                for (var i in b)
                    b.hasOwnProperty(i) && (h[i] = b[i]);
                b = h
            }
            return new this.resolvedType.clazz(b)
        }
        throw Error("[INTERNAL] Illegal value for " + this.toString(!0) + ": " + b + " (undefined type " + this.type + ")")
    }
    ,
    k.calculateLength = function(b, c) {
        if (null === c)
            return 0;
        var d;
        switch (this.type) {
        case a.TYPES.int32:
            return c < 0 ? ByteBuffer.calculateVarint64(c) : ByteBuffer.calculateVarint32(c);
        case a.TYPES.uint32:
            return ByteBuffer.calculateVarint32(c);
        case a.TYPES.sint32:
            return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(c));
        case a.TYPES.fixed32:
        case a.TYPES.sfixed32:
        case a.TYPES["float"]:
            return 4;
        case a.TYPES.int64:
        case a.TYPES.uint64:
            return ByteBuffer.calculateVarint64(c);
        case a.TYPES.sint64:
            return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(c));
        case a.TYPES.fixed64:
        case a.TYPES.sfixed64:
            return 8;
        case a.TYPES.bool:
            return 1;
        case a.TYPES["enum"]:
            return ByteBuffer.calculateVarint32(c);
        case a.TYPES["double"]:
            return 8;
        case a.TYPES.string:
            return d = ByteBuffer.calculateUTF8Bytes(c),
            ByteBuffer.calculateVarint32(d) + d;
        case a.TYPES.bytes:
            if (c.remaining() < 0)
                throw Error("Illegal value for " + this.toString(!0) + ": " + c.remaining() + " bytes remaining");
            return ByteBuffer.calculateVarint32(c.remaining()) + c.remaining();
        case a.TYPES.message:
            return d = this.resolvedType.calculate(c),
            ByteBuffer.calculateVarint32(d) + d;
        case a.TYPES.group:
            return d = this.resolvedType.calculate(c),
            d + ByteBuffer.calculateVarint32(b << 3 | a.WIRE_TYPES.ENDGROUP)
        }
        throw Error("[INTERNAL] Illegal value to encode in " + this.toString(!0) + ": " + c + " (unknown type)")
    }
    ,
    k.encodeValue = function(b, c, d) {
        if (null === c)
            return d;
        switch (this.type) {
        case a.TYPES.int32:
            c < 0 ? d.writeVarint64(c) : d.writeVarint32(c);
            break;
        case a.TYPES.uint32:
            d.writeVarint32(c);
            break;
        case a.TYPES.sint32:
            d.writeVarint32ZigZag(c);
            break;
        case a.TYPES.fixed32:
            d.writeUint32(c);
            break;
        case a.TYPES.sfixed32:
            d.writeInt32(c);
            break;
        case a.TYPES.int64:
        case a.TYPES.uint64:
            d.writeVarint64(c);
            break;
        case a.TYPES.sint64:
            d.writeVarint64ZigZag(c);
            break;
        case a.TYPES.fixed64:
            d.writeUint64(c);
            break;
        case a.TYPES.sfixed64:
            d.writeInt64(c);
            break;
        case a.TYPES.bool:
            "string" == typeof c ? d.writeVarint32("false" === c.toLowerCase() ? 0 : !!c) : d.writeVarint32(c ? 1 : 0);
            break;
        case a.TYPES["enum"]:
            d.writeVarint32(c);
            break;
        case a.TYPES["float"]:
            d.writeFloat32(c);
            break;
        case a.TYPES["double"]:
            d.writeFloat64(c);
            break;
        case a.TYPES.string:
            d.writeVString(c);
            break;
        case a.TYPES.bytes:
            if (c.remaining() < 0)
                throw Error("Illegal value for " + this.toString(!0) + ": " + c.remaining() + " bytes remaining");
            var e = c.offset;
            d.writeVarint32(c.remaining()),
            d.append(c),
            c.offset = e;
            break;
        case a.TYPES.message:
            var f = (new ByteBuffer).LE();
            this.resolvedType.encode(c, f),
            d.writeVarint32(f.offset),
            d.append(f.flip());
            break;
        case a.TYPES.group:
            this.resolvedType.encode(c, d),
            d.writeVarint32(b << 3 | a.WIRE_TYPES.ENDGROUP);
            break;
        default:
            throw Error("[INTERNAL] Illegal value to encode in " + this.toString(!0) + ": " + c + " (unknown type)")
        }
        return d
    }
    ,
    k.decode = function(b, c, d) {
        if (c != this.type.wireType)
            throw Error("Unexpected wire type for element");
        var e, f;
        switch (this.type) {
        case a.TYPES.int32:
            return 0 | b.readVarint32();
        case a.TYPES.uint32:
            return b.readVarint32() >>> 0;
        case a.TYPES.sint32:
            return 0 | b.readVarint32ZigZag();
        case a.TYPES.fixed32:
            return b.readUint32() >>> 0;
        case a.TYPES.sfixed32:
            return 0 | b.readInt32();
        case a.TYPES.int64:
            return b.readVarint64();
        case a.TYPES.uint64:
            return b.readVarint64().toUnsigned();
        case a.TYPES.sint64:
            return b.readVarint64ZigZag();
        case a.TYPES.fixed64:
            return b.readUint64();
        case a.TYPES.sfixed64:
            return b.readInt64();
        case a.TYPES.bool:
            return !!b.readVarint32();
        case a.TYPES["enum"]:
            return b.readVarint32();
        case a.TYPES["float"]:
            return b.readFloat();
        case a.TYPES["double"]:
            return b.readDouble();
        case a.TYPES.string:
            return b.readVString();
        case a.TYPES.bytes:
            if (f = b.readVarint32(),
            b.remaining() < f)
                throw Error("Illegal number of bytes for " + this.toString(!0) + ": " + f + " required but got only " + b.remaining());
            return e = b.clone(),
            e.limit = e.offset + f,
            b.offset += f,
            e;
        case a.TYPES.message:
            return f = b.readVarint32(),
            this.resolvedType.decode(b, f);
        case a.TYPES.group:
            return this.resolvedType.decode(b, -1, d)
        }
        throw Error("[INTERNAL] Illegal decode type")
    }
    ,
    k.valueFromString = function(b) {
        if (!this.isMapKey)
            throw Error("valueFromString() called on non-map-key element");
        switch (this.type) {
        case a.TYPES.int32:
        case a.TYPES.sint32:
        case a.TYPES.sfixed32:
        case a.TYPES.uint32:
        case a.TYPES.fixed32:
            return this.verifyValue(parseInt(b));
        case a.TYPES.int64:
        case a.TYPES.sint64:
        case a.TYPES.sfixed64:
        case a.TYPES.uint64:
        case a.TYPES.fixed64:
            return this.verifyValue(b);
        case a.TYPES.bool:
            return "true" === b;
        case a.TYPES.string:
            return this.verifyValue(b);
        case a.TYPES.bytes:
            return ByteBuffer.fromBinary(b)
        }
    }
    ,
    k.valueToString = function(b) {
        if (!this.isMapKey)
            throw Error("valueToString() called on non-map-key element");
        return this.type === a.TYPES.bytes ? b.toString("binary") : b.toString()
    }
    ,
    e.Element = j;
    var l = function(a, b, c, d, e, f) {
        h.call(this, a, b, c, d, f),
        this.className = "Message",
        this.extensions = void 0,
        this.clazz = null ,
        this.isGroup = !!e,
        this._fields = null ,
        this._fieldsById = null ,
        this._fieldsByName = null
    }
      , m = l.prototype = Object.create(h.prototype);
    m.build = function(b) {
        if (this.clazz && !b)
            return this.clazz;
        var c = function(a, b) {
            function c(b, d, e, f) {
                if (null === b || "object" != typeof b) {
                    if (f && f instanceof a.Reflect.Enum) {
                        var g = a.Reflect.Enum.getName(f.object, b);
                        if (null !== g)
                            return g
                    }
                    return b
                }
                if (ByteBuffer.isByteBuffer(b))
                    return d ? b.toBase64() : b.toBuffer();
                if (a.Long.isLong(b))
                    return e ? b.toString() : a.Long.fromValue(b);
                var h;
                if (Array.isArray(b))
                    return h = [],
                    b.forEach(function(a, b) {
                        h[b] = c(a, d, e, f)
                    }),
                    h;
                if (h = {},
                b instanceof a.Map) {
                    for (var i = b.entries(), j = i.next(); !j.done; j = i.next())
                        h[b.keyElem.valueToString(j.value[0])] = c(j.value[1], d, e, b.valueElem.resolvedType);
                    return h
                }
                var k = b.$type
                  , l = void 0;
                for (var m in b)
                    b.hasOwnProperty(m) && (k && (l = k.getChild(m)) ? h[m] = c(b[m], d, e, l.resolvedType) : h[m] = c(b[m], d, e));
                return h
            }
            var d = b.getChildren(a.Reflect.Message.Field)
              , e = b.getChildren(a.Reflect.Message.OneOf)
              , f = function(c, g) {
                a.Builder.Message.call(this);
                for (var h = 0, i = e.length; h < i; ++h)
                    this[e[h].name] = null ;
                for (h = 0,
                i = d.length; h < i; ++h) {
                    var j = d[h];
                    this[j.name] = j.repeated ? [] : j.map ? new a.Map(j) : null ,
                    !j.required && "proto3" !== b.syntax || null === j.defaultValue || (this[j.name] = j.defaultValue)
                }
                if (arguments.length > 0) {
                    var k;
                    if (1 !== arguments.length || null === c || "object" != typeof c || !("function" != typeof c.encode || c instanceof f) || Array.isArray(c) || c instanceof a.Map || ByteBuffer.isByteBuffer(c) || c instanceof ArrayBuffer || a.Long && c instanceof a.Long)
                        for (h = 0,
                        i = arguments.length; h < i; ++h)
                            "undefined" != typeof (k = arguments[h]) && this.$set(d[h].name, k);
                    else
                        this.$set(c)
                }
            }
              , g = f.prototype = Object.create(a.Builder.Message.prototype);
            g.add = function(c, d, e) {
                var f = b._fieldsByName[c];
                if (!e) {
                    if (!f)
                        throw Error(this + "#" + c + " is undefined");
                    if (!(f instanceof a.Reflect.Message.Field))
                        throw Error(this + "#" + c + " is not a field: " + f.toString(!0));
                    if (!f.repeated)
                        throw Error(this + "#" + c + " is not a repeated field");
                    d = f.verifyValue(d, !0)
                }
                return null === this[c] && (this[c] = []),
                this[c].push(d),
                this
            }
            ,
            g.$add = g.add,
            g.set = function(c, d, e) {
                if (c && "object" == typeof c) {
                    e = d;
                    for (var f in c)
                        c.hasOwnProperty(f) && "undefined" != typeof (d = c[f]) && this.$set(f, d, e);
                    return this
                }
                var g = b._fieldsByName[c];
                if (e)
                    this[c] = d;
                else {
                    if (!g)
                        throw Error(this + "#" + c + " is not a field: undefined");
                    if (!(g instanceof a.Reflect.Message.Field))
                        throw Error(this + "#" + c + " is not a field: " + g.toString(!0));
                    this[g.name] = d = g.verifyValue(d)
                }
                if (g && g.oneof) {
                    var h = this[g.oneof.name];
                    null !== d ? (null !== h && h !== g.name && (this[h] = null ),
                    this[g.oneof.name] = g.name) : h === c && (this[g.oneof.name] = null )
                }
                return this
            }
            ,
            g.$set = g.set,
            g.get = function(c, d) {
                if (d)
                    return this[c];
                var e = b._fieldsByName[c];
                if (!(e && e instanceof a.Reflect.Message.Field))
                    throw Error(this + "#" + c + " is not a field: undefined");
                if (!(e instanceof a.Reflect.Message.Field))
                    throw Error(this + "#" + c + " is not a field: " + e.toString(!0));
                return this[e.name]
            }
            ,
            g.$get = g.get;
            for (var h = 0; h < d.length; h++) {
                var i = d[h];
                i instanceof a.Reflect.Message.ExtensionField || b.builder.options.populateAccessors && function(a) {
                    var c = a.originalName.replace(/(_[a-zA-Z])/g, function(a) {
                        return a.toUpperCase().replace("_", "")
                    });
                    c = c.substring(0, 1).toUpperCase() + c.substring(1);
                    var d = a.originalName.replace(/([A-Z])/g, function(a) {
                        return "_" + a
                    })
                      , e = function(b, c) {
                        return this[a.name] = c ? b : a.verifyValue(b),
                        this
                    }
                      , f = function() {
                        return this[a.name]
                    }
                    ;
                    null === b.getChild("set" + c) && (g["set" + c] = e),
                    null === b.getChild("set_" + d) && (g["set_" + d] = e),
                    null === b.getChild("get" + c) && (g["get" + c] = f),
                    null === b.getChild("get_" + d) && (g["get_" + d] = f)
                }(i)
            }
            g.encode = function(a, c) {
                "boolean" == typeof a && (c = a,
                a = void 0);
                var d = !1;
                a || (a = new ByteBuffer,
                d = !0);
                var e = a.littleEndian;
                try {
                    return b.encode(this, a.LE(), c),
                    (d ? a.flip() : a).LE(e)
                } catch (f) {
                    throw a.LE(e),
                    f
                }
            }
            ,
            f.encode = function(a, b, c) {
                return new f(a).encode(b, c)
            }
            ,
            g.calculate = function() {
                return b.calculate(this)
            }
            ,
            g.encodeDelimited = function(a, c) {
                var d = !1;
                a || (a = new ByteBuffer,
                d = !0);
                var e = (new ByteBuffer).LE();
                return b.encode(this, e, c).flip(),
                a.writeVarint32(e.remaining()),
                a.append(e),
                d ? a.flip() : a
            }
            ,
            g.encodeAB = function() {
                try {
                    return this.encode().toArrayBuffer()
                } catch (a) {
                    throw a.encoded && (a.encoded = a.encoded.toArrayBuffer()),
                    a
                }
            }
            ,
            g.toArrayBuffer = g.encodeAB,
            g.encodeNB = function() {
                try {
                    return this.encode().toBuffer()
                } catch (a) {
                    throw a.encoded && (a.encoded = a.encoded.toBuffer()),
                    a
                }
            }
            ,
            g.toBuffer = g.encodeNB,
            g.encode64 = function() {
                try {
                    return this.encode().toBase64()
                } catch (a) {
                    throw a.encoded && (a.encoded = a.encoded.toBase64()),
                    a
                }
            }
            ,
            g.toBase64 = g.encode64,
            g.encodeHex = function() {
                try {
                    return this.encode().toHex()
                } catch (a) {
                    throw a.encoded && (a.encoded = a.encoded.toHex()),
                    a
                }
            }
            ,
            g.toHex = g.encodeHex,
            g.toRaw = function(a, b) {
                return c(this, !!a, !!b, this.$type)
            }
            ,
            g.encodeJSON = function() {
                return JSON.stringify(c(this, !0, !0, this.$type))
            }
            ,
            f.decode = function(a, c, d) {
                "string" == typeof c && (d = c,
                c = -1),
                "string" == typeof a && (a = ByteBuffer.wrap(a, d ? d : "base64")),
                a = ByteBuffer.isByteBuffer(a) ? a : ByteBuffer.wrap(a);
                var e = a.littleEndian;
                try {
                    var f = b.decode(a.LE());
                    return a.LE(e),
                    f
                } catch (g) {
                    throw a.LE(e),
                    g
                }
            }
            ,
            f.decodeDelimited = function(a, c) {
                if ("string" == typeof a && (a = ByteBuffer.wrap(a, c ? c : "base64")),
                a = ByteBuffer.isByteBuffer(a) ? a : ByteBuffer.wrap(a),
                a.remaining() < 1)
                    return null ;
                var d = a.offset
                  , e = a.readVarint32();
                if (a.remaining() < e)
                    return a.offset = d,
                    null ;
                try {
                    var f = b.decode(a.slice(a.offset, a.offset + e).LE());
                    return a.offset += e,
                    f
                } catch (g) {
                    throw a.offset += e,
                    g
                }
            }
            ,
            f.decode64 = function(a) {
                return f.decode(a, "base64")
            }
            ,
            f.decodeHex = function(a) {
                return f.decode(a, "hex")
            }
            ,
            f.decodeJSON = function(a) {
                return new f(JSON.parse(a))
            }
            ,
            g.toString = function() {
                return b.toString()
            }
            ;
            return Object.defineProperty && (Object.defineProperty(f, "$options", {
                value: b.buildOpt()
            }),
            Object.defineProperty(g, "$options", {
                value: f.$options
            }),
            Object.defineProperty(f, "$type", {
                value: b
            }),
            Object.defineProperty(g, "$type", {
                value: b
            })),
            f
        }(a, this);
        this._fields = [],
        this._fieldsById = {},
        this._fieldsByName = {};
        for (var d, e = 0, f = this.children.length; e < f; e++)
            if (d = this.children[e],
            d instanceof r || d instanceof l || d instanceof v) {
                if (c.hasOwnProperty(d.name))
                    throw Error("Illegal reflect child of " + this.toString(!0) + ": " + d.toString(!0) + " cannot override static property '" + d.name + "'");
                c[d.name] = d.build()
            } else if (d instanceof l.Field)
                d.build(),
                this._fields.push(d),
                this._fieldsById[d.id] = d,
                this._fieldsByName[d.name] = d;
            else if (!(d instanceof l.OneOf || d instanceof u))
                throw Error("Illegal reflect child of " + this.toString(!0) + ": " + this.children[e].toString(!0));
        return this.clazz = c
    }
    ,
    m.encode = function(a, b, c) {
        for (var d, e, f = null , g = 0, h = this._fields.length; g < h; ++g)
            d = this._fields[g],
            e = a[d.name],
            d.required && null === e ? null === f && (f = d) : d.encode(c ? e : d.verifyValue(e), b, a);
        if (null !== f) {
            var i = Error("Missing at least one required field for " + this.toString(!0) + ": " + f);
            throw i.encoded = b,
            i
        }
        return b
    }
    ,
    m.calculate = function(a) {
        for (var b, c, d = 0, e = 0, f = this._fields.length; e < f; ++e) {
            if (b = this._fields[e],
            c = a[b.name],
            b.required && null === c)
                throw Error("Missing at least one required field for " + this.toString(!0) + ": " + b);
            d += b.calculate(c, a)
        }
        return d
    }
    ,
    m.decode = function(b, c, e) {
        c = "number" == typeof c ? c : -1;
        for (var f, g, h, i, j = b.offset, k = new this.clazz; b.offset < j + c || c === -1 && b.remaining() > 0; ) {
            if (f = b.readVarint32(),
            g = 7 & f,
            h = f >>> 3,
            g === a.WIRE_TYPES.ENDGROUP) {
                if (h !== e)
                    throw Error("Illegal group end indicator for " + this.toString(!0) + ": " + h + " (" + (e ? e + " expected" : "not a group") + ")");
                break
            }
            if (i = this._fieldsById[h]) {
                if (i.repeated && !i.options.packed)
                    k[i.name].push(i.decode(g, b));
                else if (i.map) {
                    var l = i.decode(g, b);
                    k[i.name].set(l[0], l[1])
                } else if (k[i.name] = i.decode(g, b),
                i.oneof) {
                    var m = k[i.oneof.name];
                    null !== m && m !== i.name && (k[m] = null ),
                    k[i.oneof.name] = i.name
                }
            } else
                switch (g) {
                case a.WIRE_TYPES.VARINT:
                    b.readVarint32();
                    break;
                case a.WIRE_TYPES.BITS32:
                    b.offset += 4;
                    break;
                case a.WIRE_TYPES.BITS64:
                    b.offset += 8;
                    break;
                case a.WIRE_TYPES.LDELIM:
                    var n = b.readVarint32();
                    b.offset += n;
                    break;
                case a.WIRE_TYPES.STARTGROUP:
                    for (; d(h, b); )
                        ;
                    break;
                default:
                    throw Error("Illegal wire type for unknown field " + h + " in " + this.toString(!0) + "#decode: " + g)
                }
        }
        for (var o = 0, p = this._fields.length; o < p; ++o)
            if (i = this._fields[o],
            null === k[i.name])
                if ("proto3" === this.syntax)
                    k[i.name] = i.defaultValue;
                else {
                    if (i.required) {
                        var q = Error("Missing at least one required field for " + this.toString(!0) + ": " + i.name);
                        throw q.decoded = k,
                        q
                    }
                    a.populateDefaults && null !== i.defaultValue && (k[i.name] = i.defaultValue)
                }
        return k
    }
    ,
    e.Message = l;
    var n = function(b, c, d, e, g, h, i, j, k, m) {
        f.call(this, b, c, h),
        this.className = "Message.Field",
        this.required = "required" === d,
        this.repeated = "repeated" === d,
        this.map = "map" === d,
        this.keyType = e || null ,
        this.type = g,
        this.resolvedType = null ,
        this.id = i,
        this.options = j || {},
        this.defaultValue = null ,
        this.oneof = k || null ,
        this.syntax = m || "proto2",
        this.originalName = this.name,
        this.element = null ,
        this.keyElement = null ,
        !this.builder.options.convertFieldsToCamelCase || this instanceof l.ExtensionField || (this.name = a.Util.toCamelCase(this.name))
    }
      , o = n.prototype = Object.create(f.prototype);
    o.build = function() {
        this.element = new j(this.type,this.resolvedType,(!1),this.syntax),
        this.map && (this.keyElement = new j(this.keyType,(void 0),(!0),this.syntax)),
        "proto3" !== this.syntax || this.repeated || this.map ? "undefined" != typeof this.options["default"] && (this.defaultValue = this.verifyValue(this.options["default"])) : this.defaultValue = j.defaultFieldValue(this.type)
    }
    ,
    o.verifyValue = function(b, c) {
        function d(a, b) {
            throw Error("Illegal value for " + e.toString(!0) + " of type " + e.type.name + ": " + a + " (" + b + ")")
        }
        c = c || !1;
        var e = this;
        if (null === b)
            return this.required && d(typeof b, "required"),
            "proto3" === this.syntax && this.type !== a.TYPES.message && d(typeof b, "proto3 field without field presence cannot be null"),
            null ;
        var f;
        if (this.repeated && !c) {
            Array.isArray(b) || (b = [b]);
            var g = [];
            for (f = 0; f < b.length; f++)
                g.push(this.element.verifyValue(b[f]));
            return g
        }
        return this.map && !c ? b instanceof a.Map ? b : (b instanceof Object || d(typeof b, "expected ProtoBuf.Map or raw object for map field"),
        new a.Map(this,b)) : (!this.repeated && Array.isArray(b) && d(typeof b, "no array expected"),
        this.element.verifyValue(b))
    }
    ,
    o.hasWirePresence = function(b, c) {
        if ("proto3" !== this.syntax)
            return null !== b;
        if (this.oneof && c[this.oneof.name] === this.name)
            return !0;
        switch (this.type) {
        case a.TYPES.int32:
        case a.TYPES.sint32:
        case a.TYPES.sfixed32:
        case a.TYPES.uint32:
        case a.TYPES.fixed32:
            return 0 !== b;
        case a.TYPES.int64:
        case a.TYPES.sint64:
        case a.TYPES.sfixed64:
        case a.TYPES.uint64:
        case a.TYPES.fixed64:
            return 0 !== b.low || 0 !== b.high;
        case a.TYPES.bool:
            return b;
        case a.TYPES["float"]:
        case a.TYPES["double"]:
            return 0 !== b;
        case a.TYPES.string:
            return b.length > 0;
        case a.TYPES.bytes:
            return b.remaining() > 0;
        case a.TYPES["enum"]:
            return 0 !== b;
        case a.TYPES.message:
            return null !== b;
        default:
            return !0
        }
    }
    ,
    o.encode = function(b, c, d) {
        if (null === this.type || "object" != typeof this.type)
            throw Error("[INTERNAL] Unresolved type in " + this.toString(!0) + ": " + this.type);
        if (null === b || this.repeated && 0 == b.length)
            return c;
        try {
            if (this.repeated) {
                var e;
                if (this.options.packed && a.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                    c.writeVarint32(this.id << 3 | a.WIRE_TYPES.LDELIM),
                    c.ensureCapacity(c.offset += 1);
                    var f = c.offset;
                    for (e = 0; e < b.length; e++)
                        this.element.encodeValue(this.id, b[e], c);
                    var g = c.offset - f
                      , h = ByteBuffer.calculateVarint32(g);
                    if (h > 1) {
                        var i = c.slice(f, c.offset);
                        f += h - 1,
                        c.offset = f,
                        c.append(i)
                    }
                    c.writeVarint32(g, f - h)
                } else
                    for (e = 0; e < b.length; e++)
                        c.writeVarint32(this.id << 3 | this.type.wireType),
                        this.element.encodeValue(this.id, b[e], c)
            } else
                this.map ? b.forEach(function(b, d, e) {
                    var f = ByteBuffer.calculateVarint32(8 | this.keyType.wireType) + this.keyElement.calculateLength(1, d) + ByteBuffer.calculateVarint32(16 | this.type.wireType) + this.element.calculateLength(2, b);
                    c.writeVarint32(this.id << 3 | a.WIRE_TYPES.LDELIM),
                    c.writeVarint32(f),
                    c.writeVarint32(8 | this.keyType.wireType),
                    this.keyElement.encodeValue(1, d, c),
                    c.writeVarint32(16 | this.type.wireType),
                    this.element.encodeValue(2, b, c)
                }, this) : this.hasWirePresence(b, d) && (c.writeVarint32(this.id << 3 | this.type.wireType),
                this.element.encodeValue(this.id, b, c))
        } catch (j) {
            throw Error("Illegal value for " + this.toString(!0) + ": " + b + " (" + j + ")")
        }
        return c
    }
    ,
    o.calculate = function(b, c) {
        if (b = this.verifyValue(b),
        null === this.type || "object" != typeof this.type)
            throw Error("[INTERNAL] Unresolved type in " + this.toString(!0) + ": " + this.type);
        if (null === b || this.repeated && 0 == b.length)
            return 0;
        var d = 0;
        try {
            if (this.repeated) {
                var e, f;
                if (this.options.packed && a.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                    for (d += ByteBuffer.calculateVarint32(this.id << 3 | a.WIRE_TYPES.LDELIM),
                    f = 0,
                    e = 0; e < b.length; e++)
                        f += this.element.calculateLength(this.id, b[e]);
                    d += ByteBuffer.calculateVarint32(f),
                    d += f
                } else
                    for (e = 0; e < b.length; e++)
                        d += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType),
                        d += this.element.calculateLength(this.id, b[e])
            } else
                this.map ? b.forEach(function(b, c, e) {
                    var f = ByteBuffer.calculateVarint32(8 | this.keyType.wireType) + this.keyElement.calculateLength(1, c) + ByteBuffer.calculateVarint32(16 | this.type.wireType) + this.element.calculateLength(2, b);
                    d += ByteBuffer.calculateVarint32(this.id << 3 | a.WIRE_TYPES.LDELIM),
                    d += ByteBuffer.calculateVarint32(f),
                    d += f
                }, this) : this.hasWirePresence(b, c) && (d += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType),
                d += this.element.calculateLength(this.id, b))
        } catch (g) {
            throw Error("Illegal value for " + this.toString(!0) + ": " + b + " (" + g + ")")
        }
        return d
    }
    ,
    o.decode = function(b, c, d) {
        var e, f, g = !this.map && b == this.type.wireType || !d && this.repeated && this.options.packed && b == a.WIRE_TYPES.LDELIM || this.map && b == a.WIRE_TYPES.LDELIM;
        if (!g)
            throw Error("Illegal wire type for field " + this.toString(!0) + ": " + b + " (" + this.type.wireType + " expected)");
        if (b == a.WIRE_TYPES.LDELIM && this.repeated && this.options.packed && a.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0 && !d) {
            f = c.readVarint32(),
            f = c.offset + f;
            for (var h = []; c.offset < f; )
                h.push(this.decode(this.type.wireType, c, !0));
            return h
        }
        if (this.map) {
            var i = j.defaultFieldValue(this.keyType);
            if (e = j.defaultFieldValue(this.type),
            f = c.readVarint32(),
            c.remaining() < f)
                throw Error("Illegal number of bytes for " + this.toString(!0) + ": " + f + " required but got only " + c.remaining());
            var k = c.clone();
            for (k.limit = k.offset + f,
            c.offset += f; k.remaining() > 0; ) {
                var l = k.readVarint32();
                b = 7 & l;
                var m = l >>> 3;
                if (1 === m)
                    i = this.keyElement.decode(k, b, m);
                else {
                    if (2 !== m)
                        throw Error("Unexpected tag in map field key/value submessage");
                    e = this.element.decode(k, b, m)
                }
            }
            return [i, e]
        }
        return this.element.decode(c, b, this.id)
    }
    ,
    e.Message.Field = n;
    var p = function(a, b, c, d, e, f, g) {
        n.call(this, a, b, c, null , d, e, f, g),
        this.extension
    }
    ;
    p.prototype = Object.create(n.prototype),
    e.Message.ExtensionField = p;
    var q = function(a, b, c) {
        f.call(this, a, b, c),
        this.fields = []
    }
    ;
    e.Message.OneOf = q;
    var r = function(a, b, c, d, e) {
        h.call(this, a, b, c, d, e),
        this.className = "Enum",
        this.object = null
    }
    ;
    r.getName = function(a, b) {
        for (var c, d = Object.keys(a), e = 0; e < d.length; ++e)
            if (a[c = d[e]] === b)
                return c;
        return null
    }
    ;
    var s = r.prototype = Object.create(h.prototype);
    s.build = function(b) {
        if (this.object && !b)
            return this.object;
        for (var c = new a.Builder.Enum, d = this.getChildren(r.Value), e = 0, f = d.length; e < f; ++e)
            c[d[e].name] = d[e].id;
        return Object.defineProperty && Object.defineProperty(c, "$options", {
            value: this.buildOpt(),
            enumerable: !1
        }),
        this.object = c
    }
    ,
    e.Enum = r;
    var t = function(a, b, c, d) {
        f.call(this, a, b, c),
        this.className = "Enum.Value",
        this.id = d
    }
    ;
    t.prototype = Object.create(f.prototype),
    e.Enum.Value = t;
    var u = function(a, b, c, d) {
        f.call(this, a, b, c),
        this.field = d
    }
    ;
    u.prototype = Object.create(f.prototype),
    e.Extension = u;
    var v = function(a, b, c, d) {
        h.call(this, a, b, c, d),
        this.className = "Service",
        this.clazz = null
    }
      , w = v.prototype = Object.create(h.prototype);
    w.build = function(b) {
        return this.clazz && !b ? this.clazz : this.clazz = function(a, b) {
            for (var c = function(b) {
                a.Builder.Service.call(this),
                this.rpcImpl = b || function(a, b, c) {
                    setTimeout(c.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0)
                }
            }
            , d = c.prototype = Object.create(a.Builder.Service.prototype), e = b.getChildren(a.Reflect.Service.RPCMethod), f = 0; f < e.length; f++)
                !function(a) {
                    d[a.name] = function(c, d) {
                        try {
                            try {
                                c = a.resolvedRequestType.clazz.decode(ByteBuffer.wrap(c))
                            } catch (e) {
                                if (!(e instanceof TypeError))
                                    throw e
                            }
                            if (null === c || "object" != typeof c)
                                throw Error("Illegal arguments");
                            c instanceof a.resolvedRequestType.clazz || (c = new a.resolvedRequestType.clazz(c)),
                            this.rpcImpl(a.fqn(), c, function(c, e) {
                                if (c)
                                    return void d(c);
                                null === e && (e = "");
                                try {
                                    e = a.resolvedResponseType.clazz.decode(e)
                                } catch (f) {}
                                return e && e instanceof a.resolvedResponseType.clazz ? void d(null , e) : void d(Error("Illegal response type received in service method " + b.name + "#" + a.name))
                            })
                        } catch (e) {
                            setTimeout(d.bind(this, e), 0)
                        }
                    }
                    ,
                    c[a.name] = function(b, d, e) {
                        new c(b)[a.name](d, e)
                    }
                    ,
                    Object.defineProperty && (Object.defineProperty(c[a.name], "$options", {
                        value: a.buildOpt()
                    }),
                    Object.defineProperty(d[a.name], "$options", {
                        value: c[a.name].$options
                    }))
                }(e[f]);
            return Object.defineProperty && (Object.defineProperty(c, "$options", {
                value: b.buildOpt()
            }),
            Object.defineProperty(d, "$options", {
                value: c.$options
            }),
            Object.defineProperty(c, "$type", {
                value: b
            }),
            Object.defineProperty(d, "$type", {
                value: b
            })),
            c
        }(a, this)
    }
    ,
    e.Service = v;
    var x = function(a, b, c, d) {
        f.call(this, a, b, c),
        this.className = "Service.Method",
        this.options = d || {}
    }
      , y = x.prototype = Object.create(f.prototype);
    y.buildOpt = i.buildOpt,
    e.Service.Method = x;
    var z = function(a, b, c, d, e, f, g, h) {
        x.call(this, a, b, c, h),
        this.className = "Service.RPCMethod",
        this.requestName = d,
        this.responseName = e,
        this.requestStream = f,
        this.responseStream = g,
        this.resolvedRequestType = null ,
        this.resolvedResponseType = null
    }
    ;
    return z.prototype = Object.create(x.prototype),
    e.Service.RPCMethod = z,
    e
}(ProtoBuf),
ProtoBuf.Builder = function(a, b, c) {
    "use strict";
    function d(a) {
        a.messages && a.messages.forEach(function(b) {
            b.syntax = a.syntax,
            d(b)
        }),
        a.enums && a.enums.forEach(function(b) {
            b.syntax = a.syntax
        })
    }
    var e = function(a) {
        this.ns = new c.Namespace(this,null ,""),
        this.ptr = this.ns,
        this.resolved = !1,
        this.result = null ,
        this.files = {},
        this.importRoot = null ,
        this.options = a || {}
    }
      , f = e.prototype;
    return e.isMessage = function(a) {
        return "string" == typeof a.name && ("undefined" == typeof a.values && "undefined" == typeof a.rpc)
    }
    ,
    e.isMessageField = function(a) {
        return "string" == typeof a.rule && "string" == typeof a.name && "string" == typeof a.type && "undefined" != typeof a.id
    }
    ,
    e.isEnum = function(a) {
        return "string" == typeof a.name && !("undefined" == typeof a.values || !Array.isArray(a.values) || 0 === a.values.length)
    }
    ,
    e.isService = function(a) {
        return !("string" != typeof a.name || "object" != typeof a.rpc || !a.rpc)
    }
    ,
    e.isExtend = function(a) {
        return "string" == typeof a.ref
    }
    ,
    f.reset = function() {
        return this.ptr = this.ns,
        this
    }
    ,
    f.define = function(a) {
        if ("string" != typeof a || !b.TYPEREF.test(a))
            throw Error("illegal namespace: " + a);
        return a.split(".").forEach(function(a) {
            var b = this.ptr.getChild(a);
            null === b && this.ptr.addChild(b = new c.Namespace(this,this.ptr,a)),
            this.ptr = b
        }, this),
        this
    }
    ,
    f.create = function(b) {
        if (!b)
            return this;
        if (Array.isArray(b)) {
            if (0 === b.length)
                return this;
            b = b.slice()
        } else
            b = [b];
        for (var d = [b]; d.length > 0; ) {
            if (b = d.pop(),
            !Array.isArray(b))
                throw Error("not a valid namespace: " + JSON.stringify(b));
            for (; b.length > 0; ) {
                var f = b.shift();
                if (e.isMessage(f)) {
                    var g = new c.Message(this,this.ptr,f.name,f.options,f.isGroup,f.syntax)
                      , h = {};
                    f.oneofs && Object.keys(f.oneofs).forEach(function(a) {
                        g.addChild(h[a] = new c.Message.OneOf(this,g,a))
                    }, this),
                    f.fields && f.fields.forEach(function(a) {
                        if (null !== g.getChild(0 | a.id))
                            throw Error("duplicate or invalid field id in " + g.name + ": " + a.id);
                        if (a.options && "object" != typeof a.options)
                            throw Error("illegal field options in " + g.name + "#" + a.name);
                        var b = null ;
                        if ("string" == typeof a.oneof && !(b = h[a.oneof]))
                            throw Error("illegal oneof in " + g.name + "#" + a.name + ": " + a.oneof);
                        a = new c.Message.Field(this,g,a.rule,a.keytype,a.type,a.name,a.id,a.options,b,f.syntax),
                        b && b.fields.push(a),
                        g.addChild(a)
                    }, this);
                    var i = [];
                    if (f.enums && f.enums.forEach(function(a) {
                        i.push(a)
                    }),
                    f.messages && f.messages.forEach(function(a) {
                        i.push(a)
                    }),
                    f.services && f.services.forEach(function(a) {
                        i.push(a)
                    }),
                    f.extensions && ("number" == typeof f.extensions[0] ? g.extensions = [f.extensions] : g.extensions = f.extensions),
                    this.ptr.addChild(g),
                    i.length > 0) {
                        d.push(b),
                        b = i,
                        i = null ,
                        this.ptr = g,
                        g = null ;
                        continue
                    }
                    i = null
                } else if (e.isEnum(f))
                    g = new c.Enum(this,this.ptr,f.name,f.options,f.syntax),
                    f.values.forEach(function(a) {
                        g.addChild(new c.Enum.Value(this,g,a.name,a.id))
                    }, this),
                    this.ptr.addChild(g);
                else if (e.isService(f))
                    g = new c.Service(this,this.ptr,f.name,f.options),
                    Object.keys(f.rpc).forEach(function(a) {
                        var b = f.rpc[a];
                        g.addChild(new c.Service.RPCMethod(this,g,a,b.request,b.response,(!!b.request_stream),(!!b.response_stream),b.options))
                    }, this),
                    this.ptr.addChild(g);
                else {
                    if (!e.isExtend(f))
                        throw Error("not a valid definition: " + JSON.stringify(f));
                    if (g = this.ptr.resolve(f.ref, !0))
                        f.fields.forEach(function(b) {
                            if (null !== g.getChild(0 | b.id))
                                throw Error("duplicate extended field id in " + g.name + ": " + b.id);
                            if (g.extensions) {
                                var d = !1;
                                if (g.extensions.forEach(function(a) {
                                    b.id >= a[0] && b.id <= a[1] && (d = !0)
                                }),
                                !d)
                                    throw Error("illegal extended field id in " + g.name + ": " + b.id + " (not within valid ranges)")
                            }
                            var e = b.name;
                            this.options.convertFieldsToCamelCase && (e = a.Util.toCamelCase(e));
                            var f = new c.Message.ExtensionField(this,g,b.rule,b.type,this.ptr.fqn() + "." + e,b.id,b.options)
                              , h = new c.Extension(this,this.ptr,b.name,f);
                            f.extension = h,
                            this.ptr.addChild(h),
                            g.addChild(f)
                        }, this);
                    else if (!/\.?google\.protobuf\./.test(f.ref))
                        throw Error("extended message " + f.ref + " is not defined")
                }
                f = null ,
                g = null
            }
            b = null ,
            this.ptr = this.ptr.parent
        }
        return this.resolved = !1,
        this.result = null ,
        this
    }
    ,
    f["import"] = function(b, c) {
        var e = "/";
        if ("string" == typeof c) {
            if (a.Util.IS_NODE && (c = require("path").resolve(c)),
            this.files[c] === !0)
                return this.reset();
            this.files[c] = !0
        } else if ("object" == typeof c) {
            var f = c.root;
            a.Util.IS_NODE && (f = require("path").resolve(f)),
            (f.indexOf("\\") >= 0 || c.file.indexOf("\\") >= 0) && (e = "\\");
            var g = f + e + c.file;
            if (this.files[g] === !0)
                return this.reset();
            this.files[g] = !0
        }
        if (b.imports && b.imports.length > 0) {
            var h, i = !1;
            "object" == typeof c ? (this.importRoot = c.root,
            i = !0,
            h = this.importRoot,
            c = c.file,
            (h.indexOf("\\") >= 0 || c.indexOf("\\") >= 0) && (e = "\\")) : "string" == typeof c ? this.importRoot ? h = this.importRoot : c.indexOf("/") >= 0 ? (h = c.replace(/\/[^\/]*$/, ""),
            "" === h && (h = "/")) : c.indexOf("\\") >= 0 ? (h = c.replace(/\\[^\\]*$/, ""),
            e = "\\") : h = "." : h = null ;
            for (var j = 0; j < b.imports.length; j++)
                if ("string" == typeof b.imports[j]) {
                    if (!h)
                        throw Error("cannot determine import root");
                    var k = b.imports[j];
                    if ("google/protobuf/descriptor.proto" === k)
                        continue;if (k = h + e + k,
                    this.files[k] === !0)
                        continue;/\.proto$/i.test(k) && !a.DotProto && (k = k.replace(/\.proto$/, ".json"));
                    var l = a.Util.fetch(k);
                    if (null === l)
                        throw Error("failed to import '" + k + "' in '" + c + "': file not found");
                    /\.json$/i.test(k) ? this["import"](JSON.parse(l + ""), k) : this["import"](a.DotProto.Parser.parse(l), k)
                } else
                    c ? /\.(\w+)$/.test(c) ? this["import"](b.imports[j], c.replace(/^(.+)\.(\w+)$/, function(a, b, c) {
                        return b + "_import" + j + "." + c
                    })) : this["import"](b.imports[j], c + "_import" + j) : this["import"](b.imports[j]);
            i && (this.importRoot = null )
        }
        b["package"] && this.define(b["package"]),
        b.syntax && d(b);
        var m = this.ptr;
        return b.options && Object.keys(b.options).forEach(function(a) {
            m.options[a] = b.options[a]
        }),
        b.messages && (this.create(b.messages),
        this.ptr = m),
        b.enums && (this.create(b.enums),
        this.ptr = m),
        b.services && (this.create(b.services),
        this.ptr = m),
        b["extends"] && this.create(b["extends"]),
        this.reset()
    }
    ,
    f.resolveAll = function() {
        var d;
        if (null == this.ptr || "object" == typeof this.ptr.type)
            return this;
        if (this.ptr instanceof c.Namespace)
            this.ptr.children.forEach(function(a) {
                this.ptr = a,
                this.resolveAll()
            }, this);
        else if (this.ptr instanceof c.Message.Field) {
            if (b.TYPE.test(this.ptr.type))
                this.ptr.type = a.TYPES[this.ptr.type];
            else {
                if (!b.TYPEREF.test(this.ptr.type))
                    throw Error("illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                if (d = (this.ptr instanceof c.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, !0),
                !d)
                    throw Error("unresolvable type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                if (this.ptr.resolvedType = d,
                d instanceof c.Enum) {
                    if (this.ptr.type = a.TYPES["enum"],
                    "proto3" === this.ptr.syntax && "proto3" !== d.syntax)
                        throw Error("proto3 message cannot reference proto2 enum")
                } else {
                    if (!(d instanceof c.Message))
                        throw Error("illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                    this.ptr.type = d.isGroup ? a.TYPES.group : a.TYPES.message
                }
            }
            if (this.ptr.map) {
                if (!b.TYPE.test(this.ptr.keyType))
                    throw Error("illegal key type for map field in " + this.ptr.toString(!0) + ": " + this.ptr.keyType);
                this.ptr.keyType = a.TYPES[this.ptr.keyType]
            }
        } else if (this.ptr instanceof a.Reflect.Service.Method) {
            if (!(this.ptr instanceof a.Reflect.Service.RPCMethod))
                throw Error("illegal service type in " + this.ptr.toString(!0));
            if (d = this.ptr.parent.resolve(this.ptr.requestName, !0),
            !(d && d instanceof a.Reflect.Message))
                throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.requestName);
            if (this.ptr.resolvedRequestType = d,
            d = this.ptr.parent.resolve(this.ptr.responseName, !0),
            !(d && d instanceof a.Reflect.Message))
                throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.responseName);
            this.ptr.resolvedResponseType = d
        } else if (!(this.ptr instanceof a.Reflect.Message.OneOf || this.ptr instanceof a.Reflect.Extension || this.ptr instanceof a.Reflect.Enum.Value))
            throw Error("illegal object in namespace: " + typeof this.ptr + ": " + this.ptr);
        return this.reset()
    }
    ,
    f.build = function(a) {
        if (this.reset(),
        this.resolved || (this.resolveAll(),
        this.resolved = !0,
        this.result = null ),
        null === this.result && (this.result = this.ns.build()),
        !a)
            return this.result;
        for (var b = "string" == typeof a ? a.split(".") : a, c = this.result, d = 0; d < b.length; d++) {
            if (!c[b[d]]) {
                c = null ;
                break
            }
            c = c[b[d]]
        }
        return c
    }
    ,
    f.lookup = function(a, b) {
        return a ? this.ns.resolve(a, b) : this.ns
    }
    ,
    f.toString = function() {
        return "Builder"
    }
    ,
    e.Message = function() {}
    ,
    e.Enum = function() {}
    ,
    e.Service = function() {}
    ,
    e
}(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect),
ProtoBuf.Map = function(a, b) {
    "use strict";
    function c(a) {
        var b = 0;
        return {
            next: function() {
                return b < a.length ? {
                    done: !1,
                    value: a[b++]
                } : {
                    done: !0
                }
            }
        }
    }
    var d = function(a, c) {
        if (!a.map)
            throw Error("field is not a map");
        if (this.field = a,
        this.keyElem = new b.Element(a.keyType,null ,(!0),a.syntax),
        this.valueElem = new b.Element(a.type,a.resolvedType,(!1),a.syntax),
        this.map = {},
        Object.defineProperty(this, "size", {
            get: function() {
                return Object.keys(this.map).length
            }
        }),
        c)
            for (var d = Object.keys(c), e = 0; e < d.length; e++) {
                var f = this.keyElem.valueFromString(d[e])
                  , g = this.valueElem.verifyValue(c[d[e]]);
                this.map[this.keyElem.valueToString(f)] = {
                    key: f,
                    value: g
                }
            }
    }
      , e = d.prototype;
    return e.clear = function() {
        this.map = {}
    }
    ,
    e["delete"] = function(a) {
        var b = this.keyElem.valueToString(this.keyElem.verifyValue(a))
          , c = b in this.map;
        return delete this.map[b],
        c
    }
    ,
    e.entries = function() {
        for (var a, b = [], d = Object.keys(this.map), e = 0; e < d.length; e++)
            b.push([(a = this.map[d[e]]).key, a.value]);
        return c(b)
    }
    ,
    e.keys = function() {
        for (var a = [], b = Object.keys(this.map), d = 0; d < b.length; d++)
            a.push(this.map[b[d]].key);
        return c(a)
    }
    ,
    e.values = function() {
        for (var a = [], b = Object.keys(this.map), d = 0; d < b.length; d++)
            a.push(this.map[b[d]].value);
        return c(a)
    }
    ,
    e.forEach = function(a, b) {
        for (var c, d = Object.keys(this.map), e = 0; e < d.length; e++)
            a.call(b, (c = this.map[d[e]]).value, c.key, this)
    }
    ,
    e.set = function(a, b) {
        var c = this.keyElem.verifyValue(a)
          , d = this.valueElem.verifyValue(b);
        return this.map[this.keyElem.valueToString(c)] = {
            key: c,
            value: d
        },
        this
    }
    ,
    e.get = function(a) {
        var b = this.keyElem.valueToString(this.keyElem.verifyValue(a));
        if (b in this.map)
            return this.map[b].value
    }
    ,
    e.has = function(a) {
        var b = this.keyElem.valueToString(this.keyElem.verifyValue(a));
        return b in this.map
    }
    ,
    d
}(ProtoBuf, ProtoBuf.Reflect),
ProtoBuf.loadProto = function(a, b, c) {
    return ("string" == typeof b || b && "string" == typeof b.file && "string" == typeof b.root) && (c = b,
    b = void 0),
    ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(a), b, c)
}
,
ProtoBuf.protoFromString = ProtoBuf.loadProto,
ProtoBuf.loadProtoFile = function(a, b, c) {
    if (b && "object" == typeof b ? (c = b,
    b = null ) : b && "function" == typeof b || (b = null ),
    b)
        return ProtoBuf.Util.fetch("string" == typeof a ? a : a.root + "/" + a.file, function(d) {
            if (null === d)
                return void b(Error("Failed to fetch file"));
            try {
                b(null , ProtoBuf.loadProto(d, c, a))
            } catch (e) {
                b(e)
            }
        });
    var d = ProtoBuf.Util.fetch("object" == typeof a ? a.root + "/" + a.file : a);
    return null === d ? null : ProtoBuf.loadProto(d, c, a)
}
,
ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile,
ProtoBuf.newBuilder = function(a) {
    return a = a || {},
    "undefined" == typeof a.convertFieldsToCamelCase && (a.convertFieldsToCamelCase = ProtoBuf.convertFieldsToCamelCase),
    "undefined" == typeof a.populateAccessors && (a.populateAccessors = ProtoBuf.populateAccessors),
    new ProtoBuf.Builder(a)
}
,
ProtoBuf.loadJson = function(a, b, c) {
    return ("string" == typeof b || b && "string" == typeof b.file && "string" == typeof b.root) && (c = b,
    b = null ),
    b && "object" == typeof b || (b = ProtoBuf.newBuilder()),
    "string" == typeof a && (a = JSON.parse(a)),
    b["import"](a, c),
    b.resolveAll(),
    b
}
,
ProtoBuf.loadJsonFile = function(a, b, c) {
    if (b && "object" == typeof b ? (c = b,
    b = null ) : b && "function" == typeof b || (b = null ),
    b)
        return ProtoBuf.Util.fetch("string" == typeof a ? a : a.root + "/" + a.file, function(d) {
            if (null === d)
                return void b(Error("Failed to fetch file"));
            try {
                b(null , ProtoBuf.loadJson(JSON.parse(d), c, a))
            } catch (e) {
                b(e)
            }
        });
    var d = ProtoBuf.Util.fetch("object" == typeof a ? a.root + "/" + a.file : a);
    return null === d ? null : ProtoBuf.loadJson(JSON.parse(d), c, a)
}
;
var _rootfloor = ProtoBuf.newBuilder({})["import"]({
    messages: [{
        name: "FloorGeo",
        fields: [{
            rule: "required",
            type: "string",
            name: "mid",
            id: 1
        }, {
            rule: "required",
            type: "int32",
            name: "gid",
            id: 2
        }, {
            rule: "optional",
            type: "float",
            name: "height",
            id: 3
        }, {
            rule: "repeated",
            type: "GeneralGeoInfo",
            name: "extentLayer",
            id: 4
        }, {
            rule: "repeated",
            type: "GeneralGeoInfo",
            name: "modelLayer",
            id: 5
        }, {
            rule: "repeated",
            type: "GeneralGeoInfo",
            name: "labelLayer",
            id: 6
        }, {
            rule: "repeated",
            type: "GeneralGeoInfo",
            name: "poiLayer",
            id: 7
        }, {
            rule: "repeated",
            type: "GeneralGeoInfo",
            name: "polygonLayer",
            id: 8
        }, {
            rule: "repeated",
            type: "GeneralGeoInfo",
            name: "liftLayer",
            id: 9
        }, {
            rule: "repeated",
            type: "GeneralGeoInfo",
            name: "stairLayer",
            id: 10
        }, {
            rule: "repeated",
            type: "GeneralGeoInfo",
            name: "escalatorLayer",
            id: 11
        }],
        messages: [{
            name: "GeneralGeoInfo",
            fields: [{
                rule: "required",
                type: "int32",
                name: "eid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "geo",
                id: 2
            }, {
                rule: "optional",
                type: "float",
                name: "height",
                id: 3
            }, {
                rule: "optional",
                type: "float",
                name: "area",
                id: 4
            }]
        }]
    }, {
        name: "FloorBiz",
        fields: [{
            rule: "required",
            type: "string",
            name: "mid",
            id: 1
        }, {
            rule: "required",
            type: "int32",
            name: "gid",
            id: 2
        }, {
            rule: "repeated",
            type: "ExtentBizInfo",
            name: "extentLayer",
            id: 3
        }, {
            rule: "repeated",
            type: "ModelBizInfo",
            name: "modelLayer",
            id: 4
        }, {
            rule: "repeated",
            type: "LabelBizInfo",
            name: "labelLayer",
            id: 5
        }, {
            rule: "repeated",
            type: "POIBizInfo",
            name: "poiLayer",
            id: 6
        }, {
            rule: "repeated",
            type: "PolygonBizInfo",
            name: "polygonLayer",
            id: 7
        }, {
            rule: "repeated",
            type: "LiftBizInfo",
            name: "liftLayer",
            id: 8
        }, {
            rule: "repeated",
            type: "StairBizInfo",
            name: "stairLayer",
            id: 9
        }],
        messages: [{
            name: "ExtentBizInfo",
            fields: [{
                rule: "required",
                type: "int32",
                name: "eid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "fid",
                id: 2
            }, {
                rule: "optional",
                type: "int32",
                name: "type",
                id: 3
            }, {
                rule: "optional",
                type: "string",
                name: "name",
                id: 4
            }, {
                rule: "optional",
                type: "string",
                name: "ename",
                id: 5
            }]
        }, {
            name: "ModelBizInfo",
            fields: [{
                rule: "required",
                type: "int32",
                name: "eid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "fid",
                id: 2
            }, {
                rule: "optional",
                type: "int32",
                name: "type",
                id: 3
            }, {
                rule: "optional",
                type: "string",
                name: "name",
                id: 4
            }, {
                rule: "optional",
                type: "string",
                name: "ename",
                id: 5
            }]
        }, {
            name: "LabelBizInfo",
            fields: [{
                rule: "required",
                type: "int32",
                name: "eid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "fid",
                id: 2
            }, {
                rule: "optional",
                type: "int32",
                name: "type",
                id: 3
            }, {
                rule: "optional",
                type: "string",
                name: "name",
                id: 4
            }, {
                rule: "optional",
                type: "string",
                name: "ename",
                id: 5
            }]
        }, {
            name: "PolygonBizInfo",
            fields: [{
                rule: "required",
                type: "int32",
                name: "eid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "fid",
                id: 2
            }, {
                rule: "optional",
                type: "int32",
                name: "type",
                id: 3
            }, {
                rule: "optional",
                type: "string",
                name: "name",
                id: 4
            }, {
                rule: "optional",
                type: "string",
                name: "ename",
                id: 5
            }]
        }, {
            name: "POIBizInfo",
            fields: [{
                rule: "required",
                type: "int32",
                name: "eid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "fid",
                id: 2
            }, {
                rule: "optional",
                type: "int32",
                name: "type",
                id: 3
            }, {
                rule: "optional",
                type: "string",
                name: "name",
                id: 4
            }, {
                rule: "optional",
                type: "string",
                name: "ename",
                id: 5
            }, {
                rule: "optional",
                type: "int32",
                name: "minlevel",
                id: 6
            }, {
                rule: "optional",
                type: "int32",
                name: "maxlevel",
                id: 7
            }]
        }, {
            name: "LiftBizInfo",
            fields: [{
                rule: "required",
                type: "int32",
                name: "eid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "fid",
                id: 2
            }, {
                rule: "optional",
                type: "int32",
                name: "type",
                id: 3
            }, {
                rule: "optional",
                type: "int32",
                name: "flag",
                id: 4
            }, {
                rule: "optional",
                type: "string",
                name: "floor",
                id: 5
            }, {
                rule: "optional",
                type: "int32",
                name: "minlevel",
                id: 6
            }, {
                rule: "optional",
                type: "int32",
                name: "maxlevel",
                id: 7
            }]
        }, {
            name: "StairBizInfo",
            fields: [{
                rule: "required",
                type: "int32",
                name: "eid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "fid",
                id: 2
            }, {
                rule: "optional",
                type: "int32",
                name: "type",
                id: 3
            }, {
                rule: "optional",
                type: "int32",
                name: "flag",
                id: 4
            }, {
                rule: "optional",
                type: "int32",
                name: "minlevel",
                id: 5
            }, {
                rule: "optional",
                type: "int32",
                name: "maxlevel",
                id: 6
            }]
        }]
    }, {
        name: "FloorNavi",
        fields: [{
            rule: "required",
            type: "string",
            name: "mid",
            id: 1
        }, {
            rule: "required",
            type: "int32",
            name: "gid",
            id: 2
        }, {
            rule: "repeated",
            type: "NaviNode",
            name: "naviNodes",
            id: 3
        }, {
            rule: "repeated",
            type: "NaviSegment",
            name: "naviSegments",
            id: 4
        }],
        messages: [{
            name: "NaviNode",
            fields: [{
                rule: "optional",
                type: "int32",
                name: "nodeId",
                id: 1
            }, {
                rule: "optional",
                type: "int32",
                name: "nodeType",
                id: 2
            }, {
                rule: "optional",
                type: "int32",
                name: "liftType",
                id: 3
            }, {
                rule: "optional",
                type: "int32",
                name: "liftFlag",
                id: 4
            }, {
                rule: "optional",
                type: "int32",
                name: "liftEntry",
                id: 5
            }, {
                rule: "optional",
                type: "string",
                name: "liftFloor",
                id: 6
            }, {
                rule: "optional",
                type: "string",
                name: "linkSeg",
                id: 7
            }, {
                rule: "optional",
                type: "string",
                name: "geo",
                id: 8
            }]
        }, {
            name: "NaviSegment",
            fields: [{
                rule: "optional",
                type: "int32",
                name: "segmentId",
                id: 1
            }, {
                rule: "optional",
                type: "int32",
                name: "snode",
                id: 2
            }, {
                rule: "optional",
                type: "int32",
                name: "enode",
                id: 3
            }, {
                rule: "optional",
                type: "double",
                name: "length",
                id: 4
            }, {
                rule: "optional",
                type: "int32",
                name: "rank",
                id: 5
            }, {
                rule: "optional",
                type: "string",
                name: "name",
                id: 6
            }, {
                rule: "optional",
                type: "int32",
                name: "entry",
                id: 7
            }, {
                rule: "optional",
                type: "string",
                name: "desc",
                id: 8
            }, {
                rule: "optional",
                type: "string",
                name: "geo",
                id: 9
            }]
        }]
    }]
})
  , _rootmap = ProtoBuf.newBuilder({})["import"]({
    messages: [{
        name: "Map",
        fields: [{
            rule: "required",
            type: "string",
            name: "mid",
            id: 1
        }, {
            rule: "required",
            type: "int32",
            name: "file_ver",
            id: 2
        }, {
            rule: "required",
            type: "uint64",
            name: "date_ver",
            id: 3
        }, {
            rule: "required",
            type: "string",
            name: "mname",
            id: 4
        }, {
            rule: "required",
            type: "string",
            name: "hash_code",
            id: 5
        }, {
            rule: "optional",
            type: "string",
            name: "key",
            id: 6
        }, {
            rule: "optional",
            type: "string",
            name: "file_date",
            id: 7
        }, {
            rule: "optional",
            type: "string",
            name: "desc",
            id: 8
        }, {
            rule: "optional",
            type: "bool",
            name: "read_only",
            id: 9,
            options: {
                "default": !1
            }
        }, {
            rule: "repeated",
            type: "Buffer",
            name: "buffers",
            id: 10
        }],
        messages: [{
            name: "Buffer",
            fields: [{
                rule: "required",
                type: "int32",
                name: "gid",
                id: 1
            }, {
                rule: "required",
                type: "int32",
                name: "file_ver",
                id: 2
            }, {
                rule: "required",
                type: "int32",
                name: "btype",
                id: 3
            }, {
                rule: "required",
                type: "uint64",
                name: "len",
                id: 4
            }, {
                rule: "required",
                type: "bytes",
                name: "data",
                id: 5
            }]
        }]
    }]
})
  , _rootscene = ProtoBuf.newBuilder({})["import"]({
    messages: [{
        name: "Scene",
        fields: [{
            rule: "required",
            type: "string",
            name: "mid",
            id: 19
        }, {
            rule: "required",
            type: "int32",
            name: "file_ver",
            id: 20
        }, {
            rule: "required",
            type: "uint64",
            name: "date_ver",
            id: 21
        }, {
            rule: "required",
            type: "string",
            name: "mname",
            id: 22
        }, {
            rule: "required",
            type: "string",
            name: "hash_code",
            id: 23
        }, {
            rule: "optional",
            type: "string",
            name: "key",
            id: 24
        }, {
            rule: "optional",
            type: "string",
            name: "desc",
            id: 25
        }, {
            rule: "optional",
            type: "bool",
            name: "read_only",
            id: 26,
            options: {
                "default": !1
            }
        }, {
            rule: "optional",
            type: "float",
            name: "x",
            id: 1
        }, {
            rule: "optional",
            type: "float",
            name: "y",
            id: 2
        }, {
            rule: "optional",
            type: "float",
            name: "z",
            id: 3
        }, {
            rule: "optional",
            type: "float",
            name: "minX",
            id: 4
        }, {
            rule: "optional",
            type: "float",
            name: "minY",
            id: 5
        }, {
            rule: "optional",
            type: "float",
            name: "maxX",
            id: 6
        }, {
            rule: "optional",
            type: "float",
            name: "maxY",
            id: 7
        }, {
            rule: "optional",
            type: "string",
            name: "defGid",
            id: 8
        }, {
            rule: "optional",
            type: "float",
            name: "defCenX",
            id: 9
        }, {
            rule: "optional",
            type: "float",
            name: "defCenY",
            id: 10
        }, {
            rule: "optional",
            type: "float",
            name: "defCenZ",
            id: 11
        }, {
            rule: "optional",
            type: "float",
            name: "height",
            id: 12
        }, {
            rule: "optional",
            type: "float",
            name: "rotateAngleX",
            id: 13
        }, {
            rule: "optional",
            type: "float",
            name: "rotateAngleY",
            id: 14
        }, {
            rule: "optional",
            type: "float",
            name: "rotateAngleZ",
            id: 15
        }, {
            rule: "optional",
            type: "float",
            name: "scale",
            id: 16
        }, {
            rule: "optional",
            type: "string",
            name: "scaleLevel",
            id: 17
        }, {
            rule: "repeated",
            type: "LayerGroup",
            name: "layerGroups",
            id: 18
        }],
        messages: [{
            name: "Layer",
            fields: [{
                rule: "optional",
                type: "int32",
                name: "lid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "lname",
                id: 2
            }, {
                rule: "optional",
                type: "string",
                name: "alias",
                id: 3
            }, {
                rule: "optional",
                type: "Type",
                name: "ltype",
                id: 4
            }, {
                rule: "optional",
                type: "float",
                name: "offsetX",
                id: 5
            }, {
                rule: "optional",
                type: "float",
                name: "offsetY",
                id: 6
            }, {
                rule: "optional",
                type: "float",
                name: "height",
                id: 7
            }, {
                rule: "optional",
                type: "float",
                name: "rotateAngleX",
                id: 8
            }, {
                rule: "optional",
                type: "float",
                name: "rotateAngleY",
                id: 9
            }, {
                rule: "optional",
                type: "float",
                name: "rotateAngleZ",
                id: 10
            }, {
                rule: "optional",
                type: "float",
                name: "minScaleLevel",
                id: 11
            }, {
                rule: "optional",
                type: "float",
                name: "maxScaleLevel",
                id: 12
            }, {
                rule: "optional",
                type: "bool",
                name: "isVisible",
                id: 13
            }, {
                rule: "optional",
                type: "bool",
                name: "isSelectable",
                id: 14
            }, {
                rule: "optional",
                type: "bool",
                name: "isEditable",
                id: 15
            }, {
                rule: "optional",
                type: "string",
                name: "desc",
                id: 16
            }],
            enums: [{
                name: "Type",
                values: [{
                    name: "GEOPOINT",
                    id: 1
                }, {
                    name: "GEOPOINT_ESCALATOR",
                    id: 2
                }, {
                    name: "GEOPOINT_LIFT",
                    id: 3
                }, {
                    name: "GEOPOINT_STAIR",
                    id: 4
                }, {
                    name: "GEOPOINT_PANORAMA",
                    id: 5
                }, {
                    name: "GEOPOINT_POI",
                    id: 6
                }, {
                    name: "GEOPOINT_STORELABEL",
                    id: 7
                }, {
                    name: "GEOPOINT_NAVINODE",
                    id: 8
                }, {
                    name: "GEOLINE",
                    id: 20
                }, {
                    name: "GEOLINE_NAVISEGMENT",
                    id: 21
                }, {
                    name: "GEOLINE_BORDER",
                    id: 22
                }, {
                    name: "GEOPOLYGON",
                    id: 30
                }, {
                    name: "GEOPOLYGON_EXTENT",
                    id: 31
                }, {
                    name: "GEOPOLYGON_STORE",
                    id: 32
                }, {
                    name: "GEOPOLYGON_LABEL",
                    id: 33
                }, {
                    name: "RASTERATA",
                    id: 40
                }, {
                    name: "OVERLAYDATA",
                    id: 50
                }]
            }]
        }, {
            name: "LayerGroup",
            fields: [{
                rule: "optional",
                type: "int32",
                name: "gid",
                id: 1
            }, {
                rule: "optional",
                type: "string",
                name: "gname",
                id: 2
            }, {
                rule: "optional",
                type: "string",
                name: "alias",
                id: 3
            }, {
                rule: "optional",
                type: "float",
                name: "height",
                id: 4
            }, {
                rule: "optional",
                type: "string",
                name: "desc",
                id: 5
            }, {
                rule: "repeated",
                type: "Layer",
                name: "layers",
                id: 6
            }]
        }]
    }]
})
  , geo = geo || {};
geo.GData = function() {
    this.points_,
    this.holes_
}
,
geo.GLEN1 = "MULTIPOLYGON(((".length,
geo.GLEN2 = "POINT(".length,
geo.GData.prototype = {
    parse: function(a) {
        if (this.points_ = [],
        this.holes_ = [],
        0 == a.indexOf("MULTIPOLYGON((("))
            for (var b = a.substring(geo.GLEN1, a.length - 3).split(/\),\(/), c = 0; c < b.length; c++) {
                var d = b[c].split(/,/);
                if (0 == c)
                    for (var e = 0; e < d.length; e++) {
                        var f = d[e].split(" ");
                        this.points_.push({
                            x: parseFloat(f[0]),
                            y: parseFloat(f[1])
                        })
                    }
                else {
                    for (var g = [], e = 0; e < d.length; e++) {
                        var f = d[e].split(" ");
                        g.push({
                            x: parseFloat(f[0]),
                            y: parseFloat(f[1])
                        })
                    }
                    this.holes_.push(g)
                }
            }
        else if (0 == a.indexOf("POINT(")) {
            var f = a.substring(geo.GLEN2, a.length - 1).split(" ");
            this.points_.push({
                x: parseFloat(f[0]),
                y: parseFloat(f[1])
            })
        }
        return this
    },
    toStrip: function(a) {
        var b = []
          , c = this.points_.length;
        if (a === !0) {
            if (c >= 1)
                for (var d = 0; d < c - 1; d++) {
                    var e = this.points_[d];
                    b.push(e.x, e.y)
                }
        } else
            for (var d = 0; d < c; d++) {
                var e = this.points_[d];
                b.push(e.x, e.y)
            }
        return b
    },
    hasHoles: function() {
        return null != this.holes_ && this.holes_.length > 0
    },
    toStripHoles: function(a) {
        for (var b = [], c = 0; c < this.holes_.length; c++) {
            var d = this.holes_[c]
              , e = []
              , f = d.length;
            if (a === !0) {
                if (f >= 1)
                    for (var g = 0; g < f - 1; g++) {
                        var h = d[g];
                        e.push(h.x, h.y)
                    }
            } else
                for (var g = 0; g < f; g++) {
                    var h = d[g];
                    e.push(h.x, h.y)
                }
            b.push(e)
        }
        return b
    }
},
fengmap.FMMap = function(a) {
    fengmap.Map.call(this, a),
    this.gestureEnableController_ = new fengmap.FMMapGestureEnableController(this.mapPicker,this.controls)
}
,
fengmap.FMMap.prototype = Object.create(fengmap.Map.prototype),
fengmap.FMMap.prototype.constructor = fengmap.FMMap,
Object.assign(fengmap.FMMap.prototype, {
    openMapById: function(a) {
        this.openMap(a)
    },
    moveTo: function(a) {
        if (a) {
            var b = this
              , c = a.groupID ? a.groupID : this.focusGroupId_
              , d = this.mapScene.getO3dGroup(c);
            c != this.focusGroupId_ && this.focusGroup_(c, {
                notMove: !0
            });
            var e = this.mapView.camera.position.clone()
              , f = (e.y - this.controls.target.y,
            new fm.Vector3(-a.x - this.mapScene.sceneX_,d.position.y,a.y - this.mapScene.sceneZ_))
              , g = this
              , h = g.controls.target.clone()
              , i = f.clone().sub(h)
              , j = g.controls.getPolarAngle();
            clearInterval(this.__moveToId),
            this.__moveToId = fm.Tween.action(g.mapView.camera.position, void 0 == a.time ? g.options.moveToAnimateMode ? g.options.moveToAnimateTime : 0 : a.time, {}, null , function() {
                a.callback && a.callback(c)
            }, function(a) {
                g.controls.target.copy(h.clone().add(i.clone().multiplyScalar(a))),
                "top" == b.viewMode && b.mapView.camera.position.copy(e.clone().add(i.clone().multiplyScalar(a))),
                g.controls.update({
                    forceTheta: g.controls.constraint.getAzimuthalAngle(),
                    forcePhi: j
                })
            }),
            this.groupCenter_ = f
        }
    },
    getFMGroup: function(a) {
        var b = this.mapScene.o3dGroups_[a];
        return void 0 == b ? null : b.fm_
    }
}),
Object.defineProperties(fengmap.FMMap.prototype, {
    gestureEnableController: {
        get: function() {
            return this.gestureEnableController_
        }
    },
    fullScreenAvaliable: {
        get: function() {
            return fengmap.util.FullScreen.available
        }
    },
    fullScreen: {
        get: function() {
            return fengmap.util.FullScreen.activated
        },
        set: function(a) {
            a ? fengmap.util.FullScreen.request(this.mapView.container_) : fengmap.util.FullScreen.canel()
        }
    },
    searchAnalyser: {
        get: function() {
            return this.searchAnalyser_ || (this.searchAnalyser_ = new fengmap.FMSearchAnalyser(this)),
            this.searchAnalyser_
        }
    },
    layerLocalHeight: {
        get: function() {
            return 6
        }
    }
}),
fengmap.FMLayerInfo = function(a) {
    this.editable_ = !0
}
,
fengmap.FMLayerInfo.prototype = {
    get ID() {},
    get alias() {},
    get desc() {},
    get height() {},
    get name() {},
    get offsetX() {
        return 0
    },
    get offsetY() {
        return 0
    },
    get rotateAngleX() {
        return 0
    },
    get rotateAngleY() {
        return 0
    },
    get rotateAngleZ() {
        return 0
    },
    get type() {
        return 0
    },
    get editable() {
        this.editable_
    }
},
window.onerror = null ,
fengmap.FMMapCoord = function(a, b, c) {
    this.x = a,
    this.y = b,
    this.z = c,
    this.setGeoPoint = function(a) {
        this.x = a.x,
        this.y = a.y
    }
}
,
fengmap.FMScreenCoord = function(a, b) {
    this.x = a,
    this.y = b
}
,
fengmap.FMMapGestureEnableController = function(a, b) {
    this.mapPicker_ = a,
    this.controls_ = b,
    this.enableMapPan_ = !0,
    this.enableMapRotate_ = !0,
    this.enableMapIncline_ = !0,
    this.enableMapPinch_ = !0,
    this.enableMapSingleTap_ = !0
}
,
fengmap.FMMapGestureEnableController.prototype = {
    get enableMapPan() {
        return this.enableMapPan_
    },
    set enableMapPan(a) {
        a != this.enableMapPan_ && (this.enableMapPan_ = a,
        this.controls_.enablePan = a)
    },
    get enableMapRotate() {
        return this.enableMapRotate_
    },
    set enableMapRotate(a) {
        a != this.enableMapRotate_ && (this.enableMapRotate_ = a,
        this.controls_.enableGestureRotate = a)
    },
    get enableMapIncline() {
        return this.enableMapIncline_
    },
    set enableMapIncline(a) {
        a != this.enableMapIncline_ && (this.enableMapIncline_ = a,
        this.controls_.enableGestureIncline = a)
    },
    get enableMapPinch() {
        return this.enableMapPinch_
    },
    set enableMapPinch(a) {
        a != this.enableMapPinch_ && (this.enableMapPinch_ = a,
        this.controls_.enableZoom = a)
    },
    get enableMapSingleTap() {
        return this.enableMapSingleTap_
    },
    set enableMapSingleTap(a) {
        a != this.enableMapSingleTap_ && (this.enableMapSingleTap_ = a,
        this.mapPicker_.enabled = a)
    }
},
fengmap.FMNode = function(a, b, c, d) {
    c.fm_ = this,
    Object.defineProperties(this, {
        nodeType: {
            get: function() {
                return a
            }
        },
        scene_: {
            get: function() {
                return d
            },
            set: function(a) {
                d = a
            }
        },
        o3d_: {
            get: function() {
                return c
            },
            set: function(a) {
                c = a
            }
        },
        data_: {
            get: function() {
                return b
            }
        }
    })
}
,
Object.defineProperties(fengmap.FMNode.prototype, {
    x: {
        get: function() {
            return this.scene_ ? -this.o3d_.position.x - this.scene_.sceneX_ : 0
        },
        set: function(a) {
            this.scene_ ? this.o3d_.position.setX(-a - this.scene_.sceneX_) : (this.opts_ = this.opts_ || {},
            this.opts_.x = a)
        }
    },
    y: {
        get: function() {
            return this.scene_ ? this.o3d_.position.y + this.scene_.sceneZ_ : 0
        },
        set: function(a) {
            this.scene_ ? this.o3d_.position.setZ(a - this.scene_.sceneZ_) : (this.opts_ = this.opts_ || {},
            this.opts_.y = a)
        }
    },
    z: {
        get: function() {
            return this.scene_ ? this.o3d_.position.y : 0
        },
        set: function(a) {}
    },
    mapCoord: {
        get: function() {
            return new fengmap.FMMapCoord(this.x,this.y,this.z)
        }
    },
    parent: {
        get: function() {
            return this.o3d_.parent ? this.o3d_.parent.fm_ : null
        }
    },
    visible: {
        set: function(a) {
            this.o3d_.visible = a
        },
        get: function() {
            return this.o3d_.visible
        }
    },
    group: {
        get: function() {
            if (this instanceof fengmap.FMGroup)
                return this;
            var a = this.parent;
            if (a) {
                if (a instanceof fengmap.FMGroup)
                    return a;
                var b = a.parent;
                if (b && b instanceof fengmap.FMGroup)
                    return b
            }
            return null
        }
    },
    groupID: {
        get: function() {
            return this.group ? this.group.groupID : null
        }
    }
}),
Object.assign(fengmap.FMNode.prototype, {
    dispose: function() {
        if (this.o3d_) {
            this.o3d_.visible = !1;
            var a = this.o3d_.parent;
            return a ? (a.remove(this.o3d_),
            !0) : void 0
        }
    }
}),
fengmap.FMDirection = {
    NORTH: "n",
    SOUTH: "s",
    WEST: "w",
    EAST: "e",
    NORTH_EAST: "ne",
    NORTH_WEST: "nw",
    SOUTH_EAST: "se",
    SOUTH_WEST: "sw"
},
fengmap.FMNodeType = {
    NONE: 0,
    FLOOR: 4,
    MODEL: 5,
    FACILITY: 11,
    LABEL: 12,
    LINE: 21,
    IMAGE_MARKER: 31,
    TEXT_MARKER: 32,
    LOCATION_MARKER: 33,
    ALL: 65535
},
fengmap.FMViewMode = {
    MODE_3D: "3d",
    MODE_2D: "top"
},
fengmap.FMFacility = function(a, b, c) {
    fengmap.FMNode.call(this, fengmap.FMNodeType.FACILITY, a, b, c),
    this.o3d_.forceVisible_ = this.o3d_.visible
}
,
fengmap.FMFacility.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMFacility.prototype.constructor = fengmap.FMFacility,
Object.defineProperties(fengmap.FMFacility.prototype, {
    ID: {
        get: function() {
            return this.data_.fid
        }
    },
    name: {
        get: function() {
            return this.data_.name
        }
    },
    typeID: {
        get: function() {
            return this.data_.type
        }
    },
    x: {
        get: function() {
            return this.coord_.x
        },
        set: function(a) {}
    },
    y: {
        get: function() {
            return this.coord_.y
        },
        set: function(a) {}
    },
    z: {
        get: function() {
            return this.coord_.z
        },
        set: function(a) {}
    },
    mapCoord: {
        get: function() {
            if (!this.coord_) {
                var a = this.data_.vertex;
                this.coord_ = new fengmap.FMMapCoord((-a[0]),a[1],this.o3d_.parent.localToWorld(new fm.Vector3(0,6,0)).y)
            }
            return this.coord_
        }
    },
    visible: {
        get: function() {
            return this.forceVisible_
        },
        set: function(a) {
            this.o3d_.forceVisible_ = a,
            this.o3d_.visible = a
        }
    }
}),
fengmap.FMImageMarker = function(a) {
    fengmap.FMNode.call(this, fengmap.FMNodeType.IMAGE_MARKER, {}, new fm.Object3D),
    this.o3d_.forceVisible_ = this.o3d_.visible,
    this.opts_ = a || {}
}
,
fengmap.FMImageMarker.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMImageMarker.prototype.constructor = fengmap.FMImageMarker,
Object.assign(fengmap.FMImageMarker.prototype, {
    tryCreate_: function(a) {
        if (this.o3d_ instanceof fm.Object3D)
            if (a.parent) {
                a.o3d_.remove(this.o3d_);
                var b = a.parent
                  , c = b.scene_;
                this.scene_ = c;
                var d = fengmap.util.Option;
                this.x_ = d.getValue(this.opts_, "x", b.mapCoord.x),
                this.y_ = d.getValue(this.opts_, "y", b.mapCoord.y),
                this.opts_.url = d.getValue(this.opts_, "url", "../static/img/user-icons/user_group.png"),
                this.name_ = d.getValue(this.opts_, "name", null ),
                this.id_ = d.getValue(this.opts_, "id", fengmap.util.id++),
                this.size_ = d.getValue(this.opts_, "size", 32);
                var e = this.o3d_.forceVisible_;
                this.o3d_ = new fengmap.MapPoi2(b.groupID,{
                    fid: this.id_,
                    vertex: [this.x_, this.y_],
                    name: this.name_,
                    size_: this.size_
                },this.opts_.url),
                this.o3d_.forceVisible_ = e,
                this.o3d_.fm_ = this,
                this.o3d_.material.depthWrite = !1,
                a.o3d_.add(this.o3d_),
                this.o3d_.position.set(-this.x_ - c.sceneX_, 6, this.y_ - c.sceneZ_),
                c.map_.mapPicker.addUserPOI(this.o3d_)
            } else
                a.o3d_.add(this.o3d_)
    }
}),
Object.defineProperties(fengmap.FMImageMarker.prototype, {
    url: {
        get: function() {
            return this.opts_.url
        },
        set: function(a) {
            this.opts_.url = a,
            this.scene_ && this.o3d_.setUrl(a)
        }
    },
    visible: {
        get: function() {
            return this.forceVisible_
        },
        set: function(a) {
            this.o3d_.forceVisible_ = a,
            this.o3d_.visible = a
        }
    },
    ID: {
        get: function() {
            return this.id_
        }
    },
    name: {
        get: function() {
            return this.name_
        }
    },
    mapCoord: {
        get: function() {
            return new fengmap.FMMapCoord(this.x_,this.y_,this.z)
        }
    }
}),
fengmap.FMLabel = function(a, b, c) {
    fengmap.FMNode.call(this, fengmap.FMNodeType.LABEL, a, b, c),
    this.o3d_.forceVisible_ = this.o3d_.visible
}
,
fengmap.FMLabel.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMLabel.prototype.constructor = fengmap.FMLabel,
Object.defineProperties(fengmap.FMLabel.prototype, {
    ID: {
        get: function() {
            return this.data_.oid
        }
    },
    name: {
        get: function() {
            return this.data_.name
        }
    },
    x: {
        get: function() {
            return this.coord_.x
        },
        set: function(a) {}
    },
    y: {
        get: function() {
            return this.coord_.y
        },
        set: function(a) {}
    },
    z: {
        get: function() {
            return this.coord_.z
        },
        set: function(a) {}
    },
    mapCoord: {
        get: function() {
            if (!this.coord_) {
                var a = this.data_.vertex;
                this.coord_ = new fengmap.FMMapCoord((-a[0]),a[1],this.o3d_.parent.localToWorld(new fm.Vector3(0,6,0)).y)
            }
            return this.coord_
        }
    },
    visible: {
        get: function() {
            return this.forceVisible_
        },
        set: function(a) {
            this.o3d_.forceVisible_ = a,
            this.o3d_.visible = a
        }
    }
}),
fengmap.FMLocationMarker = function(a) {
    fengmap.FMNode.call(this, fengmap.FMNodeType.LOCATION_MARKER, {}, new fm.Object3D),
    this.o3d_.forceVisible_ = this.o3d_.visible,
    this.opts_ = a
}
,
fengmap.FMLocationMarker.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMLocationMarker.prototype.constructor = fengmap.FMLocationMarker,
Object.assign(fengmap.FMLocationMarker.prototype, {
    tryCreate_: function(a) {
        if (this.o3d_ instanceof fm.Object3D)
            if (a.parent) {
                a.o3d_.remove(this.o3d_);
                var b = a.parent
                  , c = b.scene_;
                this.scene_ = c;
                var d = fengmap.util.Option;
                this.x_ = d.getValue(this.opts_, "x", b.mapCoord.x),
                this.y_ = d.getValue(this.opts_, "y", b.mapCoord.y),
                this.url_ = d.getValue(this.opts_, "url", "../static/img/user-icons/user_group.png"),
                this.name_ = d.getValue(this.opts_, "name", null ),
                this.id_ = d.getValue(this.opts_, "id", fengmap.util.id++),
                this.size_ = d.getValue(this.opts_, "size", 128);
                var e = this.o3d_.forceVisible_;
                this.o3d_ = new fengmap.MapPoi3(b.groupID,{
                    fid: this.id_,
                    vertex: [this.x_, this.y_],
                    name: this.name_,
                    size_: this.size_
                },this.url_),
                this.o3d_.forceVisible_ = e,
                this.o3d_.fm_ = this,
                a.o3d_.add(this.o3d_),
                this.o3d_.position.set(-this.x_ - c.sceneX_, 6, this.y_ - c.sceneZ_),
                c.map_.mapPicker.addUserPOI(this.o3d_)
            } else
                a.o3d_.add(this.o3d_)
    }
}),
Object.defineProperties(fengmap.FMLocationMarker.prototype, {
    direction: {
        get: function() {
            return this.o3d_.rotation.z / Math.PI * 180 - 180
        },
        set: function(a) {
            this.o3d_.rotation.set(-Math.PI / 2, 0, a / 180 * Math.PI + Math.PI, "XYZ")
        }
    },
    visible: {
        get: function() {
            return this.forceVisible_
        },
        set: function(a) {
            this.o3d_.forceVisible_ = a,
            this.o3d_.visible = a
        }
    },
    ID: {
        get: function() {
            return this.id_
        }
    },
    name: {
        get: function() {
            return this.name_
        }
    }
}),
fengmap.FMModel = function(a, b, c) {
    fengmap.FMNode.call(this, fengmap.FMNodeType.MODEL, a, b, c)
}
,
fengmap.FMModel.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMModel.prototype.constructor = fengmap.FMModel,
Object.defineProperties(fengmap.FMModel.prototype, {
    ID: {
        get: function() {
            return this.data_.oid
        }
    },
    FID: {
        get: function() {
            return this.data_.fid
        }
    },
    name: {
        get: function() {
            return this.data_.name
        }
    },
    selected: {
        get: function() {
            this.o3d_.selected
        },
        set: function(a) {
            this.o3d_.selected = a
        }
    },
    selectedColor: {
        get: function() {
            return this.o3d_.selectedColor
        },
        set: function(a) {
            this.o3d_.selectedColor = a
        }
    },
    x: {
        get: function() {
            return this.coord_.x
        },
        set: function(a) {}
    },
    y: {
        get: function() {
            return this.coord_.y
        },
        set: function(a) {}
    },
    z: {
        get: function() {
            return this.coord_.z
        },
        set: function(a) {}
    },
    mapCoord: {
        get: function() {
            if (!this.coord_) {
                this.o3d_.geometry.boundingSphere || this.o3d_.geometry.computeBoundingSphere();
                var a = this.o3d_.geometry.boundingSphere.center;
                this.coord_ = new fengmap.FMMapCoord(-this.scene_.sceneX_ - a.x,this.scene_.sceneZ_ + a.y,this.o3d_.parent.localToWorld(new fm.Vector3).y)
            }
            return this.coord_
        }
    },
    typeID: {
        get: function() {
            return this.data_.type
        }
    }
}),
fengmap.FMTextMarker = function(a) {
    fengmap.FMNode.call(this, fengmap.FMNodeType.TEXT_MARKER, {}, new fm.Object3D),
    this.o3d_.forceVisible_ = this.o3d_.visible,
    this.opts_ = a || {};
    var b = {};
    b.fontsize = a.fontsize || 12,
    b.fillcolor = a.fillcolor || "0,0,0",
    b.strokecolor = a.strokecolor || "255,255,255",
    b.alpha = a.alpha || 1,
    this.style_ = b
}
,
fengmap.FMTextMarker.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMTextMarker.prototype.constructor = fengmap.FMTextMarker,
Object.assign(fengmap.FMTextMarker.prototype, {
    tryCreate_: function(a) {
        if (this.o3d_ instanceof fm.Object3D)
            if (a.parent) {
                a.o3d_.remove(this.o3d_);
                var b = a.parent
                  , c = b.scene_;
                this.scene_ = c;
                var d = fengmap.util.Option;
                this.x_ = d.getValue(this.opts_, "x", b.mapCoord.x),
                this.y_ = d.getValue(this.opts_, "y", b.mapCoord.y),
                this.name_ = d.getValue(this.opts_, "name", ""),
                this.id_ = d.getValue(this.opts_, "id", fengmap.util.id++);
                var e = this.o3d_.forceVisible_;
                this.o3d_ = new fengmap.MapLabel(b.groupID,{
                    oid: this.id_,
                    vertex: [this.x_, this.y_],
                    name: this.name_
                },this.style_,this.scene_.map_),
                this.o3d_.forceVisible_ = e,
                this.o3d_.fm_ = this,
                a.o3d_.add(this.o3d_),
                this.o3d_.position.set(-this.x_ - c.sceneX_, 6, this.y_ - c.sceneZ_),
                c.map_.mapPicker.addUserLabel(this.o3d_)
            } else
                a.o3d_.add(this.o3d_)
    }
}),
Object.defineProperties(fengmap.FMTextMarker.prototype, {
    name: {
        get: function() {
            if (this.opts_ && this.opts_.name)
                return this.opts_.name
        },
        set: function(a) {
            this.scene_ || (this.opts_ = this.opts_ || {},
            this.opts_.name = a)
        }
    },
    style: {
        get: function() {
            return this.style_
        }
    },
    visible: {
        get: function() {
            return this.forceVisible_
        },
        set: function(a) {
            this.o3d_.forceVisible_ = a,
            this.o3d_.visible = a
        }
    },
    ID: {
        get: function() {
            return this.id_
        }
    }
}),
fengmap.FMGroup = function(a, b) {
    fengmap.FMNode.call(this, 0, b, new fm.Object3D, a)
}
,
fengmap.FMGroup.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMGroup.prototype.constructor = fengmap.FMGroup,
Object.assign(fengmap.FMGroup.prototype, {
    addLayer: function(a) {
        if (a instanceof fengmap.FMImageMarkerLayer)
            ;
        else if (a instanceof fengmap.FMTextMarkerLayer)
            ;
        else if (!(a instanceof fengmap.FMLocationMarkerLayer))
            return void console.warn("Only FMImageMarkerLayer || FMTextMarkerLayer || FMLocationMarkerLayer acceptable!");
        this.o3d_.add(a.o3d_);
        for (var b = a.o3d_.children, c = 0; c < b.length; c++)
            b[c].fm_.tryCreate_(a)
    },
    removeLayer: function(a) {
        a.o3d_.visible = !1,
        this.o3d_.remove(a.o3d_)
    },
    traverse: function(a) {
        this.traverse_(a, this.o3d_, 0)
    },
    traverse_: function(a, b, c) {
        b.fm_ && a(b.fm_, c);
        for (var d = 0; d < b.children.length; d++)
            this.traverse_(a, b.children[d], c + 1)
    }
}),
Object.defineProperties(fengmap.FMGroup.prototype, {
    groupID: {
        get: function() {
            return this.data_.gid
        }
    },
    groupAlias: {
        get: function() {
            return this.data_.alias
        }
    },
    groupDesc: {
        get: function() {
            return this.data_.desc
        }
    },
    groupHeight: {
        get: function() {
            return this.data_.height
        }
    },
    groupName: {
        get: function() {
            return this.data_.gname
        }
    },
    mapCoord: {
        get: function() {
            return new fengmap.FMMapCoord((-this.scene_.sceneX_),this.scene_.sceneZ_,this.o3d_.meta_.height)
        }
    },
    layers: {
        get: function() {
            for (var a = [], b = 0; b < this.o3d_.children.length; b++) {
                var c = this.o3d_.children[b]
                  , d = c.fm_;
                d && a.push(d)
            }
            return a
        }
    }
}),
fengmap.FMExtentLayer = function(a) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this.requireCollide_ = !0
}
,
fengmap.FMExtentLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMExtentLayer.constructor = fengmap.FMExtentLayer,
fengmap.FMFacilityLayer = function(a) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this.requireCollide_ = !0
}
,
fengmap.FMFacilityLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMFacilityLayer.constructor = fengmap.FMFacilityLayer,
fengmap.FMImageMarkerLayer = function(a) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this.o3d_.boxCollision_ = new fengmap.MapBoxCollision,
    this.requireCollide_ = !1
}
,
fengmap.FMImageMarkerLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMImageMarkerLayer.constructor = fengmap.FMImageMarkerLayer,
Object.assign(fengmap.FMImageMarkerLayer.prototype, {
    addMarker: function(a) {
        a instanceof fengmap.FMImageMarker ? a.tryCreate_(this) : console.warn("Please use fengmap.FMImageMarker!")
    },
    removeMarker: function(a) {
        a instanceof fengmap.FMImageMarker ? a.dispose() : console.warn("Please use fengmap.FMImageMarker!")
    },
    removeAll: function() {
        for (var a = 0; a < this.o3d_.children.length; a++)
            this.o3d_.remove(this.o3d_.children[a]),
            a -= 1;
        this.o3d_.children[0].fm_.scene_.map_.mapPicker.removeObject(this.o3d_.children)
    }
}),
Object.defineProperty(fengmap.FMImageMarkerLayer.prototype, "markers", {
    get: function() {
        for (var a = [], b = 0; b < this.o3d_.children.length; b++)
            a.push(this.o3d_.children[b].fm_);
        return a
    }
}),
fengmap.FMLabelLayer = function(a) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this.requireCollide_ = !0
}
,
fengmap.FMLabelLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMLabelLayer.constructor = fengmap.FMLabelLayer,
fengmap.FMLayerType = {
    NONE: "none",
    MODEL_LINE: "modelLine"
},
fengmap.FMLayer = function(a, b) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this._type_ = b || fengmap.FMLayerType.NONE
}
,
fengmap.FMLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMLayer.constructor = fengmap.FMLayer,
fengmap.FMLineLayer = function(a) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this.requireCollide_ = !0
}
,
fengmap.FMLineLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMLineLayer.constructor = fengmap.FMLineLayer,
Object.assign(fengmap.FMLineLayer.prototype, {
    addMarker: function(a) {
        a instanceof fengmap.FMLineMarker ? a.tryCreate_(this) : console.warn("Please use fengmap.FMLineMarker!")
    },
    removeMarker: function(a) {
        a instanceof fengmap.FMLineMarker ? this.o3d_.remove(a.o3d_) : console.warn("Please use fengmap.FMLineMarker!")
    },
    removeAll: function() {
        for (var a = 0; a < this.o3d_.children.length; a++)
            this.o3d_.remove(this.o3d_.children[a])
    }
}),
Object.defineProperty(fengmap.FMLineLayer.prototype, "markers", {
    get: function() {
        for (var a = [], b = 0; b < this.o3d_.children.length; b++)
            a.push(this.o3d_.children[b].fm_);
        return a
    }
}),
fengmap.FMLocationMarkerLayer = function(a) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this.o3d_.boxCollision_ = new fengmap.MapBoxCollision,
    this.requireCollide_ = !1
}
,
fengmap.FMLocationMarkerLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMLocationMarkerLayer.constructor = fengmap.FMLocationMarkerLayer,
Object.assign(fengmap.FMLocationMarkerLayer.prototype, {
    addMarker: function(a) {
        a instanceof fengmap.FMLocationMarker ? a.tryCreate_(this) : console.warn("Please use fengmap.FMLocationMarker!")
    },
    removeMarker: function(a) {
        a instanceof fengmap.FMLocationMarker ? a.dispose() : console.warn("Please use fengmap.FMLocationMarker!")
    },
    removeAll: function() {
        for (var a = 0; a < this.o3d_.children.length; a++)
            this.o3d_.remove(this.o3d_.children[a]),
            a--;
        this.o3d_.children[0].fm_.scene_.map_.mapPicker.removeObject(this.o3d_.children)
    }
}),
Object.defineProperty(fengmap.FMLocationMarkerLayer.prototype, "markers", {
    get: function() {
        for (var a = [], b = 0; b < this.o3d_.children.length; b++)
            a.push(this.o3d_.children[b].fm_);
        return a
    }
}),
fengmap.FMModelLayer = function(a) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this.requireCollide_ = !0
}
,
fengmap.FMModelLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMModelLayer.constructor = fengmap.FMModelLayer,
fengmap.FMTextLayer = function(a) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this.requireCollide_ = !0
}
,
fengmap.FMTextLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMTextLayer.constructor = fengmap.FMTextLayer,
fengmap.FMTextMarkerLayer = function(a) {
    fengmap.FMNode.call(this, 0, a, new fm.Object3D),
    this.o3d_.boxCollision_ = new fengmap.MapBoxCollision,
    this.requireCollide_ = !1
}
,
fengmap.FMTextMarkerLayer.prototype = Object.create(fengmap.FMNode.prototype),
fengmap.FMTextMarkerLayer.constructor = fengmap.FMTextMarkerLayer,
Object.assign(fengmap.FMTextMarkerLayer.prototype, {
    addMarker: function(a) {
        a instanceof fengmap.FMTextMarker ? a.tryCreate_(this) : console.warn("Please use fengmap.FMTextMarker!")
    },
    removeMarker: function(a) {
        a instanceof fengmap.FMTextMarker ? a.dispose() : console.warn("Please use fengmap.FMTextMarker!")
    },
    removeAll: function() {
        for (var a = 0; a < this.o3d_.children.length; a++)
            this.o3d_.remove(this.o3d_.children[a]),
            a -= 1;
        this.o3d_.children[0].fm_.scene_.map_.mapPicker.removeObject(this.o3d_.children)
    }
}),
Object.defineProperty(fengmap.FMTextMarkerLayer.prototype, "markers", {
    get: function() {
        for (var a = [], b = 0; b < this.o3d_.children.length; b++)
            a.push(this.o3d_.children[b].fm_);
        return a
    }
}),
fengmap.FMSearchAnalyser = function(a) {
    this.map_ = a,
    fm.Evento.convert(this)
}
,
fengmap.FMSearchAnalyser.prototype = {
    emit_: function(a, b) {
        this.emit("queryResult", {
            target: this,
            request: a,
            result: b
        })
    },
    query: function(a, b) {
        var c = [];
        if (a && a.nodeType_) {
            var d, e = a.nodeType_;
            d = a.groupID_ ? [a.groupID_] : this.map_.groupIDs;
            for (var f in d) {
                var g = d[f];
                this.map_.getFMGroup(g).traverse(function(b) {
                    e != fengmap.FMNodeType.ALL && e != b.nodeType || a.name_ && b.name != a.name_ || a.keyword_ && (!b.name || b.name.indexOf(a.keyword_) < 0) || a.ID_ && a.ID_ != b.ID || a.typeID_ && a.typeID_ != b.typeID || c.push(b)
                })
            }
        }
        return void 0 !== b ? b(a, c) : this.emit_(a, c),
        this
    }
},
fengmap.FMSearchRequest = function(a, b) {
    this.nodeType_ = a,
    this.index_ = b
}
,
fengmap.FMSearchRequest.prototype = {
    groupID: function(a) {
        return this.groupID_ = a,
        this
    },
    ID: function(a) {
        return this.ID_ = a,
        this
    },
    keyword: function(a) {
        return this.keyword_ = a,
        this
    },
    name: function(a) {
        return this.name_ = a,
        this
    },
    typeID: function(a) {
        return this.typeID_ = a,
        this
    },
    get index() {
        return this.index_
    }
},
fengmap.util = fengmap.util || {},
fengmap.util.Option = {},
fengmap.util.Option.getValue = function(a, b, c) {
    return a && a.hasOwnProperty(b) ? a[b] : c
}
,
fengmap.util.id = 10001,
fengmap.util.FullScreen = {
    get _hasWebkitFullScreen() {
        return "webkitCancelFullScreen"in document
    },
    get _hasMozFullScreen() {
        return "mozCancelFullScreen"in document
    },
    get available() {
        return this._hasWebkitFullScreen || this._hasMozFullScreen
    },
    get activated() {
        return this._hasWebkitFullScreen ? document.webkitIsFullScreen : !!this._hasMozFullScreen && document.mozFullScreen
    },
    request: function(a) {
        a = a || document.body,
        this._hasWebkitFullScreen ? a.webkitRequestFullScreen() : this._hasMozFullScreen && a.mozRequestFullScreen()
    },
    cancel: function() {
        this._hasWebkitFullScreen ? document.webkitCancelFullScreen() : this._hasMozFullScreen && document.mozCancelFullScreen()
    }
};
