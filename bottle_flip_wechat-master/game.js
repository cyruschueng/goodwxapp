define("js/block.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e
        } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }, i = function () {
            function e(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var s = t[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, s.key, s)
                }
            }

            return function (t, i, s) {
                return i && e(t.prototype, i), s && e(t, s), t
            }
        }(), s = function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
            return t.default = e, t
        }(require("./lib/three")), a = require("./config"), o = require("./lib/animation"), h = require("./random"), r = {
            green: 6393958,
            white: 15658734,
            lightGreen: 8104320,
            gray: 10395294,
            black: 7171437,
            lightGray: 14408667,
            lightBlack: 13355979,
            brown: 6776679,
            middleLightGreen: 125084537,
            middleLightGray: 12303291,
            middleLightBlack: 8947848
        }, n = new s.MeshBasicMaterial({map: a.loader.load("res/cylinder_shadow.png"), transparent: !0, alphaTest: .01}),
        l = new s.MeshBasicMaterial({map: a.loader.load("res/desk_shadow.png"), transparent: !0, alphaTest: .01}),
        d = new s.MeshBasicMaterial({map: a.loader.load("res/shadow.png"), transparent: !0, alphaTest: .01}),
        m = new s.MeshLambertMaterial({map: a.loader.load("res/gray.png")}),
        c = new s.MeshLambertMaterial({map: a.loader.load("res/number.png"), alphaTest: .6}),
        u = new s.BoxGeometry(2 * a.BLOCK.radius + .02, a.BLOCK.height + .04, 2 * a.BLOCK.radius + .02),
        y = new s.BoxGeometry(2 * a.BLOCK.radius, a.BLOCK.height, 2 * a.BLOCK.radius), p = new s.PlaneGeometry(11, 11),
        w = new s.MeshBasicMaterial({map: a.loader.load("res/stripe.png")}),
        g = a.GAME.canShadow ? s.MeshLambertMaterial : s.MeshBasicMaterial, M = function () {
            function M(i, h) {
                var B = this;
                if (e(this, M), this.radius = a.BLOCK.radius, this.status = "stop", this.scale = 1, this.type = "green", this.types = ["green", "black", "gray"], this.radiusScale = 1, this.obj = new s.Object3D, this.obj.name = "block", this.body = new s.Object3D, (i <= 8 || 27 == i) && (this.greenMaterial = new s.MeshLambertMaterial({color: r.green}), this.whiteMaterial = new s.MeshLambertMaterial({color: r.white})), 32 != i && 33 != i && 34 != i && 35 != i || (this.greenMaterial = new s.MeshLambertMaterial({color: r.white}), this.whiteMaterial = new s.MeshLambertMaterial({color: r.gray})), this.shadowWidth = 11, 2 == i || 7 == i ? (this.shadow = new s.Mesh(p, l), this.shadow.position.set(0, -a.BLOCK.height / 2 - .001 * i, -4.5), this.shadow.scale.y = 1.2) : 3 == i || 21 == i || 27 == i || 28 == i || 29 == i ? (this.shadow = new s.Mesh(p, n), this.shadow.position.set(-.1, -a.BLOCK.height / 2 - .001 * i, -2.8), this.shadow.scale.y = 1.4, this.shadow.scale.x = 1) : (this.shadow = new s.Mesh(p, d), this.shadow.position.set(-.74, -a.BLOCK.height / 2 - .001 * i, -2.73), this.shadow.scale.y = 1.4), this.shadow.rotation.x = -Math.PI / 2, this.order = i, this.radiusSegments = 4, this.height = a.BLOCK.height, this.canChange = !0, 0 == i) {
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, b = 3,
                        C = (a.BLOCK.height - b) / 2, v = new s.BoxGeometry(2 * a.BLOCK.radius, C, 2 * a.BLOCK.radius);
                    this.geometry = v;
                    I = new s.BoxGeometry(2 * a.BLOCK.radius, b, 2 * a.BLOCK.radius);
                    this.merge(L, v, 0, [{x: 0, y: -b / 2 - C / 2, z: 0}, {
                        x: 0,
                        y: b / 2 + C / 2,
                        z: 0
                    }]), this.merge(L, I, 1, [{x: 0, y: 0, z: 0}]), this.hitObj = new s.Mesh(L, O)
                } else if (1 == i) {
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, x = a.BLOCK.height / 5,
                        K = new s.BoxGeometry(2 * a.BLOCK.radius, x, 2 * a.BLOCK.radius);
                    this.geometry = K, this.merge(L, K, 0, [{x: 0, y: 0, z: 0}, {x: 0, y: -2 * x, z: 0}, {
                        x: 0,
                        y: 2 * x,
                        z: 0
                    }]), this.merge(L, K, 1, [{x: 0, y: -x, z: 0}, {x: 0, y: x, z: 0}]), this.hitObj = new s.Mesh(L, O)
                } else if (2 == i) {
                    this.radiusSegments = 50, this.height = a.BLOCK.height / 21 * 1.5;
                    var x = a.BLOCK.height / 21 * 19.5, f = a.BLOCK.height - x,
                        G = new s.CylinderGeometry(a.BLOCK.radius - 4, a.BLOCK.radius - 2, x, 50),
                        z = new s.CylinderGeometry(a.BLOCK.radius, a.BLOCK.radius, f, 50),
                        j = new s.Mesh(z, this.greenMaterial);
                    (U = new s.Mesh(G, this.whiteMaterial)).position.y = -a.BLOCK.height / 21 * 10.5, this.body.add(U), this.hitObj = j
                } else if (3 == i) {
                    this.radiusSegments = 50, this.middleLightGreenMaterial = new s.MeshLambertMaterial({color: r.middleLightGreen});
                    var O = [this.greenMaterial, this.whiteMaterial, this.middleLightGreenMaterial], L = new s.Geometry,
                        x = 5, f = a.BLOCK.height - x, G = new s.CylinderGeometry(a.BLOCK.radius, a.BLOCK.radius, x, 50),
                        z = new s.CylinderGeometry(a.BLOCK.radius, a.BLOCK.radius, f, 50);
                    this.geometry = z, (P = new s.RingGeometry(.6 * a.BLOCK.radius, .8 * a.BLOCK.radius, 30)).rotateX(-Math.PI / 2), this.merge(L, G, 1, [{
                        x: 0,
                        y: -(a.BLOCK.height - x) / 2,
                        z: 0
                    }]), this.merge(L, z, 0, [{x: 0, y: x + f / 2 - a.BLOCK.height / 2, z: 0}]), this.merge(L, P, 2, [{
                        x: 0,
                        y: a.BLOCK.height / 2 + .01,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O)
                } else if (4 == i) {
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, K = y;
                    this.geometry = K, this.merge(L, K, 0, [{x: 0, y: 0, z: 0}]);
                    var P = new s.RingGeometry(1, 2, 30, 1);
                    this.merge(L, P, 1, [{
                        x: 0,
                        y: 0,
                        z: a.BLOCK.radius + .01
                    }]), P.rotateY(-Math.PI / 2), this.merge(L, P, 1, [{
                        x: -a.BLOCK.radius - .01,
                        y: 0,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O)
                } else if (5 == i) {
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, b = 3,
                        C = (a.BLOCK.height - b) / 2, v = new s.BoxGeometry(2 * a.BLOCK.radius, C, 2 * a.BLOCK.radius),
                        I = new s.BoxGeometry(2 * a.BLOCK.radius, b, 2 * a.BLOCK.radius);
                    this.merge(L, v, 0, [{x: 0, y: -b / 2 - C / 2, z: 0}, {
                        x: 0,
                        y: b / 2 + C / 2,
                        z: 0
                    }]), this.merge(L, I, 1, [{x: 0, y: 0, z: 0}]), this.hitObj = new s.Mesh(L, O)
                } else if (6 == i) {
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, b = 3,
                        C = (a.BLOCK.height - b) / 2, v = new s.BoxGeometry(2 * a.BLOCK.radius, C, 2 * a.BLOCK.radius),
                        I = new s.BoxGeometry(2 * a.BLOCK.radius, b, 2 * a.BLOCK.radius);
                    this.merge(L, v, 0, [{x: 0, y: -b / 2 - C / 2, z: 0}, {
                        x: 0,
                        y: b / 2 + C / 2,
                        z: 0
                    }]), this.merge(L, I, 1, [{x: 0, y: 0, z: 0}]), this.hitObj = new s.Mesh(L, O)
                } else if (7 == i) {
                    this.radiusSegments = 50, this.height = a.BLOCK.height / 21 * 1.5;
                    var x = a.BLOCK.height / 21 * 19.5, f = a.BLOCK.height - x,
                        G = new s.CylinderGeometry(a.BLOCK.radius - 4, a.BLOCK.radius - 2, x, 50),
                        z = new s.CylinderGeometry(a.BLOCK.radius, a.BLOCK.radius, f, 50),
                        j = new s.Mesh(z, this.greenMaterial), U = new s.Mesh(G, this.whiteMaterial);
                    U.position.y = -a.BLOCK.height / 21 * 10.5, this.body.add(U), this.hitObj = j
                } else if (8 == i) {
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, x = a.BLOCK.height / 5,
                        K = new s.BoxGeometry(2 * a.BLOCK.radius, x, 2 * a.BLOCK.radius);
                    this.merge(L, K, 0, [{x: 0, y: 0, z: 0}, {x: 0, y: -2 * x, z: 0}, {
                        x: 0,
                        y: 2 * x,
                        z: 0
                    }]), this.merge(L, K, 1, [{x: 0, y: -x, z: 0}, {x: 0, y: x, z: 0}]), this.hitObj = new s.Mesh(L, O)
                } else if (9 == i) {
                    var O = [new s.MeshLambertMaterial({color: 15563832}), T = new s.MeshBasicMaterial({
                        map: a.loader.load("res/game.png"),
                        transparent: !0
                    })], L = new s.Geometry, K = y;
                    this.geometry = K, this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), this.merge(L, new s.PlaneGeometry(5, 5), 1, [{
                        x: 0,
                        y: .1,
                        z: a.BLOCK.radius + .01
                    }]), this.hitObj = new s.Mesh(L, O)
                } else if (10 == i) {
                    var O = [new s.MeshLambertMaterial({color: 16508510}), T = new s.MeshBasicMaterial({
                            map: a.loader.load("res/emotion.png"),
                            transparent: !0
                        })], L = new s.Geometry, K = y, S = new s.CylinderGeometry(2, 2, 1, 50),
                        k = new s.PlaneGeometry(1.5, 1.5);
                    this.geometry = K, this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), S.rotateX(Math.PI / 2), this.merge(L, S, 0, [{
                        x: 0,
                        y: 0,
                        z: a.BLOCK.radius + .51
                    }]), S.rotateZ(Math.PI / 2), S.rotateY(Math.PI / 2), this.merge(L, S, 0, [{
                        x: -a.BLOCK.radius - .51,
                        y: 0,
                        z: 0
                    }]), this.merge(L, k, 1, [{
                        x: 0,
                        y: 0,
                        z: a.BLOCK.radius + 1.02
                    }]), k.rotateY(-Math.PI / 2), this.merge(L, k, 1, [{
                        x: -a.BLOCK.radius - 1.02,
                        y: 0,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O)
                } else if (11 == i) {
                    var K = y, _ = new s.BoxGeometry(3, 2, 4);
                    this.geometry = K;
                    var A = new s.MeshLambertMaterial({color: 11855938}),
                        T = new s.MeshBasicMaterial({map: a.loader.load("res/green_face.png"), transparent: !0}),
                        k = new s.PlaneGeometry(6, 3), O = [A, T], L = new s.Geometry;
                    this.merge(L, K, 0, [{x: 0, y: 0, z: 0}]), this.merge(L, k, 1, [{
                        x: .5,
                        y: -1,
                        z: a.BLOCK.radius + .01
                    }]), _.rotateZ(Math.PI / 5), this.merge(L, _, 0, [{
                        x: -a.BLOCK.radius - 1,
                        y: 1,
                        z: 2.5
                    }]), _.rotateZ(-2 * Math.PI / 5), this.merge(L, _, 0, [{
                        x: a.BLOCK.radius,
                        y: 1,
                        z: 2.5
                    }]), this.hitObj = new s.Mesh(L, O)
                } else if (12 == i) {
                    var K = y, _ = new s.BoxGeometry(3, 2, 4);
                    this.geometry = K;
                    var A = new s.MeshLambertMaterial({color: 15921906}),
                        T = new s.MeshLambertMaterial({map: a.loader.load("res/white_face.png")}),
                        k = new s.PlaneGeometry(6, 3), O = [A, T], L = new s.Geometry;
                    this.merge(L, K, 0, [{x: 0, y: 0, z: 0}]), this.merge(L, k, 1, [{
                        x: .5,
                        y: -1,
                        z: a.BLOCK.radius + .01
                    }]), _.rotateZ(Math.PI / 5), this.merge(L, _, 0, [{
                        x: -a.BLOCK.radius - 1,
                        y: 1,
                        z: 2.5
                    }]), _.rotateZ(-2 * Math.PI / 5), this.merge(L, _, 0, [{
                        x: a.BLOCK.radius,
                        y: 1,
                        z: 2.5
                    }]), this.hitObj = new s.Mesh(L, O)
                } else if (13 == i) {
                    K = y;
                    this.geometry = K;
                    var T = new s.MeshLambertMaterial({map: a.loader.load("res/money.png")}), k = new s.PlaneGeometry(3, 3),
                        O = [T], L = new s.Geometry;
                    this.mapUv(64, 64, K, 1, 2, 2, 4, 4), this.mapUv(64, 64, K, 2, 2, 2, 4, 4), this.mapUv(64, 64, K, 4, 2, 2, 4, 4), this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), this.merge(L, k, 0, [{x: 0, y: 0, z: a.BLOCK.radius + .01}]), this.hitObj = new s.Mesh(L, O)
                } else if (14 == i) {
                    K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius);
                    this.geometry = K;
                    D = new s.MeshLambertMaterial({map: a.loader.load("res/tit.png")});
                    this.mapUv(310, 310, K, 1, 0, 0, 200, 110), this.mapUv(310, 310, K, 2, 0, 110, 200, 310), this.mapUv(310, 310, K, 4, 200, 110, 310, 310), this.hitObj = new s.Mesh(K, D)
                } else if (15 == i) {
                    K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius);
                    this.map = a.loader.load("res/bag.png");
                    D = new s.MeshLambertMaterial({map: this.map});
                    this.glowMap = a.loader.load("res/glow_bag.png"), this.hitObj = new s.Mesh(K, D), this.whenSucceed = this.glow, this.beforePopup = this.hideGlow, this.score = 20
                } else if (16 == i) {
                    var K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius),
                        D = new s.MeshLambertMaterial({map: a.loader.load("res/dict.png")});
                    this.mapUv(428, 428, K, 1, 0, 148, 280, 0), this.mapUv(428, 428, K, 2, 0, 148, 280, 428), this.mapUv(428, 428, K, 4, 280, 148, 428, 428), this.hitObj = new s.Mesh(K, D)
                } else if (17 == i) {
                    this.height /= 3;
                    var Y = new s.MeshLambertMaterial({map: a.loader.load("res/box_top.png")}),
                        H = new s.MeshLambertMaterial({map: a.loader.load("res/box_bottom.png")}),
                        K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius);
                    this.geometry = K;
                    var E = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius), O = [Y, H],
                        L = new s.Geometry;
                    this.mapUv(198, 198, K, 1, 0, 0, 148, 50), this.mapUv(198, 198, K, 2, 0, 50, 148, 198), this.mapUv(198, 198, K, 4, 148, 50, 198, 198), this.mapUv(444, 50, E, 4, 148, 0, 296, 50, !0), this.mapUv(444, 50, E, 1, 0, 0, 148, 50), this.mapUv(444, 50, E, 2, 0, 0, 1, 1), this.mapUv(444, 50, E, 0, 296, 50, 444, 0), this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), this.merge(L, E, 1, [{x: 0, y: -2 * this.height, z: 0}]);
                    var Z = new s.MeshLambertMaterial({map: a.loader.load("res/box_middle.png")});
                    this.middle = new s.Mesh(E, Z), this.middle.position.y = -this.height, this.body.add(this.middle), this.hitObj = new s.Mesh(L, O), this.succeedTimer = this.rotateBox, this.score = 10
                } else if (18 == i) {
                    var K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius),
                        D = new s.MeshLambertMaterial({map: a.loader.load("res/express.png")});
                    this.mapUv(428, 428, K, 1, 0, 0, 280, 148), this.mapUv(428, 428, K, 2, 0, 148, 280, 428), this.mapUv(428, 428, K, 4, 280, 148, 428, 428), this.hitObj = new s.Mesh(K, D)
                } else if (19 == i) {
                    this.min = .9, this.height = a.BLOCK.height / 21 * 4;
                    K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height + .1, 2 * a.BLOCK.radius);
                    this.geometry = K;
                    var D = new s.MeshLambertMaterial({color: 16777215, transparent: !0, opacity: .3}),
                        G = new s.BoxGeometry(2.05 * a.BLOCK.radius, a.BLOCK.height / 21 * 17, 2.05 * a.BLOCK.radius),
                        O = [D, H = new s.MeshBasicMaterial({map: a.loader.load("res/sing.png")})], L = new s.Geometry;
                    this.mapUv(416, 416, G, 1, 0, 0, 256, 160), this.mapUv(416, 416, G, 2, 0, 160, 256, 416), this.mapUv(416, 416, G, 4, 256, 160, 416, 416), this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), this.merge(L, G, 1, [{
                        x: 0,
                        y: -a.BLOCK.height / 21 * 10.5,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O), this.record = new s.Object3D, this.record.add(new s.Mesh(new s.CylinderGeometry(.9 * a.BLOCK.radius, .9 * a.BLOCK.radius, .4, 50), new s.MeshBasicMaterial({color: 2894892})));
                    var k = new s.CircleGeometry(.9 * a.BLOCK.radius, 40),
                        T = new s.MeshBasicMaterial({map: a.loader.load("res/record.png")});
                    (Be = new s.Mesh(k, T)).rotation.x = -Math.PI / 2, Be.position.y = .26, this.record.add(Be), this.body.add(this.record);
                    k = new s.PlaneGeometry(2, 2);
                    this.musicIcon = new s.Mesh(k, new s.MeshBasicMaterial({
                        map: a.loader.load("res/music_icon.png"),
                        transparent: !0
                    })), this.musicIcon.position.set(0, 0, 0), this.musicIcon.rotation.y = -Math.PI / 4, this.musicIcon.rotation.x = -Math.PI / 5, this.musicIcon.rotation.z = -Math.PI / 5, this.musicIcon.visible = !1, this.secondMusicIcon = new s.Mesh(k, new s.MeshBasicMaterial({
                        map: a.loader.load("res/music_icon_two.png"),
                        transparent: !0
                    })), this.secondMusicIcon.rotation.y = -Math.PI / 4, this.secondMusicIcon.rotation.x = -Math.PI / 5, this.secondMusicIcon.rotation.z = -Math.PI / 5, this.secondMusicIcon.visible = !1, this.icons = [], this.icons.push(this.musicIcon, this.secondMusicIcon);
                    for (V = 0; V < 2; ++V) this.body.add(this.icons[V]);
                    this.succeedTimer = this.playMusic, this.score = 30, this.musicName = "sing", this.perFrame = function () {
                        B.record.rotation.y += .01
                    }, this.whenLeave = function () {
                        B.stopMusic()
                    }
                } else if (20 == i) {
                    K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius / 38 * 48);
                    this.geometry = K, this.shadow.scale.set(1, 61 / 38, 48 / 38);
                    var D = new s.MeshLambertMaterial({map: a.loader.load("res/disk.png")}),
                        F = new s.MeshBasicMaterial({map: a.loader.load("res/disk_dark.png"), transparent: !0}),
                        k = new s.PlaneGeometry(3, 3), O = [F, D], L = new s.Geometry;
                    this.mapUv(236, 300, K, 1, 0, 250, 10, 260), this.mapUv(236, 300, K, 2, 0, 300, 236, 0), this.mapUv(236, 300, K, 4, 0, 250, 10, 260), this.merge(L, K, 1, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), this.merge(L, k, 0, [{
                        x: 3.5,
                        y: .5,
                        z: a.BLOCK.radius / 38 * 48 + .01
                    }]), this.hitObj = new s.Mesh(L, O), this.plane = new s.Mesh(k, new s.MeshBasicMaterial({
                        map: a.loader.load("res/disk_light.png"),
                        transparent: !0
                    })), this.plane.position.set(3.5, .5, a.BLOCK.radius / 38 * 48 + .03), this.plane.updateMatrix(), this.plane.matrixAutoUpdate = !1, this.body.add(this.plane), this.timer = setInterval(function () {
                        B.plane.visible = !B.plane.visible
                    }, 1e3)
                } else if (21 == i) {
                    this.radiusSegments = 50, this.min = .8, this.height = a.BLOCK.height / 21 * 4;
                    K = new s.CylinderGeometry(.7 * a.BLOCK.radius, .8 * a.BLOCK.radius, this.height, 50);
                    this.geometry = K;
                    var k = new s.CircleGeometry(.7 * a.BLOCK.radius, 50),
                        G = new s.CylinderGeometry(.7 * a.BLOCK.radius, .5 * a.BLOCK.radius, a.BLOCK.height / 21 * 17, 50),
                        D = new s.MeshBasicMaterial({color: 5066061}),
                        T = new s.MeshLambertMaterial({map: a.loader.load("res/westore_desk.png")}),
                        H = new s.MeshBasicMaterial({map: a.loader.load("res/westore.png")});
                    this.shadow.scale.set(.55, .9, .7);
                    var O = [D, H, T], L = new s.Geometry;
                    this.merge(L, K, 0, [{x: 0, y: 0, z: 0}]), G.rotateY(2.3), this.merge(L, G, 1, [{
                        x: 0,
                        y: -a.BLOCK.height / 21 * 10.5,
                        z: 0
                    }]), k.rotateX(-Math.PI / 2), k.rotateY(-.7), this.merge(L, k, 2, [{
                        x: 0,
                        y: this.height / 2 + .01,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O)
                } else if (22 == i) {
                    this.height = a.BLOCK.height / 21 * 6;
                    K = new s.BoxGeometry(2.1 * a.BLOCK.radius, this.height, 2.1 * a.BLOCK.radius);
                    this.geometry = K;
                    var D = new s.MeshLambertMaterial({map: a.loader.load("res/gift.png")}),
                        G = new s.BoxGeometry(2 * a.BLOCK.radius, a.BLOCK.height / 21 * 15, 2 * a.BLOCK.radius),
                        H = new s.MeshLambertMaterial({color: 11637749});
                    this.mapUv(300, 370, K, 1, 0, 0, 300, 70), this.mapUv(300, 370, K, 2, 0, 70, 300, 370), this.mapUv(300, 370, K, 4, 0, 0, 300, 70, !0);
                    var O = [D, H], L = new s.Geometry;
                    this.merge(L, K, 0, [{x: 0, y: 0, z: 0}]), this.merge(L, G, 1, [{
                        x: 0,
                        y: -a.BLOCK.height / 21 * 10.5,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O)
                } else if (23 == i) {
                    this.height = a.BLOCK.height / 21 * 5;
                    var K = new s.Geometry,
                        R = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius / 38 * 40);
                    K.merge(R), this.shadow.scale.set(1, 48 / 38, 48 / 38);
                    var X = new s.BoxGeometry(1.5, 3.5, 1.5);
                    X.rotateZ(-.3), X.vertices[7].y -= .4, X.vertices[6].y -= .4, X.translate(-4, -3, -3.5), K.merge(X), X.vertices[6].y += .5, X.translate(0, 0, 7), X.rotateX(-.2), K.merge(X), X.vertices[7].y += .4, X.translate(5, -1, 0), X.rotateZ(.4), K.merge(X);
                    D = new s.MeshLambertMaterial({map: a.loader.load("res/stool.png")});
                    this.hitObj = new s.Mesh(K, D), this.shadow = new s.Mesh(new s.PlaneGeometry(this.shadowWidth, this.shadowWidth), new s.MeshBasicMaterial({
                        map: a.loader.load("res/stool_shadow.png"),
                        transparent: !0,
                        alphaTest: .01
                    })), this.shadow.position.set(-.76, -a.BLOCK.height / 2 - .001 * i, -3.6), this.shadow.scale.y = 1.4, this.shadow.scale.x = .9, this.shadow.rotation.x = -Math.PI / 2
                } else if (24 == i) {
                    this.height = a.BLOCK.height / 21 * 6;
                    K = new s.BoxGeometry(2 * a.BLOCK.radius / 38 * 45, this.height, 2 * a.BLOCK.radius / 38 * 45);
                    this.geometry = K;
                    G = new s.BoxGeometry(2 * a.BLOCK.radius / 38 * 40, a.BLOCK.height / 21 * 15, 2 * a.BLOCK.radius / 38 * 40);
                    this.shadow.scale.set(40 / 38, 1.4, 1);
                    var O = [D = new s.MeshLambertMaterial({map: a.loader.load("res/store_top.png")}), H = new s.MeshBasicMaterial({
                            map: a.loader.load("res/store_bottom.png"),
                            transparent: !0
                        }), T = new s.MeshBasicMaterial({map: a.loader.load("res/indoor.png"), transparent: !0})],
                        k = new s.PlaneGeometry(3.1, 3.1), L = new s.Geometry;
                    this.mapUv(340, 340, K, 1, 0, 0, 280, 60), this.mapUv(340, 340, K, 2, 0, 60, 280, 340), this.mapUv(340, 340, K, 4, 280, 60, 340, 340), this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), this.mapUv(434, 164, G, 1, 0, 0, 217, 164), this.mapUv(434, 164, G, 4, 217, 0, 434, 164, !0), this.merge(L, G, 1, [{
                        x: 0,
                        y: -a.BLOCK.height / 21 * 10.5,
                        z: 0
                    }]), k.rotateY(-Math.PI / 2), this.merge(L, k, 2, [{
                        x: -a.BLOCK.radius / 38 * 40 - .01,
                        y: -3.3,
                        z: -2.5
                    }]), this.hitObj = new s.Mesh(L, O);
                    de = new s.PlaneGeometry(1.55, 3.1);
                    this.door = new s.Mesh(de, new s.MeshBasicMaterial({
                        map: a.loader.load("res/door.png"),
                        transparent: !0
                    })), this.door.rotation.y = -Math.PI / 2, this.door.position.set(-a.BLOCK.radius / 38 * 40 - .02, -3.3, -3.3), this.body.add(this.door), this.secondDoor = new s.Mesh(de, new s.MeshBasicMaterial({
                        map: a.loader.load("res/second_door.png"),
                        transparent: !0
                    })), this.secondDoor.rotation.y = -Math.PI / 2, this.secondDoor.position.set(-a.BLOCK.radius / 38 * 40 - .02, -3.3, -1.7), this.body.add(this.secondDoor), this.score = 15
                } else if (25 == i) {
                    K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius);
                    this.geometry = K;
                    D = new s.MeshLambertMaterial({map: a.loader.load("res/clock.png")});
                    this.mapUv(320, 200, K, 1, 0, 0, 5, 5), this.mapUv(320, 200, K, 2, 0, 0, 5, 5), this.mapUv(320, 200, K, 4, 0, 200, 320, 0, !0);
                    var W = w, N = new s.CylinderGeometry(1, 1, 1, 30), O = [D, W], L = new s.Geometry;
                    this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), N.rotateZ(Math.PI / 2), this.merge(L, N, 1, [{
                        x: -a.BLOCK.radius - .5,
                        y: 0,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O), this.plane = new s.Mesh(new s.PlaneGeometry(3, 3), new s.MeshBasicMaterial({
                        map: a.loader.load("res/point.png"),
                        transparent: !0
                    })), this.plane.position.set(0, 0, a.BLOCK.radius + .04), this.body.add(this.plane), this.timer = setInterval(function () {
                        B.plane.visible = !B.plane.visible
                    }, 1e3), this.numbers = [];
                    for (var q = new s.PlaneGeometry(3, 3), V = 0; V < 10; ++V) {
                        for (var J = new s.MeshBasicMaterial({
                            map: a.loader.load("res/" + V + ".png"),
                            alphaTest: .5
                        }), Q = [], $ = 0; $ < 4; ++$) {
                            var ee = new s.Mesh(q, J);
                            ee.position.z = a.BLOCK.radius + .01, ee.visible = !1, Q.push(ee), this.body.add(ee)
                        }
                        this.numbers.push(Q)
                    }
                    var te = new Date, ie = ("0" + te.getHours()).slice(-2), se = ("0" + te.getMinutes()).slice(-2);
                    this.numbers[ie[0]][0].position.x = -3.2 * this.radiusScale, this.numbers[ie[0]][0].visible = !0, this.numbers[ie[1]][1].position.x = -1.3 * this.radiusScale, this.numbers[ie[1]][1].visible = !0, this.numbers[se[0]][2].position.x = 1.3 * this.radiusScale, this.numbers[se[0]][2].visible = !0, this.numbers[se[1]][3].position.x = 3.2 * this.radiusScale, this.numbers[se[1]][3].visible = !0
                } else if (26 == i) {
                    var K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius),
                        D = new s.MeshLambertMaterial({map: a.loader.load("res/well.png")});
                    this.mapUv(280, 428, K, 1, 0, 0, 280, 148), this.mapUv(280, 428, K, 2, 0, 148, 280, 428), this.mapUv(280, 428, K, 4, 0, 0, 280, 148, !0), this.hitObj = new s.Mesh(K, D), this.score = 5
                } else if (27 == i) {
                    this.radiusSegments = 50;
                    K = new s.CylinderGeometry(2 * a.BLOCK.radius / 38 * 25, 2 * a.BLOCK.radius / 38 * 25, this.height, 50);
                    this.geometry = K, this.shadow.scale.set(50 / 38, 50 / 38, 50 / 38);
                    var D = new s.MeshBasicMaterial({map: a.loader.load("res/golf_bottom.png")}),
                        k = new s.CircleGeometry(2 * a.BLOCK.radius / 38 * 25 + .01, 30),
                        T = new g({map: a.loader.load("res/golf_top.png")}), L = new s.Geometry, O = [D, T];
                    K.rotateY(3), this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), k.rotateX(-Math.PI / 2), k.rotateY(-.7), this.merge(L, k, 1, [{
                        x: 0,
                        y: this.height / 2 + .01,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O), this.sphere = new s.Mesh(new s.SphereGeometry(.6, 10, 10), this.whiteMaterial), this.sphere.position.set(-8, -1, -1.5), this.obj.add(this.sphere);
                    var ae = new s.Mesh(new s.PlaneGeometry(2, 5), new s.MeshBasicMaterial({
                        map: a.loader.load("res/flag.png"),
                        transparent: !0
                    }));
                    this.body.add(ae), ae.position.set(-4.4, 5, -4.3), ae.rotation.y = -Math.PI / 4, ae.rotation.x = -.928, ae.rotation.z = -Math.PI / 5
                } else if (28 == i) {
                    this.radiusSegments = 50;
                    K = new s.CylinderGeometry(2 * a.BLOCK.radius / 38 * 15, 2 * a.BLOCK.radius / 38 * 15, this.height, 50);
                    this.geometry = K, this.shadow.scale.set(30 / 38, 30 / 38, 30 / 38);
                    var D = new s.MeshBasicMaterial({map: a.loader.load("res/paper_bottom.png")}),
                        k = new s.CircleGeometry(2 * a.BLOCK.radius / 38 * 15 + .01, 30),
                        T = new g({map: a.loader.load("res/paper_top.png")}), L = new s.Geometry, O = [D, T];
                    K.rotateY(4), this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), k.rotateX(-Math.PI / 2), k.rotateY(-.7), this.merge(L, k, 1, [{
                        x: 0,
                        y: this.height / 2 + .01,
                        z: 0
                    }]), this.shadow.scale.y = 1.1, this.hitObj = new s.Mesh(L, O)
                } else if (29 == i) {
                    this.radiusSegments = 50, this.min = .8, this.height = a.BLOCK.height / 21 * 4;
                    K = new s.CylinderGeometry(.4 * a.BLOCK.radius, .4 * a.BLOCK.radius, this.height, 50);
                    this.geometry = K;
                    var D = w, k = new s.CircleGeometry(.4 * a.BLOCK.radius, 50),
                        T = new s.MeshBasicMaterial({color: 16777215}),
                        E = new s.CylinderGeometry(.4 * a.BLOCK.radius, .5 * a.BLOCK.radius, a.BLOCK.height / 21 * 1, 50),
                        G = new s.CylinderGeometry(.5 * a.BLOCK.radius, .5 * a.BLOCK.radius, a.BLOCK.height / 21 * 16, 50),
                        H = new s.MeshBasicMaterial({map: a.loader.load("res/medicine.png")}), L = new s.Geometry,
                        O = [D, T, H];
                    this.merge(L, K, 0, [{x: 0, y: 0, z: 0}]), k.rotateX(-Math.PI / 2), this.merge(L, k, 1, [{
                        x: 0,
                        y: this.height / 2 + .01,
                        z: 0
                    }]), this.merge(L, E, 1, [{
                        x: 0,
                        y: -a.BLOCK.height / 21 * 2.5,
                        z: 0
                    }]), G.rotateY(2.3), this.merge(L, G, 2, [{
                        x: 0,
                        y: -a.BLOCK.height / 21 * 11,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O), this.shadow.scale.set(.55, .9, .7)
                } else if (30 == i) {
                    K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius);
                    this.geometry = K;
                    D = new s.MeshLambertMaterial({map: a.loader.load("res/luban.png")});
                    this.mapUv(338, 338, K, 1, 0, 128, 208, 0), this.mapUv(338, 338, K, 2, 0, 128, 210, 338), this.mapUv(338, 338, K, 4, 210, 129, 337, 338);
                    var oe = new s.MeshLambertMaterial({color: 2199e3}),
                        he = new s.Mesh(new s.BoxGeometry(10, .4, 1.5), oe),
                        re = new s.MeshLambertMaterial({color: 4531468}), ne = new s.MeshLambertMaterial({color: 8037621});
                    this.earBlack = new s.Mesh(new s.BoxGeometry(1.2, 3.5, 3.5), re), this.earBlue = new s.Mesh(new s.BoxGeometry(1, 2.5, 2.5), ne), he.position.set(0, .8, 5.75), this.body.add(he), this.earBlack.position.set(-5.4, 0, 0), this.earBlue.position.set(-6, 0, 0), this.body.add(this.earBlue), this.body.add(this.earBlack), this.hitObj = new s.Mesh(K, D), this.musicName = "luban", this.score = 20;
                    k = new s.PlaneGeometry(2, 2);
                    this.icons = [];
                    for (var le = a.loader.load("res/music_icon_two.png"), V = 0; V < 4; ++V) this.icons[V] = new s.Mesh(k, new s.MeshBasicMaterial({
                        map: le,
                        transparent: !0
                    })), this.icons[V].rotation.y = -Math.PI / 4, this.icons[V].rotation.x = -Math.PI / 5, this.icons[V].rotation.z = -Math.PI / 5, this.body.add(this.icons[V]), this.icons[V].scale.set(.6, .6, .6);
                    this.succeedTimer = this.playLubanMusic, this.whenLeave = this.stopLubanMusic
                } else if (31 == i) {
                    this.canChange = !1, this.height = a.BLOCK.height / 21 * 7;
                    K = new s.BoxGeometry(2 * a.BLOCK.radius / 38 * 45, this.height, 2 * a.BLOCK.radius / 38 * 45);
                    this.geometry = K;
                    G = new s.BoxGeometry(2 * a.BLOCK.radius / 38 * 40, a.BLOCK.height / 21 * 14, 2 * a.BLOCK.radius / 38 * 40);
                    this.shadow.scale.set(40 / 38, 1.4, 1), this.map = a.loader.load("res/wechat_close.png"), this.topMap = a.loader.load("res/wechat_top.png");
                    var O = [D = new s.MeshLambertMaterial({map: this.topMap}), H = new s.MeshBasicMaterial({
                        map: this.map,
                        transparent: !0
                    })], L = new s.Geometry;
                    this.mapUv(340, 340, K, 1, 0, 0, 280, 60), this.mapUv(340, 340, K, 2, 0, 60, 280, 340), this.mapUv(340, 340, K, 4, 280, 60, 340, 340), this.merge(L, K, 0, [{
                        x: 0,
                        y: 0,
                        z: 0
                    }]), this.mapUv(434, 164, G, 1, 0, 0, 217, 164), this.mapUv(434, 164, G, 4, 217, 0, 434, 164, !0), this.merge(L, G, 1, [{
                        x: 0,
                        y: -a.BLOCK.height / 21 * 10.5,
                        z: 0
                    }]), this.hitObj = new s.Mesh(L, O);
                    var de = new s.PlaneGeometry(2.5, 3.34);
                    this.door = new s.Mesh(de, new s.MeshBasicMaterial({
                        map: a.loader.load("res/wechat_door.png"),
                        transparent: !0
                    })), this.door.rotation.y = -Math.PI / 2, this.door.position.set(-a.BLOCK.radius / 38 * 40 - .05, -2.9, 1.2), this.door.visible = !1, this.body.add(this.door), this.secondDoor = new s.Mesh(de, new s.MeshBasicMaterial({
                        map: a.loader.load("res/wechat_second_door.png"),
                        transparent: !0
                    })), this.secondDoor.visible = !1, this.secondDoor.rotation.y = -Math.PI / 2, this.secondDoor.position.set(-a.BLOCK.radius / 38 * 40 - .05, -2.9, -1.2), this.body.add(this.secondDoor), this.glowMap = a.loader.load("res/wechat_open.png"), this.glowTopMap = a.loader.load("res/wechat_glow_top.png"), this.succeedTimer = function () {
                        5 != this.score && (this.hitObj.material[1].map = this.glowMap, this.hitObj.material[0].map = this.glowTopMap, this.logo.visible = !1, this.glowLogo.visible = !0, this.door.visible = !0, this.secondDoor.visible = !0)
                    }, this.glowLogo = new s.Object3D, this.logo = new s.Object3D;
                    var E = new s.CylinderGeometry(1.8, 1.8, .5, 30), me = new s.MeshLambertMaterial({color: 3457369}),
                        F = new s.MeshLambertMaterial({color: 5879160}), ce = new s.Mesh(E, F), ue = new s.Mesh(E, me);
                    (k = new s.CircleGeometry(1.8, 30)).rotateX(Math.PI / 2), k.rotateY(-Math.PI / 2);
                    var T = new s.MeshBasicMaterial({map: a.loader.load("res/wechat_logo.png")}),
                        ye = new s.MeshBasicMaterial({map: a.loader.load("res/wechat_glow_logo.png")}),
                        pe = new s.Mesh(k, T), we = new s.Mesh(k, ye);
                    this.logo.add(ce), pe.position.y = -.251, this.logo.add(pe), this.logo.position.x = -6.5, this.logo.rotation.z = -Math.PI / 2, this.body.add(this.logo), we.position.y = -.251, this.glowLogo.add(we), this.glowLogo.add(ue), this.glowLogo.position.x = -6.5, this.glowLogo.rotation.z = -Math.PI / 2, this.glowLogo.visible = !1, this.body.add(this.glowLogo), this.musicName = "pay", this.registerAudio = function () {
                        5 != B.score && (o.customAnimation.to(B.door.position, 1, {z: 2.2}), o.customAnimation.to(B.secondDoor.position, 1, {z: -1.9}))
                    }, this.registerEndAudio = function () {
                        5 != B.score && (o.customAnimation.to(B.door.position, 1, {z: 1.2}), o.customAnimation.to(B.secondDoor.position, 1, {z: -1.2}))
                    }, this.beforePopup = function () {
                        B.hitObj.material[1].map = B.map, B.hitObj.material[0].map = B.topMap, B.logo.visible = !0, B.glowLogo.visible = !1, B.door.visible = !1, B.secondDoor.visible = !1
                    }, this.score = 20
                } else if (32 == i) {
                    this.canChange = !1;
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, b = 3,
                        C = (a.BLOCK.height - b) / 2, v = new s.BoxGeometry(2 * a.BLOCK.radius, C, 2 * a.BLOCK.radius);
                    this.geometry = v;
                    I = new s.BoxGeometry(2 * a.BLOCK.radius, b, 2 * a.BLOCK.radius);
                    this.merge(L, v, 0, [{x: 0, y: -b / 2 - C / 2, z: 0}, {
                        x: 0,
                        y: b / 2 + C / 2,
                        z: 0
                    }]), this.merge(L, I, 1, [{x: 0, y: 0, z: 0}]), this.hitObj = new s.Mesh(L, O);
                    var E = new s.CylinderGeometry(1.5, 1.5, .4, 30),
                        ge = new s.Mesh(E, new s.MeshLambertMaterial({color: 9099465}));
                    (k = new s.CircleGeometry(1.5, 30)).rotateX(Math.PI / 2), k.rotateY(-Math.PI / 2);
                    var T = new s.MeshBasicMaterial({map: a.loader.load("res/relax_back.png")}),
                        Me = new s.MeshBasicMaterial({map: a.loader.load("res/relax_front.png"), side: s.DoubleSide}),
                        Be = new s.Mesh(k, T), Oe = new s.Mesh(k, Me);
                    this.board = new s.Object3D, Be.position.y = -.21, Oe.position.y = .21, this.board.add(Be), this.board.add(Oe), this.board.add(ge), this.board.rotation.z = -Math.PI / 2, this.board.position.set(6.7, 3.5, 6.7), this.obj.add(this.board);
                    var Le = new s.Mesh(E, this.greenMaterial), be = new s.Mesh(E, this.greenMaterial);
                    be.scale.set(1, 1, 1), be.position.set(6.7, -2, 6.7), this.obj.add(be), Le.scale.set(.7, .7, .7), Le.position.set(6.7, -1.5, 6.7), this.obj.add(Le);
                    var Ce = Le.clone();
                    Ce.scale.set(.1, 11, .1), Ce.position.set(6.7, 0, 6.7), this.obj.add(Ce), this.perFrame = function () {
                        B.board.rotation.y += .01
                    }, this.score = -20, this.musicName = "relax"
                } else if (33 == i) {
                    this.canChange = !1;
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, b = 3,
                        C = (a.BLOCK.height - b) / 2, v = new s.BoxGeometry(2 * a.BLOCK.radius, C, 2 * a.BLOCK.radius);
                    this.geometry = v;
                    I = new s.BoxGeometry(2 * a.BLOCK.radius, b, 2 * a.BLOCK.radius);
                    this.merge(L, v, 0, [{x: 0, y: -b / 2 - C / 2, z: 0}, {
                        x: 0,
                        y: b / 2 + C / 2,
                        z: 0
                    }]), this.merge(L, I, 1, [{x: 0, y: 0, z: 0}]), this.hitObj = new s.Mesh(L, O)
                } else if (34 == i) {
                    this.canChange = !1;
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, b = 3,
                        C = (a.BLOCK.height - b) / 2, v = new s.BoxGeometry(2 * a.BLOCK.radius, C, 2 * a.BLOCK.radius);
                    this.geometry = v;
                    I = new s.BoxGeometry(2 * a.BLOCK.radius, b, 2 * a.BLOCK.radius);
                    this.merge(L, v, 0, [{x: 0, y: -b / 2 - C / 2, z: 0}, {
                        x: 0,
                        y: b / 2 + C / 2,
                        z: 0
                    }]), this.merge(L, I, 1, [{x: 0, y: 0, z: 0}]), this.hitObj = new s.Mesh(L, O)
                } else if (35 == i) {
                    this.canChange = !1;
                    var O = [this.greenMaterial, this.whiteMaterial], L = new s.Geometry, b = 3,
                        C = (a.BLOCK.height - b) / 2, v = new s.BoxGeometry(2 * a.BLOCK.radius, C, 2 * a.BLOCK.radius);
                    this.geometry = v;
                    I = new s.BoxGeometry(2 * a.BLOCK.radius, b, 2 * a.BLOCK.radius);
                    this.merge(L, v, 0, [{x: 0, y: -b / 2 - C / 2, z: 0}, {
                        x: 0,
                        y: b / 2 + C / 2,
                        z: 0
                    }]), this.merge(L, I, 1, [{x: 0, y: 0, z: 0}]), this.hitObj = new s.Mesh(L, O)
                } else if (-1 == i) {
                    var ve = [15622240, 14980702, 15712087, 9089870, 7451844, 6519997, 10772948], K = u,
                        D = new s.MeshLambertMaterial({color: ve[h], transparent: !0});
                    this.hitObj = new s.Mesh(K, D);
                    var xe = new s.BoxGeometry(2 * a.BLOCK.radius, a.BLOCK.height, 2 * a.BLOCK.radius);
                    this.mapUv(100, 88, xe, 2, 0, 0, 5, 5);
                    var Ke = new s.Mesh(xe, m);
                    0 == h && (Ke.receiveShadow = !0), this.body.add(Ke);
                    var fe, Ge, ze, je, k = new s.PlaneGeometry(4, 8);
                    ze = (fe = h % 4 * 64) + 64, je = (Ge = 128 * parseInt(h / 4)) + 128, this.mapUv(256, 256, k, 0, fe, je, ze, Ge), (Be = new s.Mesh(k, c)).rotation.x = -Math.PI / 2, Be.rotation.z = -Math.PI / 2, Be.position.y = a.BLOCK.height / 2 + .05, this.body.add(Be), this.obj.scale.set(.7, 1, .7)
                } else if ("object" == t(arguments[1])) {
                    var K = new s.BoxGeometry(2 * a.BLOCK.radius, this.height, 2 * a.BLOCK.radius),
                        D = new s.MeshLambertMaterial({map: a.loader.load(wx.env.USER_DATA_PATH + "/" + arguments[1].res[0].path)});
                    this.mapUv(428, 428, K, 1, 0, 0, 280, 148), this.mapUv(428, 428, K, 2, 0, 148, 280, 428), this.mapUv(428, 428, K, 4, 280, 148, 428, 428), this.hitObj = new s.Mesh(K, D), this.score = arguments[1].score, arguments[1].music_src && (this.musicName = arguments[1].music_name, arguments[2].addMusic(arguments[1].music_name, arguments[1].music_src))
                }
                this.shadow.initZ = this.shadow.position.z, this.hitObj.receiveShadow = !0, this.hitObj.name = "hitObj", this.body.add(this.hitObj), this.hitObj.matrixAutoUpdate = !1, this.shadow.initScale = this.shadow.scale.y, this.body.position.y = a.BLOCK.height / 2 - this.height / 2, this.obj.add(this.shadow), this.obj.add(this.body)
            }

            return i(M, [{
                key: "merge", value: function (e, t, i, a) {
                    for (var o = 0, h = t.faces.length; o < h; ++o) t.faces[o].materialIndex = 0;
                    for (var r = new s.Mesh(t), o = 0, h = a.length; o < h; ++o) r.position.set(a[o].x, a[o].y, a[o].z), r.updateMatrix(), e.merge(r.geometry, r.matrix, i)
                }
            }, {
                key: "_mapUv", value: function (e, t, i, a, o, h, r, n, l) {
                    var d = 1 / e, m = 1 / t;
                    if (i.faces[a] instanceof s.Face3) {
                        c = i.faceVertexUvs[0][2 * a];
                        4 == a && !l || 2 == a && l ? (c[0].x = o * d, c[0].y = h * m, c[2].x = o * d, c[2].y = n * m, c[1].x = r * d, c[1].y = h * m) : (c[0].x = o * d, c[0].y = h * m, c[1].x = o * d, c[1].y = n * m, c[2].x = r * d, c[2].y = h * m);
                        var c = i.faceVertexUvs[0][2 * a + 1];
                        4 == a && !l || 2 == a && l ? (c[2].x = o * d, c[2].y = n * m, c[1].x = r * d, c[1].y = n * m, c[0].x = r * d, c[0].y = h * m) : (c[0].x = o * d, c[0].y = n * m, c[1].x = r * d, c[1].y = n * m, c[2].x = r * d, c[2].y = h * m)
                    }
                }
            }, {
                key: "mapUv", value: function (e, t, i, s, a, o, h, r, n) {
                    if (s.length) for (var l = 0; l < s.length; ++l) this._mapUv(e, t, i, s[l], a, o, h, r, n); else this._mapUv(e, t, i, s, a, o, h, r, n)
                }
            }, {
                key: "getBox", value: function () {
                    return this.boundingBox ? this.boundingBox : (this.boundingBox = (new s.Box3).setFromObject(this.body), this.boundingBox)
                }
            }, {
                key: "glow", value: function () {
                    this.hitObj.material.map = this.glowMap
                }
            }, {
                key: "wechatGlow", value: function () {
                }
            }, {
                key: "openDoor", value: function () {
                    o.customAnimation.to(this.door.position, 1, {z: -4.5}), o.customAnimation.to(this.secondDoor.position, 1, {z: -.5})
                }
            }, {
                key: "closeDoor", value: function () {
                    o.customAnimation.to(this.door.position, 1, {z: -3.3}), o.customAnimation.to(this.secondDoor.position, 1, {z: -1.7})
                }
            }, {
                key: "rotateBox", value: function () {
                    o.customAnimation.to(this.middle.rotation, .5, {y: -Math.PI / 2})
                }
            }, {
                key: "playLubanMusic", value: function () {
                    var e = this, t = function () {
                        e.icons[0].position.set(1, 7, -1), e.icons[1].position.set(-1, 7, -1), e.icons[2].position.set(1, 7, 1), e.icons[3].position.set(-1, 7, 1);
                        for (var t = 0, i = e.icons.length; t < i; ++t) e.icons[t].material.opacity = 0, o.customAnimation.to(e.icons[t].position, .7, {
                            y: 12,
                            ease: "Cubic.easeIn",
                            delay: .1 * t
                        }), o.customAnimation.to(e.icons[t].position, .7, {
                            x: 0 == t || 2 == t ? 3 : -3,
                            delay: .1 * t
                        }), o.customAnimation.to(e.icons[t].material, .7, {
                            opacity: 1,
                            delay: .1 * t
                        }), o.customAnimation.to(e.icons[t].position, .7, {
                            y: 17,
                            ease: "Cubic.easeOut",
                            delay: .1 * t + .7
                        }), o.customAnimation.to(e.icons[t].position, .7, {
                            x: 0 == t || 2 == t ? 1 : -1,
                            delay: .1 * t + .7
                        }), o.customAnimation.to(e.icons[t].material, .7, {opacity: 0, delay: .1 * t + .7})
                    };
                    setTimeout(function () {
                        t()
                    }, 1e3), this.lubanMusicTimer = setInterval(function () {
                        t()
                    }, 3e3);
                    var i = function () {
                        for (var t = 0; t < 15; ++t) o.customAnimation.to(e.earBlack.scale, .2, {
                            y: 1.3,
                            z: 1.3,
                            delay: .4 * t
                        }), o.customAnimation.to(e.earBlue.scale, .2, {
                            y: 1.3,
                            z: 1.3,
                            delay: .4 * t
                        }), o.customAnimation.to(e.earBlack.scale, .2, {
                            y: 1,
                            z: 1,
                            delay: .4 * t + .2
                        }), o.customAnimation.to(e.earBlue.scale, .2, {y: 1, z: 1, delay: .4 * t + .2})
                    };
                    i(), this.earTimer = setInterval(function () {
                        i()
                    }, 9e3)
                }
            }, {
                key: "stopLubanMusic", value: function () {
                    this.earTimer && (clearTimeout(this.earTimer), this.earTimer = null), this.lubanMusicTimer && (clearTimeout(this.lubanMusicTimer), this.lubanMusicTimer = null)
                }
            }, {
                key: "playMusic", value: function () {
                    for (var e = this, t = 0; t < 2; ++t) setTimeout(function (e) {
                        return function () {
                            e.visible = !0, e.position.set(0, 0, 0), e.material.opacity = 1, o.customAnimation.to(e.position, 2, {
                                x: 5 * (1 - 2 * Math.random()),
                                y: 15,
                                z: 5 * (1 - 2 * Math.random())
                            }), o.customAnimation.to(e.material, 2, {opacity: 0})
                        }
                    }(this.icons[t]), 1e3 * t);
                    this.musicTimer = setTimeout(function () {
                        e.playMusic()
                    }, 2500)
                }
            }, {
                key: "stopMusic", value: function () {
                    this.musicTimer && (clearTimeout(this.musicTimer), this.musicTimer = null)
                }
            }, {
                key: "change", value: function (e, t, i) {
                    if (this.canChange) {
                        if (this.order >= 9) {
                            var s = this.order >= 13 ? .7 : .6;
                            return this.radiusScale = i || Math.max((0, h.random)() * (a.BLOCK.maxRadiusScale - a.BLOCK.minRadiusScale) + a.BLOCK.minRadiusScale, this.min || s), this.radiusScale = +this.radiusScale.toFixed(2), this.radius = e || this.radiusScale * a.BLOCK.radius, this.radius = +this.radius.toFixed(2), void this.obj.scale.set(this.radiusScale, 1, this.radiusScale)
                        }
                        this.radiusScale = i || (0, h.random)() * (a.BLOCK.maxRadiusScale - a.BLOCK.minRadiusScale) + a.BLOCK.minRadiusScale, this.radiusScale = +this.radiusScale.toFixed(2), this.radius = e || this.radiusScale * a.BLOCK.radius, this.radius = +this.radius.toFixed(2), this.obj.scale.set(this.radiusScale, 1, this.radiusScale), this.changeColor(t)
                    }
                }
            }, {
                key: "changeColor", value: function (e) {
                    var t = e || this.types[Math.floor(3 * Math.random())];
                    this.type != t && (this.type = t, "green" == t ? (this.greenMaterial.color.setHex(r.green), this.whiteMaterial.color.setHex(r.white), this.middleLightGreenMaterial && this.middleLightGreenMaterial.color.setHex(r.middleLightGreen)) : "gray" == t ? (this.greenMaterial.color.setHex(r.white), this.whiteMaterial.color.setHex(r.gray), this.middleLightGreenMaterial && this.middleLightGreenMaterial.color.setHex(r.middleLightGray)) : "black" == t && (this.greenMaterial.color.setHex(r.black), this.whiteMaterial.color.setHex(r.lightBlack), this.middleLightGreenMaterial && this.middleLightGreenMaterial.color.setHex(r.middleLightBlack)))
                }
            }, {
                key: "getVertices", value: function () {
                    var e = this, t = [], i = this.geometry || this.hitObj.geometry;
                    if (this.obj.updateMatrixWorld(), 4 === this.radiusSegments) [0, 1, 4, 5].forEach(function (s) {
                        var a = i.vertices[s].clone().applyMatrix4(e.hitObj.matrixWorld);
                        t.push([a.x, a.z])
                    }); else for (var s = 0; s < this.radiusSegments; ++s) {
                        var a = i.vertices[s].clone().applyMatrix4(this.hitObj.matrixWorld);
                        t.push([a.x, a.z])
                    }
                    return t
                }
            }, {
                key: "shrink", value: function () {
                    this.status = "shrink"
                }
            }, {
                key: "_shrink", value: function () {
                    if (this.scale -= a.BLOCK.reduction, this.scale = Math.max(a.BLOCK.minScale, this.scale), this.scale <= a.BLOCK.minScale) this.status = "stop"; else {
                        this.body.scale.y = this.scale, this.shadow.scale.y -= a.BLOCK.reduction / 2, this.shadow.position.z += a.BLOCK.reduction / 4 * this.shadowWidth;
                        var e = a.BLOCK.reduction / 2 * a.BLOCK.height * (a.BLOCK.height - this.height / 2) / a.BLOCK.height * 2;
                        this.body.position.y -= e
                    }
                }
            }, {
                key: "showup", value: function (e) {
                    var t = this.shadow.position.z;
                    this.body.position.set(0, 20, 0), this.shadow.position.z = -15, this.obj.visible = !0, 3 == e || 4 == e || 6 == e ? this.obj.position.set(7.5 * (6 == e ? 5 : 3), 0, 3.8 * (3 == e || 6 == e ? -1 : 1)) : 5 == e ? this.obj.position.set(30, 0, 0) : this.obj.position.set(7.5 * e, 0, 0), (0, o.TweenAnimation)(this.body.position.y, a.BLOCK.height / 2 - this.height / 2, 500, "Bounce.easeOut", function (e, t) {
                        this.body.position.y = e
                    }.bind(this)), (0, o.TweenAnimation)(this.shadow.position.z, t, 500, "Bounce.easeOut", function (e, t) {
                        this.shadow.position.z = e
                    }.bind(this))
                }
            }, {
                key: "hideGlow", value: function () {
                    this.hitObj.material.map = this.map
                }
            }, {
                key: "popup", value: function () {
                    var e = this;
                    if (this.beforePopup && this.beforePopup(), 25 == this.order) {
                        for (var t = 0; t < 10; ++t) for (var i = 0; i < 4; ++i) this.numbers[t][i].visible = !1;
                        var s = new Date, h = ("0" + s.getHours()).slice(-2), r = ("0" + s.getMinutes()).slice(-2);
                        this.numbers[h[0]][0].position.x = -3.1 * this.radiusScale, this.numbers[h[0]][0].visible = !0, this.numbers[h[1]][1].position.x = -1.2 * this.radiusScale, this.numbers[h[1]][1].visible = !0, this.numbers[r[0]][2].position.x = 1.2 * this.radiusScale, this.numbers[r[0]][2].visible = !0, this.numbers[r[1]][3].position.x = 3.1 * this.radiusScale, this.numbers[r[1]][3].visible = !0
                    } else 17 == this.order && (this.middle.rotation.y = 0);
                    var n = this.shadow.position.z;
                    this.body.position.y = 20, this.shadow.position.z = -15, this.obj.visible = !0, this.boundingBox = null, o.customAnimation.to(this.body.position, .5, {
                        y: a.BLOCK.height / 2 - this.height / 2,
                        ease: "Bounce.easeOut",
                        onEnded: function () {
                            e.body.position.y = a.BLOCK.height / 2 - e.height / 2
                        }
                    }), o.customAnimation.to(this.shadow.position, .5, {
                        z: n, ease: "Bounce.easeOut", onEnded: function () {
                            e.shadow.position.z = n
                        }
                    })
                }
            }, {
                key: "reset", value: function () {
                    this.status = "stop", this.scale = 1, this.obj.scale.y = 1, this.body.scale.y = 1, this.obj.position.y = 0, this.body.position.y = a.BLOCK.height / 2 - this.height / 2, this.shadow.scale.y = this.shadow.initScale, this.shadow.position.z = this.shadow.initZ, this.boundingBox = null
                }
            }, {
                key: "rebound", value: function () {
                    this.status = "stop", this.scale = 1, o.customAnimation.to(this.body.scale, .5, {
                        ease: "Elastic.easeOut",
                        y: 1
                    }), o.customAnimation.to(this.body.position, .5, {
                        ease: "Elastic.easeOut",
                        y: a.BLOCK.height / 2 - this.height / 2
                    }), o.customAnimation.to(this.shadow.scale, .5, {
                        ease: "Elastic.easeOut",
                        y: this.shadow.initScale
                    }), o.customAnimation.to(this.shadow.position, .5, {ease: "Elastic.easeOut", z: this.shadow.initZ})
                }
            }, {
                key: "update", value: function () {
                    this.perFrame && this.perFrame(), "stop" !== this.status && ("shrink" === this.status ? this._shrink() : this.status)
                }
            }]), M
        }();
    exports.default = M;
});
define("js/bottle.js", function (require, module, exports) {
    "use strict";

    function t(t, i) {
        if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
        function t(t, i) {
            for (var o = 0; o < i.length; o++) {
                var s = i[o];
                s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
            }
        }

        return function (i, o, s) {
            return o && t(i.prototype, o), s && t(i, s), i
        }
    }(), o = function (t) {
        if (t && t.__esModule) return t;
        var i = {};
        if (null != t) for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (i[o] = t[o]);
        return i.default = t, i
    }(require("./lib/three")), s = require("./lib/animation"), e = require("./config"), n = function (t) {
        return t && t.__esModule ? t : {default: t}
    }(require("./text")), a = function () {
        function a() {
            t(this, a), this.obj = new o.Object3D, this.obj.name = "bottle", this.trail = null, this.bottle = new o.Object3D;
            var i = new o.MeshBasicMaterial({map: e.loader.load("res/head.png")});
            this.human = new o.Object3D, this.head = new o.Mesh(new o.SphereGeometry(2.1 * .45, 20, 20), i), this.head.castShadow = !0, this.bottom = new o.Mesh(new o.CylinderGeometry(.8316, 1.20015, 2.1 * .45 * 2.68, 20), new o.MeshBasicMaterial({map: e.loader.load("res/bottom.png")})), this.bottom.rotation.y = 4.7, this.bottom.castShadow = !0;
            var s = new o.CylinderGeometry(2.1 * .45, .8316, 2.1 * .45 * 1.2, 20),
                h = [new o.MeshBasicMaterial({map: e.loader.load("res/top.png")}), i], r = new o.Geometry;
            s.rotateY(4.7), this.merge(r, s, 0, [{x: 0, y: this.bottom.position.y + 2.1 * .45 * 1.94, z: 0}]);
            var u = new o.SphereGeometry(2.1 * .45, 20, 20);
            u.scale(1, .54, 1), this.merge(r, u, 1, [{
                x: 0,
                y: this.bottom.position.y + 2.4003,
                z: 0
            }]), this.middle = new o.Mesh(r, h), this.middle.castShadow = !0, this.body = new o.Object3D, this.body.add(this.bottom), this.body.add(this.middle), this.human.add(this.body), this.head.position.y = 4.725, this.human.add(this.head), this.bottle.add(this.human), this.bottle.position.y = e.BOTTLE.bodyHeight / 2 - .25, this.obj.add(this.bottle), this.status = "stop", this.scale = 1, this.double = 1, this.velocity = {}, this.flyingTime = 0, this.direction = "straight", this.jumpStatus = "init", this.particles = [];
            for (var c = new o.MeshBasicMaterial({
                map: e.loader.load("res/white.png"),
                alphaTest: .5
            }), l = new o.MeshBasicMaterial({
                map: e.loader.load("res/green.png"),
                alphaTest: .5
            }), d = new o.PlaneGeometry(1, 1), m = 0; m < 15; ++m) (y = new o.Mesh(d, c)).rotation.y = -Math.PI / 4, y.rotation.x = -Math.PI / 5, y.rotation.z = -Math.PI / 5, this.particles.push(y), this.obj.add(y);
            for (m = 0; m < 5; ++m) {
                var y = new o.Mesh(d, l);
                y.rotation.y = -Math.PI / 4, y.rotation.x = -Math.PI / 5, y.rotation.z = -Math.PI / 5, this.particles.push(y), this.obj.add(y)
            }
            this.scoreText = new n.default("0", {
                fillStyle: 2434341,
                textAlign: "center",
                plusScore: !0
            }), this.scoreText.obj.visible = !1, this.scoreText.obj.rotation.y = -Math.PI / 4, this.scoreText.obj.scale.set(.5, .5, .5), this.obj.add(this.scoreText.obj)
        }

        return i(a, [{
            key: "merge", value: function (t, i, s, e) {
                for (var n = 0, a = i.faces.length; n < a; ++n) i.faces[n].materialIndex = 0;
                for (var h = new o.Mesh(i), n = 0, a = e.length; n < a; ++n) h.position.set(e[n].x, e[n].y, e[n].z), h.updateMatrix(), t.merge(h.geometry, h.matrix, s)
            }
        }, {
            key: "showAddScore", value: function (t, i, o, n) {
                n ? this.scoreText.setScore(t.toString()) : (i ? 1 === this.double ? this.double = 2 : this.double += 2 : this.double = 1, o && this.double <= 2 && (this.double *= 2), this.double = Math.min(32, this.double), t *= this.double, this.scoreText.setScore(t.toString())), this.scoreText.obj.visible = !0, this.scoreText.obj.position.y = 3, this.scoreText.material.opacity = 1, (0, s.TweenAnimation)(this.scoreText.obj.position.y, e.BOTTLE.bodyHeight + 6, 700, function (t) {
                    void 0 !== t && (this.scoreText.obj.position.y = t)
                }.bind(this)), (0, s.TweenAnimation)(this.scoreText.material.opacity, 0, 700, function (t, i, o) {
                    void 0 !== t && (this.scoreText.material.opacity = t, o && (this.scoreText.obj.visible = !1))
                }.bind(this))
            }
        }, {
            key: "changeScorePos", value: function (t) {
                this.scoreText.obj.position.z = t
            }
        }, {
            key: "resetParticles", value: function () {
                this.gatherTimer && clearTimeout(this.gatherTimer), this.gatherTimer = null;
                for (var t = 0, i = this.particles.length; t < i; ++t) this.particles[t].gathering = !1, this.particles[t].visible = !1, this.particles[t].scattering = !1
            }
        }, {
            key: "scatterParticles", value: function () {
                for (var t = 0; t < 10; ++t) this.particles[t].scattering = !0, this.particles[t].gathering = !1, this._scatterParticles(this.particles[t])
            }
        }, {
            key: "_scatterParticles", value: function (t) {
                var i = e.BOTTLE.bodyWidth / 2, o = (i + Math.random() * (2 - i)) * (1 - 2 * Math.random()),
                    n = (i + Math.random() * (2 - i)) * (1 - 2 * Math.random());
                t.scale.set(1, 1, 1), t.visible = !1, t.position.x = o, t.position.y = -.5, t.position.z = n, setTimeout(function (t) {
                    return function () {
                        if (t.scattering) {
                            t.visible = !0;
                            var i = .3 + .2 * Math.random();
                            s.customAnimation.to(t.scale, i, {
                                x: .2,
                                y: .2,
                                z: .2
                            }), s.customAnimation.to(t.position, i, {
                                x: 2 * o,
                                y: 2.5 * Math.random() + 2,
                                z: 2 * n,
                                onComplete: function () {
                                    t.scattering = !1, t.visible = !1
                                }
                            })
                        }
                    }
                }(t), 0)
            }
        }, {
            key: "gatherParticles", value: function () {
                for (var t = this, i = 10; i < 20; ++i) this.particles[i].gathering = !0, this.particles[i].scattering = !1, this._gatherParticles(this.particles[i]);
                this.gatherTimer = setTimeout(function () {
                    for (var i = 0; i < 10; ++i) t.particles[i].gathering = !0, t.particles[i].scattering = !1, t._gatherParticles(t.particles[i])
                }, 500 + 1e3 * Math.random())
            }
        }, {
            key: "_gatherParticles", value: function (t) {
                var i = this;
                t.scale.set(1, 1, 1), t.visible = !1;
                var o = Math.random() > .5 ? 1 : -1, e = Math.random() > .5 ? 1 : -1;
                t.position.x = (1 + 7 * Math.random()) * o, t.position.y = 1 + 7 * Math.random(), t.position.z = (1 + 7 * Math.random()) * e, setTimeout(function (t) {
                    return function () {
                        if (t.gathering) {
                            t.visible = !0;
                            var n = .5 + .4 * Math.random();
                            (0, s.TweenAnimation)(t.scale.x, .8 + Math.random(), 1e3 * n, function (i) {
                                void 0 !== i && (t.scale.x = i)
                            }), (0, s.TweenAnimation)(t.scale.y, .8 + Math.random(), 1e3 * n, function (i) {
                                void 0 !== i && (t.scale.y = i)
                            }), (0, s.TweenAnimation)(t.scale.z, .8 + Math.random(), 1e3 * n, function (i) {
                                void 0 !== i && (t.scale.z = i)
                            }), (0, s.TweenAnimation)(t.position.x, Math.random() * o, 1e3 * n, function (i) {
                                void 0 !== i && (t.position.x = i)
                            }), (0, s.TweenAnimation)(t.position.y, 2.5 * Math.random(), 1e3 * n, function (i) {
                                void 0 !== i && (t.position.y = i)
                            }), (0, s.TweenAnimation)(t.position.z, Math.random() * e, 1e3 * n, function (o, s) {
                                void 0 !== o && (t.position.z = o, s && t.gathering && i._gatherParticles(t))
                            })
                        }
                    }
                }(t), 500 * Math.random())
            }
        }, {
            key: "update", value: function (t) {
                "stop" != this.status && ("prepare" == this.status ? this._prepare() : "jump" == this.status ? this._jump(t) : "turn" == this.status && this.turn())
            }
        }, {
            key: "lookAt", value: function (t, i) {
                t !== this.direction && ("straight" === t ? (this.turnAngle = -Math.PI / 2, this.angle = 0) : (this.turnAngle = Math.PI / 2, this.angle = Math.PI / 2), this.direction = t)
            }
        }, {
            key: "turn", value: function () {
                var t = this.turnAngle > 0 ? .2 : -.2;
                this.bottle.rotation.y += t, this.turnAngle -= t, this.turnAngle >= -.2 && this.turnAngle <= .2 && (this.bottle.rotation.y = this.angle, this.status = "stop")
            }
        }, {
            key: "fall", value: function () {
                var t = this;
                this.stop(), setTimeout(function () {
                    t.status = "fall", (0, s.TweenAnimation)(t.obj.position.y, -e.BLOCK.height / 2 - .3, 400, function (t) {
                        void 0 !== t && (this.obj.position.y = t)
                    }.bind(t))
                }, 0)
            }
        }, {
            key: "forerake", value: function () {
                var t = this;
                this.stop(), this.status = "forerake", setTimeout(function () {
                    "straight" === t.direction ? (0, s.TweenAnimation)(t.obj.rotation.z, -Math.PI / 2, 1e3, function (t) {
                        void 0 !== t && (this.obj.rotation.z = t)
                    }.bind(t)) : (0, s.TweenAnimation)(t.obj.rotation.x, -Math.PI / 2, 1e3, function (t) {
                        void 0 !== t && (this.obj.rotation.x = t)
                    }.bind(t)), setTimeout(function () {
                        "suspend" != t.status ? ((0, s.TweenAnimation)(t.obj.position.y, -e.BLOCK.height / 2 + 1.2, 400, function (t, i) {
                            void 0 !== t && (this.obj.position.y = t)
                        }.bind(t)), s.customAnimation.to(t.head.position, .2, {x: -1.125}), s.customAnimation.to(t.head.position, .2, {
                            x: 0,
                            delay: .2
                        })) : t.status = "stop"
                    }, 200)
                }, 200)
            }
        }, {
            key: "hypsokinesis", value: function () {
                var t = this;
                this.stop(), this.status = "hypsokinesis", setTimeout(function () {
                    "straight" === t.direction ? (0, s.TweenAnimation)(t.obj.rotation.z, Math.PI / 2, 800, function (t) {
                        void 0 !== t && (this.obj.rotation.z = t)
                    }.bind(t)) : (0, s.TweenAnimation)(t.obj.rotation.x, Math.PI / 2, 800, function (t) {
                        void 0 !== t && (this.obj.rotation.x = t)
                    }.bind(t)), setTimeout(function () {
                        "suspend" != t.status ? ((0, s.TweenAnimation)(t.obj.position.y, -e.BLOCK.height / 2 + 1.2, 400, function (t, i) {
                            void 0 !== t && (this.obj.position.y = t)
                        }.bind(t)), s.customAnimation.to(t.head.position, .2, {x: 1.125}), s.customAnimation.to(t.head.position, .2, {
                            x: 0,
                            delay: .2
                        })) : t.status = "stop"
                    }, 350)
                }, 200)
            }
        }, {
            key: "_jump", value: function (t) {
                var i = new o.Vector3(0, 0, 0);
                i.z = this.velocity.vz * t, i.y = this.velocity.vy * t - e.GAME.gravity / 2 * t * t - e.GAME.gravity * this.flyingTime * t, this.flyingTime += t, this.obj.translateY(i.y), this.obj.translateOnAxis(this.axis, i.z)
            }
        }, {
            key: "squeeze", value: function () {
                this.obj.position.y = e.BLOCK.height / 2, s.customAnimation.to(this.body.scale, .15, {
                    y: .9,
                    x: 1.07,
                    z: 1.07
                }), s.customAnimation.to(this.body.scale, .15, {
                    y: 1,
                    x: 1,
                    z: 1,
                    delay: .15
                }), s.customAnimation.to(this.head.position, .15, {y: 4.725, delay: .15})
            }
        }, {
            key: "stop", value: function () {
                this.status = "stop", this.flyingTime = 0, this.scale = 1, this.velocity = {}, this.jumpStatus = "init"
            }
        }, {
            key: "suspend", value: function () {
                this.status = "suspend", s.TweenAnimation.killAll()
            }
        }, {
            key: "rotate", value: function () {
                if (s.TweenAnimation.killAll(), "straight" === this.direction) {
                    (0, s.TweenAnimation)(this.obj.rotation.z, 0, 300, function (t) {
                        void 0 !== t && (this.obj.rotation.z = t)
                    }.bind(this));
                    var t;
                    t = this.status.indexOf("forerake") >= 0 ? 2 : -2, (0, s.TweenAnimation)(this.obj.position.x, this.obj.position.x + t, 300, function (t) {
                        void 0 !== t && (this.obj.position.x = t)
                    }.bind(this))
                } else (0, s.TweenAnimation)(this.obj.rotation.x, 0, 300, function (t) {
                    void 0 !== t && (this.obj.rotation.x = t)
                }.bind(this)), t = this.status.indexOf("forerake") >= 0 ? -2 : 2, (0, s.TweenAnimation)(this.obj.position.z, this.obj.position.z + t, 300, function (t) {
                    void 0 !== t && (this.obj.position.z = t)
                }.bind(this));
                (0, s.TweenAnimation)(this.head.position.x, 0, 100, function (t) {
                    void 0 !== t && (this.head.position.x = t)
                }.bind(this)), (0, s.TweenAnimation)(this.obj.position.y, -e.BLOCK.height / 2, 300, function (t, i) {
                    void 0 !== t && (this.obj.position.y = t, i && (this.status = "stop"))
                }.bind(this)), this.status = "rotate"
            }
        }, {
            key: "_prepare", value: function () {
                if (this.scale -= e.BOTTLE.reduction, this.scale = Math.max(e.BOTTLE.minScale, this.scale), !(this.scale <= e.BOTTLE.minScale)) {
                    this.body.scale.y = this.scale, this.body.scale.x += .007, this.body.scale.z += .007, this.head.position.y -= .018;
                    this.obj.position.y -= e.BLOCK.reduction / 2 * e.BLOCK.height / 2 + .027
                }
            }
        }, {
            key: "prepare", value: function () {
                this.status = "prepare", this.gatherParticles()
            }
        }, {
            key: "jump", value: function (t) {
                this.resetParticles(), this.status = "jump", this.axis = t, s.customAnimation.to(this.body.scale, .25, {
                    x: 1,
                    y: 1,
                    z: 1
                }), this.head.position.y = 4.725, this.scale = 1;
                var i = Math.min(Math.max(this.velocity.vz / 35, 1.2), 1.4);
                this.human.rotation.z = this.human.rotation.x = 0, "straight" === this.direction ? (s.customAnimation.to(this.human.rotation, .14, {z: this.human.rotation.z - Math.PI}), s.customAnimation.to(this.human.rotation, .18, {
                    z: this.human.rotation.z - 2 * Math.PI,
                    delay: .14
                }), s.customAnimation.to(this.head.position, .1, {
                    y: this.head.position.y + .9 * i,
                    x: this.head.position.x + .45 * i
                }), s.customAnimation.to(this.head.position, .1, {
                    y: this.head.position.y - .9 * i,
                    x: this.head.position.x - .45 * i,
                    delay: .1
                }), s.customAnimation.to(this.head.position, .15, {
                    y: 4.725,
                    x: 0,
                    delay: .25
                }), s.customAnimation.to(this.body.scale, .1, {
                    y: Math.max(i, 1),
                    x: Math.max(Math.min(1 / i, 1), .7),
                    z: Math.max(Math.min(1 / i, 1), .7)
                }), s.customAnimation.to(this.body.scale, .1, {
                    y: Math.min(.9 / i, .7),
                    x: Math.max(i, 1.2),
                    z: Math.max(i, 1.2),
                    delay: .1
                }), s.customAnimation.to(this.body.scale, .3, {
                    y: 1,
                    x: 1,
                    z: 1,
                    delay: .2
                })) : (s.customAnimation.to(this.human.rotation, .14, {x: this.human.rotation.x - Math.PI}), s.customAnimation.to(this.human.rotation, .18, {
                    x: this.human.rotation.x - 2 * Math.PI,
                    delay: .14
                }), s.customAnimation.to(this.head.position, .1, {
                    y: this.head.position.y + .9 * i,
                    z: this.head.position.z - .45 * i
                }), s.customAnimation.to(this.head.position, .1, {
                    z: this.head.position.z + .45 * i,
                    y: this.head.position.y - .9 * i,
                    delay: .1
                }), s.customAnimation.to(this.head.position, .15, {
                    y: 4.725,
                    z: 0,
                    delay: .25
                }), s.customAnimation.to(this.body.scale, .05, {
                    y: Math.max(i, 1),
                    x: Math.max(Math.min(1 / i, 1), .7),
                    z: Math.max(Math.min(1 / i, 1), .7)
                }), s.customAnimation.to(this.body.scale, .05, {
                    y: Math.min(.9 / i, .7),
                    x: Math.max(i, 1.2),
                    z: Math.max(i, 1.2),
                    delay: .1
                }), s.customAnimation.to(this.body.scale, .2, {y: 1, x: 1, z: 1, delay: .2}))
            }
        }, {
            key: "showup", value: function () {
                this.status = "showup", this.obj.position.y = 25, this.human.rotation.x = this.human.rotation.z = 0, (0, s.TweenAnimation)(this.obj.position.y, e.BLOCK.height / 2, 500, "Bounce.easeOut", function (t, i) {
                    void 0 !== t && (this.obj.position.y = t, i && (this.status = "stop"))
                }.bind(this))
            }
        }, {
            key: "stopPrepare", value: function () {
                this.obj.position.y = e.BLOCK.height / 2, this.stop(), this.body.scale.set(1, 1, 1), this.head.position.y = 4.725, this.head.position.x = 0, this.resetParticles()
            }
        }, {
            key: "getBox", value: function () {
                return [(new o.Box3).setFromObject(this.head), (new o.Box3).setFromObject(this.middle), (new o.Box3).setFromObject(this.bottom)]
            }
        }, {
            key: "reset", value: function (t) {
                this.stop(), this.obj.position.y = e.BLOCK.height / 2, this.obj.position.x = this.obj.position.z = 0, this.obj.rotation.z = 0, this.obj.rotation.y = 0, this.obj.rotation.x = 0, this.bottle.rotation.y = 0, this.bottle.rotation.z = 0, this.bottle.rotation.x = 0, this.body && this.head && (this.body.scale.set(1, 1, 1), this.body.rotation.z = this.body.rotation.x = this.body.rotation.y = 0, this.head.position.y = 4.725, this.head.position.x = 0, this.human.rotation.y = this.human.rotation.z = this.human.rotation.x = 0), t || (this.direction = "straight"), this.jumpStatus = "init", this.double = 1, this.resetParticles(), this.scoreText.obj.visible = !1, this.destination = []
            }
        }]), a
    }();
    exports.default = a;
});
define("js/config.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0}), exports.EVENT = exports.USEMMPAYBASE = exports.USEWANGZHEBASE = exports.SUBVERSION = exports.VERSION = exports.REPORTERTIMEOUT = exports.loader = exports.FRUSTUMSIZE = exports.BLOCK = exports.AUDIO = exports.CAMERA = exports.WAVE = exports.GAME = exports.PARTICLE = exports.BOTTLE = exports.COLORS = void 0;
    var E = function (E) {
        if (E && E.__esModule) return E;
        var e = {};
        if (null != E) for (var R in E) Object.prototype.hasOwnProperty.call(E, R) && (e[R] = E[R]);
        return e.default = E, e
    }(require("./lib/three")), e = (exports.COLORS = {
        red: 13387325,
        pureRed: 16711680,
        white: 14209233,
        brown: 5845806,
        pink: 15964855,
        brownDark: 2300175,
        blue: 40951,
        yellow: 16760320,
        pureWhite: 16777215,
        orange: 16231020,
        orangeDark: 16747520,
        black: 0,
        cream: 16119285,
        green: 2924391,
        lightBlue: 13758190,
        cyan: 9692366,
        yellowBrown: 16764811,
        purple: 9083606
    }, exports.BOTTLE = {
        headRadius: .945,
        bodyWidth: 2.34,
        bodyDepth: 2.34,
        bodyHeight: 3.2,
        reduction: .005,
        minScale: .5,
        velocityYIncrement: 15,
        velocityY: 135,
        velocityZIncrement: 70
    }), R = (exports.PARTICLE = {radius: .3, detail: 2}, exports.GAME = {
        BOTTOMBOUND: -55,
        TOPBOUND: 41,
        gravity: 720,
        touchmoveTolerance: 20,
        LEFTBOUND: -140,
        topTrackZ: -30,
        rightBound: 90,
        HEIGHT: window.innerHeight || 736,
        WIDTH: window.innerWidth || 414,
        canShadow: !0
    });
    exports.WAVE = {
        innerRadius: 2.2,
        outerRadius: 3,
        thetaSeg: 25
    }, exports.CAMERA = {fov: 60}, exports.AUDIO = {
        success: "res/success.mp3",
        perfect: "res/perfect.mp3",
        scale_loop: "res/scale_loop.mp3",
        scale_intro: "res/scale_intro.mp3",
        restart: "res/start.mp3",
        fall: "res/fall.mp3",
        fall_2: "res/fall_2.mp3",
        combo1: "res/combo1.mp3",
        combo2: "res/combo2.mp3",
        combo3: "res/combo3.mp3",
        combo4: "res/combo4.mp3",
        combo5: "res/combo5.mp3",
        combo6: "res/combo6.mp3",
        combo7: "res/combo7.mp3",
        combo8: "res/combo8.mp3",
        icon: "res/icon.mp3",
        pop: "res/pop.mp3",
        sing: "res/sing.mp3",
        store: "res/store.mp3",
        water: "res/water.mp3",
        pay: "res/wechat_pay.mp3",
        luban: "res/luban.mp3",
        relax: "res/relax.mp3"
    }, exports.BLOCK = {
        radius: 5,
        width: 10,
        minRadiusScale: .8,
        maxRadiusScale: 1,
        height: 5.5,
        radiusSegments: [4, 50],
        floatHeight: 0,
        minDistance: 1,
        maxDistance: 17,
        minScale: e.minScale,
        reduction: e.reduction,
        moveDownVelocity: .07,
        fullHeight: 5.5 / 21 * 40
    }, exports.FRUSTUMSIZE = R.HEIGHT / R.WIDTH / 736 * 414 * 60, exports.loader = new E.TextureLoader, exports.REPORTERTIMEOUT = 60001, exports.VERSION = 3, exports.SUBVERSION = "3.1.1", exports.USEWANGZHEBASE = 1, exports.USEMMPAYBASE = 1, exports.EVENT = {
        RELAYCREATEROOM: "relayCreateRoom",
        JOINRELAYROOM: "JOINRELAYROOM",
        PEOPLECOME: "PEOPLECOME",
        PEOPLEOUT: "PEOPLEOUT",
        RELAYSTART: "RELAYSTART",
        NOWPLAYERJUMP: "NOWPLAYERJUMP",
        CHECKUSER: "CHECKUSER",
        RELAYCHECKUSER: "RELAYCHECKUSER",
        RUNGAME: "RUNGAME",
        ENDGAME: "ENDGAME",
        PLAYERDIED: "PLAYERDIED",
        NOWPLAYEROVER: "NOWPLAYEROVER",
        RECEIVEMINICODE: "RECEIVEMINICODE",
        GOSTARTPAGE: "GOSTARTPAGE",
        GOTOSINGLESTARTPAGE: "GOTOSINGLESTARTPAGE",
        REPLAYAGAIN: "REPLAYAGAIN",
        SYNCMSGSEQ: "SYNCMSGSEQ",
        RELAYMODEDESTROY: "RELAYMODEDESTROY",
        SYNCSCENE: "SYNCSCENE",
        WATCHRELAY: "WATCHRELAY",
        CHECK_GAME: "CHECK_GAME",
        SEND_CHECK_GAME: "SEND_CHECK_GAME",
        PROGRESSOVER: "PROGRESSOVER",
        CHANGEGAMELEVEL: "CHANGEGAMELEVEL",
        RECEIVEGAMELEVELCHANGE: "RECEIVEGAMELEVELCHANGE",
        SHOW_RELAY_GUIDE: "SHOW_RELAY_GUIDE",
        SKIP_RELAY_GUIDE: "SKIP_RELAY_GUIDE",
        CREATE_RELAY_ROOM_FAIL: "CREATE_RELAY_ROOM_FAIL",
        RP_JOIN_RELAY_ROOM_AGAIN: "RP_JOIN_RELAY_ROOM_AGAIN",
        RP_JOIN_RELAY_ROOM: "RP_JOIN_RELAY_ROOM",
        RP_RELAY_START: "RP_RELAY_START",
        ORDERRUNGAME: "ORDERRUNGAME",
        RP_RELAY_GAME_END: "RP_RELAY_GAME_END",
        GETRELAYQR: "GETRELAYQR",
        GETRELAYCHECKUSERERROR: "GETRELAYCHECKUSERERROR",
        INITRESPONSE: "INITRESPONSE",
        TRIGGER_EGG: "TRIGGER_EGG"
    };
});
define("js/control/battleCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var a = function () {
            function e(e, t) {
                for (var a = 0; a < t.length; a++) {
                    var i = t[a];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }

            return function (t, a, i) {
                return a && e(t.prototype, a), i && e(t, i), t
            }
        }(), i = e(require("../pages/battle/battlePkPage")), o = e(require("../pages/battle/battleGamePage")),
        n = e(require("../network/network")), r = function () {
            function e(a, n) {
                t(this, e), this.name = "battlePage", this.game = a, this.gameCtrl = this.game.gameCtrl, this.model = this.game.gameModel, this.view = this.game.gameView, this.modeCtrl = n, this.netWorkCtrl = this.gameCtrl.netWorkCtrl, this.currentPage = null, this.pkPage = new i.default(a), this.gamePage = new o.default(a), this.shareTicket = "", this.pkId = "", this.shareInfoTimeout = null, this.battleScore = void 0
            }

            return a(e, [{
                key: "init", value: function (e) {
                    var t = this.model.getSessionId();
                    this.shareTicket = e.shareTicket, this.pkId = e.query.pkId, this.model.setStage(""), wx.showLoading(), t ? this.afterLogin(!0) : this.netWorkCtrl.netWorkLogin(this.afterLogin.bind(this))
                }
            }, {
                key: "afterLogin", value: function (e) {
                    var t = this;
                    e ? (this.setShareInfoTimeout(), wx.getShareInfo({
                        shareTicket: this.shareTicket, success: function (e) {
                            null != t.shareInfoTimeout && (t.clearShareInfoTimeout(), t.model.setShareTicket(e.rawData), t.gotoBattlePage(), t.gameCtrl.loginBattle(1))
                        }, fail: function (e) {
                            null != t.shareInfoTimeout && (t.clearShareInfoTimeout(), t.gotoBattlePage(), t.gameCtrl.loginBattle(0))
                        }
                    })) : this.goToBattleFail()
                }
            }, {
                key: "gotoBattlePage", value: function () {
                    n.default.getBattleData(this.gotoBattlePageAfterHaveData.bind(this), this.pkId)
                }
            }, {
                key: "gotoBattlePageAfterHaveData", value: function (e, t) {
                    if (wx.hideLoading(), e) {
                        var a = [];
                        t.data.challenger.length && t.data.challenger.forEach(function (e) {
                            a.push({
                                headimg: e.headimg,
                                is_self: e.is_self ? 1 : 0,
                                nickname: e.nickname,
                                score_info: [{score: e.score}]
                            })
                        }, this), a.sort(function (e, t) {
                            return t.score_info[0].score - e.score_info[0].score
                        });
                        var i = {
                            organizerInfo: {
                                headimg: t.data.owner.headimg,
                                nickname: t.data.owner.nickname,
                                score_info: [{score: t.data.owner.score}],
                                left_time: t.data.left_time,
                                is_self: t.data.is_owner ? 1 : 0
                            }, pkListInfo: a, gg_score: this.battleScore
                        };
                        this.currentPage && this.currentPage.hide(), this.pkPage.show(i), this.model.setStage(this.pkPage.name), this.currentPage = this.pkPage, this.gameCtrl.showPkPage(t.data.owner.score)
                    } else this.goToBattleFail()
                }
            }, {
                key: "goToBattleFail", value: function () {
                    this.view.showGoToBattleFail(), this.modeCtrl.changeMode("singleCtrl")
                }
            }, {
                key: "setShareInfoTimeout", value: function () {
                    this.shareInfoTimeout = setTimeout(this.handleShareInfoTimeout.bind(this), 5e3)
                }
            }, {
                key: "clearShareInfoTimeout", value: function () {
                    null != this.shareInfoTimeout && (clearTimeout(this.shareInfoTimeout), this.shareInfoTimeout = null)
                }
            }, {
                key: "handleShareInfoTimeout", value: function () {
                    this.clearShareInfoTimeout(), this.goToBattleFail()
                }
            }, {
                key: "destroy", value: function () {
                    this.currentPage && this.currentPage.hide(), this.model.setStage(""), wx.hideLoading(), this.shareTicket = "", this.pkId = "", this.clearShareInfoTimeout(), this.model.clearShareTicket(), this.game.resetScene(), this.battleScore = void 0
                }
            }, {
                key: "battlePlay", value: function (e) {
                    e ? (this.currentPage && this.currentPage.hide(), this.gamePage.show(), this.game.replayGame(), this.model.setStage(this.gamePage.name), this.currentPage = this.gamePage) : (this.modeCtrl.directPlaySingleGame(), this.gameCtrl.battleToSingle())
                }
            }, {
                key: "showGameOverPage", value: function () {
                    this.currentPage && this.currentPage.hide(), this.model.setStage(""), this.currentPage = null;
                    var e = this.model.currentScore;
                    this.battleScore = e, wx.showLoading(), n.default.updatepkinfo(this.gotoBattlePageAgain.bind(this), this.pkId, e)
                }
            }, {
                key: "gotoBattlePageAgain", value: function (e) {
                    e || this.view.showUploadPkScoreFail(), this.gotoBattlePage()
                }
            }, {
                key: "wxOnhide", value: function () {
                }
            }]), e
        }();
    exports.default = r;
});
define("js/control/groupShareCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var o = t[i];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
            }
        }

        return function (t, i, o) {
            return i && e(t.prototype, i), o && e(t, o), t
        }
    }(), o = e(require("../pages/group/groupPage")), r = e(require("../network/network")), a = function () {
        function e(i, r) {
            t(this, e), this.name = "groupShare", this.game = i, this.gameCtrl = this.game.gameCtrl, this.model = this.game.gameModel, this.view = this.game.gameView, this.netWorkCtrl = this.gameCtrl.netWorkCtrl, this.modeCtrl = r, this.groupPage = new o.default(i), this.shareTicket = "", this.shareInfoTimeout = null
        }

        return i(e, [{
            key: "init", value: function (e) {
                var t = this.model.getServerConfig();
                if (t && !t.group_score_switch) return this.view.showServeConfigForbiddenGroupShare(), void this.modeCtrl.changeMode("singleCtrl");
                this.model.setStage("");
                var i = this.model.getSessionId();
                this.shareTicket = e.shareTicket, wx.showLoading(), i ? this.afterLogin(!0) : this.netWorkCtrl.netWorkLogin(this.afterLogin.bind(this))
            }
        }, {
            key: "afterLogin", value: function (e) {
                var t = this;
                e ? (this.setShareInfoTimeout(), wx.getShareInfo({
                    shareTicket: this.shareTicket, success: function (e) {
                        null != t.shareInfoTimeout && (t.clearShareInfoTimeout(), t.model.setShareTicket(e.rawData), r.default.getGroupScore(function (e, i) {
                            if (e) {
                                var o = i.data.user_info || [], r = i.data.my_user_info || {};
                                t.model.setStage(o, r), t.showGroupRankPage(o, r)
                            } else t.goToGroupShareFail();
                            wx.hideLoading()
                        }))
                    }, fail: function (e) {
                        null != t.shareInfoTimeout && (t.clearShareInfoTimeout(), wx.hideLoading(), t.goToGroupShareFail("~"))
                    }
                })) : (wx.hideLoading(), this.goToGroupShareFail())
            }
        }, {
            key: "setShareInfoTimeout", value: function () {
                this.shareInfoTimeout = setTimeout(this.handleShareInfoTimeout.bind(this), 5e3)
            }
        }, {
            key: "clearShareInfoTimeout", value: function () {
                null != this.shareInfoTimeout && (clearTimeout(this.shareInfoTimeout), this.shareInfoTimeout = null)
            }
        }, {
            key: "handleShareInfoTimeout", value: function () {
                this.clearShareInfoTimeout(), this.goToGroupShareFail()
            }
        }, {
            key: "goToGroupShareFail", value: function (e) {
                this.view.showGroupShareFail(e), this.modeCtrl.changeMode("singleCtrl")
            }
        }, {
            key: "showGroupRankPage", value: function (e, t) {
                var i = this.model.getGroupRankData(), o = void 0, r = void 0;
                if (i && (o = i.list, r = i.userInfo), void 0 !== e && void 0 !== t) this.model.setGroupRankData(e, t); else {
                    if (void 0 === o || void 0 === r) throw new Error("showGroupRankPagelistmyUserInfo");
                    e = o, t = r
                }
                this.groupPage.show(e.concat([]), t), this.model.setStage(this.groupPage.name), this.currentPage = this.groupPage
            }
        }, {
            key: "destroy", value: function () {
                wx.hideLoading(), this.currentPage && this.currentPage.hide(), this.model.setStage(""), this.shareTicket = "", this.model.clearShareTicket(), this.clearShareInfoTimeout(), this.game.resetScene()
            }
        }, {
            key: "groupPlayGame", value: function () {
                this.modeCtrl.directPlaySingleGame()
            }
        }, {
            key: "wxOnhide", value: function () {
            }
        }]), e
    }();
    exports.default = a;
});
define("js/control/instructionCtrl.js", function (require, module, exports) {
    "use strict";

    function t(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var e = function () {
        function t(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        return function (e, i, n) {
            return i && t(e.prototype, i), n && t(e, n), e
        }
    }(), i = function () {
        function i(e) {
            t(this, i), this.game = e, this.commandList = [], this.isRunning = !1, this.icTimeout = null, this.cmdHandler = function () {
            }, this.gameId = 0, this.seq = 0, this.currentSeq = null, this.waited = !1
        }

        return e(i, [{
            key: "onReceiveCommand", value: function (t, e) {
                t._seq = e, this.gameId != this.game.gameCtrl.modeCtrl.observeCtrl.gameId && (this.gameId = this.game.gameCtrl.modeCtrl.observeCtrl.gameId, this.seq = e - 1);
                var i = e - this.seq;
                if (1 != i) {
                    var n;
                    i > 1 && (n = 0), i < 1 && (n = 1), this.game.sendServerError(n), this.game.socketFirstSync = !0
                }
                this.seq = e, (!this.currentSeq || e > this.currentSeq) && (this.commandList.push(t), this.commandList.sort(function (t, e) {
                    return t._seq - e._seq
                }), this.checkRunningState())
            }
        }, {
            key: "checkRunningState", value: function () {
                this.isRunning || this.runCommand()
            }
        }, {
            key: "runCommand", value: function () {
                var t = this, e = this.commandList[0];
                if (e) if (this.isRunning = !0, !this.currentSeq || this.currentSeq && e._seq - this.currentSeq == 1) this.waited = !1, this.currentSeq = e._seq, this.commandList.shift(), this.cmdHandler(e); else if (e._seq - this.currentSeq > 1) {
                    if (this.waited) return this.waited = !1, this.currentSeq = e._seq, this.commandList.shift(), void this.cmdHandler(e);
                    this.waited = !0, this.timer = setTimeout(function () {
                        t.runCommand()
                    }, 100)
                }
            }
        }, {
            key: "bindCmdHandler", value: function (t) {
                this.cmdHandler = t
            }
        }, {
            key: "onCmdComplete", value: function () {
                this.commandList.length ? this.runCommand() : this.isRunning = !1
            }
        }, {
            key: "destroy", value: function () {
                this.timer && (clearTimeout(this.timer), this.timer = null), this.commandList = [], this.gameId = 0, this.seq = 0, this.currentSeq = null, this.waited = !1, this.icTimeout && clearTimeout(this.icTimeout), this.icTimeout = null, this.isRunning = !1
            }
        }]), i
    }();
    exports.default = i;
});
define("js/control/modeCtrl.js", function (require, module, exports) {
    "use strict";

    function t(t) {
        return t && t.__esModule ? t : {default: t}
    }

    function r(t, r) {
        if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var e = function () {
            function t(t, r) {
                for (var e = 0; e < r.length; e++) {
                    var n = r[e];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }

            return function (r, e, n) {
                return e && t(r.prototype, e), n && t(r, n), r
            }
        }(), n = t(require("./singleCtrl")), l = t(require("./groupShareCtrl")), i = t(require("./battleCtrl")),
        s = t(require("./observeCtrl")), a = t(require("./playerCtrl")), u = t(require("./relayCtrl")),
        h = t(require("../lib/mue/eventcenter")), c = require("../config"), o = function () {
            function t(e) {
                r(this, t), this.game = e, this.singleCtrl = new n.default(e, this), this.groupShareCtrl = new l.default(e, this), this.battleCtrl = new i.default(e, this), this.observeCtrl = new s.default(e, this), this.playerCtrl = new a.default(e, this), this.relayCtrl = new u.default(e, this), this.model = e.gameModel, this.gameCtrl = e.gameCtrl, this.currentCtrl = null, h.default.on(c.EVENT.GOSTARTPAGE, this.goToSingleStartPage.bind(this))
            }

            return e(t, [{
                key: "initFirstPage", value: function (t) {
                    switch (this.model.getMode()) {
                        case"single":
                            this.currentCtrl = this.singleCtrl, this.singleCtrl.init(t), this.gameCtrl.netWorkLogin();
                            break;
                        case"groupShare":
                            this.currentCtrl = this.groupShareCtrl, this.groupShareCtrl.init(t);
                            break;
                        case"battle":
                            this.currentCtrl = this.battleCtrl, this.battleCtrl.init(t);
                            break;
                        case"observe":
                            this.currentCtrl = this.observeCtrl, this.observeCtrl.init(t);
                            break;
                        case"relay":
                            this.currentCtrl = this.relayCtrl, this.currentCtrl.init(t);
                            break;
                        default:
                            this.currentCtrl = this.singleCtrl, this.model.setMode("single"), this.singleCtrl.init(t), this.gameCtrl.netWorkLogin()
                    }
                }
            }, {
                key: "reInitFirstPage", value: function (t) {
                    var r = this;
                    this.currentCtrl && (this.currentCtrl.destroy(), this.gameCtrl.reviewCtrl.destroy(), this.currentCtrl = null), this.gameCtrl.queryCtrl.identifyMode(t), setTimeout(function () {
                        r.initFirstPage(t)
                    }, 500)
                }
            }, {
                key: "clickStart", value: function () {
                    this.currentCtrl && this.currentCtrl.clickStart && this.currentCtrl.clickStart()
                }
            }, {
                key: "showGameOverPage", value: function (t) {
                    this.currentCtrl && this.currentCtrl.showGameOverPage && this.currentCtrl.showGameOverPage(t)
                }
            }, {
                key: "gameOverClickReplay", value: function () {
                    this.currentCtrl && (this.currentCtrl.gameOverClickReplay ? this.currentCtrl.gameOverClickReplay() : this.game.handleWxOnError({
                        message: "cannot Find this.currentCtrl.gameOverClickReplay",
                        stack: this.game.mode + "" + this.game.stage
                    }))
                }
            }, {
                key: "showFriendRank", value: function (t) {
                    this.currentCtrl && this.currentCtrl.showFriendRank && this.currentCtrl.showFriendRank(t)
                }
            }, {
                key: "friendRankReturn", value: function () {
                    this.currentCtrl && this.currentCtrl.friendRankReturn && this.currentCtrl.friendRankReturn()
                }
            }, {
                key: "shareGroupRank", value: function () {
                    this.currentCtrl && this.currentCtrl.shareGroupRank && this.currentCtrl.shareGroupRank()
                }
            }, {
                key: "showGroupRankPage", value: function () {
                    this.currentCtrl && this.currentCtrl.showGroupRankPage && this.currentCtrl.showGroupRankPage()
                }
            }, {
                key: "clickRank", value: function () {
                    this.currentCtrl && this.currentCtrl.clickRank && this.currentCtrl.clickRank()
                }
            }, {
                key: "shareBattleCard", value: function () {
                    this.currentCtrl && this.currentCtrl.shareBattleCard && this.currentCtrl.shareBattleCard()
                }
            }, {
                key: "changeMode", value: function (t) {
                    this.currentCtrl && this.currentCtrl.destroy && (this.currentCtrl.destroy(), this.gameCtrl.reviewCtrl.destroy()), this.model.setMode(this[t].name), this.currentCtrl = this[t], "singleCtrl" === t && h.default.emit(c.EVENT.GOTOSINGLESTARTPAGE, {}), this[t].init()
                }
            }, {
                key: "singleChangeToPlayer", value: function () {
                    this.model.setMode(this.playerCtrl.name), this.currentCtrl = this.playerCtrl, this.playerCtrl.init()
                }
            }, {
                key: "groupPlayGame", value: function () {
                    this.currentCtrl && this.currentCtrl.groupPlayGame && this.currentCtrl.groupPlayGame()
                }
            }, {
                key: "directPlaySingleGame", value: function () {
                    this.currentCtrl && this.currentCtrl.destroy(), this.model.setMode(this.singleCtrl.name), this.currentCtrl = this.singleCtrl, this.singleCtrl.clickStart()
                }
            }, {
                key: "battlePlay", value: function (t) {
                    this.currentCtrl && this.currentCtrl.battlePlay && this.currentCtrl.battlePlay(t)
                }
            }, {
                key: "shareObservCard", value: function () {
                    this.currentCtrl && this.currentCtrl.shareObservCard && this.currentCtrl.shareObservCard()
                }
            }, {
                key: "socketJoinSuccess", value: function (t) {
                    this.currentCtrl && this.currentCtrl.socketJoinSuccess && this.currentCtrl.socketJoinSuccess(t)
                }
            }, {
                key: "showPlayerGG", value: function (t) {
                    this.currentCtrl && this.currentCtrl.showPlayerGG && this.currentCtrl.showPlayerGG(t)
                }
            }, {
                key: "showPlayerWaiting", value: function () {
                    this.currentCtrl && this.currentCtrl.showPlayerWaiting && this.currentCtrl.showPlayerWaiting()
                }
            }, {
                key: "onPlayerOut", value: function () {
                    this.currentCtrl && (this.currentCtrl.onPlayerOut ? this.currentCtrl.onPlayerOut() : this.game.handleWxOnError({
                        message: "cannot Find this.currentCtrl.onPlayerOut",
                        stack: this.game.mode + "" + this.game.stage
                    }))
                }
            }, {
                key: "onViewerStart", value: function () {
                    this.currentCtrl && this.currentCtrl.onViewerStart && this.currentCtrl.onViewerStart()
                }
            }, {
                key: "appealNotify", value: function () {
                    this.currentCtrl && this.currentCtrl.appealNotify && this.currentCtrl.appealNotify()
                }
            }, {
                key: "onSocketOpen", value: function () {
                    this.currentCtrl && this.currentCtrl.onSocketOpen && this.currentCtrl.onSocketOpen()
                }
            }, {
                key: "gotoRelayMode", value: function () {
                    this.currentCtrl && this.currentCtrl.gotoRelayMode && this.currentCtrl.gotoRelayMode()
                }
            }, {
                key: "outRelay1", value: function () {
                    this.currentCtrl && this.currentCtrl.outRelay1 && this.currentCtrl.outRelay1()
                }
            }, {
                key: "outRelay2", value: function () {
                    this.currentCtrl && this.currentCtrl.outRelay2 && this.currentCtrl.outRelay2()
                }
            }, {
                key: "startRelay", value: function (t) {
                    this.currentCtrl && this.currentCtrl.startRelay && this.currentCtrl.startRelay(t)
                }
            }, {
                key: "watchRelay", value: function () {
                    this.currentCtrl && this.currentCtrl.watchRelay && this.currentCtrl.watchRelay()
                }
            }, {
                key: "replayRelay", value: function () {
                    this.currentCtrl && this.currentCtrl.replayRelay && this.currentCtrl.replayRelay()
                }
            }, {
                key: "shareRelay", value: function () {
                    this.currentCtrl && this.currentCtrl.shareRelay && this.currentCtrl.shareRelay()
                }
            }, {
                key: "onSocketCloseErr", value: function () {
                    this.currentCtrl && this.currentCtrl.onSocketCloseErr && this.currentCtrl.onSocketCloseErr()
                }
            }, {
                key: "goToSingleStartPage", value: function (t) {
                    this.changeMode("singleCtrl")
                }
            }, {
                key: "skipRelayBeginner", value: function () {
                    this.currentCtrl && this.currentCtrl.skipRelayBeginner && this.currentCtrl.skipRelayBeginner()
                }
            }, {
                key: "wxOnShow", value: function () {
                    this.currentCtrl && this.currentCtrl.wxOnShow && this.currentCtrl.wxOnShow()
                }
            }, {
                key: "wxOnhide", value: function () {
                    this.currentCtrl && this.currentCtrl.wxOnhide && this.currentCtrl.wxOnhide()
                }
            }]), t
        }();
    exports.default = o;
});
define("js/control/networkCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, n = function () {
        function e(e, t) {
            var r = [], n = !0, i = !1, o = void 0;
            try {
                for (var a, u = e[Symbol.iterator](); !(n = (a = u.next()).done) && (r.push(a.value), !t || r.length !== t); n = !0) ;
            } catch (e) {
                i = !0, o = e
            } finally {
                try {
                    !n && u.return && u.return()
                } finally {
                    if (i) throw o
                }
            }
            return r
        }

        return function (t, r) {
            if (Array.isArray(t)) return t;
            if (Symbol.iterator in Object(t)) return e(t, r);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }(), i = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (t, r, n) {
            return r && e(t.prototype, r), n && e(t, n), t
        }
    }(), o = e(require("../network/network")), a = e(require("../store/storage")), u = function () {
        function e(r) {
            t(this, e), this.game = r, this.gameCtrl = r.gameCtrl, this.model = r.gameModel, this.loginCb = null, this.serverConfigInterval = null, this.historyTimes = this.game.historyTimes
        }

        return i(e, [{
            key: "netWorkLogin", value: function (e) {
                e && (this.loginCb = e), o.default.requestLogin(this.afterRequestLogin.bind(this))
            }
        }, {
            key: "afterRequestLogin", value: function (e) {
                var t = this;
                this.loginCb && this.loginCb(e);
                var r = o.default.getUserInfo(this.afterGetUserInfo.bind(this));
                r.then(function (e) {
                    e && e.open_id || o.default.sendServerError(6)
                }, function () {
                    o.default.sendServerError(6)
                }), e && (Promise.all([r, o.default.requestFriendsScore(this.updateFriendsScore.bind(this))]).then(function (e) {
                    var r = n(e, 2), i = (r[0], r[1]);
                    i && i.my_user_info && i.my_user_info.playback_id && t.setPlayBackIdTolocalStorage(i.my_user_info)
                }, function () {
                }), this.requestMmpayTimeout(), this.requestServerInit(), this.gameCtrl.onLoginSuccess())
            }
        }, {
            key: "afterGetUserInfo", value: function (e) {
                e.appeal_notify && this.gameCtrl.appealNotify()
            }
        }, {
            key: "requestServerInit", value: function () {
                o.default.requestInit(), this.serverConfigInterval = setInterval(o.default.requestInit.bind(o.default), 6e4)
            }
        }, {
            key: "requestMmpayTimeout", value: function () {
                function e() {
                    o.default.requestMmpayBonus(function (e, n) {
                        e && n.data.svr_time ? 0 == n.data.pay_status.status ? (n.data.pay_status.expire_time < r && (n.data.pay_status.expire_time = r), a.default.setMmpayBonusStatus(n.data.pay_status, n.data.svr_time), t.mmpayTimeout = setTimeout(t.requestMmpayTimeout.bind(t), 1e3 * n.data.pay_status.expire_time)) : 1 == n.data.pay_status.status && a.default.setMmpayBonusStatus(n.data.pay_status, n.data.svr_time) : t.mmpayTimeout = setTimeout(t.requestMmpayTimeout.bind(t), 1e3 * r)
                    })
                }

                var t = this, r = 120;
                this.clearMmpayTimeout();
                var n = a.default.getMmpayBonusStatus();
                n ? 1 == n.status || 0 == n.status && e() : e()
            }
        }, {
            key: "clearMmpayTimeout", value: function () {
                this.mmpayTimeout && (clearTimeout(this.mmpayTimeout), this.mmpayTimeout = null)
            }
        }, {
            key: "clearServerInit", value: function () {
                this.serverConfigInterval && clearInterval(this.serverConfigInterval)
            }
        }, {
            key: "upDateFriendsScoreList", value: function () {
                var e = this;
                this.model.getSessionId() && o.default.requestFriendsScore(function () {
                    e.updateFriendsScore2.bind(e).apply(void 0, arguments)
                })
            }
        }, {
            key: "updateUserInfo", value: function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                }, t = a.default.getMyUserInfo();
                "object" == (void 0 === t ? "undefined" : r(t)) && t.open_id || o.default.getUserInfo(e.bind(this)).then(function () {
                }, function () {
                })
            }
        }, {
            key: "updateFriendsScore", value: function (e, t) {
                if (e && (t.user_info.sort(function (e, t) {
                        return -(e.week_best_score || 0) + (t.week_best_score || 0)
                    }), this.model.saveFriendsScore(t.user_info), t.my_user_info)) {
                    var r = t.my_user_info.history_best_score || 0;
                    this.model.saveHeighestScore(r);
                    var n = t.my_user_info.week_best_score || 0;
                    this.model.weekBestScore = n, this.model.saveWeekBestScore(n);
                    var i = t.my_user_info.times;
                    this.historyTimes.verifyScore(i), t && t.my_user_info && this.setPlayBackIdTolocalStorage(t.my_user_info)
                }
            }
        }, {
            key: "setPlayBackIdTolocalStorage", value: function (e) {
                try {
                    var t = a.default.getMyUserInfo();
                    "object" == (void 0 === t ? "undefined" : r(t)) && e && e.playback_id && a.default.saveMyUserInfo(Object.assign(t, {playback_id: e.playback_id}))
                } catch (e) {
                }
            }
        }, {
            key: "updateFriendsScore2", value: function (e, t) {
                e && (t.user_info.sort(function (e, t) {
                    return -(e.week_best_score || 0) + (t.week_best_score || 0)
                }), this.model.saveFriendsScore(t.user_info))
            }
        }, {
            key: "uploadScore", value: function (e) {
                o.default.requestSettlement(e)
            }
        }, {
            key: "requestSettlement", value: function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {
                    }, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                o.default.requestSettlement(e, t, r, n)
            }
        }, {
            key: "requestLogin", value: function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                };
                o.default.requestLogin(e)
            }
        }, {
            key: "sendServerError", value: function () {
                o.default.sendServerError(2)
            }
        }, {
            key: "createRouterId", value: function (e) {
                o.default.createRouterId(e)
            }
        }]), e
    }();
    exports.default = u;
});
define("js/control/observeCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
            function e(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var a = t[i];
                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a)
                }
            }

            return function (t, i, a) {
                return i && e(t.prototype, i), a && e(t, a), t
            }
        }(), a = e(require("../pages/observe/observeWaiting")), s = e(require("../pages/observe/observeGg")),
        n = e(require("../pages/observe/observeOut")), o = e(require("../network/network")), r = function () {
            function e(i, o) {
                t(this, e), this.game = i, this.name = "observe", this.gameCtrl = this.game.gameCtrl, this.model = this.game.gameModel, this.view = this.game.gameView, this.modeCtrl = o, this.netWorkCtrl = this.gameCtrl.netWorkCtrl, this.gameSocket = this.game.gameSocket, this.currentPage = null, this.waitingPage = new a.default(i), this.ggPage = new s.default(i), this.outPage = new n.default(i), this.gameId = "", this.longTimeout = null
            }

            return i(e, [{
                key: "init", value: function (e) {
                    var t = this.model.getServerConfig();
                    if (t && !t.audience_mode_switch) return this.view.showServeConfigForbiddenObserveMode(), void this.modeCtrl.changeMode("singleCtrl");
                    this.model.setStage("");
                    var i = this.model.getSessionId();
                    this.gameId = e.query.gameId, this.model.setObserveInfo({
                        headimg: e.query.headimg,
                        nickName: e.query.nickName
                    }), this.model.setGameId(this.gameId), wx.showLoading(), i ? this.afterLogin(!0) : this.netWorkCtrl.netWorkLogin(this.afterLogin.bind(this))
                }
            }, {
                key: "afterLogin", value: function (e) {
                    e ? (this.setLongTimeHandle(), this.gameSocket.connectSocket(), this.model.setStage("")) : this.goToObserveStateFail()
                }
            }, {
                key: "socketJoinSuccess", value: function (e) {
                    this.clearLongTimeHandle(), wx.hideLoading(), e ? (this.waitingPage.show(), this.model.setStage(this.waitingPage.name), this.currentPage = this.waitingPage, this.game.UI.setScore(0), this.checkPlayerTimeout = setInterval(this.checkPlayerState.bind(this), 1e4)) : this.showPlayerDead()
                }
            }, {
                key: "goToObserveStateFail", value: function () {
                    this.view.showObserveStateFail(), this.modeCtrl.changeMode("singleCtrl")
                }
            }, {
                key: "setLongTimeHandle", value: function () {
                    this.longTimeout = setTimeout(this.handleLongTime.bind(this), 9e3)
                }
            }, {
                key: "handleLongTime", value: function () {
                    this.goToObserveStateFail()
                }
            }, {
                key: "clearLongTimeHandle", value: function () {
                    null != this.longTimeout && (clearTimeout(this.longTimeout), this.longTimeout = null)
                }
            }, {
                key: "showPlayerDead", value: function () {
                    this.gameSocket.close(), this.clearCheckPlayerTimeout(), this.currentPage && this.currentPage.hide(), this.outPage.show(), this.model.setStage(this.outPage.name), this.currentPage = this.outPage
                }
            }, {
                key: "checkPlayerState", value: function () {
                    o.default.syncop(this.judgePlayerState.bind(this))
                }
            }, {
                key: "judgePlayerState", value: function (e, t) {
                    e ? 0 != t.data.state && (this.clearCheckPlayerTimeout(), this.showPlayerDead()) : this.handleSyncopErr()
                }
            }, {
                key: "handleSyncopErr", value: function () {
                    this.view.showSyncopErr(), this.goToObserveStateFail()
                }
            }, {
                key: "clearCheckPlayerTimeout", value: function () {
                    null != this.checkPlayerTimeout && (clearInterval(this.checkPlayerTimeout), this.checkPlayerTimeout = null)
                }
            }, {
                key: "destroy", value: function () {
                    this.currentPage && this.currentPage.hide(), this.currentPage = null, this.model.setStage(""), this.model.clearGameId(), this.clearLongTimeHandle(), this.clearCheckPlayerTimeout(), wx.hideLoading(), this.gameSocket.alive && this.gameSocket.close(), this.model.clearObserveInfo(), this.game.instructionCtrl.destroy(), this.game.deadTimeout && (clearTimeout(this.game.deadTimeout), this.game.deadTimeout = null), this.game.pendingReset = !1, this.game.resetScene()
                }
            }, {
                key: "showPlayerWaiting", value: function () {
                    this.currentPage != this.waitingPage && (null != this.currentPage && this.currentPage.hide(), this.waitingPage.show(), this.model.setStage(this.waitingPage.name), this.currentPage = this.waitingPage)
                }
            }, {
                key: "showPlayerGG", value: function (e) {
                    null != this.currentPage && this.currentPage.hide(), this.ggPage.show(e), this.model.setStage(this.ggPage.name), this.currentPage = this.ggPage
                }
            }, {
                key: "onPlayerOut", value: function () {
                    this.showPlayerDead()
                }
            }, {
                key: "onViewerStart", value: function () {
                    this.gameSocket.quitObserve(), this.game.instructionCtrl.destroy(), this.modeCtrl.directPlaySingleGame()
                }
            }, {
                key: "showGameOverPage", value: function () {
                }
            }, {
                key: "wxOnhide", value: function () {
                    this.clearCheckPlayerTimeout(), this.gameSocket.quitObserve(), this.gameSocket.close(), this.game.resetScene()
                }
            }, {
                key: "wxOnshow", value: function () {
                }
            }]), e
        }();
    exports.default = r;
});
define("js/control/onebyoneCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
            function e(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var a = t[i];
                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a)
                }
            }

            return function (t, i, a) {
                return i && e(t.prototype, i), a && e(t, a), t
            }
        }(), a = e(require("../lib/mue/eventcenter")), n = e(require("../pages/headimgAnimation")),
        o = require("../config"), s = require("../lib/animation"), m = function () {
            function e(i, a) {
                t(this, e), this.game = i, this.camera = a, this.waitingList = [], this.playerOver = !0, this.bindEvent(), this.touchendList = [], this.speedTouchEndList = []
            }

            return i(e, [{
                key: "isDied", value: function () {
                    if (this.data) for (var e = 0, t = this.data.playerlist.length; e < t; ++e) if (this.data.playerlist[e].seat_no == this.data.my_seat_no) return this.data.playerlist[e].rank > 0
                }
            }, {
                key: "bindEvent", value: function () {
                    var e = this;
                    a.default.on(o.EVENT.RELAYSTART, function (t, i) {
                        e.game.resetScene(i.room_seed, {
                            bottleShowupAnimation: !0,
                            gameLevel: i.game_level
                        }), console.log("resetScene", i.room_seed, {gameLevel: i.game_level}), e.data = i, e.game.myTurn = i.my_seat_no == i.now_player_seat_no, e.game.myTurn && (e.playerOver = !1), console.log(" EVENT.RELAYSTART this.game.myTurn", e.game.myTurn, i.my_seat_no, i.now_player_seat_no)
                    }), a.default.on(o.EVENT.ENDGAME, function (t, i) {
                        console.log("ENDGAME touchList", e.touchendList.length, e.speedTouchEndList.length), e.over = !0
                    }), a.default.on(o.EVENT.RELAYCHECKUSER, function (t, i) {
                        i.my_seat_no != i.now_player_seat_no ? (console.log("in relayCheckUser"), i.msg_info.msginfo = JSON.parse(i.msg_info.msginfo), console.log("xxxx RELAYCHECKUSER", i.my_seat_no, i.now_player_seat_no, i.msg_info.msg_seq, i.msg_info.msg_id), !e.playerOver || e.waitingList.length > 0 ? (i.myType = "checkuser", console.log("push checkuser to waitingList"), e.waitingList.push(i)) : e._play(i)) : e.nowPlayerJump = !1
                    }), a.default.on(o.EVENT.RUNGAME, function (t, i) {
                        if (console.log("ddddddddddd RUNGAME", i.my_seat_no, i.now_player_seat_no, e.playerOver), e.nowPlayerJump) return console.log("RUNGAME check user EORROR", i.my_seat_no, i.now_player_seat_no, e.playerOver), void a.default.emitSync(o.EVENT.GETRELAYCHECKUSERERROR);
                        e.playerOver && e.waitingList.length <= 0 ? (e.game.myTurn = i.my_seat_no == i.now_player_seat_no, e.game.clicked = !1, e.data = i, e.game.myTurn && (e.playerOver = !1), a.default.emit(o.EVENT.ORDERRUNGAME, i)) : (i.myType = "rungame", console.log("push rungame to waitingList"), e.waitingList.push(i)), console.log("EVENT.RUNGAME:", e.game.myTurn, "", i.my_seat_no, "", i.now_player_seat_no)
                    }), a.default.on(o.EVENT.NOWPLAYEROVER, function (t, i) {
                        if (e.playerOver = !0, console.log("in NOWPLAYEROVER data", i), 1 != i.hit && 7 != i.hit && 2 != i.hit && !e.over && e.data && 0 != e.data.my_seat_no && (i.fromProgressOver && !e.game.myTurn || a.default.emitSync(o.EVENT.PLAYERDIED, {
                                player_rank: e.data.playerlist.length - e.data.failer_count,
                                player_count: e.data.playerlist.length,
                                my_seat_no: e.data.my_seat_no,
                                playerlist: e.data.playerlist,
                                now_player_seat_no: e.data.now_player_seat_no
                            })), 0 !== i.hit && 3 !== i.hit && 4 !== i.hit && 5 !== i.hit && 6 !== i.hit || (e.waitingList.length > 0 ? e.game.relayBottleReset({noAnimation: !0}) : e.game.relayBottleReset()), e.game.myTurn || e.over || 0 == i.my_seat_no || i.fromProgressOver || e.isDied() || !e.data || a.default.emitSync(o.EVENT.CHECKUSER, {
                                jump_succ: 1 == i.hit || 7 == i.hit || 2 == i.hit ? 1 : 0,
                                msgid: e.data.msg_info.msgid,
                                msg_seq: e.data.msg_info.msg_seq
                            }), e.waitingList.length > 1) {
                            for (s.TweenAnimation.killAll(), e.game.camera.position.x = e.game.camera.destination[0] || e.game.camera.position.x, e.game.camera.position.z = e.game.camera.destination[1] || e.game.camera.position.z, e.game.camera.destination = [null, null], e.game.bottle.obj.position.x = e.game.bottle.destination[0] || e.game.bottle.obj.position.x, e.game.bottle.obj.position.z = e.game.bottle.destination[1] || e.game.bottle.obj.position.z; e.waitingList.length > 0;) if ("checkuser" == (n = e.waitingList.shift()).myType) e.speedUpPlay(n, {fromWaitingList: !0}); else if ("rungame" == n.myType) {
                                if (!(m = n)) continue;
                                e.game.myTurn = m.my_seat_no == m.now_player_seat_no, e.game.clicked = !1, e.data = m, e.game.myTurn && (e.playerOver = !1), a.default.emitSync(o.EVENT.ORDERRUNGAME, m)
                            }
                        } else if (1 == e.waitingList.length) {
                            var n = e.waitingList.shift();
                            if ("checkuser" == n.myType) e._play(n); else if ("rungame" == n.myType) {
                                var m = n;
                                if (!m) return;
                                e.game.myTurn = m.my_seat_no == m.now_player_seat_no, e.game.clicked = !1, e.data = m, e.game.myTurn && (e.playerOver = !1), a.default.emitSync(o.EVENT.ORDERRUNGAME, m)
                            }
                        }
                    }), a.default.on(o.EVENT.NOWPLAYERJUMP, function () {
                        e.nowPlayerJump = !0
                    }), a.default.on(o.EVENT.SYNCSCENE, function (t, i) {
                        if (console.log("SYNCSCENE"), i && i.serverData) {
                            e.destroy();
                            var a = 0 == i.serverData.my_seat_no;
                            if (e.game.isObserver = a, console.log("syncsene", i.now_msg_seq), console.log("zset", i.serverData.room_seed, i.serverData.game_level), e.game.resetScene(i.serverData.room_seed, {gameLevel: i.serverData.game_level}), i.serverData.msg_list && i.serverData.msg_list.msg_list) for (var n = 0, o = i.serverData.msg_list.msg_list.length; n < o; ++n) i.serverData.msg_list.msg_list[n].msginfo = JSON.parse(i.serverData.msg_list.msg_list[n].msginfo), e.speedUpPlay(i.serverData.msg_list.msg_list[n])
                        }
                    }), a.default.on(o.EVENT.SHOW_RELAY_GUIDE, function (t, i) {
                        console.log("SHOW_RELAY_GUIDE");
                        var a = [{headimg: "res/2d/dog1.jpg", seat_no: 1}, {
                            headimg: "res/2d/dog2.jpg",
                            seat_no: 2
                        }, {headimg: "res/2d/dog3.jpg", seat_no: 3}, {
                            headimg: "res/2d/dog4.jpg",
                            seat_no: 4
                        }, {headimg: "res/2d/dog5.jpg", seat_no: 5}];
                        e.headimgAnimation = new n.default, e.headimgAnimation.set(a, {noEmit: !0}), e.headimgAnimation.obj.position.x = -8.8, e.headimgAnimation.obj.position.y = 20, e.camera.add(e.headimgAnimation.obj), e.headimgTimer = setInterval(function () {
                            e.headimgAnimation.next()
                        }, 4e3), e.game.resetScene(), setTimeout(function () {
                            e.game.loopAnimate()
                        }, 3500)
                    }), a.default.on(o.EVENT.RELAYMODEDESTROY, function () {
                        e.destroy()
                    }), a.default.on(o.EVENT.SKIP_RELAY_GUIDE, function () {
                        e.game.resetScene(), e.headimgTimer && (clearInterval(e.headimgTimer), e.headimgTimer = null), e.camera.remove(e.headimgAnimation.obj)
                    }), a.default.on(o.EVENT.PROGRESSOVER, function () {
                        "jump" != e.game.bottle.status && (e.game.myTurn && (e.game.clicked = !0, e.game.handleInterrupt()), a.default.emitSync(o.EVENT.NOWPLAYEROVER, {fromProgressOver: !0}))
                    })
                }
            }, {
                key: "speedUpPlay", value: function (e, t) {
                    if (!this.over) {
                        this.data = e;
                        var i, a;
                        t && t.fromWaitingList ? (console.log("from waitingList", e, e.msg_info.msginfo.initY, e.msg_info.msginfo.duration), i = e.msg_info.msginfo.initY, a = e.msg_info.msginfo.duration) : (i = e.msginfo.initY, a = e.msginfo.duration), this.speedTouchEndList.push([a, i]);
                        var n = this.game.touchEndAnim(a, i, null, null, {noAnimation: !0});
                        1 == n || 7 == n ? (this.game.succeed({noAnimation: !0}), 1 === n ? (++this.game.doubleHit, this.game.UI.addScore(1, !0, !1)) : (this.game.doubleHit = 0, this.game.UI.addScore(1, !1, !1))) : 2 == n ? (this.game.bottle.obj.position.x = this.game.bottle.destination[0], this.game.bottle.obj.position.z = this.game.bottle.destination[1]) : this.game.relayBottleReset({noAnimation: !0})
                    }
                }
            }, {
                key: "_play", value: function (e, t) {
                    var i = this;
                    if (this.over) console.log("", e, e.msg_seq); else {
                        console.log("", e, e.msg_seq), this.data = e, this.playerOver = !1;
                        var a = e.msg_info.msginfo.initY, n = e.msg_info.msginfo.duration;
                        this.game.touchStartAnim(t), this.jumpTimer = setTimeout(function () {
                            i.touchendList.push([n, a]), i.hit = i.game.touchEndAnim(n, a, null, null)
                        }, 1e3 * n)
                    }
                }
            }, {
                key: "destroy", value: function () {
                    this.touchendList = [], this.speedTouchEndList = [], console.log("destroy relay"), this.over = !1, this.data = null, this.waitingList = [], this.nowPlayerJump = !1, this.playerOver = !0, this.game.clicked = !1, this.game.isObserver = !1, this.jumpTimer && (clearTimeout(this.jumpTimer), this.jumpTimer = null), this.deadTimer && (clearTimeout(this.deadTimer), this.deadTimer = null), this.headimgTimer && (clearInterval(this.headimgTimer), this.headimgTimer = null), this.headimgAnimation && this.camera.remove(this.headimgAnimation.obj)
                }
            }]), e
        }();
    exports.default = m;
});
define("js/control/playerCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    function r(e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || "object" != typeof t && "function" != typeof t ? e : t
    }

    function a(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var o = function () {
            function e(e, t) {
                for (var r = 0; r < t.length; r++) {
                    var a = t[r];
                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a)
                }
            }

            return function (t, r, a) {
                return r && e(t.prototype, r), a && e(t, a), t
            }
        }(), n = function e(t, r, a) {
            null === t && (t = Function.prototype);
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (void 0 === o) {
                var n = Object.getPrototypeOf(t);
                return null === n ? void 0 : e(n, r, a)
            }
            if ("value" in o) return o.value;
            var i = o.get;
            if (void 0 !== i) return i.call(a)
        }, i = e(require("./singleCtrl")), s = require("../shareApp"), l = e(require("../pages/player/playerGamePage")),
        u = e(require("../network/network")), c = function (e) {
            function c(e, a) {
                t(this, c);
                var o = r(this, (c.__proto__ || Object.getPrototypeOf(c)).call(this, e, a));
                return o.name = "player", o.currentPage = null, o.gamePage = new l.default(e), o
            }

            return a(c, i.default), o(c, [{
                key: "init", value: function () {
                    switch (this.model.stage) {
                        case"game":
                            this.currentPage = this.gamePage, this.currentPage.show();
                            break;
                        case"singleSettlementPgae":
                            this.currentPage = this.gameOverPage;
                            break;
                        default:
                            this.model.setStage(this.gamePage.name), this.currentPage = this.gamePage, this.currentPage.show()
                    }
                }
            }, {
                key: "showGameOverPage", value: function (e) {
                    this.game.seq++, this.gameSocket.sendCommand(this.game.seq, {
                        type: -1,
                        s: this.game.currentScore
                    }), n(c.prototype.__proto__ || Object.getPrototypeOf(c.prototype), "showGameOverPage", this).call(this, e)
                }
            }, {
                key: "shareObservCard", value: function () {
                    this.shareObservCardA()
                }
            }, {
                key: "shareObservCardA", value: function () {
                    this.shareObservCardB()
                }
            }, {
                key: "shareObservCardB", value: function () {
                    var e = this;
                    this.model.setStage("loading"), (0, s.shareObserve)(function (t, r) {
                        t && e.gameCtrl.afterShareObserveCard(r), setTimeout(function () {
                            "loading" == e.model.stage && e.model.setStage("game")
                        }, 50)
                    })
                }
            }, {
                key: "gameOverClickReplay", value: function () {
                    n(c.prototype.__proto__ || Object.getPrototypeOf(c.prototype), "gameOverClickReplay", this).call(this), this.game.seq++, this.gameSocket.sendCommand(this.game.seq, {
                        type: 0,
                        seed: this.game.randomSeed
                    })
                }
            }, {
                key: "destroy", value: function () {
                    this.currentPage && this.currentPage.hide(), this.currentPage = null, this.model.setStage(""), this.gameSocket.alive && this.gameSocket.close(), this.model.clearGameId(), this.model.clearGameTicket(), this.game.viewer.reset(), this.game.deadTimeout && (clearTimeout(this.game.deadTimeout), this.game.deadTimeout = null), this.game.pendingReset = !1, this.game.resetScene()
                }
            }, {
                key: "wxOnhide", value: function () {
                    var e = this;
                    "loading" != this.model.stage && "singleSettlementPgae" != this.model.stage && "friendRankList" != this.model.stage && (u.default.quitGame(), this.gameSocket.cleanHeartBeat(), this.gameSocket.close(), setTimeout(function () {
                        e.modeCtrl.changeMode("singleCtrl")
                    }, 100))
                }
            }, {
                key: "wxOnshow", value: function () {
                }
            }]), c
        }();
    exports.default = c;
});
define("js/control/queryCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var i = t[r];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, r, i) {
            return r && e(t.prototype, r), i && e(t, i), t
        }
    }(), r = function () {
        function r(t) {
            e(this, r), this.game = t, this.model = this.game.gameModel, this.gameCtrl = this.game.gameCtrl, this.gameView = this.game.gameView
        }

        return t(r, [{
            key: "identifyMode", value: function (e) {
                if (e.query && e.query.hasOwnProperty("mode")) switch (e.query.mode) {
                    case"groupShare":
                        e.shareTicket ? this.model.setMode("groupShare") : (this.gameCtrl.identifyModeErr(""), this.model.setMode("single"));
                        break;
                    case"battle":
                        e.query.pkId ? this.model.setMode("battle") : (this.gameCtrl.identifyModeErr("PK"), this.model.setMode("single"));
                        break;
                    case"observe":
                        e.query.gameId ? this.model.setMode("observe") : (this.gameCtrl.identifyModeErr(""), this.model.setMode("single"));
                        break;
                    case"relay":
                        e.query.room_id && e.query.router_id && e.query.version ? this.model.setMode("relay") : this.model.setMode("single");
                        break;
                    default:
                        this.model.setMode("single")
                } else this.model.setMode("single")
            }
        }]), r
    }();
    exports.default = r;
});
define("js/control/relayCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var o = function () {
            function e(e, t) {
                for (var o = 0; o < t.length; o++) {
                    var i = t[o];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }

            return function (t, o, i) {
                return o && e(t.prototype, o), i && e(t, i), t
            }
        }(), i = require("../config"), n = e(require("../lib/mue/eventcenter")), s = e(require("../pages/relay/room")),
        a = require("../shareApp"), l = e(require("../pages/relay/gamePage")),
        r = e(require("../pages/relay/fakeRoomPage")), h = function () {
            function e(o, i) {
                t(this, e), this.name = "relay", this.game = o, this.modeCtrl = i, this.gameCtrl = this.game.gameCtrl, this.model = this.game.gameModel, this.view = this.game.gameView, this.netWorkCtrl = this.gameCtrl.netWorkCtrl, this.onSocketOpenCb = function () {
                }, this.socketTimeout = null, this.gameSocket = this.game.gameSocket, this.reconnectTimeout = null, this.currentPage = null, this.roomPage = new s.default(o), this.gamePage = new l.default(o), this.fakeRoomPage = new r.default(o), this.scene = 1, this.setStartRelayReportTimeOut = null, this.socketMonitor = this.game.socketMonitor
            }

            return o(e, [{
                key: "init", value: function (e) {
                    if (e && e.scene) switch (e.scene) {
                        case 1044:
                            this.scene = 0;
                            break;
                        default:
                            this.scene = 1
                    }
                    this.addEvent(), this.createRoomNoAddEvent(e)
                }
            }, {
                key: "createRoomNoAddEvent", value: function (e) {
                    e ? this.changePage("fakeRoomPage", 0) : this.changePage("fakeRoomPage", 1), this.model.getSessionId() ? this.afterLogin(e, !0) : this.netWorkCtrl.netWorkLogin(this.afterLogin.bind(this, e)), this.isShareCard = !1
                }
            }, {
                key: "afterLogin", value: function (e, t) {
                    if (!t) return this.view.showJoinRelayFail("n0"), e || n.default.emit(i.EVENT.CREATE_RELAY_ROOM_FAIL, {result: 1}), void this.modeCtrl.changeMode("singleCtrl");
                    if (e) {
                        console.log("options12312312312", e);
                        var o = e.query.room_id, s = decodeURIComponent(e.query.router_id), a = e.query.version;
                        console.log("optionsoptionsoptionsoptions", s), i.VERSION != a ? (this.rpJoinRoom(1), this.view.showVersionMismatching(), this.modeCtrl.changeMode("singleCtrl")) : (this.model.relayInfo = {
                            room_id: o,
                            router_id: s
                        }, this.joinRelayRoom())
                    } else this.netWorkCtrl.createRouterId(this.afterCreateRouterId.bind(this))
                }
            }, {
                key: "afterCreateRouterId", value: function (e, t) {
                    e ? (this.model.relayInfo = {router_id: t}, this.masterCreateRoom()) : (this.view.showJoinRelayFail(t), n.default.emit(i.EVENT.CREATE_RELAY_ROOM_FAIL, {result: 1}), this.modeCtrl.changeMode("singleCtrl"))
                }
            }, {
                key: "masterCreateRoom", value: function () {
                    this.onSocketOpenCb = this.socketCreateRoom.bind(this), this.connectSocket(this.masterCreateRoomFail.bind(this))
                }
            }, {
                key: "joinRelayRoom", value: function (e) {
                    var t = e || this.joinRelayRoomFail.bind(this);
                    this.onSocketOpenCb = this.socketJoinRoom.bind(this), this.connectSocket(t)
                }
            }, {
                key: "joinNextRelayRoom", value: function () {
                    n.default.emitSync(i.EVENT.RELAYMODEDESTROY, {}), this.clearSocketTimeout(), this.scene = 2, this.onSocketOpenCb = this.socketJoinNextRoom.bind(this), this.connectSocket(this.joinRelayRoomFail.bind(this))
                }
            }, {
                key: "connectSocket", value: function (e) {
                    this.socketTimeout = setTimeout(e, 5e3), this.gameSocket.alive ? this.onSocketOpenCb() : this.gameSocket.connectSocket()
                }
            }, {
                key: "onSocketOpen", value: function () {
                    this.onSocketOpenCb()
                }
            }, {
                key: "socketCreateRoom", value: function () {
                    var e = {cmdid: 10001, buff: {router_id: this.model.relayInfo.router_id, version: i.VERSION}};
                    this.sendRelayCmd(e)
                }
            }, {
                key: "socketJoinRoom", value: function () {
                    var e = {cmdid: 10002, buff: {room_id: this.model.relayInfo.room_id}};
                    this.sendRelayCmd(e)
                }
            }, {
                key: "socketJoinNextRoom", value: function () {
                    var e = {cmdid: 10011, buff: {room_id: this.model.relayInfo.room_id}};
                    this.sendRelayCmd(e)
                }
            }, {
                key: "joinRoomSucc", value: function (e, t) {
                    console.log(" joinRoomSucc"), this.clearSocketTimeout(), this.rpJoinRoom(0), this.model.relayInfo.room_seed = t.room_seed, this.model.relayInfo.my_seat_no = t.my_seat_no, this.model.relayInfo.next_room_id = t.next_room_id, this.model.relayInfo.room_wxa_code = "", this.setCheckGameInterval(), 0 != t.my_seat_no && 1 == t.game_status ? this.rejoinRelay() : this.changePage("roomPage", t)
                }
            }, {
                key: "joinRelayRoomFail", value: function () {
                    console.log("joinRelayRoomFail"), this.rpJoinRoom(1), this.view.showJoinRelayFail2(), this.modeCtrl.changeMode("singleCtrl")
                }
            }, {
                key: "masterCreateRoomFail", value: function () {
                    console.log("masterCreateRoomFail"), n.default.emit(i.EVENT.CREATE_RELAY_ROOM_FAIL, {result: 1}), this.view.showJoinRelayFail2(), this.modeCtrl.changeMode("singleCtrl")
                }
            }, {
                key: "createRoomSucc", value: function (e, t) {
                    console.log("createRoomSucc"), this.clearSocketTimeout(), this.model.relayInfo.room_id = t.room_id, this.model.relayInfo.room_seed = t.room_seed, this.model.relayInfo.my_seat_no = t.my_seat_no, this.model.relayInfo.room_wxa_code = "", this.model.relayInfo.next_room_id = t.next_room_id, this.setCheckGameInterval(), this.changePage("roomPage", t)
                }
            }, {
                key: "sendRelayCmd", value: function (e) {
                    var t = e.cmdid, o = e.buff;
                    t && ("10006" != t && console.log("", t, "", o), o = JSON.stringify(o), this.gameSocket.sendRelayCmd({
                        cmdid: t,
                        buff: o
                    }))
                }
            }, {
                key: "clearSocketTimeout", value: function () {
                    clearTimeout(this.reconnectTimeout), clearTimeout(this.socketTimeout), this.clearCheckGameInterval(), this.socketTimeout = null, this.reconnectTimeout = null
                }
            }, {
                key: "changePage", value: function (e, t) {
                    this.currentPage && this.currentPage.hide();
                    var o = this[e];
                    o && (this.currentPage = o, this.model.setStage(o.name), this.currentPage.show(t))
                }
            }, {
                key: "shareRelay", value: function () {
                    var e = this.model.relayInfo, t = e.room_id, o = e.router_id, n = i.VERSION,
                        s = this.afterShareRelay.bind(this);
                    this.isShareCard = !0, (0, a.ShareRelayCard)({room_id: t, router_id: o, version: n, cb: s})
                }
            }, {
                key: "afterShareRelay", value: function (e, t) {
                    if (console.log("shareTicket:", t, "session_id:", this.model.getSessionId()), e && t && this.gameSocket.alive) {
                        var o = {
                            cmdid: 10014,
                            buff: {
                                room_id: this.model.relayInfo.room_id,
                                session_id: this.model.getSessionId(),
                                share_ticket: t,
                                share_query: "?" + e
                            }
                        };
                        this.sendRelayCmd(o)
                    }
                }
            }, {
                key: "addEvent", value: function () {
                    n.default.on(i.EVENT.RELAYCREATEROOM, this.createRoomSucc.bind(this)), n.default.on(i.EVENT.JOINRELAYROOM, this.joinRoomSucc.bind(this)), n.default.on(i.EVENT.PEOPLECOME, this.upDateRoom.bind(this)), n.default.on(i.EVENT.PEOPLEOUT, this.upDateRoom.bind(this)), n.default.on(i.EVENT.RELAYSTART, this.relayGameStart.bind(this)), n.default.on(i.EVENT.NOWPLAYERJUMP, this.sendPlayerJumpMsg.bind(this)), n.default.on(i.EVENT.CHECKUSER, this.checkUser.bind(this)), n.default.on(i.EVENT.REPLAYAGAIN, this.joinNextRoom.bind(this)), n.default.on(i.EVENT.SYNCMSGSEQ, this.syncMsgSeq.bind(this)), n.default.on(i.EVENT.SEND_CHECK_GAME, this.sendCheckGame.bind(this)), n.default.on(i.EVENT.ENDGAME, this.endGame.bind(this)), n.default.on(i.EVENT.CHANGEGAMELEVEL, this.sendChangeGameLevel.bind(this)), n.default.on(i.EVENT.RECEIVEGAMELEVELCHANGE, this.receiveGameLevelChange.bind(this)), n.default.on(i.EVENT.GETRELAYQR, this.getRelayQR.bind(this)), n.default.on(i.EVENT.GETRELAYCHECKUSERERROR, this.syncRelay.bind(this))
                }
            }, {
                key: "offEvent", value: function () {
                    n.default.off(i.EVENT.RELAYCREATEROOM, this.createRoomSucc.bind(this)), n.default.off(i.EVENT.JOINRELAYROOM, this.joinRoomSucc.bind(this)), n.default.off(i.EVENT.PEOPLECOME, this.upDateRoom.bind(this)), n.default.off(i.EVENT.PEOPLEOUT, this.upDateRoom.bind(this)), n.default.off(i.EVENT.RELAYSTART, this.relayGameStart.bind(this)), n.default.off(i.EVENT.NOWPLAYERJUMP, this.sendPlayerJumpMsg.bind(this)), n.default.off(i.EVENT.CHECKUSER, this.checkUser.bind(this)), n.default.off(i.EVENT.REPLAYAGAIN, this.joinNextRoom.bind(this)), n.default.off(i.EVENT.SYNCMSGSEQ, this.syncMsgSeq.bind(this)), n.default.off(i.EVENT.SEND_CHECK_GAME, this.sendCheckGame.bind(this)), n.default.off(i.EVENT.ENDGAME, this.endGame.bind(this)), n.default.off(i.EVENT.CHANGEGAMELEVEL, this.sendChangeGameLevel.bind(this)), n.default.off(i.EVENT.RECEIVEGAMELEVELCHANGE, this.receiveGameLevelChange.bind(this)), n.default.off(i.EVENT.GETRELAYQR, this.getRelayQR.bind(this)), n.default.off(i.EVENT.GETRELAYCHECKUSERERROR, this.syncRelay.bind(this))
                }
            }, {
                key: "upDateRoom", value: function (e, t) {
                    console.log(""), this.currentPage == this.roomPage && this.currentPage.show(t)
                }
            }, {
                key: "outRelay1", value: function () {
                    var e = {cmdid: 10003, buff: {room_id: this.model.relayInfo.room_id}};
                    this.sendRelayCmd(e), this.modeCtrl.changeMode("singleCtrl")
                }
            }, {
                key: "outRelay2", value: function () {
                    this.modeCtrl.changeMode("singleCtrl")
                }
            }, {
                key: "startRelay", value: function (e) {
                    var t = {cmdid: 10004, buff: {room_id: this.model.relayInfo.room_id, game_level: e}};
                    this.sendRelayCmd(t), this.setStartRelayReportTimeOut = setTimeout(function () {
                        n.default.emit(i.EVENT.RP_RELAY_START, {result: 1})
                    }, 5e3)
                }
            }, {
                key: "relayGameStart", value: function (e) {
                    this.changePage("gamePage"), clearTimeout(this.setStartRelayReportTimeOut), n.default.emit(i.EVENT.RP_RELAY_START, {result: 0})
                }
            }, {
                key: "sendPlayerJumpMsg", value: function (e, t) {
                    var o = t.msginfo, i = t.jump_succ, n = t.msg_seq;
                    if (this.model.relayInfo.my_seat_no) {
                        var s = {
                            cmdid: 10009,
                            buff: {
                                room_id: this.model.relayInfo.room_id,
                                msg_info: {msgid: this.model.relayInfo.room_id + Date.now(), jump_succ: i, msginfo: o},
                                msg_seq: n
                            }
                        };
                        this.sendRelayCmd(s)
                    }
                }
            }, {
                key: "checkUser", value: function (e, t) {
                    var o = t.msgid, i = t.msg_seq, n = t.jump_succ;
                    if (this.model.relayInfo.my_seat_no) {
                        var s = {
                            cmdid: 10008,
                            buff: {room_id: this.model.relayInfo.room_id, msg_info: {msgid: o, jump_succ: n, msg_seq: i}}
                        };
                        this.sendRelayCmd(s)
                    }
                }
            }, {
                key: "endGame", value: function (e, t) {
                    this.clearCheckGameInterval(), this.gamePage.hideScore(), n.default.emit(i.EVENT.RP_RELAY_GAME_END, {
                        jielong_score: t.score,
                        player_num: t.playerlist.length,
                        max_audience: t.onlookerlist.length,
                        difficulty: t.game_level
                    })
                }
            }, {
                key: "syncMsgSeq", value: function (e, t) {
                    var o = {cmdid: 10007, buff: {room_id: this.model.relayInfo.room_id, msg_seq: t.msg_seq}};
                    this.sendRelayCmd(o)
                }
            }, {
                key: "setCheckGameInterval", value: function () {
                    this.checkRelayInterval = setInterval(function () {
                        n.default.emit(i.EVENT.CHECK_GAME, {})
                    }, 2e3)
                }
            }, {
                key: "clearCheckGameInterval", value: function () {
                    console.log(""), clearInterval(this.checkRelayInterval), this.checkRelayInterval = null
                }
            }, {
                key: "sendCheckGame", value: function (e, t) {
                    if (this.model.relayInfo.my_seat_no) {
                        var o = {cmdid: 10006, buff: {room_id: t.room_id, seq: t.seq}};
                        this.sendRelayCmd(o)
                    }
                }
            }, {
                key: "joinNextRoom", value: function (e) {
                    if (!this.model.relayInfo.next_room_id) return this.view.showJoinNextRoomFail(), void this.modeCtrl.changeMode("singleCtrl");
                    n.default.emitSync(i.EVENT.RELAYMODEDESTROY, {}), this.game.full2D.hide2D(), this.model.relayInfo.room_id = this.model.relayInfo.next_room_id, this.model.relayInfo.room_wxa_code = "", this.joinNextRelayRoom()
                }
            }, {
                key: "afterGetMiniCode", value: function (e, t) {
                    console.log("getMiniCode", "RECEIVEMINICODE"), this.upDateRoom(e, t)
                }
            }, {
                key: "getMiniCode", value: function () {
                    var e = {
                        cmdid: 10010,
                        buff: {
                            room_id: this.model.relayInfo.room_id,
                            router_id: decodeURIComponent(this.model.relayInfo.router_id),
                            client_version: i.VERSION,
                            mode: "relay"
                        }
                    };
                    this.sendRelayCmd(e)
                }
            }, {
                key: "watchRelay", value: function () {
                    this.rejoinRelay()
                }
            }, {
                key: "rejoinRelay", value: function () {
                    n.default.emitSync(i.EVENT.WATCHRELAY, {}), this.changePage("gamePage")
                }
            }, {
                key: "syncRelay", value: function () {
                    n.default.emitSync(i.EVENT.WATCHRELAY, {})
                }
            }, {
                key: "onSocketCloseErr", value: function () {
                    this.socketTimeout || (this.clearSocketTimeout(), this.model.relayInfo.room_id && this.model.relayInfo.router_id ? this.reconnectSocket() : this.modeCtrl.changeMode("singleCtrl"))
                }
            }, {
                key: "reconnectSocket", value: function () {
                    var e = this.reconnectSocketFail.bind(this);
                    this.joinRelayRoom(e)
                }
            }, {
                key: "reconnectSocketFail", value: function () {
                    this.gameSocket.close(), this.clearSocketTimeout(), clearTimeout(this.reconnectTimeout), this.reconnectTimeout = setTimeout(this.reconnectSocket.bind(this), 3e3)
                }
            }, {
                key: "progressOver", value: function (e) {
                    var t = {
                        cmdid: 10013,
                        buff: {room_id: this.model.relayInfo.room_id, msg_seq: this.game.relayInstructionCtrl.msg_seq}
                    };
                    console.log(""), this.sendRelayCmd(t)
                }
            }, {
                key: "receiveGameLevelChange", value: function (e, t) {
                    this.upDateRoom(e, t)
                }
            }, {
                key: "sendChangeGameLevel", value: function (e, t) {
                    var o = {cmdid: 10012, buff: {room_id: this.model.relayInfo.room_id, game_level: t}};
                    console.log(""), this.sendRelayCmd(o)
                }
            }, {
                key: "rpJoinRoom", value: function (e) {
                    2 == this.scene ? n.default.emit(i.EVENT.RP_JOIN_RELAY_ROOM_AGAIN, {res: e}) : n.default.emit(i.EVENT.RP_JOIN_RELAY_ROOM, {
                        scene: this.scene,
                        result: e
                    })
                }
            }, {
                key: "getRelayQR", value: function () {
                    this.model.relayInfo.room_wxa_code ? n.default.emitSync(i.EVENT.RECEIVEMINICODE, {room_wxa_code: this.model.relayInfo.room_wxa_code}) : this.getMiniCode()
                }
            }, {
                key: "checkCmd", value: function () {
                    var e = this.game.relayInstructionCtrl.cmdList, t = !1;
                    return e.length && e[e.length - 1].buff.game_status > 0 && (t = !0), t
                }
            }, {
                key: "wxOnShow", value: function () {
                    this.isShareCard ? this.checkCmd() ? this.onSocketCloseErr() : this.game.relayInstructionCtrl.run() : (this.game.relayInstructionCtrl.handleOnShow(), this.onSocketCloseErr()), this.socketMonitor.log("|os|"), this.isShareCard = !1
                }
            }, {
                key: "wxOnhide", value: function () {
                    this.isShareCard ? this.game.relayInstructionCtrl.stop() : (this.clearSocketTimeout(), this.gameSocket.close(), this.game.relayInstructionCtrl.handleOnhide()), this.socketMonitor.log("|oh|")
                }
            }, {
                key: "gotoRelayMode", value: function () {
                    n.default.emitSync(i.EVENT.RELAYMODEDESTROY, {}), this.game.full2D.hide2D(), this.clearSocketTimeout(), this.scene = 1, this.model.relayInfo = {}, this.onSocketOpenCb = function () {
                    }, this.game.relayInstructionCtrl.destroy(), this.createRoomNoAddEvent()
                }
            }, {
                key: "destroy", value: function () {
                    this.clearSocketTimeout(), this.gameSocket.close(), this.model.relayInfo = {}, this.onSocketOpenCb = function () {
                    }, this.offEvent(), this.game.full2D.hide2D(), wx.hideLoading(), this.game.relayInstructionCtrl.destroy(), this.game.resetScene(), n.default.emitSync(i.EVENT.RELAYMODEDESTROY, {})
                }
            }]), e
        }();
    exports.default = h;
});
define("js/control/relayInstructionCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function s(e, s) {
        if (!(e instanceof s)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
            function e(e, s) {
                for (var t = 0; t < s.length; t++) {
                    var i = s[t];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }

            return function (s, t, i) {
                return t && e(s.prototype, t), i && e(s, i), s
            }
        }(), i = e(require("../lib/mue/eventcenter")), o = require("../config"),
        f = (e(o), e(require("../network/network"))), n = function () {
            function e(t) {
                var f = this;
                s(this, e), this.game = t, this.runningSeq = 0, this.cmdList = [], this.seq = 0, this.model = t.gameModel, this.monitor = this.game.socketMonitor, i.default.on(o.EVENT.WATCHRELAY, function () {
                    f.sync()
                }), i.default.on(o.EVENT.CHECK_GAME, function () {
                    i.default.emit(o.EVENT.SEND_CHECK_GAME, {room_id: f.model.relayInfo.room_id || "", seq: f.seq})
                })
            }

            return t(e, [{
                key: "cmdCome", value: function (e) {
                    if (0 == e.ret) {
                        var s = JSON.parse(e.data);
                        if (0 == s.error_code) {
                            if (!s.buff) return;
                            if (s.buff = JSON.parse(s.buff), 10006 != s.cmdid && console.log("cmdid", s.cmdid, ":" + s.buff.room_id + "" + this.model.relayInfo.room_id + (s.buff.room_id == this.model.relayInfo.room_id ? "" : ""), "", s), 10009 == s.cmdid || 10008 == s.cmdid || 10006 == s.cmdid || 10004 == s.cmdid || 10012 == s.cmdid || 10013 == s.cmdid || 10014 == s.cmdid) return;
                            if (10001 != s.cmdid) {
                                if (s.buff.room_id != this.model.relayInfo.room_id) return void console.log("cmdid", s.cmdid, ":");
                                if (10007 == s.cmdid) return void this.parseCmd(s);
                                10002 != s.cmdid && 10011 != s.cmdid || (this.cmdList = [], this.canRunningCmd = !0)
                            } else this.cmdList = [], this.canRunningCmd = !0;
                            this.cmdList.push(s), this.runCmd()
                        } else {
                            var t = String(s.error_code);
                            "-1019" == t ? (this.handleSyncWrong(), f.default.sendServerError(3)) : "-1015" != t && t < 0 && this.debug(t, s.error_msg + "cmd" + e.cmd, s)
                        }
                    } else this.debug("ret:" + e.ret, "cmd:" + e.cmd), "-1" == String(e.ret) && f.default.sendServerError(4)
                }
            }, {
                key: "runCmd", value: function () {
                    if (this.cmdList.length && this.canRunningCmd) {
                        this.cmdList.sort(function (e, s) {
                            return e.ts - s.ts
                        });
                        var e = this.cmdList.shift(), s = e.cmdid;
                        if (10001 == s || 10002 == s || 10010 == s || 10011 == s) return 10010 != s && (this.seq = e.buff.seq, this.msg_seq = -1), this.parseCmd(e), void this.runCmd();
                        if (e.buff.seq > this.seq) {
                            var t = e.buff.msg_seq - this.msg_seq;
                            if (0 == t || 1 == t && "20006" == e.cmdid) return this.parseCmd(e), this.seq = e.buff.seq, this.msg_seq = e.buff.msg_seq, void this.runCmd();
                            console.log(""), this.sync()
                        } else console.log("seqseq", e), this.runCmd()
                    }
                }
            }, {
                key: "sync", value: function () {
                    this.canRunningCmd = !1, this.cmdList = [], i.default.emitSync(o.EVENT.SYNCMSGSEQ, {msg_seq: this.msg_seq}), this.clearSyncTimeOut(), this.setSyncTimeOut()
                }
            }, {
                key: "setSyncTimeOut", value: function () {
                    this.syncTimeOutArr || (this.syncTimeOutArr = []), this.syncTimeOutArr.push(setTimeout(this.sync.bind(this), 5e3))
                }
            }, {
                key: "clearSyncTimeOut", value: function () {
                    if (Array.isArray(this.syncTimeOutArr)) for (; this.syncTimeOutArr.length;) {
                        var e = this.syncTimeOutArr.pop();
                        clearTimeout(e)
                    }
                }
            }, {
                key: "receiveSyncCmd", value: function (e) {
                    if (this.clearSyncTimeOut(), 2 == e.buff.game_status) return i.default.emitSync(o.EVENT.ENDGAME, e.buff), void(this.cmdList = []);
                    i.default.emitSync(o.EVENT.SYNCSCENE, {
                        now_msg_seq: this.msg_seq,
                        serverData: e.buff
                    }), this.msg_seq = e.buff.msg_seq, this.seq = e.buff.seq, this.canRunningCmd = !0, this.runCmd()
                }
            }, {
                key: "parseCmd", value: function (e) {
                    switch (e.cmdid) {
                        case 10001:
                            console.log(10001, "", e.buff), this.monitor.log("|10001;" + e.buff.room_id + ";" + e.buff.seq + ";" + e.buff.msg_seq), i.default.emitSync(o.EVENT.RELAYCREATEROOM, e.buff);
                            break;
                        case 10002:
                            console.log(10002, "", e.buff), this.monitor.log("|10002;" + e.buff.room_id + ";" + e.buff.seq + ";" + e.buff.msg_seq), 0 == e.buff.my_seat_no && 0 != e.buff.game_status && (this.canRunningCmd = !1), i.default.emitSync(o.EVENT.JOINRELAYROOM, e.buff);
                            break;
                        case 10011:
                            console.log(10011, "", e.buff), this.monitor.log("|10011;" + e.buff.room_id + ";" + e.buff.seq + ";" + e.buff.msg_seq), 0 == e.buff.my_seat_no && 0 != e.buff.game_status && (this.canRunningCmd = !1), i.default.emitSync(o.EVENT.JOINRELAYROOM, e.buff);
                            break;
                        case 20004:
                            this.adJustBuff(e.buff, 1), this.monitor.log("|20004;" + e.buff.seq + ";" + e.buff.msg_seq), console.log(20004, "", e.buff), i.default.emitSync(o.EVENT.PEOPLECOME, e.buff);
                            break;
                        case 20005:
                            this.adJustBuff(e.buff, 1), this.monitor.log("|20005;" + e.buff.seq + ";" + e.buff.msg_seq), console.log(20005, "", e.buff), i.default.emitSync(o.EVENT.PEOPLEOUT, e.buff);
                            break;
                        case 20001:
                            this.adJustBuff(e.buff), console.log(20001, " ", e.buff), this.monitor.log("|20001;" + e.buff.seq + ";" + e.buff.msg_seq + ";" + e.buff.game_level), console.log("20001 my_seat_no", this.model.relayInfo.my_seat_no), i.default.emitSync(o.EVENT.RELAYSTART, e.buff);
                            break;
                        case 20006:
                            this.adJustBuff(e.buff), console.log(20006, " ", e.buff.msg_seq, e.buff), this.monitor.log("|20006;" + e.buff.seq + ";" + e.buff.msg_seq), console.log("20006 my_seat_no", this.model.relayInfo.my_seat_no), i.default.emitSync(o.EVENT.RELAYCHECKUSER, e.buff);
                            break;
                        case 20002:
                            this.adJustBuff(e.buff), console.log(20002, " ", e.buff.msg_seq, e.buff), this.monitor.log("|20002;" + e.buff.seq + ";" + e.buff.msg_seq), console.log("20002 my_seat_no", this.model.relayInfo.my_seat_no), i.default.emitSync(o.EVENT.RUNGAME, e.buff);
                            break;
                        case 20003:
                            this.adJustBuff(e.buff), this.monitor.log("|20003;" + e.buff.room_id + ";" + e.buff.seq + ";" + e.buff.msg_seq), console.log(20003, "", e.buff), console.log("20003 my_seat_no", this.model.relayInfo.my_seat_no), e.buff && "-1019" == e.buff.error_ret && this.monitor.report(), i.default.emitSync(o.EVENT.ENDGAME, e.buff);
                            break;
                        case 10010:
                            this.model.relayInfo.room_id && (this.model.relayInfo.room_wxa_code = e.buff.room_wxa_code), this.adJustBuff(e.buff), console.log(10010, "", e.buff), console.log("10010 my_seat_no", this.model.relayInfo.my_seat_no), i.default.emitSync(o.EVENT.RECEIVEMINICODE, e.buff);
                            break;
                        case 10007:
                            this.adJustBuff(e.buff), console.log(10007, "", e.buff), this.monitor.log("|10007;" + e.buff.seq + ";" + e.buff.msg_seq), this.receiveSyncCmd(e);
                            break;
                        case 20007:
                            this.adJustBuff(e.buff, 1), console.log(20007, "", e.buff), i.default.emitSync(o.EVENT.RECEIVEGAMELEVELCHANGE, e.buff);
                            break;
                        default:
                            console.log("", e)
                    }
                }
            }, {
                key: "adJustBuff", value: function (e, s) {
                    e.my_seat_no = this.model.relayInfo.my_seat_no, s && (e.room_wxa_code = this.model.relayInfo.room_wxa_code), e.score = this.game.UI.score, console.log(",:", e.my_seat_no)
                }
            }, {
                key: "debug", value: function () {
                    arguments.length > 0 && void 0 !== arguments[0] && arguments[0], arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments[2];
                    return
                }
            }, {
                key: "run", value: function () {
                    this.canRunningCmd = !0, this.runCmd()
                }
            }, {
                key: "stop", value: function () {
                    this.canRunningCmd = !1
                }
            }, {
                key: "handleOnShow", value: function () {
                    this.cmdList = [], this.canRunningCmd = !0
                }
            }, {
                key: "handleOnhide", value: function () {
                    this.clearSyncTimeOut(), this.cmdList = [], this.stop()
                }
            }, {
                key: "handleSyncWrong", value: function () {
                    wx.showModal({title: "", content: "", showCancel: !1})
                }
            }, {
                key: "destroy", value: function () {
                    this.clearSyncTimeOut(), this.cmdList = [], this.stop(), this.seq = 0, this.msg_seq = -1
                }
            }]), e
        }();
    exports.default = n;
});
define("js/control/reviewCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
            function e(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var s = t[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, s.key, s)
                }
            }

            return function (t, i, s) {
                return i && e(t.prototype, i), s && e(t, s), t
            }
        }(), s = e(require("../network/network")), a = require("../pages/pages2d/base"), o = e(require("../store/storage")),
        n = function () {
            function e(i) {
                t(this, e), this.game = i, this.gameCtrl = i.gameCtrl, this.initData()
            }

            return i(e, [{
                key: "initData", value: function () {
                    this.isInThisPage = !1, this.scene = void 0, this.pause = !1, this.actionList = [], this.musicList = [], this.touchStartList = [], this.index = 0, this._playCache = function () {
                    }, this.gameData = {}
                }
            }, {
                key: "setScorePostion", value: function () {
                    var e = (0, a.cx)(211), t = (0, a.cy)(178), i = (e - a.WIDTH / 2) / a.WIDTH * a.frustumSizeWidth,
                        s = (a.HEIGHT / 2 - t) / a.HEIGHT * a.frustumSizeHeight;
                    this.game.UI.scoreText.obj.position.x = i, this.game.UI.scoreText.obj.position.y = s, this.game.UI.scoreText.changeStyle({textAlign: "center"}), this.game.UI.showScore()
                }
            }, {
                key: "init", value: function (e) {
                    function t(e, i) {
                        wx.showLoading({mask: !0}), s.default.getWeeklyPlayBack(function (s, a) {
                            var o = "";
                            wx.hideLoading(), s && void 0 !== a.timestamp ? e(a) : (a && a.data && a.data.base_resp && a.data.base_resp.errcode && (o = "(e" + a.data.base_resp.errcode + ")"), wx.showModal({
                                title: "",
                                content: "" + o,
                                confirmText: "",
                                cancelText: "",
                                success: function (s) {
                                    s.confirm && t(e, i)
                                },
                                fail: function () {
                                }
                            }))
                        }, i)
                    }

                    function i(e) {
                        r.isInThisPage = !0, r.scene = n, r.setScorePostion(), r.game.full2D.showRecordPage({headimg: a.headimg}), r.gameData = e, r.play(e.seed, e.action, e.musicList, e.timestamp, e.version, e.use_wangzhe, e.mmpay_status, e.use_mmpaybase, function () {
                            if (r.game.currentScore && a.week_best_score && r.game.currentScore != a.week_best_score) {
                                s.default.sendServerError(9);
                                if (Math.random() < .01) {
                                    var e = o.default.getMyUserInfo(), t = e && e.open_id;
                                    t && s.default.badReport("searchflag:reviewNotRight;open_id:" + t + ";playback_id:" + u + ";currentScore:" + r.game.currentScore + ";week_best_score:" + a.week_best_score + ";")
                                }
                            }
                            r.destroy()
                        })
                    }

                    var a = e.user_data, n = e.scene, r = this, u = a && a.playback_id;
                    t(function (e) {
                        i(e)
                    }, u)
                }
            }, {
                key: "destroy", value: function () {
                    this.isInThisPage && (this.game.stopLoopMusic(), this.game.resetScene(), this._destroy(), this.game.UI.hideScore(), this.game.UI.scoreText.obj.position.y = 21, this.game.UI.scoreText.obj.position.x = -13, this.game.full2D.hide2D(), this.gameCtrl.reviewReturn(this.scene), this.initData())
                }
            }, {
                key: "_play", value: function (e) {
                    var t = this;
                    if (this.index < this.actionList.length && !this.pause) {
                        var i = this.actionList[this.index][1], s = this.musicList[this.index + 1],
                            a = this.actionList[this.index][2], o = this.actionList[this.index][0],
                            n = 0 == this.index ? 0 : this.touchStartList[this.index] - this.touchStartList[this.index - 1];
                        this.timer = setTimeout(function () {
                            ++t.index, "stop" != t.game.bottle.status ? (console.log(t.index, "go wrong !!!"), t.speedUpto(t.index, t.gameData, function () {
                                t._play(e)
                            })) : (t.game.touchStartAnim({fromReview: !0}), t.jumpTimer = setTimeout(function () {
                                t.game.touchEndAnim(o, i, a, s), t.index == t.actionList.length && (t.overTimeout = setTimeout(function () {
                                    e()
                                }, 3e3))
                            }, 1e3 * o), t._play(e), t._playCache = function () {
                                t._play(e)
                            })
                        }, n)
                    } else this.pause
                }
            }, {
                key: "pausePlay", value: function () {
                    this.pause = !0, this.timer && (clearTimeout(this.timer), this.timer = null)
                }
            }, {
                key: "speedUpto", value: function (e, t, i) {
                    var s = this;
                    this._destroy();
                    var a = t.seed, o = t.action, n = t.musicList, r = t.timestamp, u = t.version, c = t.use_wangzhe,
                        h = t.mmpay_status, m = t.use_mmpaybase, l = o, d = r, g = void 0;
                    for (this.actionList = l, this.musicList = n, this.touchStartList = d, this.index = 0, this.game.resetScene(a, {
                        version: u,
                        use_wangzhe: c,
                        use_mmpaybase: m,
                        mmpay_status: h
                    }), g = 0; g < this.actionList.length - 1 && g < e - 2; g++) !function (e) {
                        var t = s.actionList[e][1], i = s.actionList[e][0], a = s.musicList[e + 1],
                            o = s.actionList[e][2], n = s.game.touchEndAnim(i, t, o, a, {noAnimation: !0});
                        1 == n || 7 == n ? (s.game.succeed({
                            noAnimation: !0,
                            musicScore: a
                        }), 1 === n ? (++s.game.doubleHit, s.game.UI.addScore(1, !0, o)) : (s.game.doubleHit = 0, s.game.UI.addScore(1, !1, o))) : 2 == n && (s.game.bottle.obj.position.x = s.game.bottle.destination[0], s.game.bottle.obj.position.z = s.game.bottle.destination[1])
                    }(g);
                    this.index = g, i()
                }
            }, {
                key: "continue", value: function () {
                    this.pause = !1, this._playCache()
                }
            }, {
                key: "play", value: function (e, t, i, s, a, o, n, r, u) {
                    this.actionList = t, this.musicList = i, this.touchStartList = s, this.index = 0, this.game.resetScene(e, {
                        version: a,
                        use_wangzhe: o,
                        use_mmpaybase: r,
                        mmpay_status: n
                    }), this._play(u)
                }
            }, {
                key: "_destroy", value: function () {
                    this.timer && (clearTimeout(this.timer), this.timer = null), this.jumpTimer && (clearTimeout(this.jumpTimer), this.jumpTimer = null), this.game.deadTimeout && (clearTimeout(this.game.deadTimeout), this.game.deadTimeout = null), this.overTimeout && (clearTimeout(this.overTimeout), this.overTimeout = null)
                }
            }]), e
        }();
    exports.default = n;
});
define("js/control/singleCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var a = function () {
            function e(e, t) {
                for (var a = 0; a < t.length; a++) {
                    var i = t[a];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }

            return function (t, a, i) {
                return a && e(t.prototype, a), i && e(t, i), t
            }
        }(), i = e(require("../pages/single/singleStartPage")), s = e(require("../pages/single/singleGamePage")),
        r = e(require("../pages/single/singleGameOverPage")), n = e(require("../pages/single/singleFriendRankPage")),
        o = e(require("../pages/single/relayGuide")), h = require("../shareApp"), l = e(require("../network/network")),
        u = e(require("../lib/mue/eventcenter")), g = require("../config"), c = function () {
            function e(a, h) {
                t(this, e), this.name = "single", this.game = a, this.gameCtrl = this.game.gameCtrl, this.model = this.game.gameModel, this.view = this.game.gameView, this.modeCtrl = h, this.netWorkCtrl = this.gameCtrl.netWorkCtrl, this.gameSocket = this.game.gameSocket, this.startPage = new i.default(a), this.gamePage = new s.default(a), this.gameOverPage = new r.default(a), this.friendRankPage = new n.default(a), this.relayGuidePage = new o.default(a), this.currentPage = null, this.lastPage = null, this.socketTimeout = null
            }

            return a(e, [{
                key: "init", value: function (e) {
                    this.startPage.show(), this.model.setStage(this.startPage.name), this.currentPage = this.startPage
                }
            }, {
                key: "clickStart", value: function () {
                    this.hideCurrentPage(), this.gamePage.show(), this.game.replayGame(), this.model.setStage(this.gamePage.name), this.currentPage = this.gamePage
                }
            }, {
                key: "showGameOverPage", value: function (e) {
                    this.hideCurrentPage(), this.gameOverPage.show(e), this.model.clearPkId(), this.model.setStage(this.gameOverPage.name), this.currentPage = this.gameOverPage
                }
            }, {
                key: "gameOverClickReplay", value: function () {
                    this.clickStart()
                }
            }, {
                key: "showFriendRank", value: function (e) {
                    e || (this.lastPage = this.currentPage), this.hideCurrentPage(), this.friendRankPage.show(), this.model.setStage(this.friendRankPage.name), this.currentPage = this.friendRankPage
                }
            }, {
                key: "friendRankReturn", value: function () {
                    this.hideCurrentPage(), this.lastPage.show(), this.model.setStage(this.lastPage.name), this.currentPage = this.lastPage
                }
            }, {
                key: "shareGroupRank", value: function () {
                    var e = this;
                    (0, h.shareGroupRank)(function (t, a) {
                        e.gameCtrl.afterShareGroupRank(t, a)
                    })
                }
            }, {
                key: "clickRank", value: function () {
                    this.showFriendRank()
                }
            }, {
                key: "shareBattleCard", value: function () {
                    var e = this, t = this.model.getSessionId(), a = this.model.currentScore, i = this.model.getPkId();
                    t ? i ? this.afterHavePkId() : l.default.createPK(a).then(function () {
                        e.afterHavePkId()
                    }, function () {
                        e.getPKErr()
                    }).catch(function (e) {
                        return console.log(e)
                    }) : this.view.showNoSession()
                }
            }, {
                key: "afterHavePkId", value: function () {
                    var e = this, t = this.model.getPkId(), a = this.model.currentScore;
                    (0, h.shareBattle)(t, a, function (t, a) {
                        e.gameCtrl.afterShareBattle(t, a)
                    })
                }
            }, {
                key: "getPKErr", value: function () {
                    this.view.showGetPkIdFail()
                }
            }, {
                key: "shareObservCard", value: function () {
                    this.gamePage.hideLookersShare(), this.model.setStage("loading"), wx.showLoading(), this.model.getSessionId() ? this.afterLogin(!0) : this.netWorkCtrl.netWorkLogin(this.afterLogin.bind(this))
                }
            }, {
                key: "afterLogin", value: function (e) {
                    var t = this;
                    e ? l.default.requestCreateGame(function (e, a) {
                        e ? (t.model.setGameId(a.data.game_id), t.model.setGameTicket(a.data.up_op_ticket), t.shareObservCardA()) : t.shareObservCardFail(a)
                    }) : this.shareObservCardFail()
                }
            }, {
                key: "shareObservCardFail", value: function (e) {
                    this.view.showShareObserveCardFail(e), this.model.clearGameId(), this.model.clearGameTicket(), "loading" == this.model.stage && this.model.setStage("game"), this.clearSocketTimeout(), this.gameSocket.close(), wx.hideLoading()
                }
            }, {
                key: "shareObservCardA", value: function () {
                    this.socketTimeout = setTimeout(this.shareObservCardFail.bind(this), 5e3), this.gameSocket.connectSocket()
                }
            }, {
                key: "socketJoinSuccess", value: function (e) {
                    wx.hideLoading(), e ? (this.clearSocketTimeout(), this.shareObservCardB()) : this.shareObservCardFail()
                }
            }, {
                key: "shareObservCardB", value: function () {
                    var e = this;
                    (0, h.shareObserve)(function (t, a) {
                        t && e.gameCtrl.afterShareObserveCard(a), setTimeout(function () {
                            "loading" == e.model.stage && e.model.setStage("game"), e.modeCtrl.singleChangeToPlayer(), e.currentPage = null
                        }, 50)
                    })
                }
            }, {
                key: "clearSocketTimeout", value: function () {
                    null != this.socketTimeout && (clearTimeout(this.socketTimeout), this.socketTimeout = null)
                }
            }, {
                key: "appealNotify", value: function () {
                    this.currentPage === this.startPage && this.startPage.show({banType: 1})
                }
            }, {
                key: "gotoRelayMode", value: function () {
                    this.model.getIsRelayNewBie() ? (console.log(""), u.default.emit(g.EVENT.SHOW_RELAY_GUIDE), this.hideCurrentPage(), this.relayGuidePage.show(), this.model.setStage(this.relayGuidePage.name), this.currentPage = this.relayGuidePage) : (console.log(""), this.modeCtrl.changeMode("relayCtrl"))
                }
            }, {
                key: "skipRelayBeginner", value: function () {
                    this.modeCtrl.changeMode("relayCtrl")
                }
            }, {
                key: "wxOnhide", value: function () {
                }
            }, {
                key: "wxOnshow", value: function () {
                }
            }, {
                key: "destroy", value: function () {
                    this.hideCurrentPage(), this.currentPage = null, this.model.setStage(""), this.model.clearGameId(), this.model.clearGameTicket(), this.clearSocketTimeout(), this.game.resetScene()
                }
            }, {
                key: "hideCurrentPage", value: function () {
                    this.currentPage && this.currentPage.hide()
                }
            }]), e
        }();
    exports.default = c;
});
define("js/font.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0});
    var l, q = {
        glyphs: {
            "": {
                ha: 1389,
                x_min: 11,
                x_max: 1373,
                o: "m 407 830 l 776 830 q 781 1150 781 960 l 901 1150 q 890 830 895 955 l 1340 830 l 1340 727 l 901 727 q 1373 -38 998 233 q 1280 -141 1318 -92 q 846 564 944 130 q 380 -174 776 152 q 293 -81 336 -125 q 770 727 738 260 l 407 727 l 407 830 m 228 374 q 336 320 293 336 q 168 -179 293 174 l 54 -119 q 228 374 163 125 m 76 787 q 342 608 222 700 q 266 510 298 553 q 11 700 130 618 l 76 787 m 152 1139 q 407 955 315 1025 q 331 857 369 906 q 87 1058 212 960 l 152 1139 m 689 114 l 776 174 q 928 -33 857 60 l 830 -98 q 689 114 770 0 z "
            },
            "": {
                ha: 1389,
                x_min: 22,
                x_max: 1318,
                o: "m 461 331 l 553 331 l 553 146 l 732 146 l 732 391 l 374 391 l 374 477 l 732 477 l 732 656 l 618 656 q 515 515 564 581 q 429 575 450 559 q 640 873 553 705 l 727 836 q 673 743 700 787 l 1090 743 l 1090 656 l 825 656 l 825 477 l 1166 477 l 1166 391 l 825 391 l 825 146 l 1009 146 l 1009 331 l 1101 331 l 1101 60 l 461 60 l 461 331 m 326 754 q 586 1161 488 944 l 684 1123 q 618 1009 651 1063 l 1318 1009 q 1302 92 1313 315 q 1237 -103 1291 -49 q 1031 -157 1177 -157 q 857 -152 928 -157 q 836 -38 852 -98 q 1031 -54 933 -49 q 1161 -22 1123 -54 q 1199 103 1194 11 q 1215 917 1204 309 l 570 917 q 407 689 488 787 q 326 754 369 716 m 179 385 q 293 336 239 358 q 168 -174 228 87 l 49 -136 q 179 385 119 76 m 87 776 q 326 591 179 711 q 244 505 271 537 q 22 700 98 635 l 87 776 m 141 1134 q 374 933 250 1047 q 293 852 331 890 q 76 1058 146 998 l 141 1134 z "
            },
            "": {
                ha: 1389,
                x_min: 22,
                x_max: 1367,
                o: "m 564 955 l 917 955 l 917 1150 l 1015 1150 l 1015 955 l 1335 955 l 1335 868 q 1270 684 1313 776 q 1177 722 1226 705 q 1232 863 1210 792 l 1015 863 l 1015 597 l 1259 597 l 1259 515 q 1053 92 1194 260 q 1367 -76 1161 -5 q 1291 -179 1329 -125 q 977 22 1096 -92 q 651 -179 841 -98 q 586 -92 618 -136 q 911 92 787 -11 q 727 510 776 250 l 662 510 l 662 434 q 450 -179 662 43 q 380 -98 418 -136 q 564 434 564 114 l 564 955 m 27 792 l 27 890 l 472 890 l 472 787 q 304 537 401 662 l 304 510 q 358 456 336 477 q 467 581 423 526 l 537 521 q 418 396 488 467 q 510 293 467 336 l 439 222 q 304 385 385 298 l 304 -174 l 212 -174 l 212 423 q 54 271 141 347 q 22 385 43 320 q 353 792 239 570 l 27 792 m 662 597 l 917 597 l 917 863 l 662 863 l 662 597 m 1150 510 l 825 510 q 982 168 868 304 q 1150 510 1090 304 m 163 1118 l 250 1161 q 358 971 315 1069 l 260 922 q 163 1118 222 1009 z "
            },
            "": {
                ha: 1389,
                x_min: 22,
                x_max: 1367,
                o: "m 22 -60 q 136 488 125 125 l 233 483 q 217 239 228 347 q 342 65 260 130 l 342 570 l 33 570 l 33 667 l 304 667 l 304 863 l 76 863 l 76 960 l 304 960 l 304 1150 l 407 1150 l 407 960 l 608 960 l 608 863 l 407 863 l 407 667 l 629 667 l 629 570 l 445 570 l 445 358 l 640 358 l 640 260 l 445 260 l 445 5 q 673 -38 543 -33 q 1367 -33 928 -38 q 1335 -136 1345 -92 q 640 -136 922 -141 q 190 103 309 -125 q 81 -184 152 -76 q 22 -60 54 -119 m 711 532 l 1280 532 l 1280 43 l 1177 43 l 1177 103 l 814 103 l 814 38 l 711 38 l 711 532 m 646 1004 l 646 1096 l 1291 1096 q 1275 781 1286 906 q 1112 624 1259 624 q 944 624 1042 618 q 922 732 933 678 q 1090 722 1020 716 q 1177 808 1172 722 q 1194 1004 1188 884 l 933 1004 q 705 575 922 694 q 640 662 678 613 q 830 1004 825 765 l 646 1004 m 1177 439 l 814 439 l 814 195 l 1177 195 l 1177 439 z "
            },
            "": {
                ha: 1389,
                x_min: 27,
                x_max: 1367,
                o: "m 27 -71 q 136 488 130 114 l 228 483 q 212 233 228 347 q 336 71 260 130 l 336 570 l 33 570 l 33 662 l 298 662 l 298 863 l 76 863 l 76 955 l 298 955 l 298 1150 l 391 1150 l 391 955 l 602 955 l 602 863 l 391 863 l 391 662 l 624 662 l 624 570 l 434 570 l 434 353 l 608 353 l 608 260 l 434 260 l 434 11 q 667 -38 532 -33 q 1367 -33 982 -38 q 1335 -136 1345 -92 q 640 -136 944 -136 q 190 98 315 -130 q 81 -184 157 -76 q 27 -71 54 -119 m 770 87 q 987 336 895 206 q 917 808 933 521 l 760 808 l 760 347 q 895 467 819 396 q 917 369 906 418 q 754 222 836 298 q 694 152 727 195 l 624 222 q 667 353 667 277 l 667 895 l 911 895 q 911 1156 911 1020 l 998 1156 q 1004 895 998 1031 l 1340 895 l 1340 808 l 1009 808 q 1058 445 1020 597 q 1183 711 1134 575 l 1270 673 q 1096 326 1199 488 q 1156 201 1118 255 q 1204 163 1177 163 q 1232 212 1221 163 q 1253 423 1242 298 q 1345 385 1313 396 q 1318 168 1335 239 q 1215 49 1297 49 q 1085 125 1139 49 q 1025 233 1053 174 q 846 27 944 119 q 770 87 819 54 m 1074 1101 l 1145 1150 q 1280 993 1204 1085 l 1199 939 q 1074 1101 1128 1036 z "
            },
            "": {
                ha: 1389,
                x_min: 618,
                x_max: 770,
                o: "m 770 776 l 738 250 l 656 250 l 618 776 l 618 993 l 770 993 l 770 776 m 765 0 l 624 0 l 624 141 l 765 141 l 765 0 z "
            },
            "": {
                ha: 1389,
                x_min: 71,
                x_max: 1280,
                o: "m 662 651 q 1090 939 890 792 l 71 939 l 71 1053 l 1280 1053 l 1280 917 q 781 591 1036 754 l 781 92 q 727 -92 781 -38 q 543 -146 678 -146 q 326 -141 467 -146 q 304 -11 315 -76 q 532 -27 434 -27 q 662 98 662 -27 l 662 651 z "
            },
            "": {
                ha: 1389,
                x_min: 16,
                x_max: 1373,
                o: "m 16 483 q 347 1156 233 781 l 456 1123 q 326 808 396 955 l 326 -179 l 222 -179 l 222 602 q 65 363 146 467 q 16 483 43 423 m 1150 624 l 1237 836 l 662 836 q 526 602 597 705 q 445 667 488 635 q 684 1156 597 890 l 792 1112 q 716 939 754 1020 l 1345 939 l 1345 825 l 1248 586 q 1150 624 1188 608 m 846 732 l 955 732 l 955 16 q 787 -163 955 -163 q 608 -163 711 -163 q 586 -43 602 -109 q 760 -54 694 -54 q 846 38 846 -60 l 846 732 m 722 499 q 521 38 629 277 q 418 81 477 60 q 618 532 532 304 l 722 499 m 1166 537 q 1373 98 1259 347 l 1270 49 q 1069 499 1183 266 l 1166 537 z "
            },
            "": {
                ha: 1389,
                x_min: 22,
                x_max: 1313,
                o: "m 618 895 q 825 559 727 732 q 716 505 770 537 q 673 608 694 559 q 114 548 380 575 l 65 662 q 201 798 146 705 q 304 971 255 873 l 54 971 l 54 1074 l 830 1074 l 830 971 l 434 971 q 228 662 331 803 q 618 694 423 673 q 526 846 575 776 l 618 895 m 60 374 l 380 374 l 380 543 l 488 543 l 488 374 l 798 374 l 798 277 l 488 277 l 488 38 q 819 81 651 60 q 825 -27 819 33 q 54 -130 439 -71 l 22 -16 q 380 22 195 0 l 380 277 l 60 277 l 60 374 m 1199 1156 l 1313 1156 l 1313 5 q 1145 -163 1313 -163 q 949 -163 1090 -163 q 928 -38 939 -103 q 1112 -49 1047 -49 q 1199 38 1199 -49 l 1199 1156 m 901 1009 l 1015 1009 l 1015 146 l 901 146 l 901 1009 z "
            },
            "": {
                ha: 1389,
                x_min: 22,
                x_max: 1367,
                o: "m 152 483 l 315 483 l 315 781 l 412 781 l 412 483 l 586 483 l 586 391 l 412 391 l 412 206 q 597 233 510 222 q 597 136 597 201 q 412 114 499 125 l 412 -190 l 315 -190 l 315 103 q 33 65 168 81 l 22 168 q 315 195 174 179 l 315 391 l 49 391 l 49 477 q 174 852 119 678 l 33 852 l 33 944 l 201 944 q 260 1156 233 1053 l 363 1134 q 304 944 336 1036 l 602 944 l 602 852 l 271 852 q 152 483 212 656 m 684 629 l 792 629 l 792 326 q 1118 575 966 429 l 1204 510 q 792 217 998 320 l 792 43 q 884 -43 792 -43 l 1069 -43 q 1177 38 1161 -43 q 1199 239 1194 125 q 1302 201 1210 233 q 1275 5 1291 98 q 1085 -141 1253 -141 l 852 -141 q 684 16 684 -141 l 684 629 m 1009 1139 l 987 1101 q 1367 689 1139 808 q 1297 602 1324 640 q 922 1004 1080 727 q 570 586 765 743 q 499 662 537 629 q 879 1139 738 846 l 1009 1139 z "
            },
            0: {
                ha: 868,
                x_min: 0,
                x_max: 696,
                o: "m 0 868 l 696 868 l 696 693 l 0 693 l 0 868 m 696 0 l 0 0 l 0 175 l 696 175 l 696 0 m 0 694 l 175 694 l 175 174 l 0 174 l 0 694 m 521 694 l 696 694 l 696 174 l 521 174 l 521 694 z "
            },
            1: {ha: 521, x_min: 0, x_max: 347, o: "m 174 0 l 347 0 l 347 868 l 0 868 l 0 694 l 174 694 l 174 0 z "},
            2: {
                ha: 868,
                x_min: 0,
                x_max: 694,
                o: "m 0 868 l 0 694 l 521 694 l 521 521 l 0 521 l 0 0 l 694 0 l 694 174 l 174 174 l 174 347 l 694 347 l 694 868 l 0 868 z "
            },
            3: {
                ha: 868,
                x_min: 0,
                x_max: 694,
                o: "m 694 0 l 694 868 l 0 868 l 0 694 l 521 694 l 521 521 l 0 521 l 0 347 l 521 347 l 521 174 l 0 174 l 0 0 l 694 0 z "
            },
            4: {
                ha: 868,
                x_min: 0,
                x_max: 694,
                o: "m 521 347 l 174 347 l 174 868 l 0 868 l 0 174 l 521 174 l 521 0 l 694 0 l 694 868 l 521 868 l 521 347 z "
            },
            5: {
                ha: 868,
                x_min: 0,
                x_max: 694,
                o: "m 694 694 l 694 868 l 0 868 l 0 347 l 521 347 l 521 174 l 0 174 l 0 0 l 694 0 l 694 521 l 174 521 l 174 694 l 694 694 z "
            },
            6: {
                ha: 868,
                x_min: 0,
                x_max: 694,
                o: "m 0 869 l 175 869 l 175 0 l 0 0 l 0 869 m 174 519 l 694 519 l 694 346 l 174 346 l 174 519 m 174 869 l 519 869 l 519 694 l 174 694 l 174 869 m 174 174 l 694 174 l 694 0 l 174 0 l 174 174 m 521 347 l 694 347 l 694 174 l 521 174 l 521 347 z "
            },
            7: {
                ha: 868,
                x_min: 0,
                x_max: 694,
                o: "m 0 868 l 0 694 l 521 694 l 521 521 l 694 521 l 694 868 l 0 868 m 347 347 l 521 347 l 521 521 l 347 521 l 347 347 m 174 0 l 347 0 l 347 347 l 174 347 l 174 0 z "
            },
            8: {
                ha: 868,
                x_min: 0,
                x_max: 694,
                o: "m 0 868 l 174 868 l 174 0 l 0 0 l 0 868 m 521 868 l 694 868 l 694 0 l 521 0 l 521 868 m 174 174 l 521 174 l 521 0 l 174 0 l 174 174 m 174 868 l 521 868 l 521 693 l 174 693 l 174 868 m 174 521 l 521 521 l 521 346 l 174 346 l 174 521 z "
            },
            9: {
                ha: 868,
                x_min: 0,
                x_max: 696,
                o: "m 0 521 l 696 521 l 696 346 l 0 346 l 0 521 m 0 868 l 694 868 l 694 694 l 0 694 l 0 868 m 0 696 l 175 696 l 175 519 l 0 519 l 0 696 m 521 696 l 694 696 l 694 521 l 521 521 l 521 696 m 521 349 l 696 349 l 696 -1 l 521 -1 l 521 349 m 174 174 l 521 174 l 521 -1 l 174 -1 l 174 174 z "
            },
            "+": {
                ha: 694,
                x_min: 0,
                x_max: 521,
                o: "m 174 174 l 347 174 l 347 347 l 521 347 l 521 521 l 347 521 l 347 694 l 174 694 l 174 521 l 0 521 l 0 347 l 174 347 l 174 174 z "
            },
            "-": {ha: 694, x_min: 0, x_max: 521, o: "m 0 521 l 0 347 l 521 347 l 521 521 l 0 521 z "}
        },
        familyName: "Microsoft YaHei",
        ascender: 1636,
        descender: -296,
        underlinePosition: -119,
        underlineThickness: 80,
        boundingBox: {yMin: -186, xMin: -220, yMax: 1706, xMax: 1763},
        resolution: 1e3,
        original_font_information: {
            format: 0,
            copyright: "`2005 Microsoft Corporation. All rights reserved.",
            fontFamily: "Microsoft YaHei",
            fontSubfamily: "Regular",
            uniqueID: "Microsoft YaHei-Regular",
            fullName: "Microsoft YaHei",
            version: "Version 0.71",
            postScriptName: "MicrosoftYaHei",
            trademark: "Microsoft YaHei is either a registered trademark or a trademark of Microsoft Corporation in the United States and/or other countries.",
            manufacturer: "Microsoft Corporation",
            designer: "Founder",
            description: "Microsoft YaHei is a Simplified Chinese font developed by taking advantage of ClearType technology, and it provides excellent reading experience particularly onscreen. The font is very legible at small sizes.",
            manufacturerURL: "http://www.microsoft.com/typography",
            designerURL: "http://www.founder.com.cn/cn",
            licence: "\r\nNOTIFICATION OF LICENSE AGREEMENT \r\n\r\nThis font software is part of the Microsoft software product in which it was included and is provided under the end user license agreement (EULA) for that Microsoft software product. The terms and conditions of the EULA govern the use of font software. Please refer to the applicable Microsoft product EULA if you have any questions about how you may use this font software. Microsoft reserves all rights that are not expressly granted in the EULA. For products that may have installed this font please see the license link.\r\n",
            licenceURL: "http://www.microsoft.com/typography/fonts"
        },
        cssFontWeight: "normal",
        cssFontStyle: "normal"
    };
    (new (function (l) {
        if (l && l.__esModule) return l;
        var q = {};
        if (null != l) for (var e in l) Object.prototype.hasOwnProperty.call(l, e) && (q[e] = l[e]);
        return q.default = l, q
    }(require("./lib/three")).FontLoader)).load(JSON.stringify(q), function (q) {
        l = q
    }), exports.default = l;
});
define("js/gameCtrl.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var r = function () {
            function e(e, t) {
                for (var r = 0; r < t.length; r++) {
                    var o = t[r];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                }
            }

            return function (t, r, o) {
                return r && e(t.prototype, r), o && e(t, o), t
            }
        }(), o = e(require("./control/queryCtrl")), i = e(require("./control/modeCtrl")),
        a = e(require("./control/networkCtrl")), s = e(require("./control/reviewCtrl")),
        n = (require("./lib/animation"), require("./config")), l = e(require("./store/session")), h = function () {
            function e(r) {
                t(this, e), this.game = r
            }

            return r(e, [{
                key: "init", value: function () {
                    this.gameView = this.game.gameView, this.queryCtrl = new o.default(this.game), this.netWorkCtrl = new a.default(this.game), this.reviewCtrl = new s.default(this.game), this.modeCtrl = new i.default(this.game), this.model = this.game.gameModel, this.reporter = this.game.reporter, this.historyTimes = this.game.historyTimes, this.viewer = this.game.viewer, this.reUpLoadShowOverPage = !0
                }
            }, {
                key: "firstInitGame", value: function (e) {
                    this.queryCtrl.identifyMode(e), this.modeCtrl.initFirstPage(e)
                }
            }, {
                key: "identifyModeErr", value: function (e) {
                    this.gameView.showIdentifyModeErr(e)
                }
            }, {
                key: "onLoginSuccess", value: function () {
                    this.reporter.setTimer(n.REPORTERTIMEOUT), this.checkLaterUpLoad()
                }
            }, {
                key: "clickStart", value: function () {
                    this.modeCtrl.clickStart()
                }
            }, {
                key: "showFriendRank", value: function () {
                    this.modeCtrl.showFriendRank()
                }
            }, {
                key: "initReview", value: function (e, t) {
                    this.reviewCtrl.init(e, t)
                }
            }, {
                key: "quitReview", value: function () {
                    this.reviewCtrl.destroy()
                }
            }, {
                key: "reviewReturn", value: function (e) {
                    "group" == e ? this.modeCtrl.showGroupRankPage() : (e = "friends") && this.modeCtrl.showFriendRank(!0)
                }
            }, {
                key: "clickRank", value: function () {
                    this.modeCtrl.clickRank()
                }
            }, {
                key: "gameOver", value: function (e) {
                    if ("relay" != this.model.mode) {
                        if (this.reviewCtrl.isInThisPage || this.model.setScore(e), "observe" != this.model.mode) {
                            var t = this.model.getHighestScore();
                            this.netWorkCtrl.requestMmpayTimeout(), this.historyTimes.addOne();
                            var r = this.historyTimes.getTimes();
                            this.reporter.playGameReport(e, t, r), this.netWorkCtrl.upDateFriendsScoreList(), this.netWorkCtrl.updateUserInfo()
                        }
                        "player" == this.model.mode && this.reporter.playAudienceReport(), "battle" == this.model.mode && this.reporter.playPKReport(e), this.reporter.sendReport()
                    }
                }
            }, {
                key: "gameOverShowPage", value: function () {
                    var e = this;
                    if ("relay" != this.model.mode) if (this.reUpLoadShowOverPage = !0, "observe" == this.model.mode) this.modeCtrl.showGameOverPage(); else {
                        this.model.getHighestScore();
                        var t = this.model.weekBestScore, r = this.model.currentScore;
                        r < t ? (this.modeCtrl.showGameOverPage(), this.historyTimes.checkUp()) : function () {
                            var t = {
                                seed: e.game.randomSeed,
                                time_seed: e.game.time_seed,
                                action: e.game.actionList,
                                musicList: e.game.musicList,
                                touchList: e.game.touchList,
                                steps: e.game.touchMoveList,
                                timestamp: e.game.touchStartTime,
                                version: n.VERSION,
                                use_wangzhe: e.game.use_wangzhe,
                                use_mmpaybase: e.game.use_mmpaybase,
                                mmpay_status: e.game.mmpay_status,
                                mmpay_checksum: e.game.mmpay_checksum
                            };
                            console.log(e.game.use_wangzhe), console.log(e.game.use_mmpaybase), console.log(e.game.mmpay_status), console.log(e.game.mmpay_checksum);
                            var o = e.historyTimes.getTimes();
                            e.model.upLoadScoreData = {
                                currentScore: r,
                                gameTimes: o,
                                verifyData: t
                            }, e.netWorkCtrl.requestSettlement(r, o, e.afterRequestSettlement.bind(e), t)
                        }()
                    }
                }
            }, {
                key: "afterRequestSettlement", value: function (e, t, r) {
                    if (e) {
                        if (this.reUpLoadShowOverPage && this.modeCtrl.showGameOverPage(t), this.historyTimes.afterUpload(!0), "observe" == this.model.mode) return;
                        var o = this.model.upLoadScoreData.currentScore;
                        if (void 0 == o || t && t.banType) return;
                        o >= this.model.weekBestScore && (this.model.weekBestScore = o, this.model.saveWeekBestScore(o), o > this.model.getHighestScore() && this.model.saveHeighestScore(this.model.currentScore), r && r.playback_id && this.netWorkCtrl.setPlayBackIdTolocalStorage({playback_id: r.playback_id}))
                    } else this.netWorkCtrl.sendServerError(), this.showReUpLoadScoreModel(t)
                }
            }, {
                key: "showReUpLoadScoreModel", value: function (e) {
                    var t = this;
                    wx.showModal({
                        title: "",
                        content: ",(" + e + ")",
                        confirmText: "",
                        cancelText: "",
                        success: function (r) {
                            r.confirm ? t.reUploadScore() : r.cancel ? t.reUpLoadShowOverPage && t.showOverPage(!0) : t.showReUpLoadScoreModel(e)
                        },
                        fail: function () {
                            t.reUpLoadShowOverPage && t.showOverPage(!1)
                        }
                    })
                }
            }, {
                key: "showOverPage", value: function (e) {
                    if (this.modeCtrl.showGameOverPage(), e && "observe" != this.model.mode) {
                        if (!this.model.upLoadScoreData.verifyData || !this.model.upLoadScoreData.currentScore) return;
                        var t = this.model.getActionData(), r = this.model.upLoadScoreData.verifyData,
                            o = this.model.upLoadScoreData.currentScore;
                        t && t.ts > Date.now() && t.score >= o || this.model.saveLaterUpLoadScore(o, r)
                    }
                }
            }, {
                key: "reUploadScore", value: function () {
                    var e = this;
                    l.default.sessionId ? this.reUploadScore2() : this.netWorkCtrl.requestLogin(function (t) {
                        t ? e.reUploadScore2() : e.showReUpLoadScoreModel("n0")
                    })
                }
            }, {
                key: "reUploadScore2", value: function () {
                    var e = this.model.upLoadScoreData, t = e.currentScore, r = e.gameTimes, o = e.verifyData;
                    this.netWorkCtrl.requestSettlement(t, r, this.afterRequestSettlement.bind(this), o)
                }
            }, {
                key: "clickReplay", value: function () {
                    this.reporter.playAudienceReportStart(), this.modeCtrl.gameOverClickReplay()
                }
            }, {
                key: "friendRankReturn", value: function () {
                    this.modeCtrl.friendRankReturn()
                }
            }, {
                key: "netWorkLogin", value: function () {
                    this.netWorkCtrl.netWorkLogin()
                }
            }, {
                key: "shareGroupRank", value: function () {
                    this.modeCtrl.shareGroupRank()
                }
            }, {
                key: "afterShareGroupRank", value: function (e, t) {
                    this.reporter.shareGroupReport(t)
                }
            }, {
                key: "shareBattleCard", value: function () {
                    this.modeCtrl.shareBattleCard()
                }
            }, {
                key: "afterShareBattle", value: function (e, t) {
                    e && this.reporter.sharePKReport(t)
                }
            }, {
                key: "groupPlayGame", value: function () {
                    this.modeCtrl.groupPlayGame()
                }
            }, {
                key: "loginBattle", value: function (e) {
                    this.reporter.joinPKReport(e), this.reporter.playPKReportStart(e)
                }
            }, {
                key: "showPkPage", value: function (e) {
                    this.reporter.playPKScore(e)
                }
            }, {
                key: "onBattlePlay", value: function (e) {
                    this.modeCtrl.battlePlay(e)
                }
            }, {
                key: "battleToSingle", value: function () {
                    this.reporter.resetPKReport()
                }
            }, {
                key: "shareObservCard", value: function () {
                    this.modeCtrl.shareObservCard()
                }
            }, {
                key: "socketJoinSuccess", value: function (e) {
                    this.modeCtrl.socketJoinSuccess(e), "observe" == this.model.mode ? e ? (this.game.socketFirstSync = !0, this.reporter.joinAudienceReportStart()) : this.reporter.joinAudienceReport() : e && this.reporter.playAudienceReportStart()
                }
            }, {
                key: "afterShareObserveCard", value: function (e) {
                    this.reporter.shareAudienceReport(e)
                }
            }, {
                key: "showPlayerGG", value: function (e) {
                    this.modeCtrl.showPlayerGG(e)
                }
            }, {
                key: "showPlayerWaiting", value: function () {
                    this.modeCtrl.showPlayerWaiting()
                }
            }, {
                key: "onPlayerOut", value: function () {
                    this.modeCtrl.onPlayerOut()
                }
            }, {
                key: "onViewerStart", value: function () {
                    this.game.audioManager.scale_intro.stop(), this.game.deadTimeout && (clearTimeout(this.game.deadTimeout), this.game.deadTimeout = null), this.game.pendingReset = !1, this.modeCtrl.onViewerStart(), this.reporter.joinAudienceReport()
                }
            }, {
                key: "wxOnShow", value: function (e) {
                    var t = this;
                    this.netWorkCtrl.requestServerInit(), this.netWorkCtrl.requestMmpayTimeout(), this.reporter.setTimer(n.REPORTERTIMEOUT), setTimeout(function () {
                        e.query && e.query.hasOwnProperty("mode") ? (t.reUpLoadShowOverPage = !1, t.modeCtrl.reInitFirstPage(e), t.game.guider = !1) : "single" != t.model.mode && "player" != t.model.mode && "battle" != t.model.mode && "relay" != t.model.mode ? (t.reUpLoadShowOverPage = !1, t.modeCtrl.changeMode("singleCtrl"), t.game.guider = !1) : t.reviewCtrl.isInThisPage ? t.reviewCtrl.continue() : t.modeCtrl.wxOnShow()
                    }, 300)
                }
            }, {
                key: "wxOnhide", value: function () {
                    this.reporter.quitReport(), "observe" == this.model.mode ? this.reporter.joinAudienceReport() : this.reviewCtrl.isInThisPage && this.reviewCtrl.pausePlay(), this.netWorkCtrl.clearServerInit(), this.netWorkCtrl.clearMmpayTimeout(), this.reporter.clearTimer(), this.modeCtrl.wxOnhide()
                }
            }, {
                key: "onReplayGame", value: function () {
                    "observe" != this.model.mode && (this.reporter.playGameReportStart(), this.reporter.gameBeginReport())
                }
            }, {
                key: "onPeopleCome", value: function (e) {
                    0 == e.audience_cmd ? (this.viewer.peopleCome(e), this.reporter.playAudienceReportMaxPeople(this.viewer.num)) : 1 == e.audience_cmd && this.viewer.peopleOut(e)
                }
            }, {
                key: "onServerConfigForbid", value: function () {
                }
            }, {
                key: "onSocketCloseErr", value: function () {
                    "relay" === this.game.mode ? this.modeCtrl.onSocketCloseErr() : (this.gameView.showSocketCloseErr(), this.modeCtrl.changeMode("singleCtrl"))
                }
            }, {
                key: "appealNotify", value: function () {
                    this.modeCtrl.appealNotify()
                }
            }, {
                key: "checkLaterUpLoad", value: function (e) {
                    var t = this, r = this.model.getActionData();
                    if (r && r.ts > Date.now() && r.score) {
                        var o = r.score, i = r.data, a = this.historyTimes.getTimes();
                        e ? this.netWorkCtrl.requestSettlement(o, a, this.afterCheckLaterUpLoad.bind(this, o), i) : wx.showModal({
                            title: "",
                            content: "",
                            confirmText: "",
                            cancelText: "",
                            success: function (e) {
                                e.confirm ? t.netWorkCtrl.requestSettlement(o, a, t.afterCheckLaterUpLoad.bind(t, o), i) : e.cancel ? t.model.clearLaterUpLoadScore() : t.checkLaterUpLoad()
                            },
                            fail: function () {
                                t.checkLaterUpLoad()
                            }
                        })
                    }
                }
            }, {
                key: "afterCheckLaterUpLoad", value: function (e, t, r) {
                    var o = this;
                    if (t) return wx.showToast({
                        title: "",
                        icon: "success",
                        duration: 1e3
                    }), this.model.clearLaterUpLoadScore(), e > this.model.weekBestScore && (this.model.weekBestScore = e, this.model.saveWeekBestScore(e)), void(e > this.model.highestScore && this.model.saveHeighestScore(e));
                    wx.showModal({
                        title: "",
                        content: ",(" + r + ")",
                        confirmText: "",
                        cancelText: "",
                        success: function (e) {
                            e.confirm ? o.checkLaterUpLoad(!0) : e.cancel || o.afterCheckLaterUpLoad(!1, r)
                        },
                        fail: function () {
                            o.afterCheckLaterUpLoad(!1, r)
                        }
                    })
                }
            }, {
                key: "onSocketOpen", value: function () {
                    this.modeCtrl.onSocketOpen()
                }
            }, {
                key: "gotoRelayMode", value: function () {
                    this.reporter.reportGotoRelayMode(), this.modeCtrl.gotoRelayMode()
                }
            }, {
                key: "skipRelayBeginner", value: function () {
                    this.modeCtrl.skipRelayBeginner()
                }
            }, {
                key: "outRelay1", value: function () {
                    this.modeCtrl.outRelay1()
                }
            }, {
                key: "outRelay2", value: function () {
                    this.modeCtrl.outRelay2()
                }
            }, {
                key: "startRelay", value: function (e) {
                    this.modeCtrl.startRelay(e)
                }
            }, {
                key: "watchRelay", value: function () {
                    this.modeCtrl.watchRelay()
                }
            }, {
                key: "replayRelay", value: function () {
                    this.modeCtrl.replayRelay()
                }
            }, {
                key: "shareRelay", value: function () {
                    this.modeCtrl.shareRelay()
                }
            }]), e
        }();
    exports.default = h;
});
define("js/gameModel.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var a = function () {
        function e(e, t) {
            for (var a = 0; a < t.length; a++) {
                var i = t[a];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, a, i) {
            return a && e(t.prototype, a), i && e(t, i), t
        }
    }(), i = e(require("./store/storage")), n = e(require("./store/session")), r = function () {
        function e(a) {
            t(this, e), this.game = a, this.mode = "", this.stage = "", this.is_from_wn = 0, this.firstBlood = !1, this.currentScore = 0, this.highestScore = 0, this.observeInfo = {}, this.friendsScore = [], this.weekBestScore = 0, this.startTime = Math.floor(Date.now() / 1e3), this.upLoadScoreData = {}, this.relayInfo = {}, this.groupListData = !1
        }

        return a(e, [{
            key: "setMode", value: function (e) {
                this.mode = e, this.game.mode = e
            }
        }, {
            key: "setStage", value: function (e) {
                this.stage = e, this.game.stage = e
            }
        }, {
            key: "init", value: function () {
                n.default.init(), i.default.getFirstBlood() || (this.setFirstBlood(!0), i.default.saveFirstBlood()), this.highestScore = i.default.getHeighestScore() || 0, n.default.setServerConfig(i.default.getServerConfig()), this.weekBestScore = i.default.getWeekBestScore() || 0, this.friendsScore = i.default.getFriendsScore()
            }
        }, {
            key: "getServerConfig", value: function () {
                return n.default.serverConfig
            }
        }, {
            key: "setIsFromWn", value: function (e) {
                this.is_from_wn = e, this.game.is_from_wn = e
            }
        }, {
            key: "setFirstBlood", value: function (e) {
                this.firstBlood = e, this.game.firstBlood = e
            }
        }, {
            key: "getMode", value: function () {
                return this.mode
            }
        }, {
            key: "setScore", value: function (e) {
                this.currentScore = e
            }
        }, {
            key: "saveHeighestScore", value: function (e) {
                i.default.saveHeighestScore(e), this.highestScore = e
            }
        }, {
            key: "saveLaterUpLoadScore", value: function (e, t) {
                if (e && t) {
                    var a = {ts: this.getNextSunday(), score: e, data: t};
                    i.default.saveActionData(a)
                }
            }
        }, {
            key: "clearLaterUpLoadScore", value: function () {
                i.default.saveActionData("")
            }
        }, {
            key: "saveWeekBestScore", value: function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = {ts: this.getNextSunday(), data: e};
                i.default.saveWeekBestScore(t)
            }
        }, {
            key: "getActionData", value: function () {
                return i.default.getActionData()
            }
        }, {
            key: "getHighestScore", value: function () {
                return this.highestScore
            }
        }, {
            key: "saveFriendsScore", value: function (e) {
                this.friendsScore = e;
                var t = {ts: this.getNextSunday(), data: e};
                i.default.saveFriendsScore(t)
            }
        }, {
            key: "getSessionId", value: function () {
                return n.default.sessionId
            }
        }, {
            key: "getPkId", value: function () {
                return n.default.pkId
            }
        }, {
            key: "clearPkId", value: function () {
                n.default.clearPkId()
            }
        }, {
            key: "setShareTicket", value: function (e) {
                n.default.setShareTicket(e)
            }
        }, {
            key: "getShareTicket", value: function () {
                return n.default.shareTicket
            }
        }, {
            key: "clearShareTicket", value: function () {
                n.default.clearShareTicket()
            }
        }, {
            key: "setGameId", value: function (e) {
                n.default.setGameId(e)
            }
        }, {
            key: "setGameTicket", value: function (e) {
                n.default.setGameTicket(e)
            }
        }, {
            key: "clearGameId", value: function () {
                n.default.clearGameId()
            }
        }, {
            key: "clearGameTicket", value: function () {
                n.default.clearGameTicket()
            }
        }, {
            key: "setObserveInfo", value: function (e) {
                this.observeInfo.headimg = e.headimg, this.observeInfo.nickName = e.nickName
            }
        }, {
            key: "clearObserveInfo", value: function () {
                this.observeInfo.headimg = null, this.observeInfo.nickName = null
            }
        }, {
            key: "getIsRelayNewBie", value: function () {
                var e = !i.default.getRelayNewBie();
                return e && i.default.setRelayNewBie(), e
            }
        }, {
            key: "getNextSunday", value: function () {
                var e = new Date, t = e.getDay();
                e.setHours(0, 0, 0, 0);
                var a = 7 - t + 1;
                return 8 == a && (a = 1), e.valueOf() + 24 * a * 60 * 60 * 1e3
            }
        }, {
            key: "setGroupRankData", value: function (e, t) {
                this.groupListData = {list: e, userInfo: t}
            }
        }, {
            key: "getGroupRankData", value: function () {
                var e = this.groupListData;
                return !(!e || !e.userInfo) && {list: e.list, userInfo: e.userInfo}
            }
        }]), e
    }();
    exports.default = r;
});
define("js/gameView.js", function (require, module, exports) {
    "use strict";

    function o(o, e) {
        if (!(o instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var e = function () {
        function o(o, e) {
            for (var n = 0; n < e.length; n++) {
                var t = e[n];
                t.enumerable = t.enumerable || !1, t.configurable = !0, "value" in t && (t.writable = !0), Object.defineProperty(o, t.key, t)
            }
        }

        return function (e, n, t) {
            return n && o(e.prototype, n), t && o(e, t), e
        }
    }(), n = function () {
        function n(e) {
            o(this, n), this.game = e
        }

        return e(n, [{
            key: "init", value: function () {
            }
        }, {
            key: "showIdentifyModeErr", value: function (o) {
                this.showModal(o)
            }
        }, {
            key: "showNoSession", value: function () {
                this.showModal()
            }
        }, {
            key: "showGetPkIdFail", value: function () {
                this.showModal()
            }
        }, {
            key: "showGroupShareFail", value: function () {
                var o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ",";
                this.showModal(o)
            }
        }, {
            key: "showGoToBattleFail", value: function () {
                this.showModal()
            }
        }, {
            key: "showUploadPkScoreFail", value: function () {
                this.showModal("")
            }
        }, {
            key: "showShareObserveCardFail", value: function (o) {
                this.showModal(o)
            }
        }, {
            key: "showObserveStateFail", value: function () {
                this.showModal("")
            }
        }, {
            key: "showModal", value: function () {
                var o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ",";
                wx.showModal({title: "", content: o, showCancel: !1})
            }
        }, {
            key: "showServeConfigForbiddenObserveMode", value: function () {
                this.showModal("")
            }
        }, {
            key: "showServeConfigForbiddenGroupShare", value: function () {
                this.showModal("")
            }
        }, {
            key: "showSocketCloseErr", value: function () {
            }
        }, {
            key: "showJoinRelayFail", value: function () {
                var o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                this.showModal("(" + o + ")")
            }
        }, {
            key: "showVersionMismatching", value: function () {
                this.showModal(",")
            }
        }, {
            key: "showJoinRelayFail2", value: function () {
                this.showModal("")
            }
        }, {
            key: "showJoinNextRoomFail", value: function () {
                this.showModal("")
            }
        }, {
            key: "showSyncopErr", value: function () {
            }
        }]), n
    }();
    exports.default = n;
});
define("js/ground.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var a = t[n];
                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a)
                }
            }

            return function (t, n, a) {
                return n && e(t.prototype, n), a && e(t, a), t
            }
        }(), n = function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e) for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            return t.default = e, t
        }(require("./lib/three")), a = require("./config"),
        r = (require("./lib/animation"), window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth),
        i = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth, o = function () {
            function o() {
                var t = this;
                e(this, o), this.obj = new n.Object3D, this.obj.name = "ground";
                var s = new n.PlaneGeometry(i / r * a.FRUSTUMSIZE, a.FRUSTUMSIZE);
                this.materials = [], this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.canvas.width = 64, this.canvas.height = 64;
                for (var c = [["rgba(215, 219, 230, 1)", "rgba(188, 190, 199, 1)"], ["rgba(255, 231, 220, 1)", "rgba(255, 196, 204, 1)"], ["rgba(255, 224, 163, 1)", "rgba(255, 202, 126, 1)"], ["rgba(255, 248, 185, 1)", "rgba(255, 245, 139, 1)"], ["rgba(218, 244, 255, 1)", "rgba(207, 233, 210, 1)"], ["rgba(219, 235, 255, 1)", "rgba(185, 213, 235, 1)"], ["rgba(216, 218, 255, 1)", "rgba(165, 176, 232, 1)"], ["rgba(207, 207, 207, 1)", "rgba(199, 196, 201, 1)"]], h = this, u = 0; u < 1; ++u) setTimeout(function (e) {
                    return function () {
                        h.generateLaserBodyCanvas(c[e][0], c[e][1]);
                        var t = new n.Texture(h.canvas);
                        t.needsUpdate = !0;
                        var a = new n.MeshBasicMaterial({map: t, opacity: 1, transparent: !0});
                        h.materials.push(a);
                        var r = new n.Mesh(s, a);
                        r.position.z = .1 * -(e + 1), r.name = e, r.updateMatrix(), r.matrixAutoUpdate = !1, h.obj.add(r)
                    }
                }(u), 1e3 * u);
                setTimeout(function () {
                    for (var e = 1; e < 1; ++e) t.obj.children[e].visible = !1
                }, 8e3), this.current = 0
            }

            return t(o, [{
                key: "generateLaserBodyCanvas", value: function (e, t) {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    var n = this.context.createLinearGradient(0, 0, 0, this.canvas.height);
                    n.addColorStop(0, e), n.addColorStop(1, t), this.context.fillStyle = n, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)
                }
            }, {
                key: "changeColor", value: function () {
                    return
                }
            }]), o
        }();
    exports.default = o;
});
define("js/index.js", function (require, module, exports) {
    "use strict";

    function t(t) {
        return t && t.__esModule ? t : {default: t}
    }

    function e(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function i() {
        var t = Date.now(), e = t - F;
        F = t, requestAnimationFrame(i, !0), e > 100 || U.update(e / 1e3)
    }

    var o = function () {
        function t(t, e) {
            for (var i = 0; i < e.length; i++) {
                var o = e[i];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o)
            }
        }

        return function (e, i, o) {
            return i && t(e.prototype, i), o && t(e, o), e
        }
    }();
    require("./weapp-adapter");
    var s = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(require("./lib/three")), n = t(require("./block")), r = t(require("./ui")), a = t(require("./wave")),
        h = t(require("./ground")), l = t(require("./bottle")), c = require("./config"),
        u = t(require("./ui/audioManager")), d = t(require("./tailSystem")), m = t(require("./lib/point-in-polygon")),
        g = t(require("./network/network")), b = t(require("./store/storage")), p = t(require("./store/session")),
        k = t(require("./rankSystem")), v = t(require("./network/socket")), f = t(require("./pages/full2D")),
        y = (t(require("./pages/singleSettlementPage")), require("./shareApp")), w = t(require("./viewer")),
        x = require("./lib/animation"), B = t(require("./store/historyTimes")), T = t(require("./network/reporter")),
        C = t(require("./gameCtrl")), S = t(require("./gameView")), j = t(require("./gameModel")),
        L = require("./random"), M = t(require("./control/instructionCtrl")),
        O = t(require("./control/relayInstructionCtrl")), R = t(require("./lib/mue/eventcenter")),
        z = t(require("./control/onebyoneCtrl")), A = require("util/encryption"),
        E = t(require("./network/relayMoniter")),
        P = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth,
        I = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth,
        q = wx.getSystemInfoSync() || {}, G = "ios" == q.platform, D = q.model, _ = function () {
            function t(i) {
                e(this, t), this.options = i, this.is_from_wn = 0, this.firstInit = !0, this.distance = 0, this.heightestScore = 0, this.stage = "", this.succeedTime = 0, this.lastAddBonus = -2, this.lastStage = "", this.deadTimeout = null, this.currentScore = 0, this.seq = 0, this.thirdBlock = null, this.straight = !0, this.firstBlood = !1, this.lastHardLevel = 200, this.guider = !1, this.hardDistances = [], this.socketFirstSync = !1, this.init(), this.randomSeed = this.generateSeed(), (0, L.setRandomSeed)(this.randomSeed), this.actionList = [], this.musicList = [], this.touchList = [], this.touchMoveList = [], this.onceTouchMoveList = [], this.touchStartTime = [], this.blocks = [], this.liveTime = 0, this.eggBlocksCount = [], this.eggBlocksTriggerCount = [], this.eggBlocksFailCount = [], this.eggBlocksSucceedCount = [], wx.setKeepScreenOn && wx.setKeepScreenOn({keepScreenOn: !0})
            }

            return o(t, [{
                key: "moveTo", value: function (t) {
                    this.camera.position.x = this.camera.position.x + t.x, this.camera.position.z = this.camera.position.z + t.z
                }
            }, {
                key: "moveGradually", value: function (t, e) {
                    if (this.animating && !this.guider) {
                        (0, x.TweenAnimation)(this.bottle.obj.position.x, this.bottle.obj.position.x - t.x, 500 * e, "Linear", function (t, e) {
                            void 0 !== t && (this.bottle.obj.position.x = t, e && (this.bottle.obj.position.x = -.098))
                        }.bind(this));
                        for (var i = 0, o = this.blocksInUse.length; i < o; ++i) (0, x.TweenAnimation)(this.blocksInUse[i].obj.position.x, this.blocksInUse[i].obj.position.x - t.x, 500 * e, "Linear", function (t) {
                            void 0 !== t && (this.obj.position.x = t)
                        }.bind(this.blocksInUse[i]));
                        this.blocks && this.blocks[0] && (0, x.TweenAnimation)(this.blocks[0].obj.position.x, this.blocks[0].obj.position.x - t.x, 500 * e, "Linear", function (t) {
                            void 0 !== t && (this.obj.position.x = t)
                        }.bind(this.blocks[0]))
                    } else this.camera.destination = [this.camera.position.x + t.x, this.camera.position.z + t.z], (0, x.TweenAnimation)(this.camera.position.x, this.camera.position.x + t.x, 500 * e, "Quad.easeOut", function (t) {
                        void 0 !== t && (this.camera.position.x = t)
                    }.bind(this)), (0, x.TweenAnimation)(this.camera.position.z, this.camera.position.z + t.z, 500 * e, "Quad.easeOut", function (t) {
                        void 0 !== t && (this.camera.position.z = t)
                    }.bind(this))
                }
            }, {
                key: "update", value: function (t) {
                    var e = this;
                    this.tailSystem && this.tailSystem.update(1e3 * t), this.bottle.update(t), this.renderer.shadowMap.enabled && (this.shadowTarget.position.x = this.bottle.obj.position.x, this.shadowTarget.position.z = this.bottle.obj.position.z, this.shadowLight.position.x = this.bottle.obj.position.x + 0, this.shadowLight.position.z = this.bottle.obj.position.z + 10);
                    for (var i = 0, o = this.blocksInUse.length; i < o; ++i) this.blocksInUse[i].update();
                    if (this.blocks && this.blocks[0] && this.blocks[0].update(), ("forerake" === this.bottle.status || "hypsokinesis" === this.bottle.status) && 5 != this.hit) for (var s = this.bottle.getBox(), n = "forerake" === this.bottle.status ? this.nextBlock.getBox() : this.currentBlock.getBox(), i = 0, o = s.length; i < o; ++i) if (s[i].intersectsBox(n)) {
                        0 == i ? (this.bottle.rotate(), this.suspendTimer && (clearTimeout(this.suspendTimer), this.suspendTimer = null)) : 1 == i ? (this.bottle.suspend(), this.suspendTimer && (clearTimeout(this.suspendTimer), this.suspendTimer = null)) : 2 != i || this.suspendTimer || (this.suspendTimer = setTimeout(function () {
                            e.bottle.suspend(), e.suspendTimer = null
                        }, 90 * this.distance));
                        break
                    }
                    if (this.bottle.obj.position.y <= c.BLOCK.height / 2 + .1 && "jump" === this.bottle.status && this.bottle.flyingTime > .3 && !this.pendingReset) {
                        if (1 === this.hit || 7 === this.hit) {
                            if (this.bottle.stop(), this.bottle.changeScorePos(0), this.succeed(), this.animating) return;
                            1 === this.hit ? (this.audioManager["combo" + Math.min(this.doubleHit + 1, 8)].seek(0), this.audioManager["combo" + Math.min(this.doubleHit + 1, 8)].play(), ++this.doubleHit, this.addWave(Math.min(this.doubleHit, 4)), this.bottle.showAddScore(1, !0, this.quick), this.UI.addScore(1, !0, this.quick), this.currentScore = this.UI.score, "observe" != this.mode && this.showCombo()) : (this.doubleHit = 0, this.UI.addScore(1, !1, this.quick), this.currentScore = this.UI.score, this.bottle.showAddScore(1, !1, this.quick)), this.audioManager.success.seek(0), this.audioManager.success.play(), "observe" == this.mode || "relay" == this.mode || this.gameCtrl.reviewCtrl.isInThisPage || this.rankSystem.update()
                        } else 2 === this.hit ? (this.bottle.stop(), this.bottle.obj.position.y = c.BLOCK.height / 2, this.bottle.obj.position.x = this.bottle.destination[0], this.bottle.obj.position.z = this.bottle.destination[1]) : 3 === this.hit ? (this.bottle.hypsokinesis(), this.audioManager.fall_2.play(), this.bottle.obj.position.y = c.BLOCK.height / 2) : 4 === this.hit || 5 === this.hit ? (this.bottle.forerake(), this.audioManager.fall_2.play(), this.bottle.obj.position.y = c.BLOCK.height / 2) : 0 === this.hit ? (this.bottle.fall(), this.audioManager.fall.play(), this.bottle.obj.position.y = c.BLOCK.height / 2) : 6 === this.hit ? (this.bottle.stop(), this.audioManager.fall.play(), this.bottle.obj.position.y = c.BLOCK.height / 2) : -1 === this.hit && (this.bottle.stop(), this.bottle.obj.position.y = c.BLOCK.height / 2, this.bottle.obj.position.x = 0);
                        if (0 === this.hit || 3 === this.hit || 4 === this.hit || 5 === this.hit || 6 === this.hit) {
                            if (this.guider) if (this.UI.score > 0) this.guider = !1; else {
                                if (!(this.liveTime > 3)) return void this.live();
                                this.guider = !1, this.full2D.hide2DGradually()
                            }
                            this.pendingReset = !0, this.currentScore = this.UI.score, this.reporter.addEggBlockReport(this.eggBlocksCount, this.eggBlocksTriggerCount, this.eggBlocksFailCount, this.eggBlocksSucceedCount), this.gameCtrl.gameOver(this.currentScore);
                            var r = this.mode;
                            this.deadTimeout = setTimeout(function () {
                                e.pendingReset = !1, "relay" == r || e.gameCtrl.reviewCtrl.isInThisPage || (x.TweenAnimation.killAll(), e.gameCtrl.gameOverShowPage()), "observe" == e.mode && e.instructionCtrl.onCmdComplete()
                            }, 2e3)
                        } else "observe" == this.mode && this.instructionCtrl.onCmdComplete();
                        "relay" == this.mode && setTimeout(function () {
                            R.default.emitSync(c.EVENT.NOWPLAYEROVER, {hit: e.hit})
                        }, 0 === this.hit || 3 === this.hit || 4 === this.hit || 5 === this.hit || 6 === this.hit ? 2e3 : 0)
                    }
                    this.renderer.render(this.scene, this.camera)
                }
            }, {
                key: "succeed", value: function (t) {
                    var e = this;
                    if (++this.succeedTime, this.musicScore = !1, this.lastSucceedTime = Date.now(), this.succeedTime % 15 == 0 && (t && t.noAnimation || this.ground.changeColor()), this.blocksInUse.length >= 9) {
                        var i = this.blocksInUse.shift();
                        i.obj.visible = !1, this.blocksPool.push(i)
                    }
                    var o = this.nextBlock.obj.position.clone().sub(this.currentBlock.obj.position);
                    this.bottle.obj.position.x = this.bottle.destination[0], this.bottle.obj.position.z = this.bottle.destination[1];
                    var s = this.thirdBlock;
                    if (this.audioManager.setTimerFlag(!0), !this.firstAnimating) {
                        if (this.guider && (this.guider = !1, this.full2D.hide2DGradually()), !this.animating) {
                            if (this.nextBlock.whenSucceed && this.nextBlock.whenSucceed(), !this.nextBlock.succeedTimer && void 0 === this.nextBlock.score && !this.nextBlock.musicName || t && t.noAnimation || "relay" == this.mode) t && t.musicScore && "relay" != this.mode && (31 == this.nextBlock.order && (this.nextBlock.score = this.mmpayScore), this.UI.addScore(this.nextBlock.score, !1, !1, !0), 32 == this.nextBlock.order && (this.relaxLeft += 2)); else {
                                var n = this.nextBlock;
                                this.musicTimer = setTimeout(function () {
                                    void 0 !== n.score && (2 == e.reviewVersion && 15 == n.order || (e.musicScore = !0, 31 == n.order && (n.score = e.mmpayScore), e.UI.addScore(n.score, !1, !1, !0), e.bottle.showAddScore(n.score, !1, !1, !0), R.default.emit(c.EVENT.TRIGGER_EGG, {order: n.order}))), n.musicName && (e.audioManager[n.musicName].seek(0), e.audioManager[n.musicName].play(), n.registerAudio && e.audioManager.register(n.musicName, function () {
                                        n.registerAudio()
                                    }, function () {
                                        n.registerEndAudio && n.registerEndAudio()
                                    })), n.succeedTimer && n.succeedTimer(e.UI.score), 32 == n.order && (e.relaxLeft += 2)
                                }, 2e3), this.audioManager.pop.seek(0), this.audioManager.pop.play()
                            }
                            var r = this.nextBlock.obj.position.clone(),
                                a = this.nextBlock.radius + this.distance + s.radius;
                            this.straight ? (r.x += a, this.bottle.lookAt("straight", r.clone())) : (r.z -= a, this.bottle.lookAt("left", r.clone())), s.obj.position.x = r.x, s.obj.position.z = r.z
                        }
                        var h = s.obj.position.clone().sub(this.nextBlock.obj.position), l = o.add(h);
                        l.x /= 2, l.z /= 2, this.scene.add(s.obj), this.currentBlock = this.nextBlock, this.nextBlock = s;
                        var u = l.length() / 10;
                        this.bottle.human.rotation.z = 0, this.bottle.human.rotation.x = 0, t && t.noAnimation ? (this.moveTo(l), s.body.position.y = c.BLOCK.height / 2 - s.height / 2, s.obj.visible = !0) : (this.bottle.squeeze(), s.popup(), c.GAME.canShadow && this.bottle.scatterParticles(), this.animating && (l.x = 19.8), this.cameraMoveDuration = u, this.moveGradually(l, u))
                    }
                }
            }, {
                key: "handleWxOnHideEvent", value: function () {
                    this.show = !1, "prepare" == this.bottle.status && (this.touchObserve = !0), this.animateTimer && (clearTimeout(this.animateTimer), this.animateTimer = null), this.onshowAnimateTimer && (clearTimeout(this.onshowAnimateTimer), this.onshowAnimateTimer = null), this.gameCtrl.wxOnhide()
                }
            }, {
                key: "init", value: function () {
                    var t = this;
                    b.default.getFirstBlood() || this.options.query.mode || (this.guider = !0), this.socketMonitor = new E.default({
                        report: this.report.bind(this),
                        duration: 13e3,
                        logMaxLength: 5e3
                    }), this.gameCtrl = new C.default(this), this.gameView = new S.default(this), this.gameModel = new j.default(this), this.instructionCtrl = new M.default(this), this.relayInstructionCtrl = new O.default(this), this.historyTimes = new B.default(this), this.reporter = new T.default, this.audioManager = new u.default(this), this.gameSocket = new v.default(this), this.scene = new s.Scene;
                    var e = c.FRUSTUMSIZE, i = I / P;
                    this.camera = new s.OrthographicCamera(e * i / -2, e * i / 2, e / 2, e / -2, -10, 85), this.camera.position.set(-17, 30, 26), this.camera.lookAt(new s.Vector3(13, 0, -4)), this.scene.add(this.camera), this.renderer = new s.WebGLRenderer({
                        antialias: !0,
                        canvas: canvas,
                        preserveDrawingBuffer: !0
                    }), window.renderer = this.renderer, this.blocksPool = [], this.blocksInUse = [], this.blocksRemoved = [], this.doubleHit = 0, G && (D.indexOf("iPhone 4") >= 0 || D.indexOf("iPhone 5") >= 0 || q.system.indexOf("iOS 9") >= 0 || q.system.indexOf("iOS 8") >= 0 || D.indexOf("iPhone 6") >= 0 && D.indexOf("iPhone 6s") < 0) ? (this.renderer.shadowMap.enabled = !1, c.GAME.canShadow = !1, this.renderer.setPixelRatio(1.5)) : void 0 !== q.benchmarkLevel && q.benchmarkLevel < 5 && -1 != q.benchmarkLevel ? (c.GAME.canShadow = !1, this.renderer.shadowMap.enabled = !1, this.renderer.setPixelRatio(window.devicePixelRatio ? G ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio : 1)) : (this.renderer.setPixelRatio(window.devicePixelRatio ? G ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio : 1), this.renderer.shadowMap.enabled = !0), this.renderer.setSize(I, P), this.renderer.localClippingEnabled = !0, this.ground = new h.default, this.ground.obj.position.z = -84, this.camera.add(this.ground.obj), this.waves = [];
                    for (g = 0; g < 4; ++g) {
                        var o = new a.default;
                        this.waves.push(o), o.obj.visible = !1, this.scene.add(o.obj)
                    }
                    var m = new s.MeshBasicMaterial({color: 16119285});
                    this.combo = new s.Mesh(new s.CircleGeometry(.6, 30), m), this.combo.name = "combo", this.combo.position.x = -50, this.combo.rotation.x = -Math.PI / 2, this.scene.add(this.combo), this.renderer.shadowMap.enabled && (this.shadowTarget = new s.Mesh(new s.PlaneGeometry(.1, .1), m), this.shadowTarget.visible = !1, this.shadowTarget.name = "shadowTarget", this.scene.add(this.shadowTarget)), this.currentBlock = new n.default(0), this.initNextBlock = this.nextBlock = new n.default(1), this.nextBlock.obj.position.x = 20, this.bottle = new l.default, this.bottle.obj.position.set(-10, -c.BLOCK.height / 2, 0), this.scene.add(this.bottle.obj), this.guider && (this.bottle.obj.position.set(-11, 50, 0), this.camera.position.x -= 19, setTimeout(function () {
                        t.bottle.showup()
                    }, 800), this.currentBlock.obj.position.x = -11, this.currentBlock.change(null, "gray", .7), this.scene.add(this.currentBlock.obj), this.guiderTimer = setInterval(function () {
                        t.bottle.velocity.vz = 0, t.bottle.velocity.vy = 150, t.direction = new s.Vector2(1, 0);
                        var e = new s.Vector3(1, 0, 0);
                        t.bottle.jump(e.normalize()), t.hit = t.checkHit2(t.bottle, t.currentBlock)
                    }, 3e3)), this.blocksInUse.push(this.nextBlock), this.blocksInUse.push(this.currentBlock);
                    for (var g = 2; g < 36; ++g) {
                        var p = new n.default(g);
                        this.blocksPool.push(p)
                    }
                    this.removeFromPool(), this.showRelaxScore = 0, this.relaxLeft = 0, this.onebyoneCtrl = new z.default(this, this.camera), this.full2D = new f.default({
                        camera: this.camera,
                        onClickRank: this.gameCtrl.clickRank.bind(this.gameCtrl),
                        onClickReplay: this.gameCtrl.clickReplay.bind(this.gameCtrl),
                        onClickShare: this.gameCtrl.shareBattleCard.bind(this.gameCtrl),
                        onClickStart: this.gameCtrl.clickStart.bind(this.gameCtrl),
                        onShowFriendRank: this.gameCtrl.showFriendRank.bind(this.gameCtrl),
                        onBattlePlay: this.gameCtrl.onBattlePlay.bind(this.gameCtrl),
                        onGroupShare: this.gameCtrl.shareGroupRank.bind(this.gameCtrl),
                        friendRankReturn: this.gameCtrl.friendRankReturn.bind(this.gameCtrl),
                        groupPlayGame: this.gameCtrl.groupPlayGame.bind(this.gameCtrl),
                        onLookersStart: this.gameCtrl.onViewerStart.bind(this.gameCtrl),
                        onReturnWechat: function () {
                            wx.exitMiniProgram()
                        },
                        onClickPureShare: function (e) {
                            (0, y.pureShare)(e, t.gameModel.currentScore)
                        },
                        newRelay: this.gameCtrl.gotoRelayMode.bind(this.gameCtrl),
                        outRelay1: this.gameCtrl.outRelay1.bind(this.gameCtrl),
                        outRelay2: this.gameCtrl.outRelay2.bind(this.gameCtrl),
                        startRelay: this.gameCtrl.startRelay.bind(this.gameCtrl),
                        watchRelay: this.gameCtrl.watchRelay.bind(this.gameCtrl),
                        replayRelay: this.gameCtrl.replayRelay.bind(this.gameCtrl),
                        shareRelay: this.gameCtrl.shareRelay.bind(this.gameCtrl),
                        quitRecord: this.gameCtrl.quitReview.bind(this.gameCtrl),
                        goRecord: this.gameCtrl.initReview.bind(this.gameCtrl),
                        skipRelayBeginner: this.gameCtrl.skipRelayBeginner.bind(this.gameCtrl)
                    }), this.UI = new r.default(this.scene, this.camera, this.full2D, this), c.GAME.canShadow && (this.tailSystem = new d.default(this.scene, this.bottle)), this.addLight(), this.bindEvent(), this.viewer = new w.default(this.camera), this.rankSystem = new k.default(this), setTimeout(function () {
                        t.audioManager.icon.play()
                    }, 300), this.UI.hideScore(), this.gameModel.init(), this.gameCtrl.init(), this.gameView.init(), wx.onShow(this.handleWxOnShowEvent.bind(this)), wx.onHide(this.handleWxOnHideEvent.bind(this)), wx.onError(this.handleWxOnError.bind(this)), wx.onAudioInterruptionBegin && wx.onAudioInterruptionBegin(this.handleInterrupt.bind(this)), this.gameCtrl.firstInitGame(this.options), wx.showShareMenu(), wx.onShareAppMessage(function () {
                        return {
                            title: "",
                            imageUrl: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJHS4AOib6MiaPhwEaqw1NPcZGtgAGTlVJ4lrBAGtchhnXanMyo7q7toRpD4DukV5F2TA/0?wx_fmt=png"
                        }
                    })
                }
            }, {
                key: "loopAnimate", value: function () {
                    var t = this;
                    this.animating = !0;
                    this.touchStartAnim({fromGuider: !0}), this.touchStartTimer = setTimeout(function () {
                        t.bottle.velocity.vz = Math.min(.719 * c.BOTTLE.velocityZIncrement, 180), t.bottle.velocity.vy = Math.min(c.BOTTLE.velocityY + .719 * c.BOTTLE.velocityYIncrement, 180);
                        var e = new s.Vector3(t.nextBlock.obj.position.x - t.bottle.obj.position.x, 0, t.nextBlock.obj.position.z - t.bottle.obj.position.z);
                        t.direction = new s.Vector2(t.nextBlock.obj.position.x - t.bottle.obj.position.x, t.nextBlock.obj.position.z - t.bottle.obj.position.z), t.hit = t.checkHit2(t.bottle, t.currentBlock, t.nextBlock), t.thirdBlock = t.generateNextBlock(), t.thirdBlock && t.thirdBlock.obj && (t.thirdBlock.obj.position.set(39.7, 0, 0), t.tailSystem && t.tailSystem.correctPosition(), x.TweenAnimation.kill("progress"), t.bottle.jump(e.normalize()), t.currentBlock.rebound(), t.animateTimer = setTimeout(function () {
                            console.log("loopAnimate loopAnimate"), t.loopAnimate()
                        }, 3e3))
                    }, 719)
                }
            }, {
                key: "animate", value: function () {
                    var t = this;
                    this.firstAnimating = !0;
                    for (var e = this, i = 0; i < 7; ++i) setTimeout(function (t) {
                        return function () {
                            if (("single" == e.mode && ("startPage" == e.stage || "friendRankList" == e.stage) || e.guider) && e.blocks && e.blocks.length < 7) {
                                var i = new n.default(-1, t);
                                i.showup(t), e.scene.add(i.obj), e.blocks.push(i), 0 == t && (this.nextBlock = i)
                            }
                        }
                    }(i), 200 * i);
                    this.animateTimer = setTimeout(function () {
                        if ("single" == e.mode && ("startPage" == e.stage || "friendRankList" == e.stage) || e.guider) {
                            t.bottle.velocity.vz = Math.min(.4 * c.BOTTLE.velocityZIncrement, 180), t.bottle.velocity.vy = Math.min(c.BOTTLE.velocityY + .4 * c.BOTTLE.velocityYIncrement, 180), t.direction = new s.Vector2(t.nextBlock.obj.position.x - t.bottle.obj.position.x, t.nextBlock.obj.position.z - t.bottle.obj.position.z);
                            var i = new s.Vector3(t.nextBlock.obj.position.x - t.bottle.obj.position.x, 0, t.nextBlock.obj.position.z - t.bottle.obj.position.z);
                            if (t.bottle.jump(i.normalize()), t.hit = -1, t.nextBlock = t.initNextBlock, t.blocks) {
                                for (var o = 0, n = t.blocks.length; o < n; ++o) x.customAnimation.to(t.blocks[o].hitObj.material, 1, {
                                    opacity: 0,
                                    delay: .2 * o + .5
                                });
                                for (var o = 1, n = t.blocks.length; o < n; ++o) x.customAnimation.to(t.blocks[o].obj.position, .5, {
                                    z: o % 2 == 0 ? 60 : -60,
                                    delay: .1 * o + 2.2
                                });
                                if (t.guider) {
                                    x.customAnimation.to(t.currentBlock.obj.position, .5, {z: -60, delay: 2.1});
                                    var r = t.currentBlock;
                                    setTimeout(function () {
                                        r.obj.visible = !1
                                    }, 3e3)
                                }
                                t.currentBlock = t.blocks[0], t.beginnerTimer = setTimeout(function () {
                                    if (("single" == e.mode && ("startPage" == e.stage || "friendRankList" == e.stage) || e.guider) && (e.guider && t.full2D.showBeginnerPage(), t.nextBlock.popup(), t.nextBlock.greenMaterial.color.setHex(6118749), t.nextBlock.whiteMaterial.color.setHex(11184810), t.scene.add(t.nextBlock.obj), t.blocks)) {
                                        for (var i = 1, o = t.blocks.length; i < o; ++i) t.blocks[i].obj.visible = !1;
                                        t.guider && (t.animating = !1), t.firstAnimating = !1
                                    }
                                }, 3e3), t.loopAnimateTimer = setTimeout(function () {
                                    "single" != e.mode || "startPage" != e.stage && "friendRankList" != e.stage || e.show && (console.log("loopAnimateTimer loopAnimateTimer loopAnimate"), t.loopAnimate())
                                }, 4500)
                            }
                        }
                    }, 1500)
                }
            }, {
                key: "handleWxOnShowEvent", value: function (t) {
                    (t.query && t.query.mode || this.options.query && this.options.query.mode) && (this.guider = !1), console.log("onshow ", t);
                    var e = this;
                    this.show = !0, this.reporter.enterReport(t.scene), this.guiderTimer && !this.guider && (clearInterval(this.guiderTimer), this.guiderTimer = null), this.onshowAnimateTimer = setTimeout(function (t) {
                        return function () {
                            "single" == e.mode && "startPage" == e.stage && !e.animateTimer && e.show && (e.blocks && e.blocks.length > 0 && !e.firstAnimating ? (console.log("onSHow loopAnimate"), e.loopAnimate()) : e.animating || !t || e.guider || (e.animating = !0, e.animate()))
                        }
                    }(this.firstInit), 1e3), this.firstInit ? this.firstInit = !1 : this.gameCtrl.wxOnShow(t)
                }
            }, {
                key: "showCombo", value: function () {
                    var t = this;
                    setTimeout(function () {
                        t.combo.position.set(t.nextBlock.obj.position.x, c.BLOCK.height / 2 + .15, t.nextBlock.obj.position.z)
                    }, 200)
                }
            }, {
                key: "hideCombo", value: function () {
                    this.combo.position.set(-30, 0, 0)
                }
            }, {
                key: "replayGame", value: function (t) {
                    this.currentScore = 0, this.gameCtrl.onReplayGame(), this.audioManager.restart.seek(0), this.audioManager.restart.play(), this.guider ? (this.guiderTimer && (clearInterval(this.guiderTimer), this.guiderTimer = null), this.animating = !0, this.animate(), this.moveGradually(new s.Vector3(19, 0, 0), 3), this.randomSeed = this.generateSeed(), (0, L.setRandomSeed)(this.randomSeed)) : (this.resetScene(t), this.bottle.showup())
                }
            }, {
                key: "addWave", value: function (t) {
                    for (var e = this, i = 0; i < t; ++i) setTimeout(function (t) {
                        return function () {
                            e.waves[t].obj.visible = !0, e.waves[t].obj.position.set(e.bottle.obj.position.x, c.BLOCK.height / 2 + .1 * t + 1, e.bottle.obj.position.z), (0, x.TweenAnimation)(e.waves[t].obj.scale.x, 4, 2 / (t / 2.5 + 2) * 500, "Linear", function (i, o) {
                                void 0 !== i && (e.waves[t].obj.scale.x = i, e.waves[t].obj.scale.y = i, e.waves[t].obj.scale.z = i)
                            }), (0, x.TweenAnimation)(e.waves[t].obj.material.opacity, 0, 2 / (t / 2.5 + 2) * 500, "Linear", function (i, o, s) {
                                void 0 !== i && (e.waves[t].obj.material.opacity = i, s && e.waves[t].reset())
                            })
                        }
                    }(i), 200 * i)
                }
            }, {
                key: "addLight", value: function () {
                    var t = new s.AmbientLight(16777215, .8);
                    if (this.shadowLight = new s.DirectionalLight(16777215, .28), this.shadowLight.position.set(0, 15, 10), this.renderer.shadowMap.enabled) {
                        this.shadowLight.castShadow = !0, this.shadowLight.target = this.shadowTarget, this.shadowLight.shadow.camera.near = 5, this.shadowLight.shadow.camera.far = 32, this.shadowLight.shadow.camera.left = -10, this.shadowLight.shadow.camera.right = 10, this.shadowLight.shadow.camera.top = 10, this.shadowLight.shadow.camera.bottom = -10, this.shadowLight.shadow.mapSize.width = 512, this.shadowLight.shadow.mapSize.height = 512;
                        var e = new s.PlaneGeometry(65, 25);
                        this.shadowGround = new s.Mesh(e, new s.ShadowMaterial({
                            transparent: !0,
                            color: 0,
                            opacity: .3
                        })), this.shadowGround.receiveShadow = !0, this.shadowGround.position.x = -25, this.shadowGround.position.y = -18, this.shadowGround.position.z = -15, this.shadowGround.rotation.x = -Math.PI / 2, this.shadowLight.add(this.shadowGround)
                    }
                    this.scene.add(this.shadowLight), this.scene.add(t)
                }
            }, {
                key: "checkHit2", value: function (t, e, i, o) {
                    var s = this.checkHit2Core(t, e, i, o);
                    if ("relay" == this.mode) {
                        s.translate.x = s.translate.x.toFixed(2), s.translate.y = s.translate.y.toFixed(2);
                        var n = "|cH:" + s.hit + ";fT:" + s.flyingTime + ",t:" + s.time + ",tsl:" + s.translate.x + "," + s.translate.y + ";dst:" + JSON.stringify(s.destination) + ",inY:" + s.initY + ",cb:" + this.currentBlock.order + "," + this.currentBlock.obj.position.x.toFixed(2) + "," + this.currentBlock.obj.position.z.toFixed(2) + ";nb:" + this.nextBlock.order + "," + this.nextBlock.obj.position.x.toFixed(2) + "," + this.nextBlock.obj.position.z.toFixed(2);
                        this.socketMonitor.log(n)
                    } else i && i.order >= 13 && (1 == s.hit || 7 == s.hit ? this.eggBlocksSucceedCount[i.order] = this.eggBlocksSucceedCount[i.order] ? this.eggBlocksSucceedCount[i.order] + 1 : 1 : 2 != s.hit && (this.eggBlocksFailCount[i.order] = this.eggBlocksFailCount[i.order] ? this.eggBlocksFailCount[i.order] + 1 : 1));
                    return s.hit
                }
            }, {
                key: "checkHit2Core", value: function (t, e, i, o) {
                    var n = t.velocity.vy / c.GAME.gravity * 2;
                    o = o || +t.obj.position.y.toFixed(2);
                    var r = c.BLOCK.height / 2 - o,
                        a = +((-t.velocity.vy + Math.sqrt(Math.pow(t.velocity.vy, 2) - 2 * c.GAME.gravity * r)) / -c.GAME.gravity).toFixed(2);
                    n = +(n -= a).toFixed(2);
                    var h = [], l = new s.Vector2(t.obj.position.x, t.obj.position.z),
                        u = this.direction.setLength(t.velocity.vz * n);
                    if (l.add(u), t.destination = [+l.x.toFixed(2), +l.y.toFixed(2)], h.push(+l.x.toFixed(2), +l.y.toFixed(2)), this.animating, i) {
                        var d, g = Math.pow(h[0] - i.obj.position.x, 2) + Math.pow(h[1] - i.obj.position.z, 2),
                            b = i.getVertices();
                        (0, m.default)(h, b) ? d = Math.abs(g) < .5 ? 1 : 7 : (0, m.default)([h[0] - c.BOTTLE.bodyWidth / 2, h[1]], b) || (0, m.default)([h[0], h[1] + c.BOTTLE.bodyDepth / 2], b) ? d = 5 : ((0, m.default)([h[0], h[1] - c.BOTTLE.bodyDepth / 2], b) || (0, m.default)([h[0] + c.BOTTLE.bodyDepth / 2, h[1]], b)) && (d = 3)
                    }
                    var p = e.getVertices();
                    return (0, m.default)(h, p) ? d = 2 : ((0, m.default)([h[0], h[1] + c.BOTTLE.bodyDepth / 2], p) || (0, m.default)([h[0] - c.BOTTLE.bodyWidth / 2, h[1]], p)) && (d = d ? 6 : 4), {
                        hit: d || 0,
                        flyingTime: n,
                        time: a,
                        translate: u,
                        destination: h,
                        initY: o
                    }
                }
            }, {
                key: "shuffleArray", value: function (t) {
                    for (var e = t.length - 1; e > 0; e--) {
                        var i = Math.floor((0, L.random)() * (e + 1)), o = t[e];
                        t[e] = t[i], t[i] = o
                    }
                }
            }, {
                key: "useBlock", value: function (t) {
                    for (var e, i = 0, o = t.length; i < o; ++i) for (var s = 0, n = this.blocksPool.length; s < n; ++s) if (this.blocksPool[s].order == t[i]) return this.blocksInUse.push(this.blocksPool[s]), e = this.blocksPool[s], this.blocksPool.splice(s, 1), e
                }
            }, {
                key: "generateNextBlock", value: function () {
                    var t;
                    if (2 === this.reviewVersion) ; else {
                        if (this.relaxLeft) return --this.relaxLeft, t = this.useBlock([33, 34, 35]);
                        if (this.UI.score - this.showRelaxScore >= 1e3) return t = this.useBlock([32]), this.showRelaxScore = this.UI.score, this.relaxLeft = 1, t
                    }
                    var e = 5;
                    this.UI.score > 1e3 ? e = 6 : this.succeedTime > 3e3 && (e = 7), this.animating || this.shuffleArray(this.blocksPool);
                    for (var i = 0, o = this.blocksPool.length; i < o; ++i) if (this.succeedTime - this.lastAddBonus >= e && this.blocksPool[i].order >= 13 || this.succeedTime - this.lastAddBonus < e && this.blocksPool[i].order < 13) {
                        if ((t = this.blocksPool[i]).order >= 13) {
                            if (this.lastBonusOrder && this.lastBonusOrder == t.order || this.UI.score < 100 && 29 == t.order || [32, 33, 34, 35].indexOf(t.order) >= 0) continue;
                            this.lastAddBonus = this.succeedTime, this.lastBonusOrder = t.order
                        }
                        this.blocksInUse.push(t), this.blocksPool.splice(i, 1);
                        break
                    }
                    if (!t) {
                        for (var s = this.blocksInUse.shift(); s.order >= 13;) s.obj.visible = !1, this.blocksPool.push(s), s = this.blocksInUse.shift();
                        t = s, this.blocksInUse.push(t)
                    }
                    return t.obj.visible = !1, t.change(), t
                }
            }, {
                key: "live", value: function () {
                    var t = this;
                    ++this.liveTime, setTimeout(function () {
                        t.resetScene(null, {bottleShowupAnimation: !0})
                    }, 2e3)
                }
            }, {
                key: "clearTimer", value: function () {
                    this.animateTimer && (clearTimeout(this.animateTimer), this.animateTimer = null), this.loopAnimateTimer && (clearTimeout(this.loopAnimateTimer), this.loopAnimateTimer = null), this.beginnerTimer && (clearTimeout(this.beginnerTimer), this.beginnerTimer = null), this.touchStartTimer && (clearTimeout(this.touchStartTimer), this.touchStartTimer = null), this.suspendTimer && (clearTimeout(this.suspendTimer), this.suspendTimer = null)
                }
            }, {
                key: "setSpecialBaseStatus", value: function (t) {
                    "relay" == this.mode ? this.use_mmpaybase = this.mmpay_status = this.use_wangzhe = !0 : (this.use_mmpaybase = t && void 0 !== t.use_mmpaybase ? t.use_mmpaybase : b.default.getMmpayBaseStatus(), this.mmpay_status = t && void 0 !== t.mmpay_status ? t.mmpay_status : b.default.getMmpayBonusStatus().status, this.mmpayScore = this.mmpay_status ? 20 : 5, this.mmpay_checksum = b.default.getMmpayBonusStatus().checksum, this.use_wangzhe = t && t.use_wangzhe || b.default.getWangZheBaseStatus())
                }
            }, {
                key: "removeFromPool", value: function (t) {
                    this.setSpecialBaseStatus(t);
                    var e;
                    e = 3 == (t && t.version || c.VERSION) ? [24, 26, 27] : [30, 31, 32, 33, 34, 35], !this.use_mmpaybase && e.indexOf(31) < 0 && e.push(31), !this.use_wangzhe && e.indexOf(30) < 0 && e.push(30), e.sort();
                    for (var i = e.length - 1; i >= 0; --i) for (var o = this.blocksPool.length - 1; o >= 0; --o) if (this.blocksPool[o].order === e[i]) {
                        var s = this.blocksPool.splice(o, 1);
                        this.blocksRemoved.push(s[0])
                    }
                }
            }, {
                key: "resetScene", value: function (t, e) {
                    if (this.reviewVersion = null, e && e.version && (this.reviewVersion = e.version), this.touchObserve = !1, this.firstAnimating = !1, this.myTurn = !1, this.clicked = !1, this.pendingReset = !1, this.blocks && this.blocks.length > 0) for (var i = 0, o = this.blocks.length; i < o; ++i) this.scene.remove(this.blocks[i].obj);
                    this.blocks = null, "observe" == this.mode && (this.audioManager.scale_intro.stop(), this.audioManager.scale_loop.stop()), this.randomSeed = t || this.generateSeed(), (0, L.setRandomSeed)(this.randomSeed), this.actionList = [], this.musicList = [], this.touchList = [], this.touchStartTime = [], this.touchMoveList = [], this.clearTimer(), this.currentBlock && this.currentBlock.reset(), x.TweenAnimation.killAll(), this.animating = !1, "relay" == this.mode && e && e.gameLevel ? 1 == e.gameLevel ? (c.BLOCK.minRadiusScale = .7, c.BLOCK.maxRadiusScale = .9, c.BLOCK.minDistance = 1, c.BLOCK.maxDistance = 19) : 2 == e.gameLevel && (c.BLOCK.minRadiusScale = .6, c.BLOCK.maxRadiusScale = .8, c.BLOCK.minDistance = 1, c.BLOCK.maxDistance = 20) : (c.BLOCK.minRadiusScale = .8, c.BLOCK.maxRadiusScale = 1, c.BLOCK.minDistance = 1, c.BLOCK.maxDistance = 17);
                    for (var i = 0, o = this.blocksInUse.length; i < o; ++i) (s = this.blocksInUse.pop()).obj.visible = !1, s.reset(), this.blocksPool.push(s);
                    for (var i = 0, o = this.blocksRemoved.length; i < o; ++i) {
                        var s = this.blocksRemoved.pop();
                        s.obj.visible = !1, s.reset(), this.blocksPool.push(s)
                    }
                    for (var i = 0, o = this.waves.length; i < o; ++i) this.waves[i].reset();
                    this.blocksPool.sort(function (t, e) {
                        return t.order - e.order
                    }), this.removeFromPool(e), this.currentBlock = this.blocksPool.shift(), this.currentBlock.obj.visible = !0, this.scene.add(this.currentBlock.obj), this.blocksInUse.push(this.currentBlock), this.shadowTarget && this.shadowTarget.position.set(0, 0, 0), this.nextBlock = this.blocksPool.shift(), this.currentBlock.change(null, null, 1), this.nextBlock.change(null, null, 1), this.nextBlock.obj.position.set(20, 0, 0), this.currentBlock.obj.position.set(0, 0, 0), this.nextBlock.obj.visible = !0, this.scene.add(this.nextBlock.obj), this.blocksInUse.push(this.nextBlock), this.bottle.reset(), this.thirdBlock = null, this.UI.reset(), this.rankSystem.reset(), this.hit = null, this.lastAddBonus = -2, this.lastBonusOrder = null, this.succeedTime = 0, this.doubleHit = 0, this.camera.position.set(-17, 30, 26), this.shadowLight.position.set(0, 15, 10), e && e.bottleShowupAnimation && (this.bottle.showup(), this.audioManager.restart.seek(0), this.audioManager.restart.play()), this.showRelaxScore = 0, this.relaxLeft = 0, this.eggBlocksCount = [], this.eggBlocksTriggerCount = [], this.eggBlocksFailCount = [], this.eggBlocksSucceedCount = [], wx.triggerGC && wx.triggerGC()
                }
            }, {
                key: "generateSeed", value: function () {
                    var t = b.default.getMyUserInfo();
                    if (t && t.open_id) {
                        var e = Date.now();
                        return this.time_seed = e, (0, A.encryptSeed)(e, t.open_id)
                    }
                    return g.default.sendServerError(7), null === t && g.default.sendServerError(8), this.time_seed = void 0, Date.now()
                }
            }, {
                key: "stopLoopMusic", value: function () {
                    this.audioManager.scale_intro && this.audioManager.scale_intro.stop(), this.audioManager.scale_loop && this.audioManager.scale_loop.stop(), this.stopBlockMusic()
                }
            }, {
                key: "generateHardDistances", value: function () {
                    for (var t = 2 + Math.floor(2 * (0, L.random)()), e = [], i = 0; i < t; ++i) i < t - 1 ? e.push(c.BLOCK.minDistance + 2 * (0, L.random)()) : e.push(c.BLOCK.maxDistance - 2 * (0, L.random)());
                    return e
                }
            }, {
                key: "touchStartAnim", value: function (t) {
                    this.stopBlockMusic(), this.bottle.prepare(), this.currentBlock.shrink(), t && t.fromGuider || (this.audioManager.scale_intro.seek(0), this.audioManager.scale_intro.play(), this.mouseDownTime = Date.now(), this.onceTouchMoveList = [])
                }
            }, {
                key: "touchEndAnim", value: function (t, e, i, o, n) {
                    "relay" == this.mode && x.TweenAnimation.kill("progress"), void 0 !== o && (this.musicScore = o), this.duration = t || (Date.now() - this.mouseDownTime) / 1e3, this.bottle.velocity.vz = Math.min(this.duration * c.BOTTLE.velocityZIncrement, 150), this.bottle.velocity.vz = +this.bottle.velocity.vz.toFixed(2), this.bottle.velocity.vy = Math.min(c.BOTTLE.velocityY + this.duration * c.BOTTLE.velocityYIncrement, 180), this.bottle.velocity.vy = +this.bottle.velocity.vy.toFixed(2), this.direction = new s.Vector2(this.nextBlock.obj.position.x - this.bottle.obj.position.x, this.nextBlock.obj.position.z - this.bottle.obj.position.z), this.direction.x = +this.direction.x.toFixed(2), this.direction.y = +this.direction.y.toFixed(2);
                    var r = new s.Vector3(this.direction.x, 0, this.direction.y);
                    if (this.hit = this.checkHit2(this.bottle, this.currentBlock, this.nextBlock, e), this.distance = c.BLOCK.minDistance + (0, L.random)() * (c.BLOCK.maxDistance - c.BLOCK.minDistance), this.distance = +this.distance.toFixed(2), this.straight = (0, L.random)() > .5 ? 1 : 0, 1 === this.hit || 7 === this.hit) {
                        var a = this.generateNextBlock();
                        a && a.order >= 13 && (this.eggBlocksCount[a.order] = this.eggBlocksCount[a.order] ? this.eggBlocksCount[a.order] + 1 : 1), this.thirdBlock = a, this.quick = void 0 === i ? Date.now() - this.lastSucceedTime < 800 || !1 : i, "relay" == this.mode && (this.quick = !1)
                    }
                    return n && n.noAnimation || (this.audioManager.scale_intro.stop(), this.audioManager.scale_loop.stop(), this.currentBlock.rebound(), this.bottle.jump(r.normalize()), this.hideCombo()), this.hit
                }
            }, {
                key: "bindEvent", value: function () {
                    var t = this, e = this;
                    R.default.on(c.EVENT.GOTOSINGLESTARTPAGE, function (e, i) {
                        console.log("GOTOSINGLESTARTPAGE loopAnimate"), t.loopAnimate()
                    }), R.default.on(c.EVENT.TRIGGER_EGG, function (e, i) {
                        var o = i.order;
                        t.eggBlocksTriggerCount[o] = t.eggBlocksTriggerCount[o] ? t.eggBlocksTriggerCount[o] + 1 : 1
                    }), e.instructionCtrl.bindCmdHandler(function (t) {
                        if (-1 == t.type) return e.gameCtrl.showPlayerGG(t.s), void e.instructionCtrl.onCmdComplete();
                        if (0 == t.type) return e.socketFirstSync = !0, e.bottle.reset(), e.UI.scoreText.changeStyle({textAlign: "center"}), e.UI.setScore(0), void e.instructionCtrl.onCmdComplete();
                        if (e.gameCtrl.showPlayerWaiting(), t.score != e.UI.score && (e.UI.score = t.score, e.UI.setScore(t.score)), t && t.b && t.b.vy) {
                            if (e.socketFirstSync && (e.socketFirstSync = !1, e.camera.position.set(t.ca.x, t.ca.y, t.ca.z), e.ground.obj.position.set(t.gd.x, t.gd.y, t.gd.z)), e.currentBlock.order != t.c.order || e.nextBlock.order != t.n.order) {
                                for (var i = 0, o = e.blocksInUse.length; i < o; ++i) {
                                    var n = e.blocksInUse.pop();
                                    e.scene.remove(n.obj), e.blocksPool.push(n)
                                }
                                var r = e.blocksPool.findIndex(function (e) {
                                    return e.order == t.c.order
                                });
                                e.currentBlock = e.blocksPool[r];
                                u = e.blocksPool.splice(r, 1);
                                e.blocksInUse.push(u[0]);
                                var a = e.blocksPool.findIndex(function (e) {
                                    return e.order == t.n.order
                                });
                                e.nextBlock = e.blocksPool[a];
                                u = e.blocksPool.splice(a, 1);
                                e.blocksInUse.push(u[0])
                            }
                            e.scene.add(e.currentBlock.obj), e.scene.add(e.nextBlock.obj), e.currentBlock.obj.visible = !0, e.nextBlock.obj.visible = !0, e.currentBlock.obj.position.x = t.c.x, e.currentBlock.obj.position.z = t.c.z, e.currentBlock.change(t.c.r, t.c.type, t.c.rs), e.nextBlock.obj.position.x = t.n.x, e.nextBlock.obj.position.z = t.n.z, e.nextBlock.change(t.n.r, t.n.type, t.n.rs), e.bottle.obj.position.set(t.b.x, c.BLOCK.height / 2, t.b.z), e.bottle.velocity.vz = t.b.vz, e.bottle.velocity.vy = t.b.vy, e.distance = t.di, e.straight = t.s;
                            var h = new s.Vector3(e.nextBlock.obj.position.x - e.bottle.obj.position.x, 0, e.nextBlock.obj.position.z - e.bottle.obj.position.z);
                            if (e.direction = new s.Vector2(e.nextBlock.obj.position.x - e.bottle.obj.position.x, e.nextBlock.obj.position.z - e.bottle.obj.position.z), e.checkHit2(e.bottle, e.currentBlock, e.nextBlock, t.b.y), e.quick = t.q, t.t) {
                                var l = e.blocksPool.findIndex(function (e) {
                                    return e.order == t.t.order
                                });
                                if (l > -1) {
                                    e.thirdBlock = e.blocksPool[l];
                                    var u = e.blocksPool.splice(l, 1);
                                    e.blocksInUse.push(e.thirdBlock)
                                } else e.thirdBlock = e.blocksInUse.find(function (e) {
                                    return e.order == t.t.order
                                }), e.thirdBlock && e.thirdBlock.obj && e.scene.remove(e.thirdBlock.obj);
                                e.thirdBlock.change(t.t.r, t.t.type, t.t.rs)
                            }
                            e.hit = t.h, e.tailSystem && e.tailSystem.correctPosition(), e.audioManager.scale_intro.seek(0), e.audioManager.scale_intro.play(), e.bottle.prepare(), e.currentBlock.shrink();
                            var d = {x: t.ca.x, y: t.ca.y, z: t.ca.z}, m = {x: t.gd.x, y: t.gd.y, z: t.gd.z};
                            e.stopBlockMusic(), e.instructionCtrl.icTimeout = setTimeout(function () {
                                e.audioManager.scale_intro.stop(), e.audioManager.scale_loop.stop(), 15 == e.currentBlock.order && e.currentBlock.hideGlow(), e.currentBlock.rebound(), e.camera.position.set(d.x, d.y, d.z), e.ground.obj.position.set(m.x, m.y, m.z), d = null, m = null, e.bottle.jump(h.normalize())
                            }, 1e3 * t.d), t = null
                        } else e.instructionCtrl.onCmdComplete()
                    }), e.gameSocket.onReciveCommand(function (t, i) {
                        "observe" == e.mode && e.instructionCtrl.onReceiveCommand(i, t)
                    }), e.gameSocket.onPeopleCome(function (t) {
                        e.gameCtrl.onPeopleCome(t)
                    }), e.gameSocket.onPlayerOut(function () {
                        e.gameCtrl.onPlayerOut()
                    }), e.gameSocket.onJoinSuccess(function (t) {
                        e.gameCtrl.socketJoinSuccess(t), "observe" == e.mode && (e.bottle.obj.position.set(8, -c.BLOCK.height / 2, 0), e.camera.position.set(-17, 30, 26), e.shadowLight.position.set(0, 15, 10), e.currentBlock && (e.currentBlock.obj.visible = !1), e.nextBlock && (e.nextBlock.obj.visible = !1))
                    }), e.gameSocket.onRelayCmdCome(e.relayInstructionCtrl.cmdCome.bind(e.relayInstructionCtrl)), canvas.addEventListener("touchstart", function (t) {
                        if (t.touches.length >= 2) e.touchObserve = !0; else if ("relay" == e.mode && "game" == e.stage && e.full2D.doTouchStartEvent(t), "relay" != e.mode || "game" != e.stage || !e.clicked && e.myTurn) if (e.gameCtrl.reviewCtrl.isInThisPage) e.full2D.doTouchStartEvent(t); else {
                            if (("single" == e.mode || "player" == e.mode) && "game" == e.stage && !e.is_from_wn && !e.guider && t.changedTouches[0].clientX < .13 * I && t.changedTouches[0].clientY > .88 * P) return "prepare" == e.bottle.status && (e.touchObserve = !0), void e.gameCtrl.shareObservCard();
                            if ("friendRankList" != e.stage && "battlePage" != e.stage && "groupRankList" != e.stage && "singleSettlementPgae" != e.stage && "startPage" != e.stage) if ("viewerWaiting" != e.stage && "viewerGG" != e.stage && "viewerOut" != e.stage) if ("relayRoom" != e.stage) {
                                if ("game" == e.stage) {
                                    if ("observe" === e.mode) return;
                                    if (!("prepare" !== e.bottle.status || e.pendingReset || e.guider && e.animating) && 1 == t.targetTouches.length) return e.touchObserve ? void(e.touchObserve = !1) : void e.handleInterrupt();
                                    "stop" !== e.bottle.status || e.pendingReset || e.guider && e.animating || e.touchStartAnim()
                                }
                            } else e.full2D.doTouchStartEvent(t); else e.full2D.doTouchStartEvent(t); else e.full2D.doTouchStartEvent(t)
                        }
                    });
                    canvas.addEventListener("touchcancel", function (t) {
                        e.handleInterrupt()
                    }), canvas.addEventListener("touchend", function (t) {
                        t.changedTouches[0].clientX, t.changedTouches[0].clientY;
                        if ("relay" == e.mode && "game" == e.stage && e.full2D.doTouchEndEvent(t), "relay" != e.mode || "game" != e.stage || !e.clicked && e.myTurn) if (e.gameCtrl.reviewCtrl.isInThisPage) e.full2D.doTouchEndEvent(t); else if ("singleSettlementPgae" != e.stage && "startPage" != e.stage) if ("viewerWaiting" != e.stage && "viewerGG" != e.stage && "viewerOut" != e.stage) if ("friendRankList" != e.stage) if ("battlePage" != e.stage) {
                            if ("groupRankList" != e.stage) return "relayRoom" == e.stage ? (console.log(e.stage), void e.full2D.doTouchEndEvent(t)) : void("game" == e.stage && ("prepare" !== e.bottle.status || e.pendingReset || e.guider && e.animating || (e.touchEndAnim(), "player" === e.mode && (++e.seq, e.gameSocket.sendCommand(e.seq, {
                                type: 1,
                                c: {
                                    x: e.currentBlock.obj.position.x,
                                    z: e.currentBlock.obj.position.z,
                                    order: e.currentBlock.order,
                                    type: e.currentBlock.type,
                                    r: e.currentBlock.radius,
                                    rs: e.currentBlock.radiusScale
                                },
                                n: {
                                    x: e.nextBlock.obj.position.x,
                                    z: e.nextBlock.obj.position.z,
                                    order: e.nextBlock.order,
                                    type: e.nextBlock.type,
                                    r: e.nextBlock.radius,
                                    rs: e.nextBlock.radiusScale
                                },
                                d: e.duration,
                                b: {
                                    x: e.bottle.obj.position.x,
                                    y: +e.bottle.obj.position.y.toFixed(2),
                                    z: e.bottle.obj.position.z,
                                    vy: e.bottle.velocity.vy,
                                    vz: e.bottle.velocity.vz
                                },
                                t: 1 === e.hit || 7 === e.hit ? {
                                    order: e.thirdBlock.order,
                                    type: e.thirdBlock.type,
                                    r: e.thirdBlock.radius,
                                    rs: e.thirdBlock.radiusScale
                                } : null,
                                h: e.hit,
                                di: e.distance,
                                s: e.straight,
                                q: e.quick,
                                ca: {x: e.camera.position.x, y: e.camera.position.y, z: e.camera.position.z},
                                gd: {x: e.ground.obj.position.x, y: e.ground.obj.position.y, z: e.ground.obj.position.z},
                                score: e.UI.score
                            })), "observe" != e.mode && "review" != e.mode && (e.actionList.push([e.duration, +e.bottle.obj.position.y.toFixed(2), e.quick]), e.musicList.push(e.musicScore), "relay" == e.mode && !e.isObserver && e.onebyoneCtrl.data && (e.clicked = !0, R.default.emitSync(c.EVENT.NOWPLAYERJUMP, {
                                jump_succ: 1 == e.hit || 7 == e.hit || 2 == e.hit ? 1 : 0,
                                msginfo: JSON.stringify({duration: e.duration, initY: +e.bottle.obj.position.y.toFixed(2)}),
                                msg_seq: e.onebyoneCtrl.data.msg_seq
                            })), e.touchStartTime.push(e.mouseDownTime), t.changedTouches && t.changedTouches[0] && (e.touchMoveList.push(e.onceTouchMoveList), e.touchList.push([t.changedTouches[0].clientX, t.changedTouches[0].clientY]))))));
                            e.full2D.doTouchEndEvent(t)
                        } else e.full2D.doTouchEndEvent(t); else e.full2D.doTouchEndEvent(t); else e.full2D.doTouchEndEvent(t); else e.full2D.doTouchEndEvent(t)
                    }), canvas.addEventListener("touchmove", function (t) {
                        if ("relay" == e.mode && "game" == e.stage && e.full2D.doTouchMoveEvent(t), "prepare" == e.bottle.status) {
                            if (e.onceTouchMoveList.length >= 10) return;
                            e.onceTouchMoveList.push(t.changedTouches[0].clientX, t.changedTouches[0].clientY)
                        }
                        "battlePage" != e.stage && "friendRankList" != e.stage && "groupRankList" != e.stage ? "relayRoom" != e.stage || e.full2D.doTouchMoveEvent(t) : e.full2D.doTouchMoveEvent(t)
                    })
                }
            }, {
                key: "report", value: function (t) {
                    Math.random() <= 1 && (console.log("" + t), g.default.logReport("|SM|:" + t))
                }
            }, {
                key: "stopBlockMusic", value: function () {
                    this.currentBlock.whenLeave && this.currentBlock.whenLeave(), this.currentBlock.musicName && this.audioManager[this.currentBlock.musicName].stop(), this.currentBlock.registerEndAudio && this.currentBlock.registerEndAudio(), this.audioManager.clearTimer(), this.audioManager.setTimerFlag(!1), this.musicTimer && (clearTimeout(this.musicTimer), this.musicTimer = null)
                }
            }, {
                key: "handleNetworkFucked", value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ",";
                    this.rollBackToSingle(), t && wx.showModal({title: "", content: e, showCancel: !1})
                }
            }, {
                key: "handleSocketFucked", value: function () {
                    this.gameSocket.close(), "player" == this.mode && (this.shareObservCardFail(), this.updateUI()), "observe" == this.mode && this.handleNetworkFucked(!0)
                }
            }, {
                key: "handleInterrupt", value: function () {
                    "prepare" == this.bottle.status && (this.bottle.velocity.vz = 0, this.bottle.velocity.vy = 150, this.bottle.jump(new s.Vector3(1, 0, 0).normalize()), this.currentBlock.rebound(), this.audioManager.scale_loop.stop(), this.direction = new s.Vector2(1, 0), this.hit = this.checkHit2(this.bottle, this.currentBlock, this.nextBlock))
                }
            }, {
                key: "relayBottleReset", value: function (t) {
                    this.bottle.reset(!0), this.bottle.obj.position.x = this.currentBlock.obj.position.x, this.bottle.obj.position.z = this.currentBlock.obj.position.z, t && t.noAnimation || (this.bottle.showup(), this.audioManager.restart.seek(0), this.audioManager.restart.play())
                }
            }, {
                key: "handleWxOnError", value: function (t) {
                    var e = (void 0 == p.default.serverConfig.bad_js_ratio ? 1e6 : p.default.serverConfig.bad_js_ratio) / 1e6 || 1;
                    Math.random() <= e && g.default.badReport(t.message, t.stack)
                }
            }, {
                key: "sendServerError", value: function (t) {
                    g.default.sendServerError(t)
                }
            }]), t
        }();
    if (wx.getLaunchOptionsSync) U = new _(wx.getLaunchOptionsSync()); else var U = new _;
    var F = Date.now(), K = requestAnimationFrame, V = [], H = void 0;
    window.requestAnimationFrame = function (t, e) {
        e ? H = t : V.push(t)
    }, function t() {
        var e = [], i = H;
        V.forEach(function (t) {
            e.push(t)
        }), H = void 0, V.length = 0, e.forEach(function (t) {
            "function" == typeof t && t()
        }), "function" == typeof i && i(), K(t)
    }(), i();
});
define("js/lib/aes.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = t || function (t, e) {
        var r = {}, i = r.lib = {}, n = function () {
        }, s = i.Base = {
            extend: function (t) {
                n.prototype = this;
                var e = new n;
                return t && e.mixIn(t), e.hasOwnProperty("init") || (e.init = function () {
                    e.$super.init.apply(this, arguments)
                }), e.init.prototype = e, e.$super = this, e
            }, create: function () {
                var t = this.extend();
                return t.init.apply(t, arguments), t
            }, init: function () {
            }, mixIn: function (t) {
                for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
                t.hasOwnProperty("toString") && (this.toString = t.toString)
            }, clone: function () {
                return this.init.prototype.extend(this)
            }
        }, o = i.WordArray = s.extend({
            init: function (t, e) {
                t = this.words = t || [], this.sigBytes = void 0 != e ? e : 4 * t.length
            }, toString: function (t) {
                return (t || a).stringify(this)
            }, concat: function (t) {
                var e = this.words, r = t.words, i = this.sigBytes;
                if (t = t.sigBytes, this.clamp(), i % 4) for (var n = 0; n < t; n++) e[i + n >>> 2] |= (r[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 24 - (i + n) % 4 * 8; else if (65535 < r.length) for (n = 0; n < t; n += 4) e[i + n >>> 2] = r[n >>> 2]; else e.push.apply(e, r);
                return this.sigBytes += t, this
            }, clamp: function () {
                var e = this.words, r = this.sigBytes;
                e[r >>> 2] &= 4294967295 << 32 - r % 4 * 8, e.length = t.ceil(r / 4)
            }, clone: function () {
                var t = s.clone.call(this);
                return t.words = this.words.slice(0), t
            }, random: function (e) {
                for (var r = [], i = 0; i < e; i += 4) r.push(4294967296 * t.random() | 0);
                return new o.init(r, e)
            }
        }), c = r.enc = {}, a = c.Hex = {
            stringify: function (t) {
                var e = t.words;
                t = t.sigBytes;
                for (var r = [], i = 0; i < t; i++) {
                    var n = e[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    r.push((n >>> 4).toString(16)), r.push((15 & n).toString(16))
                }
                return r.join("")
            }, parse: function (t) {
                for (var e = t.length, r = [], i = 0; i < e; i += 2) r[i >>> 3] |= parseInt(t.substr(i, 2), 16) << 24 - i % 8 * 4;
                return new o.init(r, e / 2)
            }
        }, h = c.Latin1 = {
            stringify: function (t) {
                var e = t.words;
                t = t.sigBytes;
                for (var r = [], i = 0; i < t; i++) r.push(String.fromCharCode(e[i >>> 2] >>> 24 - i % 4 * 8 & 255));
                return r.join("")
            }, parse: function (t) {
                for (var e = t.length, r = [], i = 0; i < e; i++) r[i >>> 2] |= (255 & t.charCodeAt(i)) << 24 - i % 4 * 8;
                return new o.init(r, e)
            }
        }, f = c.Utf8 = {
            stringify: function (t) {
                try {
                    return decodeURIComponent(escape(h.stringify(t)))
                } catch (t) {
                    throw Error("Malformed UTF-8 data")
                }
            }, parse: function (t) {
                return h.parse(unescape(encodeURIComponent(t)))
            }
        }, u = i.BufferedBlockAlgorithm = s.extend({
            reset: function () {
                this._data = new o.init, this._nDataBytes = 0
            }, _append: function (t) {
                "string" == typeof t && (t = f.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes
            }, _process: function (e) {
                var r = this._data, i = r.words, n = r.sigBytes, s = this.blockSize, c = n / (4 * s);
                if (e = (c = e ? t.ceil(c) : t.max((0 | c) - this._minBufferSize, 0)) * s, n = t.min(4 * e, n), e) {
                    for (var a = 0; a < e; a += s) this._doProcessBlock(i, a);
                    a = i.splice(0, e), r.sigBytes -= n
                }
                return new o.init(a, n)
            }, clone: function () {
                var t = s.clone.call(this);
                return t._data = this._data.clone(), t
            }, _minBufferSize: 0
        });
        i.Hasher = u.extend({
            cfg: s.extend(), init: function (t) {
                this.cfg = this.cfg.extend(t), this.reset()
            }, reset: function () {
                u.reset.call(this), this._doReset()
            }, update: function (t) {
                return this._append(t), this._process(), this
            }, finalize: function (t) {
                return t && this._append(t), this._doFinalize()
            }, blockSize: 16, _createHelper: function (t) {
                return function (e, r) {
                    return new t.init(r).finalize(e)
                }
            }, _createHmacHelper: function (t) {
                return function (e, r) {
                    return new d.HMAC.init(t, r).finalize(e)
                }
            }
        });
        var d = r.algo = {};
        return r
    }(Math);
    !function () {
        var e = t, r = e.lib.WordArray;
        e.enc.Base64 = {
            stringify: function (t) {
                var e = t.words, r = t.sigBytes, i = this._map;
                t.clamp(), t = [];
                for (var n = 0; n < r; n += 3) for (var s = (e[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 16 | (e[n + 1 >>> 2] >>> 24 - (n + 1) % 4 * 8 & 255) << 8 | e[n + 2 >>> 2] >>> 24 - (n + 2) % 4 * 8 & 255, o = 0; 4 > o && n + .75 * o < r; o++) t.push(i.charAt(s >>> 6 * (3 - o) & 63));
                if (e = i.charAt(64)) for (; t.length % 4;) t.push(e);
                return t.join("")
            }, parse: function (t) {
                var e = t.length, i = this._map;
                (n = i.charAt(64)) && -1 != (n = t.indexOf(n)) && (e = n);
                for (var n = [], s = 0, o = 0; o < e; o++) if (o % 4) {
                    var c = i.indexOf(t.charAt(o - 1)) << o % 4 * 2, a = i.indexOf(t.charAt(o)) >>> 6 - o % 4 * 2;
                    n[s >>> 2] |= (c | a) << 24 - s % 4 * 8, s++
                }
                return r.create(n, s)
            }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        }
    }(), function (e) {
        function r(t, e, r, i, n, s, o) {
            return ((t = t + (e & r | ~e & i) + n + o) << s | t >>> 32 - s) + e
        }

        function i(t, e, r, i, n, s, o) {
            return ((t = t + (e & i | r & ~i) + n + o) << s | t >>> 32 - s) + e
        }

        function n(t, e, r, i, n, s, o) {
            return ((t = t + (e ^ r ^ i) + n + o) << s | t >>> 32 - s) + e
        }

        function s(t, e, r, i, n, s, o) {
            return ((t = t + (r ^ (e | ~i)) + n + o) << s | t >>> 32 - s) + e
        }

        for (var o = t, c = (h = o.lib).WordArray, a = h.Hasher, h = o.algo, f = [], u = 0; 64 > u; u++) f[u] = 4294967296 * e.abs(e.sin(u + 1)) | 0;
        h = h.MD5 = a.extend({
            _doReset: function () {
                this._hash = new c.init([1732584193, 4023233417, 2562383102, 271733878])
            }, _doProcessBlock: function (t, e) {
                for (o = 0; 16 > o; o++) {
                    a = t[c = e + o];
                    t[c] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                }
                var o = this._hash.words, c = t[e + 0], a = t[e + 1], h = t[e + 2], u = t[e + 3], d = t[e + 4],
                    p = t[e + 5], l = t[e + 6], _ = t[e + 7], y = t[e + 8], v = t[e + 9], g = t[e + 10], B = t[e + 11],
                    x = t[e + 12], k = t[e + 13], m = t[e + 14], S = t[e + 15], w = o[0], z = o[1], C = o[2], M = o[3],
                    z = s(z = s(z = s(z = s(z = n(z = n(z = n(z = n(z = i(z = i(z = i(z = i(z = r(z = r(z = r(z = r(z, C = r(C, M = r(M, w = r(w, z, C, M, c, 7, f[0]), z, C, a, 12, f[1]), w, z, h, 17, f[2]), M, w, u, 22, f[3]), C = r(C, M = r(M, w = r(w, z, C, M, d, 7, f[4]), z, C, p, 12, f[5]), w, z, l, 17, f[6]), M, w, _, 22, f[7]), C = r(C, M = r(M, w = r(w, z, C, M, y, 7, f[8]), z, C, v, 12, f[9]), w, z, g, 17, f[10]), M, w, B, 22, f[11]), C = r(C, M = r(M, w = r(w, z, C, M, x, 7, f[12]), z, C, k, 12, f[13]), w, z, m, 17, f[14]), M, w, S, 22, f[15]), C = i(C, M = i(M, w = i(w, z, C, M, a, 5, f[16]), z, C, l, 9, f[17]), w, z, B, 14, f[18]), M, w, c, 20, f[19]), C = i(C, M = i(M, w = i(w, z, C, M, p, 5, f[20]), z, C, g, 9, f[21]), w, z, S, 14, f[22]), M, w, d, 20, f[23]), C = i(C, M = i(M, w = i(w, z, C, M, v, 5, f[24]), z, C, m, 9, f[25]), w, z, u, 14, f[26]), M, w, y, 20, f[27]), C = i(C, M = i(M, w = i(w, z, C, M, k, 5, f[28]), z, C, h, 9, f[29]), w, z, _, 14, f[30]), M, w, x, 20, f[31]), C = n(C, M = n(M, w = n(w, z, C, M, p, 4, f[32]), z, C, y, 11, f[33]), w, z, B, 16, f[34]), M, w, m, 23, f[35]), C = n(C, M = n(M, w = n(w, z, C, M, a, 4, f[36]), z, C, d, 11, f[37]), w, z, _, 16, f[38]), M, w, g, 23, f[39]), C = n(C, M = n(M, w = n(w, z, C, M, k, 4, f[40]), z, C, c, 11, f[41]), w, z, u, 16, f[42]), M, w, l, 23, f[43]), C = n(C, M = n(M, w = n(w, z, C, M, v, 4, f[44]), z, C, x, 11, f[45]), w, z, S, 16, f[46]), M, w, h, 23, f[47]), C = s(C, M = s(M, w = s(w, z, C, M, c, 6, f[48]), z, C, _, 10, f[49]), w, z, m, 15, f[50]), M, w, p, 21, f[51]), C = s(C, M = s(M, w = s(w, z, C, M, x, 6, f[52]), z, C, u, 10, f[53]), w, z, g, 15, f[54]), M, w, a, 21, f[55]), C = s(C, M = s(M, w = s(w, z, C, M, y, 6, f[56]), z, C, S, 10, f[57]), w, z, l, 15, f[58]), M, w, k, 21, f[59]), C = s(C, M = s(M, w = s(w, z, C, M, d, 6, f[60]), z, C, B, 10, f[61]), w, z, h, 15, f[62]), M, w, v, 21, f[63]);
                o[0] = o[0] + w | 0, o[1] = o[1] + z | 0, o[2] = o[2] + C | 0, o[3] = o[3] + M | 0
            }, _doFinalize: function () {
                var t = this._data, r = t.words, i = 8 * this._nDataBytes, n = 8 * t.sigBytes;
                r[n >>> 5] |= 128 << 24 - n % 32;
                var s = e.floor(i / 4294967296);
                for (r[15 + (n + 64 >>> 9 << 4)] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), r[14 + (n + 64 >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8), t.sigBytes = 4 * (r.length + 1), this._process(), r = (t = this._hash).words, i = 0; 4 > i; i++) n = r[i], r[i] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8);
                return t
            }, clone: function () {
                var t = a.clone.call(this);
                return t._hash = this._hash.clone(), t
            }
        }), o.MD5 = a._createHelper(h), o.HmacMD5 = a._createHmacHelper(h)
    }(Math), function () {
        var e = t, r = e.lib, i = r.Base, n = r.WordArray, s = (r = e.algo).EvpKDF = i.extend({
            cfg: i.extend({keySize: 4, hasher: r.MD5, iterations: 1}),
            init: function (t) {
                this.cfg = this.cfg.extend(t)
            },
            compute: function (t, e) {
                for (var r = (c = this.cfg).hasher.create(), i = n.create(), s = i.words, o = c.keySize, c = c.iterations; s.length < o;) {
                    a && r.update(a);
                    var a = r.update(t).finalize(e);
                    r.reset();
                    for (var h = 1; h < c; h++) a = r.finalize(a), r.reset();
                    i.concat(a)
                }
                return i.sigBytes = 4 * o, i
            }
        });
        e.EvpKDF = function (t, e, r) {
            return s.create(r).compute(t, e)
        }
    }(), t.lib.Cipher || function (e) {
        var r = (l = t).lib, i = r.Base, n = r.WordArray, s = r.BufferedBlockAlgorithm, o = l.enc.Base64,
            c = l.algo.EvpKDF, a = r.Cipher = s.extend({
                cfg: i.extend(), createEncryptor: function (t, e) {
                    return this.create(this._ENC_XFORM_MODE, t, e)
                }, createDecryptor: function (t, e) {
                    return this.create(this._DEC_XFORM_MODE, t, e)
                }, init: function (t, e, r) {
                    this.cfg = this.cfg.extend(r), this._xformMode = t, this._key = e, this.reset()
                }, reset: function () {
                    s.reset.call(this), this._doReset()
                }, process: function (t) {
                    return this._append(t), this._process()
                }, finalize: function (t) {
                    return t && this._append(t), this._doFinalize()
                }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function (t) {
                    return {
                        encrypt: function (e, r, i) {
                            return ("string" == typeof r ? _ : p).encrypt(t, e, r, i)
                        }, decrypt: function (e, r, i) {
                            return ("string" == typeof r ? _ : p).decrypt(t, e, r, i)
                        }
                    }
                }
            });
        r.StreamCipher = a.extend({
            _doFinalize: function () {
                return this._process(!0)
            }, blockSize: 1
        });
        var h = l.mode = {}, f = function (t, e, r) {
            var i = this._iv;
            i ? this._iv = void 0 : i = this._prevBlock;
            for (var n = 0; n < r; n++) t[e + n] ^= i[n]
        }, u = (r.BlockCipherMode = i.extend({
            createEncryptor: function (t, e) {
                return this.Encryptor.create(t, e)
            }, createDecryptor: function (t, e) {
                return this.Decryptor.create(t, e)
            }, init: function (t, e) {
                this._cipher = t, this._iv = e
            }
        })).extend();
        u.Encryptor = u.extend({
            processBlock: function (t, e) {
                var r = this._cipher, i = r.blockSize;
                f.call(this, t, e, i), r.encryptBlock(t, e), this._prevBlock = t.slice(e, e + i)
            }
        }), u.Decryptor = u.extend({
            processBlock: function (t, e) {
                var r = this._cipher, i = r.blockSize, n = t.slice(e, e + i);
                r.decryptBlock(t, e), f.call(this, t, e, i), this._prevBlock = n
            }
        }), h = h.CBC = u, u = (l.pad = {}).Pkcs7 = {
            pad: function (t, e) {
                for (var r = 4 * e, i = (r = r - t.sigBytes % r) << 24 | r << 16 | r << 8 | r, s = [], o = 0; o < r; o += 4) s.push(i);
                r = n.create(s, r), t.concat(r)
            }, unpad: function (t) {
                t.sigBytes -= 255 & t.words[t.sigBytes - 1 >>> 2]
            }
        }, r.BlockCipher = a.extend({
            cfg: a.cfg.extend({mode: h, padding: u}), reset: function () {
                a.reset.call(this);
                var t = (e = this.cfg).iv, e = e.mode;
                if (this._xformMode == this._ENC_XFORM_MODE) var r = e.createEncryptor; else r = e.createDecryptor, this._minBufferSize = 1;
                this._mode = r.call(e, this, t && t.words)
            }, _doProcessBlock: function (t, e) {
                this._mode.processBlock(t, e)
            }, _doFinalize: function () {
                var t = this.cfg.padding;
                if (this._xformMode == this._ENC_XFORM_MODE) {
                    t.pad(this._data, this.blockSize);
                    var e = this._process(!0)
                } else e = this._process(!0), t.unpad(e);
                return e
            }, blockSize: 4
        });
        var d = r.CipherParams = i.extend({
            init: function (t) {
                this.mixIn(t)
            }, toString: function (t) {
                return (t || this.formatter).stringify(this)
            }
        }), h = (l.format = {}).OpenSSL = {
            stringify: function (t) {
                var e = t.ciphertext;
                return ((t = t.salt) ? n.create([1398893684, 1701076831]).concat(t).concat(e) : e).toString(o)
            }, parse: function (t) {
                var e = (t = o.parse(t)).words;
                if (1398893684 == e[0] && 1701076831 == e[1]) {
                    var r = n.create(e.slice(2, 4));
                    e.splice(0, 4), t.sigBytes -= 16
                }
                return d.create({ciphertext: t, salt: r})
            }
        }, p = r.SerializableCipher = i.extend({
            cfg: i.extend({format: h}), encrypt: function (t, e, r, i) {
                i = this.cfg.extend(i);
                var n = t.createEncryptor(r, i);
                return e = n.finalize(e), n = n.cfg, d.create({
                    ciphertext: e,
                    key: r,
                    iv: n.iv,
                    algorithm: t,
                    mode: n.mode,
                    padding: n.padding,
                    blockSize: t.blockSize,
                    formatter: i.format
                })
            }, decrypt: function (t, e, r, i) {
                return i = this.cfg.extend(i), e = this._parse(e, i.format), t.createDecryptor(r, i).finalize(e.ciphertext)
            }, _parse: function (t, e) {
                return "string" == typeof t ? e.parse(t, this) : t
            }
        }), l = (l.kdf = {}).OpenSSL = {
            execute: function (t, e, r, i) {
                return i || (i = n.random(8)), t = c.create({keySize: e + r}).compute(t, i), r = n.create(t.words.slice(e), 4 * r), t.sigBytes = 4 * e, d.create({
                    key: t,
                    iv: r,
                    salt: i
                })
            }
        }, _ = r.PasswordBasedCipher = p.extend({
            cfg: p.cfg.extend({kdf: l}), encrypt: function (t, e, r, i) {
                return i = this.cfg.extend(i), r = i.kdf.execute(r, t.keySize, t.ivSize), i.iv = r.iv, (t = p.encrypt.call(this, t, e, r.key, i)).mixIn(r), t
            }, decrypt: function (t, e, r, i) {
                return i = this.cfg.extend(i), e = this._parse(e, i.format), r = i.kdf.execute(r, t.keySize, t.ivSize, e.salt), i.iv = r.iv, p.decrypt.call(this, t, e, r.key, i)
            }
        })
    }(), function () {
        for (var e = t, r = e.lib.BlockCipher, i = e.algo, n = [], s = [], o = [], c = [], a = [], h = [], f = [], u = [], d = [], p = [], l = [], _ = 0; 256 > _; _++) l[_] = 128 > _ ? _ << 1 : _ << 1 ^ 283;
        for (var y = 0, v = 0, _ = 0; 256 > _; _++) {
            var g = (g = v ^ v << 1 ^ v << 2 ^ v << 3 ^ v << 4) >>> 8 ^ 255 & g ^ 99;
            n[y] = g, s[g] = y;
            var B = l[y], x = l[B], k = l[x], m = 257 * l[g] ^ 16843008 * g;
            o[y] = m << 24 | m >>> 8, c[y] = m << 16 | m >>> 16, a[y] = m << 8 | m >>> 24, h[y] = m, m = 16843009 * k ^ 65537 * x ^ 257 * B ^ 16843008 * y, f[g] = m << 24 | m >>> 8, u[g] = m << 16 | m >>> 16, d[g] = m << 8 | m >>> 24, p[g] = m, y ? (y = B ^ l[l[l[k ^ B]]], v ^= l[l[v]]) : y = v = 1
        }
        var S = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], i = i.AES = r.extend({
            _doReset: function () {
                for (var t = (r = this._key).words, e = r.sigBytes / 4, r = 4 * ((this._nRounds = e + 6) + 1), i = this._keySchedule = [], s = 0; s < r; s++) if (s < e) i[s] = t[s]; else {
                    var o = i[s - 1];
                    s % e ? 6 < e && 4 == s % e && (o = n[o >>> 24] << 24 | n[o >>> 16 & 255] << 16 | n[o >>> 8 & 255] << 8 | n[255 & o]) : (o = o << 8 | o >>> 24, o = n[o >>> 24] << 24 | n[o >>> 16 & 255] << 16 | n[o >>> 8 & 255] << 8 | n[255 & o], o ^= S[s / e | 0] << 24), i[s] = i[s - e] ^ o
                }
                for (t = this._invKeySchedule = [], e = 0; e < r; e++) s = r - e, o = e % 4 ? i[s] : i[s - 4], t[e] = 4 > e || 4 >= s ? o : f[n[o >>> 24]] ^ u[n[o >>> 16 & 255]] ^ d[n[o >>> 8 & 255]] ^ p[n[255 & o]]
            }, encryptBlock: function (t, e) {
                this._doCryptBlock(t, e, this._keySchedule, o, c, a, h, n)
            }, decryptBlock: function (t, e) {
                var r = t[e + 1];
                t[e + 1] = t[e + 3], t[e + 3] = r, this._doCryptBlock(t, e, this._invKeySchedule, f, u, d, p, s), r = t[e + 1], t[e + 1] = t[e + 3], t[e + 3] = r
            }, _doCryptBlock: function (t, e, r, i, n, s, o, c) {
                for (var a = this._nRounds, h = t[e] ^ r[0], f = t[e + 1] ^ r[1], u = t[e + 2] ^ r[2], d = t[e + 3] ^ r[3], p = 4, l = 1; l < a; l++) var _ = i[h >>> 24] ^ n[f >>> 16 & 255] ^ s[u >>> 8 & 255] ^ o[255 & d] ^ r[p++], y = i[f >>> 24] ^ n[u >>> 16 & 255] ^ s[d >>> 8 & 255] ^ o[255 & h] ^ r[p++], v = i[u >>> 24] ^ n[d >>> 16 & 255] ^ s[h >>> 8 & 255] ^ o[255 & f] ^ r[p++], d = i[d >>> 24] ^ n[h >>> 16 & 255] ^ s[f >>> 8 & 255] ^ o[255 & u] ^ r[p++], h = _, f = y, u = v;
                _ = (c[h >>> 24] << 24 | c[f >>> 16 & 255] << 16 | c[u >>> 8 & 255] << 8 | c[255 & d]) ^ r[p++], y = (c[f >>> 24] << 24 | c[u >>> 16 & 255] << 16 | c[d >>> 8 & 255] << 8 | c[255 & h]) ^ r[p++], v = (c[u >>> 24] << 24 | c[d >>> 16 & 255] << 16 | c[h >>> 8 & 255] << 8 | c[255 & f]) ^ r[p++], d = (c[d >>> 24] << 24 | c[h >>> 16 & 255] << 16 | c[f >>> 8 & 255] << 8 | c[255 & u]) ^ r[p++], t[e] = _, t[e + 1] = y, t[e + 2] = v, t[e + 3] = d
            }, keySize: 8
        });
        e.AES = r._createHelper(i)
    }(), function (e) {
        for (var r = t, i = (s = r.lib).WordArray, n = s.Hasher, s = r.algo, o = [], c = [], a = function (t) {
            return 4294967296 * (t - (0 | t)) | 0
        }, h = 2, f = 0; 64 > f;) {
            var u;
            t:{
                u = h;
                for (var d = e.sqrt(u), p = 2; p <= d; p++) if (!(u % p)) {
                    u = !1;
                    break t
                }
                u = !0
            }
            u && (8 > f && (o[f] = a(e.pow(h, .5))), c[f] = a(e.pow(h, 1 / 3)), f++), h++
        }
        var l = [], s = s.SHA256 = n.extend({
            _doReset: function () {
                this._hash = new i.init(o.slice(0))
            }, _doProcessBlock: function (t, e) {
                for (var r = this._hash.words, i = r[0], n = r[1], s = r[2], o = r[3], a = r[4], h = r[5], f = r[6], u = r[7], d = 0; 64 > d; d++) {
                    if (16 > d) l[d] = 0 | t[e + d]; else {
                        var p = l[d - 15], _ = l[d - 2];
                        l[d] = ((p << 25 | p >>> 7) ^ (p << 14 | p >>> 18) ^ p >>> 3) + l[d - 7] + ((_ << 15 | _ >>> 17) ^ (_ << 13 | _ >>> 19) ^ _ >>> 10) + l[d - 16]
                    }
                    p = u + ((a << 26 | a >>> 6) ^ (a << 21 | a >>> 11) ^ (a << 7 | a >>> 25)) + (a & h ^ ~a & f) + c[d] + l[d], _ = ((i << 30 | i >>> 2) ^ (i << 19 | i >>> 13) ^ (i << 10 | i >>> 22)) + (i & n ^ i & s ^ n & s), u = f, f = h, h = a, a = o + p | 0, o = s, s = n, n = i, i = p + _ | 0
                }
                r[0] = r[0] + i | 0, r[1] = r[1] + n | 0, r[2] = r[2] + s | 0, r[3] = r[3] + o | 0, r[4] = r[4] + a | 0, r[5] = r[5] + h | 0, r[6] = r[6] + f | 0, r[7] = r[7] + u | 0
            }, _doFinalize: function () {
                var t = this._data, r = t.words, i = 8 * this._nDataBytes, n = 8 * t.sigBytes;
                return r[n >>> 5] |= 128 << 24 - n % 32, r[14 + (n + 64 >>> 9 << 4)] = e.floor(i / 4294967296), r[15 + (n + 64 >>> 9 << 4)] = i, t.sigBytes = 4 * r.length, this._process(), this._hash
            }, clone: function () {
                var t = n.clone.call(this);
                return t._hash = this._hash.clone(), t
            }
        });
        r.SHA256 = n._createHelper(s), r.HmacSHA256 = n._createHmacHelper(s)
    }(Math), exports.default = t;
});
define("js/lib/animation.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0}), exports.TweenAnimation = exports.customAnimation = void 0;
    var e = function (e) {
        return e && e.__esModule ? e : {default: e}
    }(require("./tween")), n = -1, t = n - 1, o = {};
    (exports.customAnimation = {}).to = function (e, t, o) {
        t *= 1e3;
        o.delay;
        for (var r in o) if ("delay" === r) ; else if ("onComplete" === r || "onEnded" === r) ; else if ("ease" === r) ; else if ("name" === r) ; else if (o.delay || 0 !== t) {
            var a = ++n;
            setTimeout(function (n) {
                return function () {
                    i(e[n], o[n], t, o.ease || "Linear", function (t, i, r) {
                        r && o.onEnded && o.onEnded(), void 0 !== t && (e[n] = t), i && o.onComplete && o.onComplete()
                    }, o.name, a)
                }
            }(r), 1e3 * (o.delay || 0))
        } else e[r] = o[r], o.onComplete && o.onComplete(), o.onEnded && o.onEnded()
    };
    var i = exports.TweenAnimation = function (i, r, a, l, s, u, f) {
        var f = f || ++n;
        u && (o[u] || (o[u] = []), o[u].push(f));
        var c = function (e) {
            return "function" == typeof e
        }, d = function (e) {
            return "number" == typeof e
        }, m = function (e) {
            return "string" == typeof e
        }, p = function (e) {
            if (d(e)) return e;
            if (m(e)) {
                if (/\d+m?s$/.test(e)) return /ms/.test(e) ? 1 * e.replace("ms", "") : 1e3 * e.replace("s", "");
                if (/^\d+$/.test(e)) return +e
            }
            return -1
        };
        if (!d(i) || !d(r)) return window.console && console.error("fromto", s, u, l), 0;
        var v = e.default;
        if (!v) return window.console && console.error(""), 0;
        var w = {
            duration: 300, easing: "Linear", callback: function () {
            }
        }, g = function (e) {
            c(e) ? w.callback = e : -1 != p(e) ? w.duration = p(e) : m(e) && (w.easing = e)
        };
        g(a), g(l), g(s), window.requestAnimationFrame || (requestAnimationFrame = function (e) {
            setTimeout(e, 17)
        });
        var A = -1, y = Math.ceil(w.duration / 17);
        w.easing = w.easing.slice(0, 1).toUpperCase() + w.easing.slice(1);
        var b, k = w.easing.split(".");
        if (1 == k.length ? b = v[k[0]] : 2 == k.length && (b = v[k[0]] && v[k[0]][k[1]]), 0 != c(b)) {
            var x = Date.now(), h = Date.now();
            !function e() {
                var n = Date.now(), a = n - h, l = Math.ceil(1e3 / a);
                if (h = n, a > 100) requestAnimationFrame(e); else {
                    if (l >= 30) A++; else {
                        var s = Math.floor((n - x) / 17);
                        A = s > A ? s : A + 1
                    }
                    var c = b(A, i, r - i, y);
                    if (A <= y && f > t) {
                        if (u && o[u] && o[u].indexOf(f) < 0) return;
                        w.callback(c), requestAnimationFrame(e)
                    } else if (A > y && f > t) {
                        if (u && o[u] && o[u].indexOf(f) < 0) return;
                        w.callback(r, !0, !0)
                    } else w.callback(void 0, !1, !0)
                }
            }()
        } else console.error('"' + w.easing + '"')
    };
    i.kill = function (e) {
        o[e] = []
    }, i.killAll = function () {
        t = n;
        for (var e in o) o[e] = []
    };
});
define("js/lib/mue/eventcenter.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var i = t[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, n, i) {
            return n && e(t.prototype, n), i && e(t, i), t
        }
    }(), n = exports.MueEvent = function () {
        function n(t) {
            e(this, n), this.type = t, this.defaultPrevented = !1, this.timeStamp = Date.now()
        }

        return t(n, [{
            key: "preventDefault", value: function () {
                this.defaultPrevented = !0
            }
        }]), n
    }(), i = new (exports.EventCenter = function () {
        function i() {
            e(this, i), this.listener = {}
        }

        return t(i, [{
            key: "emit", value: function (e) {
                for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                this._emit.apply(this, [!1, e].concat(n))
            }
        }, {
            key: "emitSync", value: function (e) {
                for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                this._emit.apply(this, [!0, e].concat(n))
            }
        }, {
            key: "_emit", value: function (e, t) {
                for (var i = arguments.length, r = Array(i > 2 ? i - 2 : 0), a = 2; a < i; a++) r[a - 2] = arguments[a];
                var o = this;
                if ("CHECK_GAME" != t && "SEND_CHECK_GAME" != t && console.log("", t), this.listener[t]) {
                    var l = new n(t), s = function () {
                        for (var e in o.listener[t]) {
                            var n = !0, i = !1, a = void 0;
                            try {
                                for (var s, u = o.listener[t][e][Symbol.iterator](); !(n = (s = u.next()).done); n = !0) {
                                    var f = s.value;
                                    f.call.apply(f, [f, l].concat(r))
                                }
                            } catch (e) {
                                i = !0, a = e
                            } finally {
                                try {
                                    !n && u.return && u.return()
                                } finally {
                                    if (i) throw a
                                }
                            }
                        }
                        o.listener[t].one = []
                    };
                    e ? s.call(this) : this._async(s)
                }
            }
        }, {
            key: "on", value: function (e, t) {
                this._addListener(e, "on", t)
            }
        }, {
            key: "one", value: function (e, t) {
                this._addListener(e, "one", t)
            }
        }, {
            key: "off", value: function (e, t) {
                var n = this;
                this.listener[e] && this._async(function () {
                    if (t) {
                        var i = t.toString();
                        for (var r in n.listener[e]) for (var a = 0; ;) {
                            if (a >= n.listener[e][r].length) break;
                            i === n.listener[e][r][a].toString() && (n.listener[e][r].splice(a, 1), a--), a++
                        }
                    } else n.listener[e] = {on: [], one: []}, delete n.listener[e]
                })
            }
        }, {
            key: "_addListener", value: function (e, t, n) {
                this.listener[e] || (this.listener[e] = {on: [], one: []}), this.listener[e][t].push(n)
            }
        }, {
            key: "_async", value: function (e) {
                var t = this;
                setTimeout(function () {
                    e.call(t)
                }, 0)
            }
        }]), i
    }());
    exports.default = i;
});
define("js/lib/point-in-polygon.js", function (require, module, exports) {
    "use strict";
    module.exports = function (r, t) {
        for (var e = r[0], n = r[1], o = !1, u = 0, l = t.length - 1; u < t.length; l = u++) {
            var s = t[u][0], a = t[u][1], c = t[l][0], f = t[l][1];
            a > n != f > n && e < (c - s) * (n - a) / (f - a) + s && (o = !o)
        }
        return o
    };
});
define("js/lib/three.js", function (require, module, exports) {
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
            typeof define === 'function' && define.amd ? define(['exports'], factory) :
                (factory((global.THREE = global.THREE || {})));
    }(this, (function (exports) {
        'use strict';

        // Polyfills

        if (Number.EPSILON === undefined) {

            Number.EPSILON = Math.pow(2, -52);

        }

        if (Number.isInteger === undefined) {

            // Missing in IE
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

            Number.isInteger = function (value) {

                return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;

            };

        }

        //

        if (Math.sign === undefined) {

            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

            Math.sign = function (x) {

                return (x < 0) ? -1 : (x > 0) ? 1 : +x;

            };

        }

        if ('name' in Function.prototype === false) {

            // Missing in IE
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

            Object.defineProperty(Function.prototype, 'name', {

                get: function () {

                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];

                }

            });

        }

        if (Object.assign === undefined) {

            // Missing in IE
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

            (function () {

                Object.assign = function (target) {

                    'use strict';

                    if (target === undefined || target === null) {

                        throw new TypeError('Cannot convert undefined or null to object');

                    }

                    var output = Object(target);

                    for (var index = 1; index < arguments.length; index++) {

                        var source = arguments[index];

                        if (source !== undefined && source !== null) {

                            for (var nextKey in source) {

                                if (Object.prototype.hasOwnProperty.call(source, nextKey)) {

                                    output[nextKey] = source[nextKey];

                                }

                            }

                        }

                    }

                    return output;

                };

            })();

        }

        /**
         * https://github.com/mrdoob/eventdispatcher.js/
         */

        function EventDispatcher() {
        }

        Object.assign(EventDispatcher.prototype, {

            addEventListener: function (type, listener) {

                if (this._listeners === undefined) this._listeners = {};

                var listeners = this._listeners;

                if (listeners[type] === undefined) {

                    listeners[type] = [];

                }

                if (listeners[type].indexOf(listener) === -1) {

                    listeners[type].push(listener);

                }

            },

            hasEventListener: function (type, listener) {

                if (this._listeners === undefined) return false;

                var listeners = this._listeners;

                return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;

            },

            removeEventListener: function (type, listener) {

                if (this._listeners === undefined) return;

                var listeners = this._listeners;
                var listenerArray = listeners[type];

                if (listenerArray !== undefined) {

                    var index = listenerArray.indexOf(listener);

                    if (index !== -1) {

                        listenerArray.splice(index, 1);

                    }

                }

            },

            dispatchEvent: function (event) {

                if (this._listeners === undefined) return;

                var listeners = this._listeners;
                var listenerArray = listeners[event.type];

                if (listenerArray !== undefined) {

                    event.target = this;

                    var array = listenerArray.slice(0);

                    for (var i = 0, l = array.length; i < l; i++) {

                        array[i].call(this, event);

                    }

                }

            }

        });


        var REVISION = '88dev';
        var MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2};
        var CullFaceNone = 0;
        var CullFaceBack = 1;
        var CullFaceFront = 2;
        var CullFaceFrontBack = 3;
        var FrontFaceDirectionCW = 0;
        var FrontFaceDirectionCCW = 1;
        var BasicShadowMap = 0;
        var PCFShadowMap = 1;
        var PCFSoftShadowMap = 2;
        var FrontSide = 0;
        var BackSide = 1;
        var DoubleSide = 2;
        var FlatShading = 1;
        var SmoothShading = 2;
        var NoColors = 0;
        var FaceColors = 1;
        var VertexColors = 2;
        var NoBlending = 0;
        var NormalBlending = 1;
        var AdditiveBlending = 2;
        var SubtractiveBlending = 3;
        var MultiplyBlending = 4;
        var CustomBlending = 5;
        var AddEquation = 100;
        var SubtractEquation = 101;
        var ReverseSubtractEquation = 102;
        var MinEquation = 103;
        var MaxEquation = 104;
        var ZeroFactor = 200;
        var OneFactor = 201;
        var SrcColorFactor = 202;
        var OneMinusSrcColorFactor = 203;
        var SrcAlphaFactor = 204;
        var OneMinusSrcAlphaFactor = 205;
        var DstAlphaFactor = 206;
        var OneMinusDstAlphaFactor = 207;
        var DstColorFactor = 208;
        var OneMinusDstColorFactor = 209;
        var SrcAlphaSaturateFactor = 210;
        var NeverDepth = 0;
        var AlwaysDepth = 1;
        var LessDepth = 2;
        var LessEqualDepth = 3;
        var EqualDepth = 4;
        var GreaterEqualDepth = 5;
        var GreaterDepth = 6;
        var NotEqualDepth = 7;
        var MultiplyOperation = 0;
        var MixOperation = 1;
        var AddOperation = 2;
        var NoToneMapping = 0;
        var LinearToneMapping = 1;
        var ReinhardToneMapping = 2;
        var Uncharted2ToneMapping = 3;
        var CineonToneMapping = 4;
        var UVMapping = 300;
        var CubeReflectionMapping = 301;
        var CubeRefractionMapping = 302;
        var EquirectangularReflectionMapping = 303;
        var EquirectangularRefractionMapping = 304;
        var SphericalReflectionMapping = 305;
        var CubeUVReflectionMapping = 306;
        var CubeUVRefractionMapping = 307;
        var RepeatWrapping = 1000;
        var ClampToEdgeWrapping = 1001;
        var MirroredRepeatWrapping = 1002;
        var NearestFilter = 1003;
        var NearestMipMapNearestFilter = 1004;
        var NearestMipMapLinearFilter = 1005;
        var LinearFilter = 1006;
        var LinearMipMapNearestFilter = 1007;
        var LinearMipMapLinearFilter = 1008;
        var UnsignedByteType = 1009;
        var ByteType = 1010;
        var ShortType = 1011;
        var UnsignedShortType = 1012;
        var IntType = 1013;
        var UnsignedIntType = 1014;
        var FloatType = 1015;
        var HalfFloatType = 1016;
        var UnsignedShort4444Type = 1017;
        var UnsignedShort5551Type = 1018;
        var UnsignedShort565Type = 1019;
        var UnsignedInt248Type = 1020;
        var AlphaFormat = 1021;
        var RGBFormat = 1022;
        var RGBAFormat = 1023;
        var LuminanceFormat = 1024;
        var LuminanceAlphaFormat = 1025;
        var RGBEFormat = RGBAFormat;
        var DepthFormat = 1026;
        var DepthStencilFormat = 1027;
        var RGB_S3TC_DXT1_Format = 2001;
        var RGBA_S3TC_DXT1_Format = 2002;
        var RGBA_S3TC_DXT3_Format = 2003;
        var RGBA_S3TC_DXT5_Format = 2004;
        var RGB_PVRTC_4BPPV1_Format = 2100;
        var RGB_PVRTC_2BPPV1_Format = 2101;
        var RGBA_PVRTC_4BPPV1_Format = 2102;
        var RGBA_PVRTC_2BPPV1_Format = 2103;
        var RGB_ETC1_Format = 2151;
        var LoopOnce = 2200;
        var LoopRepeat = 2201;
        var LoopPingPong = 2202;
        var InterpolateDiscrete = 2300;
        var InterpolateLinear = 2301;
        var InterpolateSmooth = 2302;
        var ZeroCurvatureEnding = 2400;
        var ZeroSlopeEnding = 2401;
        var WrapAroundEnding = 2402;
        var TrianglesDrawMode = 0;
        var TriangleStripDrawMode = 1;
        var TriangleFanDrawMode = 2;
        var LinearEncoding = 3000;
        var sRGBEncoding = 3001;
        var GammaEncoding = 3007;
        var RGBEEncoding = 3002;
        var LogLuvEncoding = 3003;
        var RGBM7Encoding = 3004;
        var RGBM16Encoding = 3005;
        var RGBDEncoding = 3006;
        var BasicDepthPacking = 3200;
        var RGBADepthPacking = 3201;

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         */

        var _Math = {

            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,

            generateUUID: function () {

                // http://www.broofa.com/Tools/Math.uuid.htm

                var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
                var uuid = new Array(36);
                var rnd = 0, r;

                return function generateUUID() {

                    for (var i = 0; i < 36; i++) {

                        if (i === 8 || i === 13 || i === 18 || i === 23) {

                            uuid[i] = '-';

                        } else if (i === 14) {

                            uuid[i] = '4';

                        } else {

                            if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
                            r = rnd & 0xf;
                            rnd = rnd >> 4;
                            uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];

                        }

                    }

                    return uuid.join('');

                };

            }(),

            clamp: function (value, min, max) {

                return Math.max(min, Math.min(max, value));

            },

            // compute euclidian modulo of m % n
            // https://en.wikipedia.org/wiki/Modulo_operation

            euclideanModulo: function (n, m) {

                return ((n % m) + m) % m;

            },

            // Linear mapping from range <a1, a2> to range <b1, b2>

            mapLinear: function (x, a1, a2, b1, b2) {

                return b1 + (x - a1) * (b2 - b1) / (a2 - a1);

            },

            // https://en.wikipedia.org/wiki/Linear_interpolation

            lerp: function (x, y, t) {

                return (1 - t) * x + t * y;

            },

            // http://en.wikipedia.org/wiki/Smoothstep

            smoothstep: function (x, min, max) {

                if (x <= min) return 0;
                if (x >= max) return 1;

                x = (x - min) / (max - min);

                return x * x * (3 - 2 * x);

            },

            smootherstep: function (x, min, max) {

                if (x <= min) return 0;
                if (x >= max) return 1;

                x = (x - min) / (max - min);

                return x * x * x * (x * (x * 6 - 15) + 10);

            },

            // Random integer from <low, high> interval

            randInt: function (low, high) {

                return low + Math.floor(Math.random() * (high - low + 1));

            },

            // Random float from <low, high> interval

            randFloat: function (low, high) {

                return low + Math.random() * (high - low);

            },

            // Random float from <-range/2, range/2> interval

            randFloatSpread: function (range) {

                return range * (0.5 - Math.random());

            },

            degToRad: function (degrees) {

                return degrees * _Math.DEG2RAD;

            },

            radToDeg: function (radians) {

                return radians * _Math.RAD2DEG;

            },

            isPowerOfTwo: function (value) {

                return (value & (value - 1)) === 0 && value !== 0;

            },

            ceilPowerOfTwo: function (value) {

                return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));

            },

            floorPowerOfTwo: function (value) {

                return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));

            }

        };

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author philogb / http://blog.thejit.org/
         * @author egraether / http://egraether.com/
         * @author zz85 / http://www.lab4games.net/zz85/blog
         */

        function Vector2(x, y) {

            this.x = x || 0;
            this.y = y || 0;

        }

        Object.defineProperties(Vector2.prototype, {

            "width": {

                get: function () {

                    return this.x;

                },

                set: function (value) {

                    this.x = value;

                }

            },

            "height": {

                get: function () {

                    return this.y;

                },

                set: function (value) {

                    this.y = value;

                }

            }

        });

        Object.assign(Vector2.prototype, {

            isVector2: true,

            set: function (x, y) {

                this.x = x;
                this.y = y;

                return this;

            },

            setScalar: function (scalar) {

                this.x = scalar;
                this.y = scalar;

                return this;

            },

            setX: function (x) {

                this.x = x;

                return this;

            },

            setY: function (y) {

                this.y = y;

                return this;

            },

            setComponent: function (index, value) {

                switch (index) {

                    case 0:
                        this.x = value;
                        break;
                    case 1:
                        this.y = value;
                        break;
                    default:
                        throw new Error('index is out of range: ' + index);

                }

                return this;

            },

            getComponent: function (index) {

                switch (index) {

                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error('index is out of range: ' + index);

                }

            },

            clone: function () {

                return new this.constructor(this.x, this.y);

            },

            copy: function (v) {

                this.x = v.x;
                this.y = v.y;

                return this;

            },

            add: function (v, w) {

                if (w !== undefined) {

                    console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                    return this.addVectors(v, w);

                }

                this.x += v.x;
                this.y += v.y;

                return this;

            },

            addScalar: function (s) {

                this.x += s;
                this.y += s;

                return this;

            },

            addVectors: function (a, b) {

                this.x = a.x + b.x;
                this.y = a.y + b.y;

                return this;

            },

            addScaledVector: function (v, s) {

                this.x += v.x * s;
                this.y += v.y * s;

                return this;

            },

            sub: function (v, w) {

                if (w !== undefined) {

                    console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                    return this.subVectors(v, w);

                }

                this.x -= v.x;
                this.y -= v.y;

                return this;

            },

            subScalar: function (s) {

                this.x -= s;
                this.y -= s;

                return this;

            },

            subVectors: function (a, b) {

                this.x = a.x - b.x;
                this.y = a.y - b.y;

                return this;

            },

            multiply: function (v) {

                this.x *= v.x;
                this.y *= v.y;

                return this;

            },

            multiplyScalar: function (scalar) {

                this.x *= scalar;
                this.y *= scalar;

                return this;

            },

            divide: function (v) {

                this.x /= v.x;
                this.y /= v.y;

                return this;

            },

            divideScalar: function (scalar) {

                return this.multiplyScalar(1 / scalar);

            },

            applyMatrix3: function (m) {

                var x = this.x, y = this.y;
                var e = m.elements;

                this.x = e[0] * x + e[3] * y + e[6];
                this.y = e[1] * x + e[4] * y + e[7];

                return this;

            },

            min: function (v) {

                this.x = Math.min(this.x, v.x);
                this.y = Math.min(this.y, v.y);

                return this;

            },

            max: function (v) {

                this.x = Math.max(this.x, v.x);
                this.y = Math.max(this.y, v.y);

                return this;

            },

            clamp: function (min, max) {

                // assumes min < max, componentwise

                this.x = Math.max(min.x, Math.min(max.x, this.x));
                this.y = Math.max(min.y, Math.min(max.y, this.y));

                return this;

            },

            clampScalar: function () {

                var min = new Vector2();
                var max = new Vector2();

                return function clampScalar(minVal, maxVal) {

                    min.set(minVal, minVal);
                    max.set(maxVal, maxVal);

                    return this.clamp(min, max);

                };

            }(),

            clampLength: function (min, max) {

                var length = this.length();

                return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));

            },

            floor: function () {

                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);

                return this;

            },

            ceil: function () {

                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);

                return this;

            },

            round: function () {

                this.x = Math.round(this.x);
                this.y = Math.round(this.y);

                return this;

            },

            roundToZero: function () {

                this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
                this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);

                return this;

            },

            negate: function () {

                this.x = -this.x;
                this.y = -this.y;

                return this;

            },

            dot: function (v) {

                return this.x * v.x + this.y * v.y;

            },

            lengthSq: function () {

                return this.x * this.x + this.y * this.y;

            },

            length: function () {

                return Math.sqrt(this.x * this.x + this.y * this.y);

            },

            manhattanLength: function () {

                return Math.abs(this.x) + Math.abs(this.y);

            },

            normalize: function () {

                return this.divideScalar(this.length() || 1);

            },

            angle: function () {

                // computes the angle in radians with respect to the positive x-axis

                var angle = Math.atan2(this.y, this.x);

                if (angle < 0) angle += 2 * Math.PI;

                return angle;

            },

            distanceTo: function (v) {

                return Math.sqrt(this.distanceToSquared(v));

            },

            distanceToSquared: function (v) {

                var dx = this.x - v.x, dy = this.y - v.y;
                return dx * dx + dy * dy;

            },

            manhattanDistanceTo: function (v) {

                return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);

            },

            setLength: function (length) {

                return this.normalize().multiplyScalar(length);

            },

            lerp: function (v, alpha) {

                this.x += (v.x - this.x) * alpha;
                this.y += (v.y - this.y) * alpha;

                return this;

            },

            lerpVectors: function (v1, v2, alpha) {

                return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);

            },

            equals: function (v) {

                return ((v.x === this.x) && (v.y === this.y));

            },

            fromArray: function (array, offset) {

                if (offset === undefined) offset = 0;

                this.x = array[offset];
                this.y = array[offset + 1];

                return this;

            },

            toArray: function (array, offset) {

                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;

                array[offset] = this.x;
                array[offset + 1] = this.y;

                return array;

            },

            fromBufferAttribute: function (attribute, index, offset) {

                if (offset !== undefined) {

                    console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');

                }

                this.x = attribute.getX(index);
                this.y = attribute.getY(index);

                return this;

            },

            rotateAround: function (center, angle) {

                var c = Math.cos(angle), s = Math.sin(angle);

                var x = this.x - center.x;
                var y = this.y - center.y;

                this.x = x * c - y * s + center.x;
                this.y = x * s + y * c + center.y;

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author supereggbert / http://www.paulbrunt.co.uk/
         * @author philogb / http://blog.thejit.org/
         * @author jordi_ros / http://plattsoft.com
         * @author D1plo1d / http://github.com/D1plo1d
         * @author alteredq / http://alteredqualia.com/
         * @author mikael emtinger / http://gomo.se/
         * @author timknip / http://www.floorplanner.com/
         * @author bhouston / http://clara.io
         * @author WestLangley / http://github.com/WestLangley
         */

        function Matrix4() {

            this.elements = [

                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1

            ];

            if (arguments.length > 0) {

                console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');

            }

        }

        Object.assign(Matrix4.prototype, {

            isMatrix4: true,

            set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {

                var te = this.elements;

                te[0] = n11;
                te[4] = n12;
                te[8] = n13;
                te[12] = n14;
                te[1] = n21;
                te[5] = n22;
                te[9] = n23;
                te[13] = n24;
                te[2] = n31;
                te[6] = n32;
                te[10] = n33;
                te[14] = n34;
                te[3] = n41;
                te[7] = n42;
                te[11] = n43;
                te[15] = n44;

                return this;

            },

            identity: function () {

                this.set(
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                );

                return this;

            },

            clone: function () {

                return new Matrix4().fromArray(this.elements);

            },

            copy: function (m) {

                var te = this.elements;
                var me = m.elements;

                te[0] = me[0];
                te[1] = me[1];
                te[2] = me[2];
                te[3] = me[3];
                te[4] = me[4];
                te[5] = me[5];
                te[6] = me[6];
                te[7] = me[7];
                te[8] = me[8];
                te[9] = me[9];
                te[10] = me[10];
                te[11] = me[11];
                te[12] = me[12];
                te[13] = me[13];
                te[14] = me[14];
                te[15] = me[15];

                return this;

            },

            copyPosition: function (m) {

                var te = this.elements, me = m.elements;

                te[12] = me[12];
                te[13] = me[13];
                te[14] = me[14];

                return this;

            },

            extractBasis: function (xAxis, yAxis, zAxis) {

                xAxis.setFromMatrixColumn(this, 0);
                yAxis.setFromMatrixColumn(this, 1);
                zAxis.setFromMatrixColumn(this, 2);

                return this;

            },

            makeBasis: function (xAxis, yAxis, zAxis) {

                this.set(
                    xAxis.x, yAxis.x, zAxis.x, 0,
                    xAxis.y, yAxis.y, zAxis.y, 0,
                    xAxis.z, yAxis.z, zAxis.z, 0,
                    0, 0, 0, 1
                );

                return this;

            },

            extractRotation: function () {

                var v1 = new Vector3();

                return function extractRotation(m) {

                    var te = this.elements;
                    var me = m.elements;

                    var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
                    var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
                    var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();

                    te[0] = me[0] * scaleX;
                    te[1] = me[1] * scaleX;
                    te[2] = me[2] * scaleX;

                    te[4] = me[4] * scaleY;
                    te[5] = me[5] * scaleY;
                    te[6] = me[6] * scaleY;

                    te[8] = me[8] * scaleZ;
                    te[9] = me[9] * scaleZ;
                    te[10] = me[10] * scaleZ;

                    return this;

                };

            }(),

            makeRotationFromEuler: function (euler) {

                if (!(euler && euler.isEuler)) {

                    console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');

                }

                var te = this.elements;

                var x = euler.x, y = euler.y, z = euler.z;
                var a = Math.cos(x), b = Math.sin(x);
                var c = Math.cos(y), d = Math.sin(y);
                var e = Math.cos(z), f = Math.sin(z);

                if (euler.order === 'XYZ') {

                    var ae = a * e, af = a * f, be = b * e, bf = b * f;

                    te[0] = c * e;
                    te[4] = -c * f;
                    te[8] = d;

                    te[1] = af + be * d;
                    te[5] = ae - bf * d;
                    te[9] = -b * c;

                    te[2] = bf - ae * d;
                    te[6] = be + af * d;
                    te[10] = a * c;

                } else if (euler.order === 'YXZ') {

                    var ce = c * e, cf = c * f, de = d * e, df = d * f;

                    te[0] = ce + df * b;
                    te[4] = de * b - cf;
                    te[8] = a * d;

                    te[1] = a * f;
                    te[5] = a * e;
                    te[9] = -b;

                    te[2] = cf * b - de;
                    te[6] = df + ce * b;
                    te[10] = a * c;

                } else if (euler.order === 'ZXY') {

                    var ce = c * e, cf = c * f, de = d * e, df = d * f;

                    te[0] = ce - df * b;
                    te[4] = -a * f;
                    te[8] = de + cf * b;

                    te[1] = cf + de * b;
                    te[5] = a * e;
                    te[9] = df - ce * b;

                    te[2] = -a * d;
                    te[6] = b;
                    te[10] = a * c;

                } else if (euler.order === 'ZYX') {

                    var ae = a * e, af = a * f, be = b * e, bf = b * f;

                    te[0] = c * e;
                    te[4] = be * d - af;
                    te[8] = ae * d + bf;

                    te[1] = c * f;
                    te[5] = bf * d + ae;
                    te[9] = af * d - be;

                    te[2] = -d;
                    te[6] = b * c;
                    te[10] = a * c;

                } else if (euler.order === 'YZX') {

                    var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

                    te[0] = c * e;
                    te[4] = bd - ac * f;
                    te[8] = bc * f + ad;

                    te[1] = f;
                    te[5] = a * e;
                    te[9] = -b * e;

                    te[2] = -d * e;
                    te[6] = ad * f + bc;
                    te[10] = ac - bd * f;

                } else if (euler.order === 'XZY') {

                    var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

                    te[0] = c * e;
                    te[4] = -f;
                    te[8] = d * e;

                    te[1] = ac * f + bd;
                    te[5] = a * e;
                    te[9] = ad * f - bc;

                    te[2] = bc * f - ad;
                    te[6] = b * e;
                    te[10] = bd * f + ac;

                }

                // last column
                te[3] = 0;
                te[7] = 0;
                te[11] = 0;

                // bottom row
                te[12] = 0;
                te[13] = 0;
                te[14] = 0;
                te[15] = 1;

                return this;

            },

            makeRotationFromQuaternion: function (q) {

                var te = this.elements;

                var x = q._x, y = q._y, z = q._z, w = q._w;
                var x2 = x + x, y2 = y + y, z2 = z + z;
                var xx = x * x2, xy = x * y2, xz = x * z2;
                var yy = y * y2, yz = y * z2, zz = z * z2;
                var wx = w * x2, wy = w * y2, wz = w * z2;

                te[0] = 1 - (yy + zz);
                te[4] = xy - wz;
                te[8] = xz + wy;

                te[1] = xy + wz;
                te[5] = 1 - (xx + zz);
                te[9] = yz - wx;

                te[2] = xz - wy;
                te[6] = yz + wx;
                te[10] = 1 - (xx + yy);

                // last column
                te[3] = 0;
                te[7] = 0;
                te[11] = 0;

                // bottom row
                te[12] = 0;
                te[13] = 0;
                te[14] = 0;
                te[15] = 1;

                return this;

            },

            lookAt: function () {

                var x = new Vector3();
                var y = new Vector3();
                var z = new Vector3();

                return function lookAt(eye, target, up) {

                    var te = this.elements;

                    z.subVectors(eye, target);

                    if (z.lengthSq() === 0) {

                        // eye and target are in the same position

                        z.z = 1;

                    }

                    z.normalize();
                    x.crossVectors(up, z);

                    if (x.lengthSq() === 0) {

                        // up and z are parallel

                        if (Math.abs(up.z) === 1) {

                            z.x += 0.0001;

                        } else {

                            z.z += 0.0001;

                        }

                        z.normalize();
                        x.crossVectors(up, z);

                    }

                    x.normalize();
                    y.crossVectors(z, x);

                    te[0] = x.x;
                    te[4] = y.x;
                    te[8] = z.x;
                    te[1] = x.y;
                    te[5] = y.y;
                    te[9] = z.y;
                    te[2] = x.z;
                    te[6] = y.z;
                    te[10] = z.z;

                    return this;

                };

            }(),

            multiply: function (m, n) {

                if (n !== undefined) {

                    console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
                    return this.multiplyMatrices(m, n);

                }

                return this.multiplyMatrices(this, m);

            },

            premultiply: function (m) {

                return this.multiplyMatrices(m, this);

            },

            multiplyMatrices: function (a, b) {

                var ae = a.elements;
                var be = b.elements;
                var te = this.elements;

                var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
                var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
                var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
                var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];

                var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
                var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
                var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
                var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];

                te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

                te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

                te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

                te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

                return this;

            },

            multiplyScalar: function (s) {

                var te = this.elements;

                te[0] *= s;
                te[4] *= s;
                te[8] *= s;
                te[12] *= s;
                te[1] *= s;
                te[5] *= s;
                te[9] *= s;
                te[13] *= s;
                te[2] *= s;
                te[6] *= s;
                te[10] *= s;
                te[14] *= s;
                te[3] *= s;
                te[7] *= s;
                te[11] *= s;
                te[15] *= s;

                return this;

            },

            applyToBufferAttribute: function () {

                var v1 = new Vector3();

                return function applyToBufferAttribute(attribute) {

                    for (var i = 0, l = attribute.count; i < l; i++) {

                        v1.x = attribute.getX(i);
                        v1.y = attribute.getY(i);
                        v1.z = attribute.getZ(i);

                        v1.applyMatrix4(this);

                        attribute.setXYZ(i, v1.x, v1.y, v1.z);

                    }

                    return attribute;

                };

            }(),

            determinant: function () {

                var te = this.elements;

                var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
                var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
                var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
                var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];

                //TODO: make this more efficient
                //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

                return (
                    n41 * (
                        +n14 * n23 * n32
                        - n13 * n24 * n32
                        - n14 * n22 * n33
                        + n12 * n24 * n33
                        + n13 * n22 * n34
                        - n12 * n23 * n34
                    ) +
                    n42 * (
                        +n11 * n23 * n34
                        - n11 * n24 * n33
                        + n14 * n21 * n33
                        - n13 * n21 * n34
                        + n13 * n24 * n31
                        - n14 * n23 * n31
                    ) +
                    n43 * (
                        +n11 * n24 * n32
                        - n11 * n22 * n34
                        - n14 * n21 * n32
                        + n12 * n21 * n34
                        + n14 * n22 * n31
                        - n12 * n24 * n31
                    ) +
                    n44 * (
                        -n13 * n22 * n31
                        - n11 * n23 * n32
                        + n11 * n22 * n33
                        + n13 * n21 * n32
                        - n12 * n21 * n33
                        + n12 * n23 * n31
                    )

                );

            },

            transpose: function () {

                var te = this.elements;
                var tmp;

                tmp = te[1];
                te[1] = te[4];
                te[4] = tmp;
                tmp = te[2];
                te[2] = te[8];
                te[8] = tmp;
                tmp = te[6];
                te[6] = te[9];
                te[9] = tmp;

                tmp = te[3];
                te[3] = te[12];
                te[12] = tmp;
                tmp = te[7];
                te[7] = te[13];
                te[13] = tmp;
                tmp = te[11];
                te[11] = te[14];
                te[14] = tmp;

                return this;

            },

            setPosition: function (v) {

                var te = this.elements;

                te[12] = v.x;
                te[13] = v.y;
                te[14] = v.z;

                return this;

            },

            getInverse: function (m, throwOnDegenerate) {

                // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
                var te = this.elements,
                    me = m.elements,

                    n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3],
                    n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7],
                    n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11],
                    n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15],

                    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

                var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

                if (det === 0) {

                    var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

                    if (throwOnDegenerate === true) {

                        throw new Error(msg);

                    } else {

                        console.warn(msg);

                    }

                    return this.identity();

                }

                var detInv = 1 / det;

                te[0] = t11 * detInv;
                te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
                te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
                te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;

                te[4] = t12 * detInv;
                te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
                te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
                te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;

                te[8] = t13 * detInv;
                te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
                te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
                te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;

                te[12] = t14 * detInv;
                te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
                te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
                te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;

                return this;

            },

            scale: function (v) {

                var te = this.elements;
                var x = v.x, y = v.y, z = v.z;

                te[0] *= x;
                te[4] *= y;
                te[8] *= z;
                te[1] *= x;
                te[5] *= y;
                te[9] *= z;
                te[2] *= x;
                te[6] *= y;
                te[10] *= z;
                te[3] *= x;
                te[7] *= y;
                te[11] *= z;

                return this;

            },

            getMaxScaleOnAxis: function () {

                var te = this.elements;

                var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
                var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
                var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

                return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));

            },

            makeTranslation: function (x, y, z) {

                this.set(
                    1, 0, 0, x,
                    0, 1, 0, y,
                    0, 0, 1, z,
                    0, 0, 0, 1
                );

                return this;

            },

            makeRotationX: function (theta) {

                var c = Math.cos(theta), s = Math.sin(theta);

                this.set(
                    1, 0, 0, 0,
                    0, c, -s, 0,
                    0, s, c, 0,
                    0, 0, 0, 1
                );

                return this;

            },

            makeRotationY: function (theta) {

                var c = Math.cos(theta), s = Math.sin(theta);

                this.set(
                    c, 0, s, 0,
                    0, 1, 0, 0,
                    -s, 0, c, 0,
                    0, 0, 0, 1
                );

                return this;

            },

            makeRotationZ: function (theta) {

                var c = Math.cos(theta), s = Math.sin(theta);

                this.set(
                    c, -s, 0, 0,
                    s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                );

                return this;

            },

            makeRotationAxis: function (axis, angle) {

                // Based on http://www.gamedev.net/reference/articles/article1199.asp

                var c = Math.cos(angle);
                var s = Math.sin(angle);
                var t = 1 - c;
                var x = axis.x, y = axis.y, z = axis.z;
                var tx = t * x, ty = t * y;

                this.set(
                    tx * x + c, tx * y - s * z, tx * z + s * y, 0,
                    tx * y + s * z, ty * y + c, ty * z - s * x, 0,
                    tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
                    0, 0, 0, 1
                );

                return this;

            },

            makeScale: function (x, y, z) {

                this.set(
                    x, 0, 0, 0,
                    0, y, 0, 0,
                    0, 0, z, 0,
                    0, 0, 0, 1
                );

                return this;

            },

            makeShear: function (x, y, z) {

                this.set(
                    1, y, z, 0,
                    x, 1, z, 0,
                    x, y, 1, 0,
                    0, 0, 0, 1
                );

                return this;

            },

            compose: function (position, quaternion, scale) {

                this.makeRotationFromQuaternion(quaternion);
                this.scale(scale);
                this.setPosition(position);

                return this;

            },

            decompose: function () {

                var vector = new Vector3();
                var matrix = new Matrix4();

                return function decompose(position, quaternion, scale) {

                    var te = this.elements;

                    var sx = vector.set(te[0], te[1], te[2]).length();
                    var sy = vector.set(te[4], te[5], te[6]).length();
                    var sz = vector.set(te[8], te[9], te[10]).length();

                    // if determine is negative, we need to invert one scale
                    var det = this.determinant();
                    if (det < 0) sx = -sx;

                    position.x = te[12];
                    position.y = te[13];
                    position.z = te[14];

                    // scale the rotation part
                    matrix.copy(this);

                    var invSX = 1 / sx;
                    var invSY = 1 / sy;
                    var invSZ = 1 / sz;

                    matrix.elements[0] *= invSX;
                    matrix.elements[1] *= invSX;
                    matrix.elements[2] *= invSX;

                    matrix.elements[4] *= invSY;
                    matrix.elements[5] *= invSY;
                    matrix.elements[6] *= invSY;

                    matrix.elements[8] *= invSZ;
                    matrix.elements[9] *= invSZ;
                    matrix.elements[10] *= invSZ;

                    quaternion.setFromRotationMatrix(matrix);

                    scale.x = sx;
                    scale.y = sy;
                    scale.z = sz;

                    return this;

                };

            }(),

            makePerspective: function (left, right, top, bottom, near, far) {

                if (far === undefined) {

                    console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');

                }

                var te = this.elements;
                var x = 2 * near / (right - left);
                var y = 2 * near / (top - bottom);

                var a = (right + left) / (right - left);
                var b = (top + bottom) / (top - bottom);
                var c = -(far + near) / (far - near);
                var d = -2 * far * near / (far - near);

                te[0] = x;
                te[4] = 0;
                te[8] = a;
                te[12] = 0;
                te[1] = 0;
                te[5] = y;
                te[9] = b;
                te[13] = 0;
                te[2] = 0;
                te[6] = 0;
                te[10] = c;
                te[14] = d;
                te[3] = 0;
                te[7] = 0;
                te[11] = -1;
                te[15] = 0;

                return this;

            },

            makeOrthographic: function (left, right, top, bottom, near, far) {

                var te = this.elements;
                var w = 1.0 / (right - left);
                var h = 1.0 / (top - bottom);
                var p = 1.0 / (far - near);

                var x = (right + left) * w;
                var y = (top + bottom) * h;
                var z = (far + near) * p;

                te[0] = 2 * w;
                te[4] = 0;
                te[8] = 0;
                te[12] = -x;
                te[1] = 0;
                te[5] = 2 * h;
                te[9] = 0;
                te[13] = -y;
                te[2] = 0;
                te[6] = 0;
                te[10] = -2 * p;
                te[14] = -z;
                te[3] = 0;
                te[7] = 0;
                te[11] = 0;
                te[15] = 1;

                return this;

            },

            equals: function (matrix) {

                var te = this.elements;
                var me = matrix.elements;

                for (var i = 0; i < 16; i++) {

                    if (te[i] !== me[i]) return false;

                }

                return true;

            },

            fromArray: function (array, offset) {

                if (offset === undefined) offset = 0;

                for (var i = 0; i < 16; i++) {

                    this.elements[i] = array[i + offset];

                }

                return this;

            },

            toArray: function (array, offset) {

                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;

                var te = this.elements;

                array[offset] = te[0];
                array[offset + 1] = te[1];
                array[offset + 2] = te[2];
                array[offset + 3] = te[3];

                array[offset + 4] = te[4];
                array[offset + 5] = te[5];
                array[offset + 6] = te[6];
                array[offset + 7] = te[7];

                array[offset + 8] = te[8];
                array[offset + 9] = te[9];
                array[offset + 10] = te[10];
                array[offset + 11] = te[11];

                array[offset + 12] = te[12];
                array[offset + 13] = te[13];
                array[offset + 14] = te[14];
                array[offset + 15] = te[15];

                return array;

            }

        });

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author bhouston / http://clara.io
         */

        function Quaternion(x, y, z, w) {

            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._w = (w !== undefined) ? w : 1;

        }

        Object.assign(Quaternion, {

            slerp: function (qa, qb, qm, t) {

                return qm.copy(qa).slerp(qb, t);

            },

            slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {

                // fuzz-free, array-based Quaternion SLERP operation

                var x0 = src0[srcOffset0 + 0],
                    y0 = src0[srcOffset0 + 1],
                    z0 = src0[srcOffset0 + 2],
                    w0 = src0[srcOffset0 + 3],

                    x1 = src1[srcOffset1 + 0],
                    y1 = src1[srcOffset1 + 1],
                    z1 = src1[srcOffset1 + 2],
                    w1 = src1[srcOffset1 + 3];

                if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {

                    var s = 1 - t,

                        cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

                        dir = (cos >= 0 ? 1 : -1),
                        sqrSin = 1 - cos * cos;

                    // Skip the Slerp for tiny steps to avoid numeric problems:
                    if (sqrSin > Number.EPSILON) {

                        var sin = Math.sqrt(sqrSin),
                            len = Math.atan2(sin, cos * dir);

                        s = Math.sin(s * len) / sin;
                        t = Math.sin(t * len) / sin;

                    }

                    var tDir = t * dir;

                    x0 = x0 * s + x1 * tDir;
                    y0 = y0 * s + y1 * tDir;
                    z0 = z0 * s + z1 * tDir;
                    w0 = w0 * s + w1 * tDir;

                    // Normalize in case we just did a lerp:
                    if (s === 1 - t) {

                        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);

                        x0 *= f;
                        y0 *= f;
                        z0 *= f;
                        w0 *= f;

                    }

                }

                dst[dstOffset] = x0;
                dst[dstOffset + 1] = y0;
                dst[dstOffset + 2] = z0;
                dst[dstOffset + 3] = w0;

            }

        });

        Object.defineProperties(Quaternion.prototype, {

            x: {

                get: function () {

                    return this._x;

                },

                set: function (value) {

                    this._x = value;
                    this.onChangeCallback();

                }

            },

            y: {

                get: function () {

                    return this._y;

                },

                set: function (value) {

                    this._y = value;
                    this.onChangeCallback();

                }

            },

            z: {

                get: function () {

                    return this._z;

                },

                set: function (value) {

                    this._z = value;
                    this.onChangeCallback();

                }

            },

            w: {

                get: function () {

                    return this._w;

                },

                set: function (value) {

                    this._w = value;
                    this.onChangeCallback();

                }

            }

        });

        Object.assign(Quaternion.prototype, {

            set: function (x, y, z, w) {

                this._x = x;
                this._y = y;
                this._z = z;
                this._w = w;

                this.onChangeCallback();

                return this;

            },

            clone: function () {

                return new this.constructor(this._x, this._y, this._z, this._w);

            },

            copy: function (quaternion) {

                this._x = quaternion.x;
                this._y = quaternion.y;
                this._z = quaternion.z;
                this._w = quaternion.w;

                this.onChangeCallback();

                return this;

            },

            setFromEuler: function (euler, update) {

                if (!(euler && euler.isEuler)) {

                    throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');

                }

                var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

                // http://www.mathworks.com/matlabcentral/fileexchange/
                // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
                //	content/SpinCalc.m

                var cos = Math.cos;
                var sin = Math.sin;

                var c1 = cos(x / 2);
                var c2 = cos(y / 2);
                var c3 = cos(z / 2);

                var s1 = sin(x / 2);
                var s2 = sin(y / 2);
                var s3 = sin(z / 2);

                if (order === 'XYZ') {

                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;

                } else if (order === 'YXZ') {

                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;

                } else if (order === 'ZXY') {

                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;

                } else if (order === 'ZYX') {

                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;

                } else if (order === 'YZX') {

                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;

                } else if (order === 'XZY') {

                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;

                }

                if (update !== false) this.onChangeCallback();

                return this;

            },

            setFromAxisAngle: function (axis, angle) {

                // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

                // assumes axis is normalized

                var halfAngle = angle / 2, s = Math.sin(halfAngle);

                this._x = axis.x * s;
                this._y = axis.y * s;
                this._z = axis.z * s;
                this._w = Math.cos(halfAngle);

                this.onChangeCallback();

                return this;

            },

            setFromRotationMatrix: function (m) {

                // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

                // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

                var te = m.elements,

                    m11 = te[0], m12 = te[4], m13 = te[8],
                    m21 = te[1], m22 = te[5], m23 = te[9],
                    m31 = te[2], m32 = te[6], m33 = te[10],

                    trace = m11 + m22 + m33,
                    s;

                if (trace > 0) {

                    s = 0.5 / Math.sqrt(trace + 1.0);

                    this._w = 0.25 / s;
                    this._x = (m32 - m23) * s;
                    this._y = (m13 - m31) * s;
                    this._z = (m21 - m12) * s;

                } else if (m11 > m22 && m11 > m33) {

                    s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

                    this._w = (m32 - m23) / s;
                    this._x = 0.25 * s;
                    this._y = (m12 + m21) / s;
                    this._z = (m13 + m31) / s;

                } else if (m22 > m33) {

                    s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

                    this._w = (m13 - m31) / s;
                    this._x = (m12 + m21) / s;
                    this._y = 0.25 * s;
                    this._z = (m23 + m32) / s;

                } else {

                    s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

                    this._w = (m21 - m12) / s;
                    this._x = (m13 + m31) / s;
                    this._y = (m23 + m32) / s;
                    this._z = 0.25 * s;

                }

                this.onChangeCallback();

                return this;

            },

            setFromUnitVectors: function () {

                // assumes direction vectors vFrom and vTo are normalized

                var v1 = new Vector3();
                var r;

                var EPS = 0.000001;

                return function setFromUnitVectors(vFrom, vTo) {

                    if (v1 === undefined) v1 = new Vector3();

                    r = vFrom.dot(vTo) + 1;

                    if (r < EPS) {

                        r = 0;

                        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {

                            v1.set(-vFrom.y, vFrom.x, 0);

                        } else {

                            v1.set(0, -vFrom.z, vFrom.y);

                        }

                    } else {

                        v1.crossVectors(vFrom, vTo);

                    }

                    this._x = v1.x;
                    this._y = v1.y;
                    this._z = v1.z;
                    this._w = r;

                    return this.normalize();

                };

            }(),

            inverse: function () {

                return this.conjugate().normalize();

            },

            conjugate: function () {

                this._x *= -1;
                this._y *= -1;
                this._z *= -1;

                this.onChangeCallback();

                return this;

            },

            dot: function (v) {

                return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

            },

            lengthSq: function () {

                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

            },

            length: function () {

                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);

            },

            normalize: function () {

                var l = this.length();

                if (l === 0) {

                    this._x = 0;
                    this._y = 0;
                    this._z = 0;
                    this._w = 1;

                } else {

                    l = 1 / l;

                    this._x = this._x * l;
                    this._y = this._y * l;
                    this._z = this._z * l;
                    this._w = this._w * l;

                }

                this.onChangeCallback();

                return this;

            },

            multiply: function (q, p) {

                if (p !== undefined) {

                    console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
                    return this.multiplyQuaternions(q, p);

                }

                return this.multiplyQuaternions(this, q);

            },

            premultiply: function (q) {

                return this.multiplyQuaternions(q, this);

            },

            multiplyQuaternions: function (a, b) {

                // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

                var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
                var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

                this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
                this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
                this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
                this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

                this.onChangeCallback();

                return this;

            },

            slerp: function (qb, t) {

                if (t === 0) return this;
                if (t === 1) return this.copy(qb);

                var x = this._x, y = this._y, z = this._z, w = this._w;

                // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

                var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

                if (cosHalfTheta < 0) {

                    this._w = -qb._w;
                    this._x = -qb._x;
                    this._y = -qb._y;
                    this._z = -qb._z;

                    cosHalfTheta = -cosHalfTheta;

                } else {

                    this.copy(qb);

                }

                if (cosHalfTheta >= 1.0) {

                    this._w = w;
                    this._x = x;
                    this._y = y;
                    this._z = z;

                    return this;

                }

                var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

                if (Math.abs(sinHalfTheta) < 0.001) {

                    this._w = 0.5 * (w + this._w);
                    this._x = 0.5 * (x + this._x);
                    this._y = 0.5 * (y + this._y);
                    this._z = 0.5 * (z + this._z);

                    return this;

                }

                var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
                var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
                    ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

                this._w = (w * ratioA + this._w * ratioB);
                this._x = (x * ratioA + this._x * ratioB);
                this._y = (y * ratioA + this._y * ratioB);
                this._z = (z * ratioA + this._z * ratioB);

                this.onChangeCallback();

                return this;

            },

            equals: function (quaternion) {

                return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);

            },

            fromArray: function (array, offset) {

                if (offset === undefined) offset = 0;

                this._x = array[offset];
                this._y = array[offset + 1];
                this._z = array[offset + 2];
                this._w = array[offset + 3];

                this.onChangeCallback();

                return this;

            },

            toArray: function (array, offset) {

                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;

                array[offset] = this._x;
                array[offset + 1] = this._y;
                array[offset + 2] = this._z;
                array[offset + 3] = this._w;

                return array;

            },

            onChange: function (callback) {

                this.onChangeCallback = callback;

                return this;

            },

            onChangeCallback: function () {
            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author kile / http://kile.stravaganza.org/
         * @author philogb / http://blog.thejit.org/
         * @author mikael emtinger / http://gomo.se/
         * @author egraether / http://egraether.com/
         * @author WestLangley / http://github.com/WestLangley
         */

        function Vector3(x, y, z) {

            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;

        }

        Object.assign(Vector3.prototype, {

            isVector3: true,

            set: function (x, y, z) {

                this.x = x;
                this.y = y;
                this.z = z;

                return this;

            },

            setScalar: function (scalar) {

                this.x = scalar;
                this.y = scalar;
                this.z = scalar;

                return this;

            },

            setX: function (x) {

                this.x = x;

                return this;

            },

            setY: function (y) {

                this.y = y;

                return this;

            },

            setZ: function (z) {

                this.z = z;

                return this;

            },

            setComponent: function (index, value) {

                switch (index) {

                    case 0:
                        this.x = value;
                        break;
                    case 1:
                        this.y = value;
                        break;
                    case 2:
                        this.z = value;
                        break;
                    default:
                        throw new Error('index is out of range: ' + index);

                }

                return this;

            },

            getComponent: function (index) {

                switch (index) {

                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error('index is out of range: ' + index);

                }

            },

            clone: function () {

                return new this.constructor(this.x, this.y, this.z);

            },

            copy: function (v) {

                this.x = v.x;
                this.y = v.y;
                this.z = v.z;

                return this;

            },

            add: function (v, w) {

                if (w !== undefined) {

                    console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                    return this.addVectors(v, w);

                }

                this.x += v.x;
                this.y += v.y;
                this.z += v.z;

                return this;

            },

            addScalar: function (s) {

                this.x += s;
                this.y += s;
                this.z += s;

                return this;

            },

            addVectors: function (a, b) {

                this.x = a.x + b.x;
                this.y = a.y + b.y;
                this.z = a.z + b.z;

                return this;

            },

            addScaledVector: function (v, s) {

                this.x += v.x * s;
                this.y += v.y * s;
                this.z += v.z * s;

                return this;

            },

            sub: function (v, w) {

                if (w !== undefined) {

                    console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                    return this.subVectors(v, w);

                }

                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z;

                return this;

            },

            subScalar: function (s) {

                this.x -= s;
                this.y -= s;
                this.z -= s;

                return this;

            },

            subVectors: function (a, b) {

                this.x = a.x - b.x;
                this.y = a.y - b.y;
                this.z = a.z - b.z;

                return this;

            },

            multiply: function (v, w) {

                if (w !== undefined) {

                    console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
                    return this.multiplyVectors(v, w);

                }

                this.x *= v.x;
                this.y *= v.y;
                this.z *= v.z;

                return this;

            },

            multiplyScalar: function (scalar) {

                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;

                return this;

            },

            multiplyVectors: function (a, b) {

                this.x = a.x * b.x;
                this.y = a.y * b.y;
                this.z = a.z * b.z;

                return this;

            },

            applyEuler: function () {

                var quaternion = new Quaternion();

                return function applyEuler(euler) {

                    if (!(euler && euler.isEuler)) {

                        console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');

                    }

                    return this.applyQuaternion(quaternion.setFromEuler(euler));

                };

            }(),

            applyAxisAngle: function () {

                var quaternion = new Quaternion();

                return function applyAxisAngle(axis, angle) {

                    return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));

                };

            }(),

            applyMatrix3: function (m) {

                var x = this.x, y = this.y, z = this.z;
                var e = m.elements;

                this.x = e[0] * x + e[3] * y + e[6] * z;
                this.y = e[1] * x + e[4] * y + e[7] * z;
                this.z = e[2] * x + e[5] * y + e[8] * z;

                return this;

            },

            applyMatrix4: function (m) {

                var x = this.x, y = this.y, z = this.z;
                var e = m.elements;

                var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);

                this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
                this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
                this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;

                return this;

            },

            applyQuaternion: function (q) {

                var x = this.x, y = this.y, z = this.z;
                var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

                // calculate quat * vector

                var ix = qw * x + qy * z - qz * y;
                var iy = qw * y + qz * x - qx * z;
                var iz = qw * z + qx * y - qy * x;
                var iw = -qx * x - qy * y - qz * z;

                // calculate result * inverse quat

                this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

                return this;

            },

            project: function () {

                var matrix = new Matrix4();

                return function project(camera) {

                    matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
                    return this.applyMatrix4(matrix);

                };

            }(),

            unproject: function () {

                var matrix = new Matrix4();

                return function unproject(camera) {

                    matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
                    return this.applyMatrix4(matrix);

                };

            }(),

            transformDirection: function (m) {

                // input: THREE.Matrix4 affine matrix
                // vector interpreted as a direction

                var x = this.x, y = this.y, z = this.z;
                var e = m.elements;

                this.x = e[0] * x + e[4] * y + e[8] * z;
                this.y = e[1] * x + e[5] * y + e[9] * z;
                this.z = e[2] * x + e[6] * y + e[10] * z;

                return this.normalize();

            },

            divide: function (v) {

                this.x /= v.x;
                this.y /= v.y;
                this.z /= v.z;

                return this;

            },

            divideScalar: function (scalar) {

                return this.multiplyScalar(1 / scalar);

            },

            min: function (v) {

                this.x = Math.min(this.x, v.x);
                this.y = Math.min(this.y, v.y);
                this.z = Math.min(this.z, v.z);

                return this;

            },

            max: function (v) {

                this.x = Math.max(this.x, v.x);
                this.y = Math.max(this.y, v.y);
                this.z = Math.max(this.z, v.z);

                return this;

            },

            clamp: function (min, max) {

                // assumes min < max, componentwise

                this.x = Math.max(min.x, Math.min(max.x, this.x));
                this.y = Math.max(min.y, Math.min(max.y, this.y));
                this.z = Math.max(min.z, Math.min(max.z, this.z));

                return this;

            },

            clampScalar: function () {

                var min = new Vector3();
                var max = new Vector3();

                return function clampScalar(minVal, maxVal) {

                    min.set(minVal, minVal, minVal);
                    max.set(maxVal, maxVal, maxVal);

                    return this.clamp(min, max);

                };

            }(),

            clampLength: function (min, max) {

                var length = this.length();

                return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));

            },

            floor: function () {

                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                this.z = Math.floor(this.z);

                return this;

            },

            ceil: function () {

                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                this.z = Math.ceil(this.z);

                return this;

            },

            round: function () {

                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                this.z = Math.round(this.z);

                return this;

            },

            roundToZero: function () {

                this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
                this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
                this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);

                return this;

            },

            negate: function () {

                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;

                return this;

            },

            dot: function (v) {

                return this.x * v.x + this.y * v.y + this.z * v.z;

            },

            // TODO lengthSquared?

            lengthSq: function () {

                return this.x * this.x + this.y * this.y + this.z * this.z;

            },

            length: function () {

                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

            },

            manhattanLength: function () {

                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);

            },

            normalize: function () {

                return this.divideScalar(this.length() || 1);

            },

            setLength: function (length) {

                return this.normalize().multiplyScalar(length);

            },

            lerp: function (v, alpha) {

                this.x += (v.x - this.x) * alpha;
                this.y += (v.y - this.y) * alpha;
                this.z += (v.z - this.z) * alpha;

                return this;

            },

            lerpVectors: function (v1, v2, alpha) {

                return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);

            },

            cross: function (v, w) {

                if (w !== undefined) {

                    console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
                    return this.crossVectors(v, w);

                }

                var x = this.x, y = this.y, z = this.z;

                this.x = y * v.z - z * v.y;
                this.y = z * v.x - x * v.z;
                this.z = x * v.y - y * v.x;

                return this;

            },

            crossVectors: function (a, b) {

                var ax = a.x, ay = a.y, az = a.z;
                var bx = b.x, by = b.y, bz = b.z;

                this.x = ay * bz - az * by;
                this.y = az * bx - ax * bz;
                this.z = ax * by - ay * bx;

                return this;

            },

            projectOnVector: function (vector) {

                var scalar = vector.dot(this) / vector.lengthSq();

                return this.copy(vector).multiplyScalar(scalar);

            },

            projectOnPlane: function () {

                var v1 = new Vector3();

                return function projectOnPlane(planeNormal) {

                    v1.copy(this).projectOnVector(planeNormal);

                    return this.sub(v1);

                };

            }(),

            reflect: function () {

                // reflect incident vector off plane orthogonal to normal
                // normal is assumed to have unit length

                var v1 = new Vector3();

                return function reflect(normal) {

                    return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));

                };

            }(),

            angleTo: function (v) {

                var theta = this.dot(v) / (Math.sqrt(this.lengthSq() * v.lengthSq()));

                // clamp, to handle numerical problems

                return Math.acos(_Math.clamp(theta, -1, 1));

            },

            distanceTo: function (v) {

                return Math.sqrt(this.distanceToSquared(v));

            },

            distanceToSquared: function (v) {

                var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

                return dx * dx + dy * dy + dz * dz;

            },

            manhattanDistanceTo: function (v) {

                return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);

            },

            setFromSpherical: function (s) {

                var sinPhiRadius = Math.sin(s.phi) * s.radius;

                this.x = sinPhiRadius * Math.sin(s.theta);
                this.y = Math.cos(s.phi) * s.radius;
                this.z = sinPhiRadius * Math.cos(s.theta);

                return this;

            },

            setFromCylindrical: function (c) {

                this.x = c.radius * Math.sin(c.theta);
                this.y = c.y;
                this.z = c.radius * Math.cos(c.theta);

                return this;

            },

            setFromMatrixPosition: function (m) {

                var e = m.elements;

                this.x = e[12];
                this.y = e[13];
                this.z = e[14];

                return this;

            },

            setFromMatrixScale: function (m) {

                var sx = this.setFromMatrixColumn(m, 0).length();
                var sy = this.setFromMatrixColumn(m, 1).length();
                var sz = this.setFromMatrixColumn(m, 2).length();

                this.x = sx;
                this.y = sy;
                this.z = sz;

                return this;

            },

            setFromMatrixColumn: function (m, index) {

                return this.fromArray(m.elements, index * 4);

            },

            equals: function (v) {

                return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));

            },

            fromArray: function (array, offset) {

                if (offset === undefined) offset = 0;

                this.x = array[offset];
                this.y = array[offset + 1];
                this.z = array[offset + 2];

                return this;

            },

            toArray: function (array, offset) {

                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;

                array[offset] = this.x;
                array[offset + 1] = this.y;
                array[offset + 2] = this.z;

                return array;

            },

            fromBufferAttribute: function (attribute, index, offset) {

                if (offset !== undefined) {

                    console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');

                }

                this.x = attribute.getX(index);
                this.y = attribute.getY(index);
                this.z = attribute.getZ(index);

                return this;

            }

        });

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author bhouston / http://clara.io
         * @author tschw
         */

        function Matrix3() {

            this.elements = [

                1, 0, 0,
                0, 1, 0,
                0, 0, 1

            ];

            if (arguments.length > 0) {

                console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');

            }

        }

        Object.assign(Matrix3.prototype, {

            isMatrix3: true,

            set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {

                var te = this.elements;

                te[0] = n11;
                te[1] = n21;
                te[2] = n31;
                te[3] = n12;
                te[4] = n22;
                te[5] = n32;
                te[6] = n13;
                te[7] = n23;
                te[8] = n33;

                return this;

            },

            identity: function () {

                this.set(
                    1, 0, 0,
                    0, 1, 0,
                    0, 0, 1
                );

                return this;

            },

            clone: function () {

                return new this.constructor().fromArray(this.elements);

            },

            copy: function (m) {

                var te = this.elements;
                var me = m.elements;

                te[0] = me[0];
                te[1] = me[1];
                te[2] = me[2];
                te[3] = me[3];
                te[4] = me[4];
                te[5] = me[5];
                te[6] = me[6];
                te[7] = me[7];
                te[8] = me[8];

                return this;

            },

            setFromMatrix4: function (m) {

                var me = m.elements;

                this.set(
                    me[0], me[4], me[8],
                    me[1], me[5], me[9],
                    me[2], me[6], me[10]
                );

                return this;

            },

            applyToBufferAttribute: function () {

                var v1 = new Vector3();

                return function applyToBufferAttribute(attribute) {

                    for (var i = 0, l = attribute.count; i < l; i++) {

                        v1.x = attribute.getX(i);
                        v1.y = attribute.getY(i);
                        v1.z = attribute.getZ(i);

                        v1.applyMatrix3(this);

                        attribute.setXYZ(i, v1.x, v1.y, v1.z);

                    }

                    return attribute;

                };

            }(),

            multiply: function (m) {

                return this.multiplyMatrices(this, m);

            },

            premultiply: function (m) {

                return this.multiplyMatrices(m, this);

            },

            multiplyMatrices: function (a, b) {

                var ae = a.elements;
                var be = b.elements;
                var te = this.elements;

                var a11 = ae[0], a12 = ae[3], a13 = ae[6];
                var a21 = ae[1], a22 = ae[4], a23 = ae[7];
                var a31 = ae[2], a32 = ae[5], a33 = ae[8];

                var b11 = be[0], b12 = be[3], b13 = be[6];
                var b21 = be[1], b22 = be[4], b23 = be[7];
                var b31 = be[2], b32 = be[5], b33 = be[8];

                te[0] = a11 * b11 + a12 * b21 + a13 * b31;
                te[3] = a11 * b12 + a12 * b22 + a13 * b32;
                te[6] = a11 * b13 + a12 * b23 + a13 * b33;

                te[1] = a21 * b11 + a22 * b21 + a23 * b31;
                te[4] = a21 * b12 + a22 * b22 + a23 * b32;
                te[7] = a21 * b13 + a22 * b23 + a23 * b33;

                te[2] = a31 * b11 + a32 * b21 + a33 * b31;
                te[5] = a31 * b12 + a32 * b22 + a33 * b32;
                te[8] = a31 * b13 + a32 * b23 + a33 * b33;

                return this;

            },

            multiplyScalar: function (s) {

                var te = this.elements;

                te[0] *= s;
                te[3] *= s;
                te[6] *= s;
                te[1] *= s;
                te[4] *= s;
                te[7] *= s;
                te[2] *= s;
                te[5] *= s;
                te[8] *= s;

                return this;

            },

            determinant: function () {

                var te = this.elements;

                var a = te[0], b = te[1], c = te[2],
                    d = te[3], e = te[4], f = te[5],
                    g = te[6], h = te[7], i = te[8];

                return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

            },

            getInverse: function (matrix, throwOnDegenerate) {

                if (matrix && matrix.isMatrix4) {

                    console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");

                }

                var me = matrix.elements,
                    te = this.elements,

                    n11 = me[0], n21 = me[1], n31 = me[2],
                    n12 = me[3], n22 = me[4], n32 = me[5],
                    n13 = me[6], n23 = me[7], n33 = me[8],

                    t11 = n33 * n22 - n32 * n23,
                    t12 = n32 * n13 - n33 * n12,
                    t13 = n23 * n12 - n22 * n13,

                    det = n11 * t11 + n21 * t12 + n31 * t13;

                if (det === 0) {

                    var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

                    if (throwOnDegenerate === true) {

                        throw new Error(msg);

                    } else {

                        console.warn(msg);

                    }

                    return this.identity();

                }

                var detInv = 1 / det;

                te[0] = t11 * detInv;
                te[1] = (n31 * n23 - n33 * n21) * detInv;
                te[2] = (n32 * n21 - n31 * n22) * detInv;

                te[3] = t12 * detInv;
                te[4] = (n33 * n11 - n31 * n13) * detInv;
                te[5] = (n31 * n12 - n32 * n11) * detInv;

                te[6] = t13 * detInv;
                te[7] = (n21 * n13 - n23 * n11) * detInv;
                te[8] = (n22 * n11 - n21 * n12) * detInv;

                return this;

            },

            transpose: function () {

                var tmp, m = this.elements;

                tmp = m[1];
                m[1] = m[3];
                m[3] = tmp;
                tmp = m[2];
                m[2] = m[6];
                m[6] = tmp;
                tmp = m[5];
                m[5] = m[7];
                m[7] = tmp;

                return this;

            },

            getNormalMatrix: function (matrix4) {

                return this.setFromMatrix4(matrix4).getInverse(this).transpose();

            },

            transposeIntoArray: function (r) {

                var m = this.elements;

                r[0] = m[0];
                r[1] = m[3];
                r[2] = m[6];
                r[3] = m[1];
                r[4] = m[4];
                r[5] = m[7];
                r[6] = m[2];
                r[7] = m[5];
                r[8] = m[8];

                return this;

            },

            setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {

                var c = Math.cos(rotation);
                var s = Math.sin(rotation);

                this.set(
                    sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx,
                    -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty,
                    0, 0, 1
                );

            },

            scale: function (sx, sy) {

                var te = this.elements;

                te[0] *= sx;
                te[3] *= sx;
                te[6] *= sx;
                te[1] *= sy;
                te[4] *= sy;
                te[7] *= sy;

                return this;

            },

            rotate: function (theta) {

                var c = Math.cos(theta);
                var s = Math.sin(theta);

                var te = this.elements;

                var a11 = te[0], a12 = te[3], a13 = te[6];
                var a21 = te[1], a22 = te[4], a23 = te[7];

                te[0] = c * a11 + s * a21;
                te[3] = c * a12 + s * a22;
                te[6] = c * a13 + s * a23;

                te[1] = -s * a11 + c * a21;
                te[4] = -s * a12 + c * a22;
                te[7] = -s * a13 + c * a23;

                return this;

            },

            translate: function (tx, ty) {

                var te = this.elements;

                te[0] += tx * te[2];
                te[3] += tx * te[5];
                te[6] += tx * te[8];
                te[1] += ty * te[2];
                te[4] += ty * te[5];
                te[7] += ty * te[8];

                return this;

            },

            equals: function (matrix) {

                var te = this.elements;
                var me = matrix.elements;

                for (var i = 0; i < 9; i++) {

                    if (te[i] !== me[i]) return false;

                }

                return true;

            },

            fromArray: function (array, offset) {

                if (offset === undefined) offset = 0;

                for (var i = 0; i < 9; i++) {

                    this.elements[i] = array[i + offset];

                }

                return this;

            },

            toArray: function (array, offset) {

                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;

                var te = this.elements;

                array[offset] = te[0];
                array[offset + 1] = te[1];
                array[offset + 2] = te[2];

                array[offset + 3] = te[3];
                array[offset + 4] = te[4];
                array[offset + 5] = te[5];

                array[offset + 6] = te[6];
                array[offset + 7] = te[7];
                array[offset + 8] = te[8];

                return array;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author szimek / https://github.com/szimek/
         */

        var textureId = 0;

        function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

            Object.defineProperty(this, 'id', {value: textureId++});

            this.uuid = _Math.generateUUID();

            this.name = '';

            this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
            this.mipmaps = [];

            this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

            this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
            this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

            this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
            this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

            this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

            this.format = format !== undefined ? format : RGBAFormat;
            this.type = type !== undefined ? type : UnsignedByteType;

            this.offset = new Vector2(0, 0);
            this.repeat = new Vector2(1, 1);
            this.center = new Vector2(0, 0);
            this.rotation = 0;

            this.matrixAutoUpdate = true;
            this.matrix = new Matrix3();

            this.generateMipmaps = true;
            this.premultiplyAlpha = false;
            this.flipY = true;
            this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

            // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
            //
            // Also changing the encoding after already used by a Material will not automatically make the Material
            // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
            this.encoding = encoding !== undefined ? encoding : LinearEncoding;

            this.version = 0;
            this.onUpdate = null;

        }

        Texture.DEFAULT_IMAGE = undefined;
        Texture.DEFAULT_MAPPING = UVMapping;

        Object.defineProperty(Texture.prototype, "needsUpdate", {

            set: function (value) {

                if (value === true) this.version++;

            }

        });

        Object.assign(Texture.prototype, EventDispatcher.prototype, {

            constructor: Texture,

            isTexture: true,

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (source) {

                this.name = source.name;

                this.image = source.image;
                this.mipmaps = source.mipmaps.slice(0);

                this.mapping = source.mapping;

                this.wrapS = source.wrapS;
                this.wrapT = source.wrapT;

                this.magFilter = source.magFilter;
                this.minFilter = source.minFilter;

                this.anisotropy = source.anisotropy;

                this.format = source.format;
                this.type = source.type;

                this.offset.copy(source.offset);
                this.repeat.copy(source.repeat);
                this.center.copy(source.center);
                this.rotation = source.rotation;

                this.matrixAutoUpdate = source.matrixAutoUpdate;
                this.matrix.copy(source.matrix);

                this.generateMipmaps = source.generateMipmaps;
                this.premultiplyAlpha = source.premultiplyAlpha;
                this.flipY = source.flipY;
                this.unpackAlignment = source.unpackAlignment;
                this.encoding = source.encoding;

                return this;

            },

            toJSON: function (meta) {

                var isRootObject = (meta === undefined || typeof meta === 'string');

                if (!isRootObject && meta.textures[this.uuid] !== undefined) {

                    return meta.textures[this.uuid];

                }

                function getDataURL(image) {

                    var canvas;

                    if (image instanceof HTMLCanvasElement) {

                        canvas = image;

                    } else {

                        canvas = document.createElement('canvas');
                        canvas.width = image.width;
                        canvas.height = image.height;

                        var context = canvas.getContext('2d');

                        if (image instanceof ImageData) {

                            context.putImageData(image, 0, 0);

                        } else {

                            context.drawImage(image, 0, 0, image.width, image.height);

                        }

                    }

                    if (canvas.width > 2048 || canvas.height > 2048) {

                        return canvas.toDataURL('image/jpeg', 0.6);

                    } else {

                        return canvas.toDataURL('image/png');

                    }

                }

                var output = {
                    metadata: {
                        version: 4.5,
                        type: 'Texture',
                        generator: 'Texture.toJSON'
                    },

                    uuid: this.uuid,
                    name: this.name,

                    mapping: this.mapping,

                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,

                    wrap: [this.wrapS, this.wrapT],

                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,

                    flipY: this.flipY
                };

                if (this.image !== undefined) {

                    // TODO: Move to THREE.Image

                    var image = this.image;

                    if (image.uuid === undefined) {

                        image.uuid = _Math.generateUUID(); // UGH

                    }

                    if (!isRootObject && meta.images[image.uuid] === undefined) {

                        meta.images[image.uuid] = {
                            uuid: image.uuid,
                            url: getDataURL(image)
                        };

                    }

                    output.image = image.uuid;

                }

                if (!isRootObject) {

                    meta.textures[this.uuid] = output;

                }

                return output;

            },

            dispose: function () {

                this.dispatchEvent({type: 'dispose'});

            },

            transformUv: function (uv) {

                if (this.mapping !== UVMapping) return;

                uv.applyMatrix3(this.matrix);

                if (uv.x < 0 || uv.x > 1) {

                    switch (this.wrapS) {

                        case RepeatWrapping:

                            uv.x = uv.x - Math.floor(uv.x);
                            break;

                        case ClampToEdgeWrapping:

                            uv.x = uv.x < 0 ? 0 : 1;
                            break;

                        case MirroredRepeatWrapping:

                            if (Math.abs(Math.floor(uv.x) % 2) === 1) {

                                uv.x = Math.ceil(uv.x) - uv.x;

                            } else {

                                uv.x = uv.x - Math.floor(uv.x);

                            }
                            break;

                    }

                }

                if (uv.y < 0 || uv.y > 1) {

                    switch (this.wrapT) {

                        case RepeatWrapping:

                            uv.y = uv.y - Math.floor(uv.y);
                            break;

                        case ClampToEdgeWrapping:

                            uv.y = uv.y < 0 ? 0 : 1;
                            break;

                        case MirroredRepeatWrapping:

                            if (Math.abs(Math.floor(uv.y) % 2) === 1) {

                                uv.y = Math.ceil(uv.y) - uv.y;

                            } else {

                                uv.y = uv.y - Math.floor(uv.y);

                            }
                            break;

                    }

                }

                if (this.flipY) {

                    uv.y = 1 - uv.y;

                }

            }

        });

        /**
         * @author supereggbert / http://www.paulbrunt.co.uk/
         * @author philogb / http://blog.thejit.org/
         * @author mikael emtinger / http://gomo.se/
         * @author egraether / http://egraether.com/
         * @author WestLangley / http://github.com/WestLangley
         */

        function Vector4(x, y, z, w) {

            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = (w !== undefined) ? w : 1;

        }

        Object.assign(Vector4.prototype, {

            isVector4: true,

            set: function (x, y, z, w) {

                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;

                return this;

            },

            setScalar: function (scalar) {

                this.x = scalar;
                this.y = scalar;
                this.z = scalar;
                this.w = scalar;

                return this;

            },

            setX: function (x) {

                this.x = x;

                return this;

            },

            setY: function (y) {

                this.y = y;

                return this;

            },

            setZ: function (z) {

                this.z = z;

                return this;

            },

            setW: function (w) {

                this.w = w;

                return this;

            },

            setComponent: function (index, value) {

                switch (index) {

                    case 0:
                        this.x = value;
                        break;
                    case 1:
                        this.y = value;
                        break;
                    case 2:
                        this.z = value;
                        break;
                    case 3:
                        this.w = value;
                        break;
                    default:
                        throw new Error('index is out of range: ' + index);

                }

                return this;

            },

            getComponent: function (index) {

                switch (index) {

                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error('index is out of range: ' + index);

                }

            },

            clone: function () {

                return new this.constructor(this.x, this.y, this.z, this.w);

            },

            copy: function (v) {

                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
                this.w = (v.w !== undefined) ? v.w : 1;

                return this;

            },

            add: function (v, w) {

                if (w !== undefined) {

                    console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                    return this.addVectors(v, w);

                }

                this.x += v.x;
                this.y += v.y;
                this.z += v.z;
                this.w += v.w;

                return this;

            },

            addScalar: function (s) {

                this.x += s;
                this.y += s;
                this.z += s;
                this.w += s;

                return this;

            },

            addVectors: function (a, b) {

                this.x = a.x + b.x;
                this.y = a.y + b.y;
                this.z = a.z + b.z;
                this.w = a.w + b.w;

                return this;

            },

            addScaledVector: function (v, s) {

                this.x += v.x * s;
                this.y += v.y * s;
                this.z += v.z * s;
                this.w += v.w * s;

                return this;

            },

            sub: function (v, w) {

                if (w !== undefined) {

                    console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                    return this.subVectors(v, w);

                }

                this.x -= v.x;
                this.y -= v.y;
                this.z -= v.z;
                this.w -= v.w;

                return this;

            },

            subScalar: function (s) {

                this.x -= s;
                this.y -= s;
                this.z -= s;
                this.w -= s;

                return this;

            },

            subVectors: function (a, b) {

                this.x = a.x - b.x;
                this.y = a.y - b.y;
                this.z = a.z - b.z;
                this.w = a.w - b.w;

                return this;

            },

            multiplyScalar: function (scalar) {

                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                this.w *= scalar;

                return this;

            },

            applyMatrix4: function (m) {

                var x = this.x, y = this.y, z = this.z, w = this.w;
                var e = m.elements;

                this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
                this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
                this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
                this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

                return this;

            },

            divideScalar: function (scalar) {

                return this.multiplyScalar(1 / scalar);

            },

            setAxisAngleFromQuaternion: function (q) {

                // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

                // q is assumed to be normalized

                this.w = 2 * Math.acos(q.w);

                var s = Math.sqrt(1 - q.w * q.w);

                if (s < 0.0001) {

                    this.x = 1;
                    this.y = 0;
                    this.z = 0;

                } else {

                    this.x = q.x / s;
                    this.y = q.y / s;
                    this.z = q.z / s;

                }

                return this;

            },

            setAxisAngleFromRotationMatrix: function (m) {

                // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

                // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

                var angle, x, y, z,		// variables for result
                    epsilon = 0.01,		// margin to allow for rounding errors
                    epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

                    te = m.elements,

                    m11 = te[0], m12 = te[4], m13 = te[8],
                    m21 = te[1], m22 = te[5], m23 = te[9],
                    m31 = te[2], m32 = te[6], m33 = te[10];

                if ((Math.abs(m12 - m21) < epsilon) &&
                    (Math.abs(m13 - m31) < epsilon) &&
                    (Math.abs(m23 - m32) < epsilon)) {

                    // singularity found
                    // first check for identity matrix which must have +1 for all terms
                    // in leading diagonal and zero in other terms

                    if ((Math.abs(m12 + m21) < epsilon2) &&
                        (Math.abs(m13 + m31) < epsilon2) &&
                        (Math.abs(m23 + m32) < epsilon2) &&
                        (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {

                        // this singularity is identity matrix so angle = 0

                        this.set(1, 0, 0, 0);

                        return this; // zero angle, arbitrary axis

                    }

                    // otherwise this singularity is angle = 180

                    angle = Math.PI;

                    var xx = (m11 + 1) / 2;
                    var yy = (m22 + 1) / 2;
                    var zz = (m33 + 1) / 2;
                    var xy = (m12 + m21) / 4;
                    var xz = (m13 + m31) / 4;
                    var yz = (m23 + m32) / 4;

                    if ((xx > yy) && (xx > zz)) {

                        // m11 is the largest diagonal term

                        if (xx < epsilon) {

                            x = 0;
                            y = 0.707106781;
                            z = 0.707106781;

                        } else {

                            x = Math.sqrt(xx);
                            y = xy / x;
                            z = xz / x;

                        }

                    } else if (yy > zz) {

                        // m22 is the largest diagonal term

                        if (yy < epsilon) {

                            x = 0.707106781;
                            y = 0;
                            z = 0.707106781;

                        } else {

                            y = Math.sqrt(yy);
                            x = xy / y;
                            z = yz / y;

                        }

                    } else {

                        // m33 is the largest diagonal term so base result on this

                        if (zz < epsilon) {

                            x = 0.707106781;
                            y = 0.707106781;
                            z = 0;

                        } else {

                            z = Math.sqrt(zz);
                            x = xz / z;
                            y = yz / z;

                        }

                    }

                    this.set(x, y, z, angle);

                    return this; // return 180 deg rotation

                }

                // as we have reached here there are no singularities so we can handle normally

                var s = Math.sqrt((m32 - m23) * (m32 - m23) +
                    (m13 - m31) * (m13 - m31) +
                    (m21 - m12) * (m21 - m12)); // used to normalize

                if (Math.abs(s) < 0.001) s = 1;

                // prevent divide by zero, should not happen if matrix is orthogonal and should be
                // caught by singularity test above, but I've left it in just in case

                this.x = (m32 - m23) / s;
                this.y = (m13 - m31) / s;
                this.z = (m21 - m12) / s;
                this.w = Math.acos((m11 + m22 + m33 - 1) / 2);

                return this;

            },

            min: function (v) {

                this.x = Math.min(this.x, v.x);
                this.y = Math.min(this.y, v.y);
                this.z = Math.min(this.z, v.z);
                this.w = Math.min(this.w, v.w);

                return this;

            },

            max: function (v) {

                this.x = Math.max(this.x, v.x);
                this.y = Math.max(this.y, v.y);
                this.z = Math.max(this.z, v.z);
                this.w = Math.max(this.w, v.w);

                return this;

            },

            clamp: function (min, max) {

                // assumes min < max, componentwise

                this.x = Math.max(min.x, Math.min(max.x, this.x));
                this.y = Math.max(min.y, Math.min(max.y, this.y));
                this.z = Math.max(min.z, Math.min(max.z, this.z));
                this.w = Math.max(min.w, Math.min(max.w, this.w));

                return this;

            },

            clampScalar: function () {

                var min, max;

                return function clampScalar(minVal, maxVal) {

                    if (min === undefined) {

                        min = new Vector4();
                        max = new Vector4();

                    }

                    min.set(minVal, minVal, minVal, minVal);
                    max.set(maxVal, maxVal, maxVal, maxVal);

                    return this.clamp(min, max);

                };

            }(),

            clampLength: function (min, max) {

                var length = this.length();

                return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));

            },

            floor: function () {

                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                this.z = Math.floor(this.z);
                this.w = Math.floor(this.w);

                return this;

            },

            ceil: function () {

                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                this.z = Math.ceil(this.z);
                this.w = Math.ceil(this.w);

                return this;

            },

            round: function () {

                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
                this.z = Math.round(this.z);
                this.w = Math.round(this.w);

                return this;

            },

            roundToZero: function () {

                this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
                this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
                this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
                this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);

                return this;

            },

            negate: function () {

                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                this.w = -this.w;

                return this;

            },

            dot: function (v) {

                return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

            },

            lengthSq: function () {

                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

            },

            length: function () {

                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

            },

            manhattanLength: function () {

                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);

            },

            normalize: function () {

                return this.divideScalar(this.length() || 1);

            },

            setLength: function (length) {

                return this.normalize().multiplyScalar(length);

            },

            lerp: function (v, alpha) {

                this.x += (v.x - this.x) * alpha;
                this.y += (v.y - this.y) * alpha;
                this.z += (v.z - this.z) * alpha;
                this.w += (v.w - this.w) * alpha;

                return this;

            },

            lerpVectors: function (v1, v2, alpha) {

                return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);

            },

            equals: function (v) {

                return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));

            },

            fromArray: function (array, offset) {

                if (offset === undefined) offset = 0;

                this.x = array[offset];
                this.y = array[offset + 1];
                this.z = array[offset + 2];
                this.w = array[offset + 3];

                return this;

            },

            toArray: function (array, offset) {

                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;

                array[offset] = this.x;
                array[offset + 1] = this.y;
                array[offset + 2] = this.z;
                array[offset + 3] = this.w;

                return array;

            },

            fromBufferAttribute: function (attribute, index, offset) {

                if (offset !== undefined) {

                    console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');

                }

                this.x = attribute.getX(index);
                this.y = attribute.getY(index);
                this.z = attribute.getZ(index);
                this.w = attribute.getW(index);

                return this;

            }

        });

        /**
         * @author szimek / https://github.com/szimek/
         * @author alteredq / http://alteredqualia.com/
         * @author Marius Kintel / https://github.com/kintel
         */

        /*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
        function WebGLRenderTarget(width, height, options) {

            this.uuid = _Math.generateUUID();

            this.width = width;
            this.height = height;

            this.scissor = new Vector4(0, 0, width, height);
            this.scissorTest = false;

            this.viewport = new Vector4(0, 0, width, height);

            options = options || {};

            if (options.minFilter === undefined) options.minFilter = LinearFilter;

            this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);

            this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
            this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
            this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

        }

        Object.assign(WebGLRenderTarget.prototype, EventDispatcher.prototype, {

            isWebGLRenderTarget: true,

            setSize: function (width, height) {

                if (this.width !== width || this.height !== height) {

                    this.width = width;
                    this.height = height;

                    this.dispose();

                }

                this.viewport.set(0, 0, width, height);
                this.scissor.set(0, 0, width, height);

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (source) {

                this.width = source.width;
                this.height = source.height;

                this.viewport.copy(source.viewport);

                this.texture = source.texture.clone();

                this.depthBuffer = source.depthBuffer;
                this.stencilBuffer = source.stencilBuffer;
                this.depthTexture = source.depthTexture;

                return this;

            },

            dispose: function () {

                this.dispatchEvent({type: 'dispose'});

            }

        });

        /**
         * @author alteredq / http://alteredqualia.com
         */

        function WebGLRenderTargetCube(width, height, options) {

            WebGLRenderTarget.call(this, width, height, options);

            this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
            this.activeMipMapLevel = 0;

        }

        WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
        WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

        WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

            Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

            this.image = {data: data, width: width, height: height};

            this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
            this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

            this.generateMipmaps = false;
            this.flipY = false;
            this.unpackAlignment = 1;

        }

        DataTexture.prototype = Object.create(Texture.prototype);
        DataTexture.prototype.constructor = DataTexture;

        DataTexture.prototype.isDataTexture = true;

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

            images = images !== undefined ? images : [];
            mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

            Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

            this.flipY = false;

        }

        CubeTexture.prototype = Object.create(Texture.prototype);
        CubeTexture.prototype.constructor = CubeTexture;

        CubeTexture.prototype.isCubeTexture = true;

        Object.defineProperty(CubeTexture.prototype, 'images', {

            get: function () {

                return this.image;

            },

            set: function (value) {

                this.image = value;

            }

        });

        /**
         * @author tschw
         *
         * Uniforms of a program.
         * Those form a tree structure with a special top-level container for the root,
         * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
         *
         *
         * Properties of inner nodes including the top-level container:
         *
         * .seq - array of nested uniforms
         * .map - nested uniforms by name
         *
         *
         * Methods of all nodes except the top-level container:
         *
         * .setValue( gl, value, [renderer] )
         *
         *        uploads a uniform value(s)
         *    the 'renderer' parameter is needed for sampler uniforms
         *
         *
         * Static methods of the top-level container (renderer factorizations):
         *
         * .upload( gl, seq, values, renderer )
         *
         *        sets uniforms in 'seq' to 'values[id].value'
         *
         * .seqWithValue( seq, values ) : filteredSeq
         *
         *        filters 'seq' entries with corresponding entry in values
         *
         *
         * Methods of the top-level container (renderer factorizations):
         *
         * .setValue( gl, name, value )
         *
         *        sets uniform with  name 'name' to 'value'
         *
         * .set( gl, obj, prop )
         *
         *        sets uniform from object and property with same name than uniform
         *
         * .setOptional( gl, obj, prop )
         *
         *        like .set for an optional property of the object
         *
         */

        var emptyTexture = new Texture();
        var emptyCubeTexture = new CubeTexture();

        // --- Base for inner nodes (including the root) ---

        function UniformContainer() {

            this.seq = [];
            this.map = {};

        }

        // --- Utilities ---

        // Array Caches (provide typed arrays for temporary by size)

        var arrayCacheF32 = [];
        var arrayCacheI32 = [];

        // Float32Array caches used for uploading Matrix uniforms

        var mat4array = new Float32Array(16);
        var mat3array = new Float32Array(9);

        // Flattening for arrays of vectors and matrices

        function flatten(array, nBlocks, blockSize) {

            var firstElem = array[0];

            if (firstElem <= 0 || firstElem > 0) return array;
            // unoptimized: ! isNaN( firstElem )
            // see http://jacksondunstan.com/articles/983

            var n = nBlocks * blockSize,
                r = arrayCacheF32[n];

            if (r === undefined) {

                r = new Float32Array(n);
                arrayCacheF32[n] = r;

            }

            if (nBlocks !== 0) {

                firstElem.toArray(r, 0);

                for (var i = 1, offset = 0; i !== nBlocks; ++i) {

                    offset += blockSize;
                    array[i].toArray(r, offset);

                }

            }

            return r;

        }

        // Texture unit allocation

        function allocTexUnits(renderer, n) {

            var r = arrayCacheI32[n];

            if (r === undefined) {

                r = new Int32Array(n);
                arrayCacheI32[n] = r;

            }

            for (var i = 0; i !== n; ++i)
                r[i] = renderer.allocTextureUnit();

            return r;

        }

        // --- Setters ---

        // Note: Defining these methods externally, because they come in a bunch
        // and this way their names minify.

        // Single scalar

        function setValue1f(gl, v) {

            gl.uniform1f(this.addr, v);

        }

        function setValue1i(gl, v) {

            gl.uniform1i(this.addr, v);

        }

        // Single float vector (from flat array or THREE.VectorN)

        function setValue2fv(gl, v) {

            if (v.x === undefined) {

                gl.uniform2fv(this.addr, v);

            } else {

                gl.uniform2f(this.addr, v.x, v.y);

            }

        }

        function setValue3fv(gl, v) {

            if (v.x !== undefined) {

                gl.uniform3f(this.addr, v.x, v.y, v.z);

            } else if (v.r !== undefined) {

                gl.uniform3f(this.addr, v.r, v.g, v.b);

            } else {

                gl.uniform3fv(this.addr, v);

            }

        }

        function setValue4fv(gl, v) {

            if (v.x === undefined) {

                gl.uniform4fv(this.addr, v);

            } else {

                gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);

            }

        }

        // Single matrix (from flat array or MatrixN)

        function setValue2fm(gl, v) {

            gl.uniformMatrix2fv(this.addr, false, v.elements || v);

        }

        function setValue3fm(gl, v) {

            if (v.elements === undefined) {

                gl.uniformMatrix3fv(this.addr, false, v);

            } else {

                mat3array.set(v.elements);
                gl.uniformMatrix3fv(this.addr, false, mat3array);

            }

        }

        function setValue4fm(gl, v) {

            if (v.elements === undefined) {

                gl.uniformMatrix4fv(this.addr, false, v);

            } else {

                mat4array.set(v.elements);
                gl.uniformMatrix4fv(this.addr, false, mat4array);

            }

        }

        // Single texture (2D / Cube)

        function setValueT1(gl, v, renderer) {

            var unit = renderer.allocTextureUnit();
            gl.uniform1i(this.addr, unit);
            renderer.setTexture2D(v || emptyTexture, unit);

        }

        function setValueT6(gl, v, renderer) {

            var unit = renderer.allocTextureUnit();
            gl.uniform1i(this.addr, unit);
            renderer.setTextureCube(v || emptyCubeTexture, unit);

        }

        // Integer / Boolean vectors or arrays thereof (always flat arrays)

        function setValue2iv(gl, v) {

            gl.uniform2iv(this.addr, v);

        }

        function setValue3iv(gl, v) {

            gl.uniform3iv(this.addr, v);

        }

        function setValue4iv(gl, v) {

            gl.uniform4iv(this.addr, v);

        }

        // Helper to pick the right setter for the singular case

        function getSingularSetter(type) {

            switch (type) {

                case 0x1406:
                    return setValue1f; // FLOAT
                case 0x8b50:
                    return setValue2fv; // _VEC2
                case 0x8b51:
                    return setValue3fv; // _VEC3
                case 0x8b52:
                    return setValue4fv; // _VEC4

                case 0x8b5a:
                    return setValue2fm; // _MAT2
                case 0x8b5b:
                    return setValue3fm; // _MAT3
                case 0x8b5c:
                    return setValue4fm; // _MAT4

                case 0x8b5e:
                case 0x8d66:
                    return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
                case 0x8b60:
                    return setValueT6; // SAMPLER_CUBE

                case 0x1404:
                case 0x8b56:
                    return setValue1i; // INT, BOOL
                case 0x8b53:
                case 0x8b57:
                    return setValue2iv; // _VEC2
                case 0x8b54:
                case 0x8b58:
                    return setValue3iv; // _VEC3
                case 0x8b55:
                case 0x8b59:
                    return setValue4iv; // _VEC4

            }

        }

        // Array of scalars

        function setValue1fv(gl, v) {

            gl.uniform1fv(this.addr, v);

        }

        function setValue1iv(gl, v) {

            gl.uniform1iv(this.addr, v);

        }

        // Array of vectors (flat or from THREE classes)

        function setValueV2a(gl, v) {

            gl.uniform2fv(this.addr, flatten(v, this.size, 2));

        }

        function setValueV3a(gl, v) {

            gl.uniform3fv(this.addr, flatten(v, this.size, 3));

        }

        function setValueV4a(gl, v) {

            gl.uniform4fv(this.addr, flatten(v, this.size, 4));

        }

        // Array of matrices (flat or from THREE clases)

        function setValueM2a(gl, v) {

            gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));

        }

        function setValueM3a(gl, v) {

            gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));

        }

        function setValueM4a(gl, v) {

            gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));

        }

        // Array of textures (2D / Cube)

        function setValueT1a(gl, v, renderer) {

            var n = v.length,
                units = allocTexUnits(renderer, n);

            gl.uniform1iv(this.addr, units);

            for (var i = 0; i !== n; ++i) {

                renderer.setTexture2D(v[i] || emptyTexture, units[i]);

            }

        }

        function setValueT6a(gl, v, renderer) {

            var n = v.length,
                units = allocTexUnits(renderer, n);

            gl.uniform1iv(this.addr, units);

            for (var i = 0; i !== n; ++i) {

                renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);

            }

        }

        // Helper to pick the right setter for a pure (bottom-level) array

        function getPureArraySetter(type) {

            switch (type) {

                case 0x1406:
                    return setValue1fv; // FLOAT
                case 0x8b50:
                    return setValueV2a; // _VEC2
                case 0x8b51:
                    return setValueV3a; // _VEC3
                case 0x8b52:
                    return setValueV4a; // _VEC4

                case 0x8b5a:
                    return setValueM2a; // _MAT2
                case 0x8b5b:
                    return setValueM3a; // _MAT3
                case 0x8b5c:
                    return setValueM4a; // _MAT4

                case 0x8b5e:
                    return setValueT1a; // SAMPLER_2D
                case 0x8b60:
                    return setValueT6a; // SAMPLER_CUBE

                case 0x1404:
                case 0x8b56:
                    return setValue1iv; // INT, BOOL
                case 0x8b53:
                case 0x8b57:
                    return setValue2iv; // _VEC2
                case 0x8b54:
                case 0x8b58:
                    return setValue3iv; // _VEC3
                case 0x8b55:
                case 0x8b59:
                    return setValue4iv; // _VEC4

            }

        }

        // --- Uniform Classes ---

        function SingleUniform(id, activeInfo, addr) {

            this.id = id;
            this.addr = addr;
            this.setValue = getSingularSetter(activeInfo.type);

            // this.path = activeInfo.name; // DEBUG

        }

        function PureArrayUniform(id, activeInfo, addr) {

            this.id = id;
            this.addr = addr;
            this.size = activeInfo.size;
            this.setValue = getPureArraySetter(activeInfo.type);

            // this.path = activeInfo.name; // DEBUG

        }

        function StructuredUniform(id) {

            this.id = id;

            UniformContainer.call(this); // mix-in

        }

        StructuredUniform.prototype.setValue = function (gl, value) {

            // Note: Don't need an extra 'renderer' parameter, since samplers
            // are not allowed in structured uniforms.

            var seq = this.seq;

            for (var i = 0, n = seq.length; i !== n; ++i) {

                var u = seq[i];
                u.setValue(gl, value[u.id]);

            }

        };

        // --- Top-level ---

        // Parser - builds up the property tree from the path strings

        var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

        // extracts
        // 	- the identifier (member name or array index)
        //  - followed by an optional right bracket (found when array index)
        //  - followed by an optional left bracket or dot (type of subscript)
        //
        // Note: These portions can be read in a non-overlapping fashion and
        // allow straightforward parsing of the hierarchy that WebGL encodes
        // in the uniform names.

        function addUniform(container, uniformObject) {

            container.seq.push(uniformObject);
            container.map[uniformObject.id] = uniformObject;

        }

        function parseUniform(activeInfo, addr, container) {

            var path = activeInfo.name,
                pathLength = path.length;

            // reset RegExp object, because of the early exit of a previous run
            RePathPart.lastIndex = 0;

            for (; ;) {

                var match = RePathPart.exec(path),
                    matchEnd = RePathPart.lastIndex,

                    id = match[1],
                    idIsIndex = match[2] === ']',
                    subscript = match[3];

                if (idIsIndex) id = id | 0; // convert to integer

                if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {

                    // bare name or "pure" bottom-level array "[0]" suffix

                    addUniform(container, subscript === undefined ?
                        new SingleUniform(id, activeInfo, addr) :
                        new PureArrayUniform(id, activeInfo, addr));

                    break;

                } else {

                    // step into inner node / create it in case it doesn't exist

                    var map = container.map, next = map[id];

                    if (next === undefined) {

                        next = new StructuredUniform(id);
                        addUniform(container, next);

                    }

                    container = next;

                }

            }

        }

        // Root Container

        function WebGLUniforms(gl, program, renderer) {

            UniformContainer.call(this);

            this.renderer = renderer;

            var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

            for (var i = 0; i < n; ++i) {

                var info = gl.getActiveUniform(program, i),
                    path = info.name,
                    addr = gl.getUniformLocation(program, path);

                parseUniform(info, addr, this);

            }

        }

        WebGLUniforms.prototype.setValue = function (gl, name, value) {

            var u = this.map[name];

            if (u !== undefined) u.setValue(gl, value, this.renderer);

        };

        WebGLUniforms.prototype.setOptional = function (gl, object, name) {

            var v = object[name];

            if (v !== undefined) this.setValue(gl, name, v);

        };


        // Static interface

        WebGLUniforms.upload = function (gl, seq, values, renderer) {

            for (var i = 0, n = seq.length; i !== n; ++i) {

                var u = seq[i],
                    v = values[u.id];

                if (v.needsUpdate !== false) {

                    // note: always updating when .needsUpdate is undefined
                    u.setValue(gl, v.value, renderer);

                }

            }

        };

        WebGLUniforms.seqWithValue = function (seq, values) {

            var r = [];

            for (var i = 0, n = seq.length; i !== n; ++i) {

                var u = seq[i];
                if (u.id in values) r.push(u);

            }

            return r;

        };

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        var ColorKeywords = {
            'aliceblue': 0xF0F8FF,
            'antiquewhite': 0xFAEBD7,
            'aqua': 0x00FFFF,
            'aquamarine': 0x7FFFD4,
            'azure': 0xF0FFFF,
            'beige': 0xF5F5DC,
            'bisque': 0xFFE4C4,
            'black': 0x000000,
            'blanchedalmond': 0xFFEBCD,
            'blue': 0x0000FF,
            'blueviolet': 0x8A2BE2,
            'brown': 0xA52A2A,
            'burlywood': 0xDEB887,
            'cadetblue': 0x5F9EA0,
            'chartreuse': 0x7FFF00,
            'chocolate': 0xD2691E,
            'coral': 0xFF7F50,
            'cornflowerblue': 0x6495ED,
            'cornsilk': 0xFFF8DC,
            'crimson': 0xDC143C,
            'cyan': 0x00FFFF,
            'darkblue': 0x00008B,
            'darkcyan': 0x008B8B,
            'darkgoldenrod': 0xB8860B,
            'darkgray': 0xA9A9A9,
            'darkgreen': 0x006400,
            'darkgrey': 0xA9A9A9,
            'darkkhaki': 0xBDB76B,
            'darkmagenta': 0x8B008B,
            'darkolivegreen': 0x556B2F,
            'darkorange': 0xFF8C00,
            'darkorchid': 0x9932CC,
            'darkred': 0x8B0000,
            'darksalmon': 0xE9967A,
            'darkseagreen': 0x8FBC8F,
            'darkslateblue': 0x483D8B,
            'darkslategray': 0x2F4F4F,
            'darkslategrey': 0x2F4F4F,
            'darkturquoise': 0x00CED1,
            'darkviolet': 0x9400D3,
            'deeppink': 0xFF1493,
            'deepskyblue': 0x00BFFF,
            'dimgray': 0x696969,
            'dimgrey': 0x696969,
            'dodgerblue': 0x1E90FF,
            'firebrick': 0xB22222,
            'floralwhite': 0xFFFAF0,
            'forestgreen': 0x228B22,
            'fuchsia': 0xFF00FF,
            'gainsboro': 0xDCDCDC,
            'ghostwhite': 0xF8F8FF,
            'gold': 0xFFD700,
            'goldenrod': 0xDAA520,
            'gray': 0x808080,
            'green': 0x008000,
            'greenyellow': 0xADFF2F,
            'grey': 0x808080,
            'honeydew': 0xF0FFF0,
            'hotpink': 0xFF69B4,
            'indianred': 0xCD5C5C,
            'indigo': 0x4B0082,
            'ivory': 0xFFFFF0,
            'khaki': 0xF0E68C,
            'lavender': 0xE6E6FA,
            'lavenderblush': 0xFFF0F5,
            'lawngreen': 0x7CFC00,
            'lemonchiffon': 0xFFFACD,
            'lightblue': 0xADD8E6,
            'lightcoral': 0xF08080,
            'lightcyan': 0xE0FFFF,
            'lightgoldenrodyellow': 0xFAFAD2,
            'lightgray': 0xD3D3D3,
            'lightgreen': 0x90EE90,
            'lightgrey': 0xD3D3D3,
            'lightpink': 0xFFB6C1,
            'lightsalmon': 0xFFA07A,
            'lightseagreen': 0x20B2AA,
            'lightskyblue': 0x87CEFA,
            'lightslategray': 0x778899,
            'lightslategrey': 0x778899,
            'lightsteelblue': 0xB0C4DE,
            'lightyellow': 0xFFFFE0,
            'lime': 0x00FF00,
            'limegreen': 0x32CD32,
            'linen': 0xFAF0E6,
            'magenta': 0xFF00FF,
            'maroon': 0x800000,
            'mediumaquamarine': 0x66CDAA,
            'mediumblue': 0x0000CD,
            'mediumorchid': 0xBA55D3,
            'mediumpurple': 0x9370DB,
            'mediumseagreen': 0x3CB371,
            'mediumslateblue': 0x7B68EE,
            'mediumspringgreen': 0x00FA9A,
            'mediumturquoise': 0x48D1CC,
            'mediumvioletred': 0xC71585,
            'midnightblue': 0x191970,
            'mintcream': 0xF5FFFA,
            'mistyrose': 0xFFE4E1,
            'moccasin': 0xFFE4B5,
            'navajowhite': 0xFFDEAD,
            'navy': 0x000080,
            'oldlace': 0xFDF5E6,
            'olive': 0x808000,
            'olivedrab': 0x6B8E23,
            'orange': 0xFFA500,
            'orangered': 0xFF4500,
            'orchid': 0xDA70D6,
            'palegoldenrod': 0xEEE8AA,
            'palegreen': 0x98FB98,
            'paleturquoise': 0xAFEEEE,
            'palevioletred': 0xDB7093,
            'papayawhip': 0xFFEFD5,
            'peachpuff': 0xFFDAB9,
            'peru': 0xCD853F,
            'pink': 0xFFC0CB,
            'plum': 0xDDA0DD,
            'powderblue': 0xB0E0E6,
            'purple': 0x800080,
            'rebeccapurple': 0x663399,
            'red': 0xFF0000,
            'rosybrown': 0xBC8F8F,
            'royalblue': 0x4169E1,
            'saddlebrown': 0x8B4513,
            'salmon': 0xFA8072,
            'sandybrown': 0xF4A460,
            'seagreen': 0x2E8B57,
            'seashell': 0xFFF5EE,
            'sienna': 0xA0522D,
            'silver': 0xC0C0C0,
            'skyblue': 0x87CEEB,
            'slateblue': 0x6A5ACD,
            'slategray': 0x708090,
            'slategrey': 0x708090,
            'snow': 0xFFFAFA,
            'springgreen': 0x00FF7F,
            'steelblue': 0x4682B4,
            'tan': 0xD2B48C,
            'teal': 0x008080,
            'thistle': 0xD8BFD8,
            'tomato': 0xFF6347,
            'turquoise': 0x40E0D0,
            'violet': 0xEE82EE,
            'wheat': 0xF5DEB3,
            'white': 0xFFFFFF,
            'whitesmoke': 0xF5F5F5,
            'yellow': 0xFFFF00,
            'yellowgreen': 0x9ACD32
        };

        function Color(r, g, b) {

            if (g === undefined && b === undefined) {

                // r is THREE.Color, hex or string
                return this.set(r);

            }

            return this.setRGB(r, g, b);

        }

        Object.assign(Color.prototype, {

            isColor: true,

            r: 1, g: 1, b: 1,

            set: function (value) {

                if (value && value.isColor) {

                    this.copy(value);

                } else if (typeof value === 'number') {

                    this.setHex(value);

                } else if (typeof value === 'string') {

                    this.setStyle(value);

                }

                return this;

            },

            setScalar: function (scalar) {

                this.r = scalar;
                this.g = scalar;
                this.b = scalar;

                return this;

            },

            setHex: function (hex) {

                hex = Math.floor(hex);

                this.r = (hex >> 16 & 255) / 255;
                this.g = (hex >> 8 & 255) / 255;
                this.b = (hex & 255) / 255;

                return this;

            },

            setRGB: function (r, g, b) {

                this.r = r;
                this.g = g;
                this.b = b;

                return this;

            },

            setHSL: function () {

                function hue2rgb(p, q, t) {

                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
                    return p;

                }

                return function setHSL(h, s, l) {

                    // h,s,l ranges are in 0.0 - 1.0
                    h = _Math.euclideanModulo(h, 1);
                    s = _Math.clamp(s, 0, 1);
                    l = _Math.clamp(l, 0, 1);

                    if (s === 0) {

                        this.r = this.g = this.b = l;

                    } else {

                        var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                        var q = (2 * l) - p;

                        this.r = hue2rgb(q, p, h + 1 / 3);
                        this.g = hue2rgb(q, p, h);
                        this.b = hue2rgb(q, p, h - 1 / 3);

                    }

                    return this;

                };

            }(),

            setStyle: function (style) {

                function handleAlpha(string) {

                    if (string === undefined) return;

                    if (parseFloat(string) < 1) {

                        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');

                    }

                }


                var m;

                if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {

                    // rgb / hsl

                    var color;
                    var name = m[1];
                    var components = m[2];

                    switch (name) {

                        case 'rgb':
                        case 'rgba':

                            if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

                                // rgb(255,0,0) rgba(255,0,0,0.5)
                                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                                this.b = Math.min(255, parseInt(color[3], 10)) / 255;

                                handleAlpha(color[5]);

                                return this;

                            }

                            if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

                                // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                                this.b = Math.min(100, parseInt(color[3], 10)) / 100;

                                handleAlpha(color[5]);

                                return this;

                            }

                            break;

                        case 'hsl':
                        case 'hsla':

                            if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

                                // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                                var h = parseFloat(color[1]) / 360;
                                var s = parseInt(color[2], 10) / 100;
                                var l = parseInt(color[3], 10) / 100;

                                handleAlpha(color[5]);

                                return this.setHSL(h, s, l);

                            }

                            break;

                    }

                } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {

                    // hex color

                    var hex = m[1];
                    var size = hex.length;

                    if (size === 3) {

                        // #ff0
                        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;

                        return this;

                    } else if (size === 6) {

                        // #ff0000
                        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;

                        return this;

                    }

                }

                if (style && style.length > 0) {

                    // color keywords
                    var hex = ColorKeywords[style];

                    if (hex !== undefined) {

                        // red
                        this.setHex(hex);

                    } else {

                        // unknown color
                        console.warn('THREE.Color: Unknown color ' + style);

                    }

                }

                return this;

            },

            clone: function () {

                return new this.constructor(this.r, this.g, this.b);

            },

            copy: function (color) {

                this.r = color.r;
                this.g = color.g;
                this.b = color.b;

                return this;

            },

            copyGammaToLinear: function (color, gammaFactor) {

                if (gammaFactor === undefined) gammaFactor = 2.0;

                this.r = Math.pow(color.r, gammaFactor);
                this.g = Math.pow(color.g, gammaFactor);
                this.b = Math.pow(color.b, gammaFactor);

                return this;

            },

            copyLinearToGamma: function (color, gammaFactor) {

                if (gammaFactor === undefined) gammaFactor = 2.0;

                var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;

                this.r = Math.pow(color.r, safeInverse);
                this.g = Math.pow(color.g, safeInverse);
                this.b = Math.pow(color.b, safeInverse);

                return this;

            },

            convertGammaToLinear: function () {

                var r = this.r, g = this.g, b = this.b;

                this.r = r * r;
                this.g = g * g;
                this.b = b * b;

                return this;

            },

            convertLinearToGamma: function () {

                this.r = Math.sqrt(this.r);
                this.g = Math.sqrt(this.g);
                this.b = Math.sqrt(this.b);

                return this;

            },

            getHex: function () {

                return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;

            },

            getHexString: function () {

                return ('000000' + this.getHex().toString(16)).slice(-6);

            },

            getHSL: function (optionalTarget) {

                // h,s,l ranges are in 0.0 - 1.0

                var hsl = optionalTarget || {h: 0, s: 0, l: 0};

                var r = this.r, g = this.g, b = this.b;

                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);

                var hue, saturation;
                var lightness = (min + max) / 2.0;

                if (min === max) {

                    hue = 0;
                    saturation = 0;

                } else {

                    var delta = max - min;

                    saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

                    switch (max) {

                        case r:
                            hue = (g - b) / delta + (g < b ? 6 : 0);
                            break;
                        case g:
                            hue = (b - r) / delta + 2;
                            break;
                        case b:
                            hue = (r - g) / delta + 4;
                            break;

                    }

                    hue /= 6;

                }

                hsl.h = hue;
                hsl.s = saturation;
                hsl.l = lightness;

                return hsl;

            },

            getStyle: function () {

                return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';

            },

            offsetHSL: function (h, s, l) {

                var hsl = this.getHSL();

                hsl.h += h;
                hsl.s += s;
                hsl.l += l;

                this.setHSL(hsl.h, hsl.s, hsl.l);

                return this;

            },

            add: function (color) {

                this.r += color.r;
                this.g += color.g;
                this.b += color.b;

                return this;

            },

            addColors: function (color1, color2) {

                this.r = color1.r + color2.r;
                this.g = color1.g + color2.g;
                this.b = color1.b + color2.b;

                return this;

            },

            addScalar: function (s) {

                this.r += s;
                this.g += s;
                this.b += s;

                return this;

            },

            sub: function (color) {

                this.r = Math.max(0, this.r - color.r);
                this.g = Math.max(0, this.g - color.g);
                this.b = Math.max(0, this.b - color.b);

                return this;

            },

            multiply: function (color) {

                this.r *= color.r;
                this.g *= color.g;
                this.b *= color.b;

                return this;

            },

            multiplyScalar: function (s) {

                this.r *= s;
                this.g *= s;
                this.b *= s;

                return this;

            },

            lerp: function (color, alpha) {

                this.r += (color.r - this.r) * alpha;
                this.g += (color.g - this.g) * alpha;
                this.b += (color.b - this.b) * alpha;

                return this;

            },

            equals: function (c) {

                return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);

            },

            fromArray: function (array, offset) {

                if (offset === undefined) offset = 0;

                this.r = array[offset];
                this.g = array[offset + 1];
                this.b = array[offset + 2];

                return this;

            },

            toArray: function (array, offset) {

                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;

                array[offset] = this.r;
                array[offset + 1] = this.g;
                array[offset + 2] = this.b;

                return array;

            },

            toJSON: function () {

                return this.getHex();

            }

        });

        /**
         * Uniforms library for shared webgl shaders
         */

        var UniformsLib = {

            common: {

                diffuse: {value: new Color(0xeeeeee)},
                opacity: {value: 1.0},

                map: {value: null},
                uvTransform: {value: new Matrix3()},

                alphaMap: {value: null},

            },

            specularmap: {

                specularMap: {value: null},

            },

            envmap: {

                envMap: {value: null},
                flipEnvMap: {value: -1},
                reflectivity: {value: 1.0},
                refractionRatio: {value: 0.98}

            },

            aomap: {

                aoMap: {value: null},
                aoMapIntensity: {value: 1}

            },

            lightmap: {

                lightMap: {value: null},
                lightMapIntensity: {value: 1}

            },

            emissivemap: {

                emissiveMap: {value: null}

            },

            bumpmap: {

                bumpMap: {value: null},
                bumpScale: {value: 1}

            },

            normalmap: {

                normalMap: {value: null},
                normalScale: {value: new Vector2(1, 1)}

            },

            displacementmap: {

                displacementMap: {value: null},
                displacementScale: {value: 1},
                displacementBias: {value: 0}

            },

            roughnessmap: {

                roughnessMap: {value: null}

            },

            metalnessmap: {

                metalnessMap: {value: null}

            },

            gradientmap: {

                gradientMap: {value: null}

            },

            fog: {

                fogDensity: {value: 0.00025},
                fogNear: {value: 1},
                fogFar: {value: 2000},
                fogColor: {value: new Color(0xffffff)}

            },

            lights: {

                ambientLightColor: {value: []},

                directionalLights: {
                    value: [], properties: {
                        direction: {},
                        color: {},

                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },

                directionalShadowMap: {value: []},
                directionalShadowMatrix: {value: []},

                spotLights: {
                    value: [], properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},

                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },

                spotShadowMap: {value: []},
                spotShadowMatrix: {value: []},

                pointLights: {
                    value: [], properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},

                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },

                pointShadowMap: {value: []},
                pointShadowMatrix: {value: []},

                hemisphereLights: {
                    value: [], properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },

                // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
                rectAreaLights: {
                    value: [], properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }

            },

            points: {

                diffuse: {value: new Color(0xeeeeee)},
                opacity: {value: 1.0},
                size: {value: 1.0},
                scale: {value: 1.0},
                map: {value: null},
                uvTransform: {value: new Matrix3()}

            }

        };

        /**
         * Uniform Utilities
         */

        var UniformsUtils = {

            merge: function (uniforms) {

                var merged = {};

                for (var u = 0; u < uniforms.length; u++) {

                    var tmp = this.clone(uniforms[u]);

                    for (var p in tmp) {

                        merged[p] = tmp[p];

                    }

                }

                return merged;

            },

            clone: function (uniforms_src) {

                var uniforms_dst = {};

                for (var u in uniforms_src) {

                    uniforms_dst[u] = {};

                    for (var p in uniforms_src[u]) {

                        var parameter_src = uniforms_src[u][p];

                        if (parameter_src && (parameter_src.isColor ||
                                parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
                                parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
                                parameter_src.isTexture)) {

                            uniforms_dst[u][p] = parameter_src.clone();

                        } else if (Array.isArray(parameter_src)) {

                            uniforms_dst[u][p] = parameter_src.slice();

                        } else {

                            uniforms_dst[u][p] = parameter_src;

                        }

                    }

                }

                return uniforms_dst;

            }

        };

        var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

        var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

        var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

        var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

        var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

        var begin_vertex = "\nvec3 transformed = vec3( position );\n";

        var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

        var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

        var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

        var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

        var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

        var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

        var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

        var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

        var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

        var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

        var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

        var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";

        var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

        var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";

        var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

        var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

        var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

        var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

        var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

        var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

        var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

        var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

        var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

        var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

        var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

        var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

        var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

        var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

        var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

        var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

        var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

        var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

        var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

        var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

        var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

        var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

        var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

        var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

        var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

        var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

        var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

        var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";

        var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

        var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

        var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

        var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";

        var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";

        var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

        var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

        var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

        var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

        var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

        var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

        var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

        var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

        var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";

        var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";

        var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";

        var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";

        var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

        var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

        var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

        var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

        var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

        var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

        var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

        var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";

        var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

        var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

        var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

        var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

        var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

        var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

        var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";

        var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

        var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

        var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

        var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

        var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";

        var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

        var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";

        var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

        var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

        var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";

        var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";

        var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

        var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

        var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

        var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

        var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

        var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

        var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

        var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

        var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

        var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

        var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

        var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

        var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

        var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

        var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

        var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

        var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";

        var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

        var ShaderChunk = {
            alphamap_fragment: alphamap_fragment,
            alphamap_pars_fragment: alphamap_pars_fragment,
            alphatest_fragment: alphatest_fragment,
            aomap_fragment: aomap_fragment,
            aomap_pars_fragment: aomap_pars_fragment,
            begin_vertex: begin_vertex,
            beginnormal_vertex: beginnormal_vertex,
            bsdfs: bsdfs,
            bumpmap_pars_fragment: bumpmap_pars_fragment,
            clipping_planes_fragment: clipping_planes_fragment,
            clipping_planes_pars_fragment: clipping_planes_pars_fragment,
            clipping_planes_pars_vertex: clipping_planes_pars_vertex,
            clipping_planes_vertex: clipping_planes_vertex,
            color_fragment: color_fragment,
            color_pars_fragment: color_pars_fragment,
            color_pars_vertex: color_pars_vertex,
            color_vertex: color_vertex,
            common: common,
            cube_uv_reflection_fragment: cube_uv_reflection_fragment,
            defaultnormal_vertex: defaultnormal_vertex,
            displacementmap_pars_vertex: displacementmap_pars_vertex,
            displacementmap_vertex: displacementmap_vertex,
            emissivemap_fragment: emissivemap_fragment,
            emissivemap_pars_fragment: emissivemap_pars_fragment,
            encodings_fragment: encodings_fragment,
            encodings_pars_fragment: encodings_pars_fragment,
            envmap_fragment: envmap_fragment,
            envmap_pars_fragment: envmap_pars_fragment,
            envmap_pars_vertex: envmap_pars_vertex,
            envmap_vertex: envmap_vertex,
            fog_vertex: fog_vertex,
            fog_pars_vertex: fog_pars_vertex,
            fog_fragment: fog_fragment,
            fog_pars_fragment: fog_pars_fragment,
            gradientmap_pars_fragment: gradientmap_pars_fragment,
            lightmap_fragment: lightmap_fragment,
            lightmap_pars_fragment: lightmap_pars_fragment,
            lights_lambert_vertex: lights_lambert_vertex,
            lights_pars: lights_pars,
            lights_phong_fragment: lights_phong_fragment,
            lights_phong_pars_fragment: lights_phong_pars_fragment,
            lights_physical_fragment: lights_physical_fragment,
            lights_physical_pars_fragment: lights_physical_pars_fragment,
            lights_template: lights_template,
            logdepthbuf_fragment: logdepthbuf_fragment,
            logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
            logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
            logdepthbuf_vertex: logdepthbuf_vertex,
            map_fragment: map_fragment,
            map_pars_fragment: map_pars_fragment,
            map_particle_fragment: map_particle_fragment,
            map_particle_pars_fragment: map_particle_pars_fragment,
            metalnessmap_fragment: metalnessmap_fragment,
            metalnessmap_pars_fragment: metalnessmap_pars_fragment,
            morphnormal_vertex: morphnormal_vertex,
            morphtarget_pars_vertex: morphtarget_pars_vertex,
            morphtarget_vertex: morphtarget_vertex,
            normal_fragment: normal_fragment,
            normalmap_pars_fragment: normalmap_pars_fragment,
            packing: packing,
            premultiplied_alpha_fragment: premultiplied_alpha_fragment,
            project_vertex: project_vertex,
            dithering_fragment: dithering_fragment,
            dithering_pars_fragment: dithering_pars_fragment,
            roughnessmap_fragment: roughnessmap_fragment,
            roughnessmap_pars_fragment: roughnessmap_pars_fragment,
            shadowmap_pars_fragment: shadowmap_pars_fragment,
            shadowmap_pars_vertex: shadowmap_pars_vertex,
            shadowmap_vertex: shadowmap_vertex,
            shadowmask_pars_fragment: shadowmask_pars_fragment,
            skinbase_vertex: skinbase_vertex,
            skinning_pars_vertex: skinning_pars_vertex,
            skinning_vertex: skinning_vertex,
            skinnormal_vertex: skinnormal_vertex,
            specularmap_fragment: specularmap_fragment,
            specularmap_pars_fragment: specularmap_pars_fragment,
            tonemapping_fragment: tonemapping_fragment,
            tonemapping_pars_fragment: tonemapping_pars_fragment,
            uv_pars_fragment: uv_pars_fragment,
            uv_pars_vertex: uv_pars_vertex,
            uv_vertex: uv_vertex,
            uv2_pars_fragment: uv2_pars_fragment,
            uv2_pars_vertex: uv2_pars_vertex,
            uv2_vertex: uv2_vertex,
            worldpos_vertex: worldpos_vertex,

            cube_frag: cube_frag,
            cube_vert: cube_vert,
            depth_frag: depth_frag,
            depth_vert: depth_vert,
            distanceRGBA_frag: distanceRGBA_frag,
            distanceRGBA_vert: distanceRGBA_vert,
            equirect_frag: equirect_frag,
            equirect_vert: equirect_vert,
            linedashed_frag: linedashed_frag,
            linedashed_vert: linedashed_vert,
            meshbasic_frag: meshbasic_frag,
            meshbasic_vert: meshbasic_vert,
            meshlambert_frag: meshlambert_frag,
            meshlambert_vert: meshlambert_vert,
            meshphong_frag: meshphong_frag,
            meshphong_vert: meshphong_vert,
            meshphysical_frag: meshphysical_frag,
            meshphysical_vert: meshphysical_vert,
            normal_frag: normal_frag,
            normal_vert: normal_vert,
            points_frag: points_frag,
            points_vert: points_vert,
            shadow_frag: shadow_frag,
            shadow_vert: shadow_vert
        };

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         * @author mikael emtinger / http://gomo.se/
         */

        var ShaderLib = {

            basic: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.common,
                    UniformsLib.specularmap,
                    UniformsLib.envmap,
                    UniformsLib.aomap,
                    UniformsLib.lightmap,
                    UniformsLib.fog
                ]),

                vertexShader: ShaderChunk.meshbasic_vert,
                fragmentShader: ShaderChunk.meshbasic_frag

            },

            lambert: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.common,
                    UniformsLib.specularmap,
                    UniformsLib.envmap,
                    UniformsLib.aomap,
                    UniformsLib.lightmap,
                    UniformsLib.emissivemap,
                    UniformsLib.fog,
                    UniformsLib.lights,
                    {
                        emissive: {value: new Color(0x000000)}
                    }
                ]),

                vertexShader: ShaderChunk.meshlambert_vert,
                fragmentShader: ShaderChunk.meshlambert_frag

            },

            phong: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.common,
                    UniformsLib.specularmap,
                    UniformsLib.envmap,
                    UniformsLib.aomap,
                    UniformsLib.lightmap,
                    UniformsLib.emissivemap,
                    UniformsLib.bumpmap,
                    UniformsLib.normalmap,
                    UniformsLib.displacementmap,
                    UniformsLib.gradientmap,
                    UniformsLib.fog,
                    UniformsLib.lights,
                    {
                        emissive: {value: new Color(0x000000)},
                        specular: {value: new Color(0x111111)},
                        shininess: {value: 30}
                    }
                ]),

                vertexShader: ShaderChunk.meshphong_vert,
                fragmentShader: ShaderChunk.meshphong_frag

            },

            standard: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.common,
                    UniformsLib.envmap,
                    UniformsLib.aomap,
                    UniformsLib.lightmap,
                    UniformsLib.emissivemap,
                    UniformsLib.bumpmap,
                    UniformsLib.normalmap,
                    UniformsLib.displacementmap,
                    UniformsLib.roughnessmap,
                    UniformsLib.metalnessmap,
                    UniformsLib.fog,
                    UniformsLib.lights,
                    {
                        emissive: {value: new Color(0x000000)},
                        roughness: {value: 0.5},
                        metalness: {value: 0.5},
                        envMapIntensity: {value: 1} // temporary
                    }
                ]),

                vertexShader: ShaderChunk.meshphysical_vert,
                fragmentShader: ShaderChunk.meshphysical_frag

            },

            points: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.points,
                    UniformsLib.fog
                ]),

                vertexShader: ShaderChunk.points_vert,
                fragmentShader: ShaderChunk.points_frag

            },

            dashed: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.common,
                    UniformsLib.fog,
                    {
                        scale: {value: 1},
                        dashSize: {value: 1},
                        totalSize: {value: 2}
                    }
                ]),

                vertexShader: ShaderChunk.linedashed_vert,
                fragmentShader: ShaderChunk.linedashed_frag

            },

            depth: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.common,
                    UniformsLib.displacementmap
                ]),

                vertexShader: ShaderChunk.depth_vert,
                fragmentShader: ShaderChunk.depth_frag

            },

            normal: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.common,
                    UniformsLib.bumpmap,
                    UniformsLib.normalmap,
                    UniformsLib.displacementmap,
                    {
                        opacity: {value: 1.0}
                    }
                ]),

                vertexShader: ShaderChunk.normal_vert,
                fragmentShader: ShaderChunk.normal_frag

            },

            /* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

            cube: {

                uniforms: {
                    tCube: {value: null},
                    tFlip: {value: -1},
                    opacity: {value: 1.0}
                },

                vertexShader: ShaderChunk.cube_vert,
                fragmentShader: ShaderChunk.cube_frag

            },

            equirect: {

                uniforms: {
                    tEquirect: {value: null},
                },

                vertexShader: ShaderChunk.equirect_vert,
                fragmentShader: ShaderChunk.equirect_frag

            },

            distanceRGBA: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.common,
                    UniformsLib.displacementmap,
                    {
                        referencePosition: {value: new Vector3()},
                        nearDistance: {value: 1},
                        farDistance: {value: 1000}
                    }
                ]),

                vertexShader: ShaderChunk.distanceRGBA_vert,
                fragmentShader: ShaderChunk.distanceRGBA_frag

            },

            shadow: {

                uniforms: UniformsUtils.merge([
                    UniformsLib.lights,
                    UniformsLib.fog,
                    {
                        color: {value: new Color(0x00000)},
                        opacity: {value: 1.0}
                    },
                ]),

                vertexShader: ShaderChunk.shadow_vert,
                fragmentShader: ShaderChunk.shadow_frag

            }

        };

        ShaderLib.physical = {

            uniforms: UniformsUtils.merge([
                ShaderLib.standard.uniforms,
                {
                    clearCoat: {value: 0},
                    clearCoatRoughness: {value: 0}
                }
            ]),

            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag

        };

        /**
         * @author bhouston / http://clara.io
         */

        function Box2(min, max) {

            this.min = (min !== undefined) ? min : new Vector2(+Infinity, +Infinity);
            this.max = (max !== undefined) ? max : new Vector2(-Infinity, -Infinity);

        }

        Object.assign(Box2.prototype, {

            set: function (min, max) {

                this.min.copy(min);
                this.max.copy(max);

                return this;

            },

            setFromPoints: function (points) {

                this.makeEmpty();

                for (var i = 0, il = points.length; i < il; i++) {

                    this.expandByPoint(points[i]);

                }

                return this;

            },

            setFromCenterAndSize: function () {

                var v1 = new Vector2();

                return function setFromCenterAndSize(center, size) {

                    var halfSize = v1.copy(size).multiplyScalar(0.5);
                    this.min.copy(center).sub(halfSize);
                    this.max.copy(center).add(halfSize);

                    return this;

                };

            }(),

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (box) {

                this.min.copy(box.min);
                this.max.copy(box.max);

                return this;

            },

            makeEmpty: function () {

                this.min.x = this.min.y = +Infinity;
                this.max.x = this.max.y = -Infinity;

                return this;

            },

            isEmpty: function () {

                // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

                return (this.max.x < this.min.x) || (this.max.y < this.min.y);

            },

            getCenter: function (optionalTarget) {

                var result = optionalTarget || new Vector2();
                return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);

            },

            getSize: function (optionalTarget) {

                var result = optionalTarget || new Vector2();
                return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);

            },

            expandByPoint: function (point) {

                this.min.min(point);
                this.max.max(point);

                return this;

            },

            expandByVector: function (vector) {

                this.min.sub(vector);
                this.max.add(vector);

                return this;

            },

            expandByScalar: function (scalar) {

                this.min.addScalar(-scalar);
                this.max.addScalar(scalar);

                return this;

            },

            containsPoint: function (point) {

                return point.x < this.min.x || point.x > this.max.x ||
                point.y < this.min.y || point.y > this.max.y ? false : true;

            },

            containsBox: function (box) {

                return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                    this.min.y <= box.min.y && box.max.y <= this.max.y;

            },

            getParameter: function (point, optionalTarget) {

                // This can potentially have a divide by zero if the box
                // has a size dimension of 0.

                var result = optionalTarget || new Vector2();

                return result.set(
                    (point.x - this.min.x) / (this.max.x - this.min.x),
                    (point.y - this.min.y) / (this.max.y - this.min.y)
                );

            },

            intersectsBox: function (box) {

                // using 4 splitting planes to rule out intersections

                return box.max.x < this.min.x || box.min.x > this.max.x ||
                box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

            },

            clampPoint: function (point, optionalTarget) {

                var result = optionalTarget || new Vector2();
                return result.copy(point).clamp(this.min, this.max);

            },

            distanceToPoint: function () {

                var v1 = new Vector2();

                return function distanceToPoint(point) {

                    var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                    return clampedPoint.sub(point).length();

                };

            }(),

            intersect: function (box) {

                this.min.max(box.min);
                this.max.min(box.max);

                return this;

            },

            union: function (box) {

                this.min.min(box.min);
                this.max.max(box.max);

                return this;

            },

            translate: function (offset) {

                this.min.add(offset);
                this.max.add(offset);

                return this;

            },

            equals: function (box) {

                return box.min.equals(this.min) && box.max.equals(this.max);

            }

        });

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         */

        function WebGLFlareRenderer(renderer, gl, state, textures, capabilities) {

            var vertexBuffer, elementBuffer;
            var shader, program, attributes, uniforms;

            var tempTexture, occlusionTexture;

            function init() {

                var vertices = new Float32Array([
                    -1, -1, 0, 0,
                    1, -1, 1, 0,
                    1, 1, 1, 1,
                    -1, 1, 0, 1
                ]);

                var faces = new Uint16Array([
                    0, 1, 2,
                    0, 2, 3
                ]);

                // buffers

                vertexBuffer = gl.createBuffer();
                elementBuffer = gl.createBuffer();

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);

                // textures

                tempTexture = gl.createTexture();
                occlusionTexture = gl.createTexture();

                state.bindTexture(gl.TEXTURE_2D, tempTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

                state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

                shader = {

                    vertexShader: [

                        'uniform lowp int renderType;',

                        'uniform vec3 screenPosition;',
                        'uniform vec2 scale;',
                        'uniform float rotation;',

                        'uniform sampler2D occlusionMap;',

                        'attribute vec2 position;',
                        'attribute vec2 uv;',

                        'varying vec2 vUV;',
                        'varying float vVisibility;',

                        'void main() {',

                        '	vUV = uv;',

                        '	vec2 pos = position;',

                        '	if ( renderType == 2 ) {',

                        '		vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
                        '		visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
                        '		visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
                        '		visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
                        '		visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
                        '		visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
                        '		visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
                        '		visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
                        '		visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',

                        '		vVisibility =        visibility.r / 9.0;',
                        '		vVisibility *= 1.0 - visibility.g / 9.0;',
                        '		vVisibility *=       visibility.b / 9.0;',
                        '		vVisibility *= 1.0 - visibility.a / 9.0;',

                        '		pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
                        '		pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',

                        '	}',

                        '	gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',

                        '}'

                    ].join('\n'),

                    fragmentShader: [

                        'uniform lowp int renderType;',

                        'uniform sampler2D map;',
                        'uniform float opacity;',
                        'uniform vec3 color;',

                        'varying vec2 vUV;',
                        'varying float vVisibility;',

                        'void main() {',

                        // pink square

                        '	if ( renderType == 0 ) {',

                        '		gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',

                        // restore

                        '	} else if ( renderType == 1 ) {',

                        '		gl_FragColor = texture2D( map, vUV );',

                        // flare

                        '	} else {',

                        '		vec4 texture = texture2D( map, vUV );',
                        '		texture.a *= opacity * vVisibility;',
                        '		gl_FragColor = texture;',
                        '		gl_FragColor.rgb *= color;',

                        '	}',

                        '}'

                    ].join('\n')

                };

                program = createProgram(shader);

                attributes = {
                    vertex: gl.getAttribLocation(program, 'position'),
                    uv: gl.getAttribLocation(program, 'uv')
                };

                uniforms = {
                    renderType: gl.getUniformLocation(program, 'renderType'),
                    map: gl.getUniformLocation(program, 'map'),
                    occlusionMap: gl.getUniformLocation(program, 'occlusionMap'),
                    opacity: gl.getUniformLocation(program, 'opacity'),
                    color: gl.getUniformLocation(program, 'color'),
                    scale: gl.getUniformLocation(program, 'scale'),
                    rotation: gl.getUniformLocation(program, 'rotation'),
                    screenPosition: gl.getUniformLocation(program, 'screenPosition')
                };

            }

            /*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */

            this.render = function (flares, scene, camera, viewport) {

                if (flares.length === 0) return;

                var tempPosition = new Vector3();

                var invAspect = viewport.w / viewport.z,
                    halfViewportWidth = viewport.z * 0.5,
                    halfViewportHeight = viewport.w * 0.5;

                var size = 16 / viewport.w,
                    scale = new Vector2(size * invAspect, size);

                var screenPosition = new Vector3(1, 1, 0),
                    screenPositionPixels = new Vector2(1, 1);

                var validArea = new Box2();

                validArea.min.set(viewport.x, viewport.y);
                validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));

                if (program === undefined) {

                    init();

                }

                state.useProgram(program);

                state.initAttributes();
                state.enableAttribute(attributes.vertex);
                state.enableAttribute(attributes.uv);
                state.disableUnusedAttributes();

                // loop through all lens flares to update their occlusion and positions
                // setup gl and common used attribs/uniforms

                gl.uniform1i(uniforms.occlusionMap, 0);
                gl.uniform1i(uniforms.map, 1);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
                gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);

                state.disable(gl.CULL_FACE);
                state.buffers.depth.setMask(false);

                for (var i = 0, l = flares.length; i < l; i++) {

                    size = 16 / viewport.w;
                    scale.set(size * invAspect, size);

                    // calc object screen position

                    var flare = flares[i];

                    tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);

                    tempPosition.applyMatrix4(camera.matrixWorldInverse);
                    tempPosition.applyMatrix4(camera.projectionMatrix);

                    // setup arrays for gl programs

                    screenPosition.copy(tempPosition);

                    // horizontal and vertical coordinate of the lower left corner of the pixels to copy

                    screenPositionPixels.x = viewport.x + (screenPosition.x * halfViewportWidth) + halfViewportWidth - 8;
                    screenPositionPixels.y = viewport.y + (screenPosition.y * halfViewportHeight) + halfViewportHeight - 8;

                    // screen cull

                    if (validArea.containsPoint(screenPositionPixels) === true) {

                        // save current RGB to temp texture

                        state.activeTexture(gl.TEXTURE0);
                        state.bindTexture(gl.TEXTURE_2D, null);
                        state.activeTexture(gl.TEXTURE1);
                        state.bindTexture(gl.TEXTURE_2D, tempTexture);
                        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);


                        // render pink quad

                        gl.uniform1i(uniforms.renderType, 0);
                        gl.uniform2f(uniforms.scale, scale.x, scale.y);
                        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);

                        state.disable(gl.BLEND);
                        state.enable(gl.DEPTH_TEST);

                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);


                        // copy result to occlusionMap

                        state.activeTexture(gl.TEXTURE0);
                        state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
                        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);


                        // restore graphics

                        gl.uniform1i(uniforms.renderType, 1);
                        state.disable(gl.DEPTH_TEST);

                        state.activeTexture(gl.TEXTURE1);
                        state.bindTexture(gl.TEXTURE_2D, tempTexture);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);


                        // update object positions

                        flare.positionScreen.copy(screenPosition);

                        if (flare.customUpdateCallback) {

                            flare.customUpdateCallback(flare);

                        } else {

                            flare.updateLensFlares();

                        }

                        // render flares

                        gl.uniform1i(uniforms.renderType, 2);
                        state.enable(gl.BLEND);

                        for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {

                            var sprite = flare.lensFlares[j];

                            if (sprite.opacity > 0.001 && sprite.scale > 0.001) {

                                screenPosition.x = sprite.x;
                                screenPosition.y = sprite.y;
                                screenPosition.z = sprite.z;

                                size = sprite.size * sprite.scale / viewport.w;

                                scale.x = size * invAspect;
                                scale.y = size;

                                gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                                gl.uniform2f(uniforms.scale, scale.x, scale.y);
                                gl.uniform1f(uniforms.rotation, sprite.rotation);

                                gl.uniform1f(uniforms.opacity, sprite.opacity);
                                gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);

                                state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                                textures.setTexture2D(sprite.texture, 1);

                                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

                            }

                        }

                    }

                }

                // restore gl

                state.enable(gl.CULL_FACE);
                state.enable(gl.DEPTH_TEST);
                state.buffers.depth.setMask(true);

                state.reset();

            };

            function createProgram(shader) {

                var program = gl.createProgram();

                var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                var vertexShader = gl.createShader(gl.VERTEX_SHADER);

                var prefix = 'precision ' + capabilities.precision + ' float;\n';

                gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
                gl.shaderSource(vertexShader, prefix + shader.vertexShader);

                gl.compileShader(fragmentShader);
                gl.compileShader(vertexShader);

                gl.attachShader(program, fragmentShader);
                gl.attachShader(program, vertexShader);

                gl.linkProgram(program);

                return program;

            }

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

            Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

            this.needsUpdate = true;

        }

        CanvasTexture.prototype = Object.create(Texture.prototype);
        CanvasTexture.prototype.constructor = CanvasTexture;

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         */

        function WebGLSpriteRenderer(renderer, gl, state, textures, capabilities) {

            var vertexBuffer, elementBuffer;
            var program, attributes, uniforms;

            var texture;

            // decompose matrixWorld

            var spritePosition = new Vector3();
            var spriteRotation = new Quaternion();
            var spriteScale = new Vector3();

            function init() {

                var vertices = new Float32Array([
                    -0.5, -0.5, 0, 0,
                    0.5, -0.5, 1, 0,
                    0.5, 0.5, 1, 1,
                    -0.5, 0.5, 0, 1
                ]);

                var faces = new Uint16Array([
                    0, 1, 2,
                    0, 2, 3
                ]);

                vertexBuffer = gl.createBuffer();
                elementBuffer = gl.createBuffer();

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);

                program = createProgram();

                attributes = {
                    position: gl.getAttribLocation(program, 'position'),
                    uv: gl.getAttribLocation(program, 'uv')
                };

                uniforms = {
                    uvOffset: gl.getUniformLocation(program, 'uvOffset'),
                    uvScale: gl.getUniformLocation(program, 'uvScale'),

                    rotation: gl.getUniformLocation(program, 'rotation'),
                    scale: gl.getUniformLocation(program, 'scale'),

                    color: gl.getUniformLocation(program, 'color'),
                    map: gl.getUniformLocation(program, 'map'),
                    opacity: gl.getUniformLocation(program, 'opacity'),

                    modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
                    projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),

                    fogType: gl.getUniformLocation(program, 'fogType'),
                    fogDensity: gl.getUniformLocation(program, 'fogDensity'),
                    fogNear: gl.getUniformLocation(program, 'fogNear'),
                    fogFar: gl.getUniformLocation(program, 'fogFar'),
                    fogColor: gl.getUniformLocation(program, 'fogColor'),
                    fogDepth: gl.getUniformLocation(program, 'fogDepth'),

                    alphaTest: gl.getUniformLocation(program, 'alphaTest')
                };

                var canvas = document.createElement('canvas');
                canvas.width = 8;
                canvas.height = 8;

                var context = canvas.getContext('2d');
                context.fillStyle = 'white';
                context.fillRect(0, 0, 8, 8);

                texture = new CanvasTexture(canvas);

            }

            this.render = function (sprites, scene, camera) {

                if (sprites.length === 0) return;

                // setup gl

                if (program === undefined) {

                    init();

                }

                state.useProgram(program);

                state.initAttributes();
                state.enableAttribute(attributes.position);
                state.enableAttribute(attributes.uv);
                state.disableUnusedAttributes();

                state.disable(gl.CULL_FACE);
                state.enable(gl.BLEND);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
                gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);

                gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);

                state.activeTexture(gl.TEXTURE0);
                gl.uniform1i(uniforms.map, 0);

                var oldFogType = 0;
                var sceneFogType = 0;
                var fog = scene.fog;

                if (fog) {

                    gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);

                    if (fog.isFog) {

                        gl.uniform1f(uniforms.fogNear, fog.near);
                        gl.uniform1f(uniforms.fogFar, fog.far);

                        gl.uniform1i(uniforms.fogType, 1);
                        oldFogType = 1;
                        sceneFogType = 1;

                    } else if (fog.isFogExp2) {

                        gl.uniform1f(uniforms.fogDensity, fog.density);

                        gl.uniform1i(uniforms.fogType, 2);
                        oldFogType = 2;
                        sceneFogType = 2;

                    }

                } else {

                    gl.uniform1i(uniforms.fogType, 0);
                    oldFogType = 0;
                    sceneFogType = 0;

                }


                // update positions and sort

                for (var i = 0, l = sprites.length; i < l; i++) {

                    var sprite = sprites[i];

                    sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                    sprite.z = -sprite.modelViewMatrix.elements[14];

                }

                sprites.sort(painterSortStable);

                // render all sprites

                var scale = [];

                for (var i = 0, l = sprites.length; i < l; i++) {

                    var sprite = sprites[i];
                    var material = sprite.material;

                    if (material.visible === false) continue;

                    sprite.onBeforeRender(renderer, scene, camera, undefined, material, undefined);

                    gl.uniform1f(uniforms.alphaTest, material.alphaTest);
                    gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);

                    sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);

                    scale[0] = spriteScale.x;
                    scale[1] = spriteScale.y;

                    var fogType = 0;

                    if (scene.fog && material.fog) {

                        fogType = sceneFogType;

                    }

                    if (oldFogType !== fogType) {

                        gl.uniform1i(uniforms.fogType, fogType);
                        oldFogType = fogType;

                    }

                    if (material.map !== null) {

                        gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                        gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);

                    } else {

                        gl.uniform2f(uniforms.uvOffset, 0, 0);
                        gl.uniform2f(uniforms.uvScale, 1, 1);

                    }

                    gl.uniform1f(uniforms.opacity, material.opacity);
                    gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);

                    gl.uniform1f(uniforms.rotation, material.rotation);
                    gl.uniform2fv(uniforms.scale, scale);

                    state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
                    state.buffers.depth.setTest(material.depthTest);
                    state.buffers.depth.setMask(material.depthWrite);
                    state.buffers.color.setMask(material.colorWrite);
                    textures.setTexture2D(material.map || texture, 0);

                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

                    sprite.onAfterRender(renderer, scene, camera, undefined, material, undefined);

                }

                // restore gl

                state.enable(gl.CULL_FACE);

                state.reset();

            };

            function createProgram() {

                var program = gl.createProgram();

                var vertexShader = gl.createShader(gl.VERTEX_SHADER);
                var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

                gl.shaderSource(vertexShader, [

                    'precision ' + capabilities.precision + ' float;',

                    '#define SHADER_NAME ' + 'SpriteMaterial',

                    'uniform mat4 modelViewMatrix;',
                    'uniform mat4 projectionMatrix;',
                    'uniform float rotation;',
                    'uniform vec2 scale;',
                    'uniform vec2 uvOffset;',
                    'uniform vec2 uvScale;',

                    'attribute vec2 position;',
                    'attribute vec2 uv;',

                    'varying vec2 vUV;',
                    'varying float fogDepth;',

                    'void main() {',

                    '	vUV = uvOffset + uv * uvScale;',

                    '	vec2 alignedPosition = position * scale;',

                    '	vec2 rotatedPosition;',
                    '	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
                    '	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

                    '	vec4 mvPosition;',

                    '	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
                    '	mvPosition.xy += rotatedPosition;',

                    '	gl_Position = projectionMatrix * mvPosition;',

                    '	fogDepth = - mvPosition.z;',

                    '}'

                ].join('\n'));

                gl.shaderSource(fragmentShader, [

                    'precision ' + capabilities.precision + ' float;',

                    '#define SHADER_NAME ' + 'SpriteMaterial',

                    'uniform vec3 color;',
                    'uniform sampler2D map;',
                    'uniform float opacity;',

                    'uniform int fogType;',
                    'uniform vec3 fogColor;',
                    'uniform float fogDensity;',
                    'uniform float fogNear;',
                    'uniform float fogFar;',
                    'uniform float alphaTest;',

                    'varying vec2 vUV;',
                    'varying float fogDepth;',

                    'void main() {',

                    '	vec4 texture = texture2D( map, vUV );',

                    '	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

                    '	if ( gl_FragColor.a < alphaTest ) discard;',

                    '	if ( fogType > 0 ) {',

                    '		float fogFactor = 0.0;',

                    '		if ( fogType == 1 ) {',

                    '			fogFactor = smoothstep( fogNear, fogFar, fogDepth );',

                    '		} else {',

                    '			const float LOG2 = 1.442695;',
                    '			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',
                    '			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

                    '		}',

                    '		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',

                    '	}',

                    '}'

                ].join('\n'));

                gl.compileShader(vertexShader);
                gl.compileShader(fragmentShader);

                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);

                gl.linkProgram(program);

                return program;

            }

            function painterSortStable(a, b) {

                if (a.renderOrder !== b.renderOrder) {

                    return a.renderOrder - b.renderOrder;

                } else if (a.z !== b.z) {

                    return b.z - a.z;

                } else {

                    return b.id - a.id;

                }

            }

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        var materialId = 0;

        function Material() {

            Object.defineProperty(this, 'id', {value: materialId++});

            this.uuid = _Math.generateUUID();

            this.name = '';
            this.type = 'Material';

            this.fog = true;
            this.lights = true;

            this.blending = NormalBlending;
            this.side = FrontSide;
            this.flatShading = false;
            this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

            this.opacity = 1;
            this.transparent = false;

            this.blendSrc = SrcAlphaFactor;
            this.blendDst = OneMinusSrcAlphaFactor;
            this.blendEquation = AddEquation;
            this.blendSrcAlpha = null;
            this.blendDstAlpha = null;
            this.blendEquationAlpha = null;

            this.depthFunc = LessEqualDepth;
            this.depthTest = true;
            this.depthWrite = true;

            this.clippingPlanes = null;
            this.clipIntersection = false;
            this.clipShadows = false;

            this.colorWrite = true;

            this.precision = null; // override the renderer's default precision for this material

            this.polygonOffset = false;
            this.polygonOffsetFactor = 0;
            this.polygonOffsetUnits = 0;

            this.dithering = false;

            this.alphaTest = 0;
            this.premultipliedAlpha = false;

            this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

            this.visible = true;

            this.userData = {};

            this.needsUpdate = true;

        }

        Object.assign(Material.prototype, EventDispatcher.prototype, {

            isMaterial: true,

            onBeforeCompile: function () {
            },

            setValues: function (values) {

                if (values === undefined) return;

                for (var key in values) {

                    var newValue = values[key];

                    if (newValue === undefined) {

                        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                        continue;

                    }

                    // for backward compatability if shading is set in the constructor
                    if (key === 'shading') {

                        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                        this.flatShading = (newValue === FlatShading) ? true : false;
                        continue;

                    }

                    var currentValue = this[key];

                    if (currentValue === undefined) {

                        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                        continue;

                    }

                    if (currentValue && currentValue.isColor) {

                        currentValue.set(newValue);

                    } else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {

                        currentValue.copy(newValue);

                    } else if (key === 'overdraw') {

                        // ensure overdraw is backwards-compatible with legacy boolean type
                        this[key] = Number(newValue);

                    } else {

                        this[key] = newValue;

                    }

                }

            },

            toJSON: function (meta) {

                var isRoot = (meta === undefined || typeof meta === 'string');

                if (isRoot) {

                    meta = {
                        textures: {},
                        images: {}
                    };

                }

                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'Material',
                        generator: 'Material.toJSON'
                    }
                };

                // standard Material serialization
                data.uuid = this.uuid;
                data.type = this.type;

                if (this.name !== '') data.name = this.name;

                if (this.color && this.color.isColor) data.color = this.color.getHex();

                if (this.roughness !== undefined) data.roughness = this.roughness;
                if (this.metalness !== undefined) data.metalness = this.metalness;

                if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
                if (this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;

                if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
                if (this.shininess !== undefined) data.shininess = this.shininess;
                if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
                if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;

                if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
                if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
                if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
                if (this.bumpMap && this.bumpMap.isTexture) {

                    data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                    data.bumpScale = this.bumpScale;

                }
                if (this.normalMap && this.normalMap.isTexture) {

                    data.normalMap = this.normalMap.toJSON(meta).uuid;
                    data.normalScale = this.normalScale.toArray();

                }
                if (this.displacementMap && this.displacementMap.isTexture) {

                    data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                    data.displacementScale = this.displacementScale;
                    data.displacementBias = this.displacementBias;

                }
                if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
                if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;

                if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
                if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

                if (this.envMap && this.envMap.isTexture) {

                    data.envMap = this.envMap.toJSON(meta).uuid;
                    data.reflectivity = this.reflectivity; // Scale behind envMap

                }

                if (this.gradientMap && this.gradientMap.isTexture) {

                    data.gradientMap = this.gradientMap.toJSON(meta).uuid;

                }

                if (this.size !== undefined) data.size = this.size;
                if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;

                if (this.blending !== NormalBlending) data.blending = this.blending;
                if (this.flatShading === true) data.flatShading = this.flatShading;
                if (this.side !== FrontSide) data.side = this.side;
                if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;

                if (this.opacity < 1) data.opacity = this.opacity;
                if (this.transparent === true) data.transparent = this.transparent;

                data.depthFunc = this.depthFunc;
                data.depthTest = this.depthTest;
                data.depthWrite = this.depthWrite;

                // rotation (SpriteMaterial)
                if (this.rotation !== 0) data.rotation = this.rotation;

                if (this.linewidth !== 1) data.linewidth = this.linewidth;
                if (this.dashSize !== undefined) data.dashSize = this.dashSize;
                if (this.gapSize !== undefined) data.gapSize = this.gapSize;
                if (this.scale !== undefined) data.scale = this.scale;

                if (this.dithering === true) data.dithering = true;

                if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
                if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;

                if (this.wireframe === true) data.wireframe = this.wireframe;
                if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
                if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
                if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;

                if (this.morphTargets === true) data.morphTargets = true;
                if (this.skinning === true) data.skinning = true;

                if (this.visible === false) data.visible = false;
                if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;

                // TODO: Copied from Object3D.toJSON

                function extractFromCache(cache) {

                    var values = [];

                    for (var key in cache) {

                        var data = cache[key];
                        delete data.metadata;
                        values.push(data);

                    }

                    return values;

                }

                if (isRoot) {

                    var textures = extractFromCache(meta.textures);
                    var images = extractFromCache(meta.images);

                    if (textures.length > 0) data.textures = textures;
                    if (images.length > 0) data.images = images;

                }

                return data;

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (source) {

                this.name = source.name;

                this.fog = source.fog;
                this.lights = source.lights;

                this.blending = source.blending;
                this.side = source.side;
                this.flatShading = source.flatShading;
                this.vertexColors = source.vertexColors;

                this.opacity = source.opacity;
                this.transparent = source.transparent;

                this.blendSrc = source.blendSrc;
                this.blendDst = source.blendDst;
                this.blendEquation = source.blendEquation;
                this.blendSrcAlpha = source.blendSrcAlpha;
                this.blendDstAlpha = source.blendDstAlpha;
                this.blendEquationAlpha = source.blendEquationAlpha;

                this.depthFunc = source.depthFunc;
                this.depthTest = source.depthTest;
                this.depthWrite = source.depthWrite;

                this.colorWrite = source.colorWrite;

                this.precision = source.precision;

                this.polygonOffset = source.polygonOffset;
                this.polygonOffsetFactor = source.polygonOffsetFactor;
                this.polygonOffsetUnits = source.polygonOffsetUnits;

                this.dithering = source.dithering;

                this.alphaTest = source.alphaTest;
                this.premultipliedAlpha = source.premultipliedAlpha;

                this.overdraw = source.overdraw;

                this.visible = source.visible;
                this.userData = JSON.parse(JSON.stringify(source.userData));

                this.clipShadows = source.clipShadows;
                this.clipIntersection = source.clipIntersection;

                var srcPlanes = source.clippingPlanes,
                    dstPlanes = null;

                if (srcPlanes !== null) {

                    var n = srcPlanes.length;
                    dstPlanes = new Array(n);

                    for (var i = 0; i !== n; ++i)
                        dstPlanes[i] = srcPlanes[i].clone();

                }

                this.clippingPlanes = dstPlanes;

                return this;

            },

            dispose: function () {

                this.dispatchEvent({type: 'dispose'});

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author bhouston / https://clara.io
         * @author WestLangley / http://github.com/WestLangley
         *
         * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
         */

        function MeshDepthMaterial(parameters) {

            Material.call(this);

            this.type = 'MeshDepthMaterial';

            this.depthPacking = BasicDepthPacking;

            this.skinning = false;
            this.morphTargets = false;

            this.map = null;

            this.alphaMap = null;

            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;

            this.wireframe = false;
            this.wireframeLinewidth = 1;

            this.fog = false;
            this.lights = false;

            this.setValues(parameters);

        }

        MeshDepthMaterial.prototype = Object.create(Material.prototype);
        MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

        MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

        MeshDepthMaterial.prototype.copy = function (source) {

            Material.prototype.copy.call(this, source);

            this.depthPacking = source.depthPacking;

            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;

            this.map = source.map;

            this.alphaMap = source.alphaMap;

            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;

            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;

            return this;

        };

        /**
         * @author WestLangley / http://github.com/WestLangley
         *
         * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
         */

        function MeshDistanceMaterial(parameters) {

            Material.call(this);

            this.type = 'MeshDistanceMaterial';

            this.referencePosition = new Vector3();
            this.nearDistance = 1;
            this.farDistance = 1000;

            this.skinning = false;
            this.morphTargets = false;

            this.map = null;

            this.alphaMap = null;

            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;

            this.fog = false;
            this.lights = false;

            this.setValues(parameters);

        }

        MeshDistanceMaterial.prototype = Object.create(Material.prototype);
        MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

        MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

        MeshDistanceMaterial.prototype.copy = function (source) {

            Material.prototype.copy.call(this, source);

            this.referencePosition.copy(source.referencePosition);
            this.nearDistance = source.nearDistance;
            this.farDistance = source.farDistance;

            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;

            this.map = source.map;

            this.alphaMap = source.alphaMap;

            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;

            return this;

        };

        /**
         * @author bhouston / http://clara.io
         * @author WestLangley / http://github.com/WestLangley
         */

        function Box3(min, max) {

            this.min = (min !== undefined) ? min : new Vector3(+Infinity, +Infinity, +Infinity);
            this.max = (max !== undefined) ? max : new Vector3(-Infinity, -Infinity, -Infinity);

        }

        Object.assign(Box3.prototype, {

            isBox3: true,

            set: function (min, max) {

                this.min.copy(min);
                this.max.copy(max);

                return this;

            },

            setFromArray: function (array) {

                var minX = +Infinity;
                var minY = +Infinity;
                var minZ = +Infinity;

                var maxX = -Infinity;
                var maxY = -Infinity;
                var maxZ = -Infinity;

                for (var i = 0, l = array.length; i < l; i += 3) {

                    var x = array[i];
                    var y = array[i + 1];
                    var z = array[i + 2];

                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (z < minZ) minZ = z;

                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                    if (z > maxZ) maxZ = z;

                }

                this.min.set(minX, minY, minZ);
                this.max.set(maxX, maxY, maxZ);

                return this;

            },

            setFromBufferAttribute: function (attribute) {

                var minX = +Infinity;
                var minY = +Infinity;
                var minZ = +Infinity;

                var maxX = -Infinity;
                var maxY = -Infinity;
                var maxZ = -Infinity;

                for (var i = 0, l = attribute.count; i < l; i++) {

                    var x = attribute.getX(i);
                    var y = attribute.getY(i);
                    var z = attribute.getZ(i);

                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (z < minZ) minZ = z;

                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                    if (z > maxZ) maxZ = z;

                }

                this.min.set(minX, minY, minZ);
                this.max.set(maxX, maxY, maxZ);

                return this;

            },

            setFromPoints: function (points) {

                this.makeEmpty();

                for (var i = 0, il = points.length; i < il; i++) {

                    this.expandByPoint(points[i]);

                }

                return this;

            },

            setFromCenterAndSize: function () {

                var v1 = new Vector3();

                return function setFromCenterAndSize(center, size) {

                    var halfSize = v1.copy(size).multiplyScalar(0.5);

                    this.min.copy(center).sub(halfSize);
                    this.max.copy(center).add(halfSize);

                    return this;

                };

            }(),

            setFromObject: function (object) {

                this.makeEmpty();

                return this.expandByObject(object);

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (box) {

                this.min.copy(box.min);
                this.max.copy(box.max);

                return this;

            },

            makeEmpty: function () {

                this.min.x = this.min.y = this.min.z = +Infinity;
                this.max.x = this.max.y = this.max.z = -Infinity;

                return this;

            },

            isEmpty: function () {

                // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

                return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);

            },

            getCenter: function (optionalTarget) {

                var result = optionalTarget || new Vector3();
                return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);

            },

            getSize: function (optionalTarget) {

                var result = optionalTarget || new Vector3();
                return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);

            },

            expandByPoint: function (point) {

                this.min.min(point);
                this.max.max(point);

                return this;

            },

            expandByVector: function (vector) {

                this.min.sub(vector);
                this.max.add(vector);

                return this;

            },

            expandByScalar: function (scalar) {

                this.min.addScalar(-scalar);
                this.max.addScalar(scalar);

                return this;

            },

            expandByObject: function () {

                // Computes the world-axis-aligned bounding box of an object (including its children),
                // accounting for both the object's, and children's, world transforms

                var scope, i, l;

                var v1 = new Vector3();

                function traverse(node) {

                    var geometry = node.geometry;

                    if (geometry !== undefined) {

                        if (geometry.isGeometry) {

                            var vertices = geometry.vertices;

                            for (i = 0, l = vertices.length; i < l; i++) {

                                v1.copy(vertices[i]);
                                v1.applyMatrix4(node.matrixWorld);

                                scope.expandByPoint(v1);

                            }

                        } else if (geometry.isBufferGeometry) {

                            var attribute = geometry.attributes.position;

                            if (attribute !== undefined) {

                                for (i = 0, l = attribute.count; i < l; i++) {

                                    v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);

                                    scope.expandByPoint(v1);

                                }

                            }

                        }

                    }

                }

                return function expandByObject(object) {

                    scope = this;

                    object.updateMatrixWorld(true);

                    object.traverse(traverse);

                    return this;

                };

            }(),

            containsPoint: function (point) {

                return point.x < this.min.x || point.x > this.max.x ||
                point.y < this.min.y || point.y > this.max.y ||
                point.z < this.min.z || point.z > this.max.z ? false : true;

            },

            containsBox: function (box) {

                return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                    this.min.y <= box.min.y && box.max.y <= this.max.y &&
                    this.min.z <= box.min.z && box.max.z <= this.max.z;

            },

            getParameter: function (point, optionalTarget) {

                // This can potentially have a divide by zero if the box
                // has a size dimension of 0.

                var result = optionalTarget || new Vector3();

                return result.set(
                    (point.x - this.min.x) / (this.max.x - this.min.x),
                    (point.y - this.min.y) / (this.max.y - this.min.y),
                    (point.z - this.min.z) / (this.max.z - this.min.z)
                );

            },

            intersectsBox: function (box) {

                // using 6 splitting planes to rule out intersections.
                return box.max.x < this.min.x || box.min.x > this.max.x ||
                box.max.y < this.min.y || box.min.y > this.max.y ||
                box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

            },

            intersectsSphere: (function () {

                var closestPoint = new Vector3();

                return function intersectsSphere(sphere) {

                    // Find the point on the AABB closest to the sphere center.
                    this.clampPoint(sphere.center, closestPoint);

                    // If that point is inside the sphere, the AABB and sphere intersect.
                    return closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);

                };

            })(),

            intersectsPlane: function (plane) {

                // We compute the minimum and maximum dot product values. If those values
                // are on the same side (back or front) of the plane, then there is no intersection.

                var min, max;

                if (plane.normal.x > 0) {

                    min = plane.normal.x * this.min.x;
                    max = plane.normal.x * this.max.x;

                } else {

                    min = plane.normal.x * this.max.x;
                    max = plane.normal.x * this.min.x;

                }

                if (plane.normal.y > 0) {

                    min += plane.normal.y * this.min.y;
                    max += plane.normal.y * this.max.y;

                } else {

                    min += plane.normal.y * this.max.y;
                    max += plane.normal.y * this.min.y;

                }

                if (plane.normal.z > 0) {

                    min += plane.normal.z * this.min.z;
                    max += plane.normal.z * this.max.z;

                } else {

                    min += plane.normal.z * this.max.z;
                    max += plane.normal.z * this.min.z;

                }

                return (min <= plane.constant && max >= plane.constant);

            },

            clampPoint: function (point, optionalTarget) {

                var result = optionalTarget || new Vector3();
                return result.copy(point).clamp(this.min, this.max);

            },

            distanceToPoint: function () {

                var v1 = new Vector3();

                return function distanceToPoint(point) {

                    var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                    return clampedPoint.sub(point).length();

                };

            }(),

            getBoundingSphere: function () {

                var v1 = new Vector3();

                return function getBoundingSphere(optionalTarget) {

                    var result = optionalTarget || new Sphere();

                    this.getCenter(result.center);

                    result.radius = this.getSize(v1).length() * 0.5;

                    return result;

                };

            }(),

            intersect: function (box) {

                this.min.max(box.min);
                this.max.min(box.max);

                // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
                if (this.isEmpty()) this.makeEmpty();

                return this;

            },

            union: function (box) {

                this.min.min(box.min);
                this.max.max(box.max);

                return this;

            },

            applyMatrix4: function () {

                var points = [
                    new Vector3(),
                    new Vector3(),
                    new Vector3(),
                    new Vector3(),
                    new Vector3(),
                    new Vector3(),
                    new Vector3(),
                    new Vector3()
                ];

                return function applyMatrix4(matrix) {

                    // transform of empty box is an empty box.
                    if (this.isEmpty()) return this;

                    // NOTE: I am using a binary pattern to specify all 2^3 combinations below
                    points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
                    points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
                    points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
                    points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
                    points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
                    points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
                    points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
                    points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);	// 111

                    this.setFromPoints(points);

                    return this;

                };

            }(),

            translate: function (offset) {

                this.min.add(offset);
                this.max.add(offset);

                return this;

            },

            equals: function (box) {

                return box.min.equals(this.min) && box.max.equals(this.max);

            }

        });

        /**
         * @author bhouston / http://clara.io
         * @author mrdoob / http://mrdoob.com/
         */

        function Sphere(center, radius) {

            this.center = (center !== undefined) ? center : new Vector3();
            this.radius = (radius !== undefined) ? radius : 0;

        }

        Object.assign(Sphere.prototype, {

            set: function (center, radius) {

                this.center.copy(center);
                this.radius = radius;

                return this;

            },

            setFromPoints: function () {

                var box = new Box3();

                return function setFromPoints(points, optionalCenter) {

                    var center = this.center;

                    if (optionalCenter !== undefined) {

                        center.copy(optionalCenter);

                    } else {

                        box.setFromPoints(points).getCenter(center);

                    }

                    var maxRadiusSq = 0;

                    for (var i = 0, il = points.length; i < il; i++) {

                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));

                    }

                    this.radius = Math.sqrt(maxRadiusSq);

                    return this;

                };

            }(),

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (sphere) {

                this.center.copy(sphere.center);
                this.radius = sphere.radius;

                return this;

            },

            empty: function () {

                return (this.radius <= 0);

            },

            containsPoint: function (point) {

                return (point.distanceToSquared(this.center) <= (this.radius * this.radius));

            },

            distanceToPoint: function (point) {

                return (point.distanceTo(this.center) - this.radius);

            },

            intersectsSphere: function (sphere) {

                var radiusSum = this.radius + sphere.radius;

                return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);

            },

            intersectsBox: function (box) {

                return box.intersectsSphere(this);

            },

            intersectsPlane: function (plane) {

                return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;

            },

            clampPoint: function (point, optionalTarget) {

                var deltaLengthSq = this.center.distanceToSquared(point);

                var result = optionalTarget || new Vector3();

                result.copy(point);

                if (deltaLengthSq > (this.radius * this.radius)) {

                    result.sub(this.center).normalize();
                    result.multiplyScalar(this.radius).add(this.center);

                }

                return result;

            },

            getBoundingBox: function (optionalTarget) {

                var box = optionalTarget || new Box3();

                box.set(this.center, this.center);
                box.expandByScalar(this.radius);

                return box;

            },

            applyMatrix4: function (matrix) {

                this.center.applyMatrix4(matrix);
                this.radius = this.radius * matrix.getMaxScaleOnAxis();

                return this;

            },

            translate: function (offset) {

                this.center.add(offset);

                return this;

            },

            equals: function (sphere) {

                return sphere.center.equals(this.center) && (sphere.radius === this.radius);

            }

        });

        /**
         * @author bhouston / http://clara.io
         */

        function Plane(normal, constant) {

            // normal is assumed to be normalized

            this.normal = (normal !== undefined) ? normal : new Vector3(1, 0, 0);
            this.constant = (constant !== undefined) ? constant : 0;

        }

        Object.assign(Plane.prototype, {

            set: function (normal, constant) {

                this.normal.copy(normal);
                this.constant = constant;

                return this;

            },

            setComponents: function (x, y, z, w) {

                this.normal.set(x, y, z);
                this.constant = w;

                return this;

            },

            setFromNormalAndCoplanarPoint: function (normal, point) {

                this.normal.copy(normal);
                this.constant = -point.dot(this.normal);

                return this;

            },

            setFromCoplanarPoints: function () {

                var v1 = new Vector3();
                var v2 = new Vector3();

                return function setFromCoplanarPoints(a, b, c) {

                    var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();

                    // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

                    this.setFromNormalAndCoplanarPoint(normal, a);

                    return this;

                };

            }(),

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (plane) {

                this.normal.copy(plane.normal);
                this.constant = plane.constant;

                return this;

            },

            normalize: function () {

                // Note: will lead to a divide by zero if the plane is invalid.

                var inverseNormalLength = 1.0 / this.normal.length();
                this.normal.multiplyScalar(inverseNormalLength);
                this.constant *= inverseNormalLength;

                return this;

            },

            negate: function () {

                this.constant *= -1;
                this.normal.negate();

                return this;

            },

            distanceToPoint: function (point) {

                return this.normal.dot(point) + this.constant;

            },

            distanceToSphere: function (sphere) {

                return this.distanceToPoint(sphere.center) - sphere.radius;

            },

            projectPoint: function (point, optionalTarget) {

                var result = optionalTarget || new Vector3();

                return result.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);

            },

            intersectLine: function () {

                var v1 = new Vector3();

                return function intersectLine(line, optionalTarget) {

                    var result = optionalTarget || new Vector3();

                    var direction = line.delta(v1);

                    var denominator = this.normal.dot(direction);

                    if (denominator === 0) {

                        // line is coplanar, return origin
                        if (this.distanceToPoint(line.start) === 0) {

                            return result.copy(line.start);

                        }

                        // Unsure if this is the correct method to handle this case.
                        return undefined;

                    }

                    var t = -(line.start.dot(this.normal) + this.constant) / denominator;

                    if (t < 0 || t > 1) {

                        return undefined;

                    }

                    return result.copy(direction).multiplyScalar(t).add(line.start);

                };

            }(),

            intersectsLine: function (line) {

                // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

                var startSign = this.distanceToPoint(line.start);
                var endSign = this.distanceToPoint(line.end);

                return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);

            },

            intersectsBox: function (box) {

                return box.intersectsPlane(this);

            },

            intersectsSphere: function (sphere) {

                return sphere.intersectsPlane(this);

            },

            coplanarPoint: function (optionalTarget) {

                var result = optionalTarget || new Vector3();

                return result.copy(this.normal).multiplyScalar(-this.constant);

            },

            applyMatrix4: function () {

                var v1 = new Vector3();
                var m1 = new Matrix3();

                return function applyMatrix4(matrix, optionalNormalMatrix) {

                    var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);

                    var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);

                    var normal = this.normal.applyMatrix3(normalMatrix).normalize();

                    this.constant = -referencePoint.dot(normal);

                    return this;

                };

            }(),

            translate: function (offset) {

                this.constant -= offset.dot(this.normal);

                return this;

            },

            equals: function (plane) {

                return plane.normal.equals(this.normal) && (plane.constant === this.constant);

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author bhouston / http://clara.io
         */

        function Frustum(p0, p1, p2, p3, p4, p5) {

            this.planes = [

                (p0 !== undefined) ? p0 : new Plane(),
                (p1 !== undefined) ? p1 : new Plane(),
                (p2 !== undefined) ? p2 : new Plane(),
                (p3 !== undefined) ? p3 : new Plane(),
                (p4 !== undefined) ? p4 : new Plane(),
                (p5 !== undefined) ? p5 : new Plane()

            ];

        }

        Object.assign(Frustum.prototype, {

            set: function (p0, p1, p2, p3, p4, p5) {

                var planes = this.planes;

                planes[0].copy(p0);
                planes[1].copy(p1);
                planes[2].copy(p2);
                planes[3].copy(p3);
                planes[4].copy(p4);
                planes[5].copy(p5);

                return this;

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (frustum) {

                var planes = this.planes;

                for (var i = 0; i < 6; i++) {

                    planes[i].copy(frustum.planes[i]);

                }

                return this;

            },

            setFromMatrix: function (m) {

                var planes = this.planes;
                var me = m.elements;
                var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
                var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
                var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
                var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];

                planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
                planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
                planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
                planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
                planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
                planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();

                return this;

            },

            intersectsObject: function () {

                var sphere = new Sphere();

                return function intersectsObject(object) {

                    var geometry = object.geometry;

                    if (geometry.boundingSphere === null)
                        geometry.computeBoundingSphere();

                    sphere.copy(geometry.boundingSphere)
                        .applyMatrix4(object.matrixWorld);

                    return this.intersectsSphere(sphere);

                };

            }(),

            intersectsSprite: function () {

                var sphere = new Sphere();

                return function intersectsSprite(sprite) {

                    sphere.center.set(0, 0, 0);
                    sphere.radius = 0.7071067811865476;
                    sphere.applyMatrix4(sprite.matrixWorld);

                    return this.intersectsSphere(sphere);

                };

            }(),

            intersectsSphere: function (sphere) {

                var planes = this.planes;
                var center = sphere.center;
                var negRadius = -sphere.radius;

                for (var i = 0; i < 6; i++) {

                    var distance = planes[i].distanceToPoint(center);

                    if (distance < negRadius) {

                        return false;

                    }

                }

                return true;

            },

            intersectsBox: function () {

                var p1 = new Vector3(),
                    p2 = new Vector3();

                return function intersectsBox(box) {

                    var planes = this.planes;

                    for (var i = 0; i < 6; i++) {

                        var plane = planes[i];

                        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                        var d1 = plane.distanceToPoint(p1);
                        var d2 = plane.distanceToPoint(p2);

                        // if both outside plane, no intersection

                        if (d1 < 0 && d2 < 0) {

                            return false;

                        }

                    }

                    return true;

                };

            }(),

            containsPoint: function (point) {

                var planes = this.planes;

                for (var i = 0; i < 6; i++) {

                    if (planes[i].distanceToPoint(point) < 0) {

                        return false;

                    }

                }

                return true;

            }

        });

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLShadowMap(_renderer, _objects, maxTextureSize) {

            var _frustum = new Frustum(),
                _projScreenMatrix = new Matrix4(),

                _shadowMapSize = new Vector2(),
                _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize),

                _lookTarget = new Vector3(),
                _lightPositionWorld = new Vector3(),

                _MorphingFlag = 1,
                _SkinningFlag = 2,

                _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,

                _depthMaterials = new Array(_NumberOfMaterialVariants),
                _distanceMaterials = new Array(_NumberOfMaterialVariants),

                _materialCache = {};

            var cubeDirections = [
                new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),
                new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)
            ];

            var cubeUps = [
                new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
                new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)
            ];

            var cube2DViewPorts = [
                new Vector4(), new Vector4(), new Vector4(),
                new Vector4(), new Vector4(), new Vector4()
            ];

            // init

            for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {

                var useMorphing = (i & _MorphingFlag) !== 0;
                var useSkinning = (i & _SkinningFlag) !== 0;

                var depthMaterial = new MeshDepthMaterial({

                    depthPacking: RGBADepthPacking,

                    morphTargets: useMorphing,
                    skinning: useSkinning

                });

                _depthMaterials[i] = depthMaterial;

                //

                var distanceMaterial = new MeshDistanceMaterial({

                    morphTargets: useMorphing,
                    skinning: useSkinning

                });

                _distanceMaterials[i] = distanceMaterial;

            }

            //

            var scope = this;

            this.enabled = false;

            this.autoUpdate = true;
            this.needsUpdate = false;

            this.type = PCFShadowMap;

            this.renderReverseSided = true;
            this.renderSingleSided = true;

            this.render = function (lights, scene, camera) {

                if (scope.enabled === false) return;
                if (scope.autoUpdate === false && scope.needsUpdate === false) return;

                if (lights.length === 0) return;

                // TODO Clean up (needed in case of contextlost)
                var _gl = _renderer.context;
                var _state = _renderer.state;

                // Set GL state for depth map.
                _state.disable(_gl.BLEND);
                _state.buffers.color.setClear(1, 1, 1, 1);
                _state.buffers.depth.setTest(true);
                _state.setScissorTest(false);

                // render depth map

                var faceCount;

                for (var i = 0, il = lights.length; i < il; i++) {

                    var light = lights[i];
                    var shadow = light.shadow;
                    var isPointLight = light && light.isPointLight;

                    if (shadow === undefined) {

                        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                        continue;

                    }

                    var shadowCamera = shadow.camera;

                    _shadowMapSize.copy(shadow.mapSize);
                    _shadowMapSize.min(_maxShadowMapSize);

                    if (isPointLight) {

                        var vpWidth = _shadowMapSize.x;
                        var vpHeight = _shadowMapSize.y;

                        // These viewports map a cube-map onto a 2D texture with the
                        // following orientation:
                        //
                        //  xzXZ
                        //   y Y
                        //
                        // X - Positive x direction
                        // x - Negative x direction
                        // Y - Positive y direction
                        // y - Negative y direction
                        // Z - Positive z direction
                        // z - Negative z direction

                        // positive X
                        cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                        // negative X
                        cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                        // positive Z
                        cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                        // negative Z
                        cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                        // positive Y
                        cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                        // negative Y
                        cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);

                        _shadowMapSize.x *= 4.0;
                        _shadowMapSize.y *= 2.0;

                    }

                    if (shadow.map === null) {

                        var pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};

                        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                        shadow.map.texture.name = light.name + ".shadowMap";

                        shadowCamera.updateProjectionMatrix();

                    }

                    if (shadow.isSpotLightShadow) {

                        shadow.update(light);

                    }

                    var shadowMap = shadow.map;
                    var shadowMatrix = shadow.matrix;

                    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                    shadowCamera.position.copy(_lightPositionWorld);

                    if (isPointLight) {

                        faceCount = 6;

                        // for point lights we set the shadow matrix to be a translation-only matrix
                        // equal to inverse of the light's position

                        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);

                    } else {

                        faceCount = 1;

                        _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                        shadowCamera.lookAt(_lookTarget);
                        shadowCamera.updateMatrixWorld();

                        // compute shadow matrix

                        shadowMatrix.set(
                            0.5, 0.0, 0.0, 0.5,
                            0.0, 0.5, 0.0, 0.5,
                            0.0, 0.0, 0.5, 0.5,
                            0.0, 0.0, 0.0, 1.0
                        );

                        shadowMatrix.multiply(shadowCamera.projectionMatrix);
                        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);

                    }

                    _renderer.setRenderTarget(shadowMap);
                    _renderer.clear();

                    // render shadow map for each cube face (if omni-directional) or
                    // run a single pass if not

                    for (var face = 0; face < faceCount; face++) {

                        if (isPointLight) {

                            _lookTarget.copy(shadowCamera.position);
                            _lookTarget.add(cubeDirections[face]);
                            shadowCamera.up.copy(cubeUps[face]);
                            shadowCamera.lookAt(_lookTarget);
                            shadowCamera.updateMatrixWorld();

                            var vpDimensions = cube2DViewPorts[face];
                            _state.viewport(vpDimensions);

                        }

                        // update camera matrices and frustum

                        _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                        _frustum.setFromMatrix(_projScreenMatrix);

                        // set object matrices & frustum culling

                        renderObject(scene, camera, shadowCamera, isPointLight);

                    }

                }

                scope.needsUpdate = false;

            };

            function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {

                var geometry = object.geometry;

                var result = null;

                var materialVariants = _depthMaterials;
                var customMaterial = object.customDepthMaterial;

                if (isPointLight) {

                    materialVariants = _distanceMaterials;
                    customMaterial = object.customDistanceMaterial;

                }

                if (!customMaterial) {

                    var useMorphing = false;

                    if (material.morphTargets) {

                        if (geometry && geometry.isBufferGeometry) {

                            useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

                        } else if (geometry && geometry.isGeometry) {

                            useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

                        }

                    }

                    if (object.isSkinnedMesh && material.skinning === false) {

                        console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);

                    }

                    var useSkinning = object.isSkinnedMesh && material.skinning;

                    var variantIndex = 0;

                    if (useMorphing) variantIndex |= _MorphingFlag;
                    if (useSkinning) variantIndex |= _SkinningFlag;

                    result = materialVariants[variantIndex];

                } else {

                    result = customMaterial;

                }

                if (_renderer.localClippingEnabled &&
                    material.clipShadows === true &&
                    material.clippingPlanes.length !== 0) {

                    // in this case we need a unique material instance reflecting the
                    // appropriate state

                    var keyA = result.uuid, keyB = material.uuid;

                    var materialsForVariant = _materialCache[keyA];

                    if (materialsForVariant === undefined) {

                        materialsForVariant = {};
                        _materialCache[keyA] = materialsForVariant;

                    }

                    var cachedMaterial = materialsForVariant[keyB];

                    if (cachedMaterial === undefined) {

                        cachedMaterial = result.clone();
                        materialsForVariant[keyB] = cachedMaterial;

                    }

                    result = cachedMaterial;

                }

                result.visible = material.visible;
                result.wireframe = material.wireframe;

                var side = material.side;

                if (scope.renderSingleSided && side == DoubleSide) {

                    side = FrontSide;

                }

                if (scope.renderReverseSided) {

                    if (side === FrontSide) side = BackSide;
                    else if (side === BackSide) side = FrontSide;

                }

                result.side = side;

                result.clipShadows = material.clipShadows;
                result.clippingPlanes = material.clippingPlanes;
                result.clipIntersection = material.clipIntersection;

                result.wireframeLinewidth = material.wireframeLinewidth;
                result.linewidth = material.linewidth;

                if (isPointLight && result.isMeshDistanceMaterial) {

                    result.referencePosition.copy(lightPositionWorld);
                    result.nearDistance = shadowCameraNear;
                    result.farDistance = shadowCameraFar;

                }

                return result;

            }

            function renderObject(object, camera, shadowCamera, isPointLight) {

                if (object.visible === false) return;

                var visible = object.layers.test(camera.layers);

                if (visible && (object.isMesh || object.isLine || object.isPoints)) {

                    if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {

                        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

                        var geometry = _objects.update(object);
                        var material = object.material;

                        if (Array.isArray(material)) {

                            var groups = geometry.groups;

                            for (var k = 0, kl = groups.length; k < kl; k++) {

                                var group = groups[k];
                                var groupMaterial = material[group.materialIndex];

                                if (groupMaterial && groupMaterial.visible) {

                                    var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);

                                }

                            }

                        } else if (material.visible) {

                            var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);

                        }

                    }

                }

                var children = object.children;

                for (var i = 0, l = children.length; i < l; i++) {

                    renderObject(children[i], camera, shadowCamera, isPointLight);

                }

            }

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLAttributes(gl) {

            var buffers = {};

            function createBuffer(attribute, bufferType) {

                var array = attribute.array;
                var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

                var buffer = gl.createBuffer();

                gl.bindBuffer(bufferType, buffer);
                gl.bufferData(bufferType, array, usage);

                attribute.onUploadCallback();

                var type = gl.FLOAT;

                if (array instanceof Float32Array) {

                    type = gl.FLOAT;

                } else if (array instanceof Float64Array) {

                    console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');

                } else if (array instanceof Uint16Array) {

                    type = gl.UNSIGNED_SHORT;

                } else if (array instanceof Int16Array) {

                    type = gl.SHORT;

                } else if (array instanceof Uint32Array) {

                    type = gl.UNSIGNED_INT;

                } else if (array instanceof Int32Array) {

                    type = gl.INT;

                } else if (array instanceof Int8Array) {

                    type = gl.BYTE;

                } else if (array instanceof Uint8Array) {

                    type = gl.UNSIGNED_BYTE;

                }

                return {
                    buffer: buffer,
                    type: type,
                    bytesPerElement: array.BYTES_PER_ELEMENT,
                    version: attribute.version
                };

            }

            function updateBuffer(buffer, attribute, bufferType) {

                var array = attribute.array;
                var updateRange = attribute.updateRange;

                gl.bindBuffer(bufferType, buffer);

                if (attribute.dynamic === false) {

                    gl.bufferData(bufferType, array, gl.STATIC_DRAW);

                } else if (updateRange.count === -1) {

                    // Not using update ranges

                    gl.bufferSubData(bufferType, 0, array);

                } else if (updateRange.count === 0) {

                    console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');

                } else {

                    gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
                        array.subarray(updateRange.offset, updateRange.offset + updateRange.count));

                    updateRange.count = -1; // reset range

                }

            }

            //

            function get(attribute) {

                if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

                return buffers[attribute.uuid];

            }

            function remove(attribute) {

                if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

                var data = buffers[attribute.uuid];

                if (data) {

                    gl.deleteBuffer(data.buffer);

                    delete buffers[attribute.uuid];

                }

            }

            function update(attribute, bufferType) {

                if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

                var data = buffers[attribute.uuid];

                if (data === undefined) {

                    buffers[attribute.uuid] = createBuffer(attribute, bufferType);

                } else if (data.version < attribute.version) {

                    updateBuffer(data.buffer, attribute, bufferType);

                    data.version = attribute.version;

                }

            }

            return {

                get: get,
                remove: remove,
                update: update

            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author bhouston / http://clara.io
         */

        function Euler(x, y, z, order) {

            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._order = order || Euler.DefaultOrder;

        }

        Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

        Euler.DefaultOrder = 'XYZ';

        Object.defineProperties(Euler.prototype, {

            x: {

                get: function () {

                    return this._x;

                },

                set: function (value) {

                    this._x = value;
                    this.onChangeCallback();

                }

            },

            y: {

                get: function () {

                    return this._y;

                },

                set: function (value) {

                    this._y = value;
                    this.onChangeCallback();

                }

            },

            z: {

                get: function () {

                    return this._z;

                },

                set: function (value) {

                    this._z = value;
                    this.onChangeCallback();

                }

            },

            order: {

                get: function () {

                    return this._order;

                },

                set: function (value) {

                    this._order = value;
                    this.onChangeCallback();

                }

            }

        });

        Object.assign(Euler.prototype, {

            isEuler: true,

            set: function (x, y, z, order) {

                this._x = x;
                this._y = y;
                this._z = z;
                this._order = order || this._order;

                this.onChangeCallback();

                return this;

            },

            clone: function () {

                return new this.constructor(this._x, this._y, this._z, this._order);

            },

            copy: function (euler) {

                this._x = euler._x;
                this._y = euler._y;
                this._z = euler._z;
                this._order = euler._order;

                this.onChangeCallback();

                return this;

            },

            setFromRotationMatrix: function (m, order, update) {

                var clamp = _Math.clamp;

                // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

                var te = m.elements;
                var m11 = te[0], m12 = te[4], m13 = te[8];
                var m21 = te[1], m22 = te[5], m23 = te[9];
                var m31 = te[2], m32 = te[6], m33 = te[10];

                order = order || this._order;

                if (order === 'XYZ') {

                    this._y = Math.asin(clamp(m13, -1, 1));

                    if (Math.abs(m13) < 0.99999) {

                        this._x = Math.atan2(-m23, m33);
                        this._z = Math.atan2(-m12, m11);

                    } else {

                        this._x = Math.atan2(m32, m22);
                        this._z = 0;

                    }

                } else if (order === 'YXZ') {

                    this._x = Math.asin(-clamp(m23, -1, 1));

                    if (Math.abs(m23) < 0.99999) {

                        this._y = Math.atan2(m13, m33);
                        this._z = Math.atan2(m21, m22);

                    } else {

                        this._y = Math.atan2(-m31, m11);
                        this._z = 0;

                    }

                } else if (order === 'ZXY') {

                    this._x = Math.asin(clamp(m32, -1, 1));

                    if (Math.abs(m32) < 0.99999) {

                        this._y = Math.atan2(-m31, m33);
                        this._z = Math.atan2(-m12, m22);

                    } else {

                        this._y = 0;
                        this._z = Math.atan2(m21, m11);

                    }

                } else if (order === 'ZYX') {

                    this._y = Math.asin(-clamp(m31, -1, 1));

                    if (Math.abs(m31) < 0.99999) {

                        this._x = Math.atan2(m32, m33);
                        this._z = Math.atan2(m21, m11);

                    } else {

                        this._x = 0;
                        this._z = Math.atan2(-m12, m22);

                    }

                } else if (order === 'YZX') {

                    this._z = Math.asin(clamp(m21, -1, 1));

                    if (Math.abs(m21) < 0.99999) {

                        this._x = Math.atan2(-m23, m22);
                        this._y = Math.atan2(-m31, m11);

                    } else {

                        this._x = 0;
                        this._y = Math.atan2(m13, m33);

                    }

                } else if (order === 'XZY') {

                    this._z = Math.asin(-clamp(m12, -1, 1));

                    if (Math.abs(m12) < 0.99999) {

                        this._x = Math.atan2(m32, m22);
                        this._y = Math.atan2(m13, m11);

                    } else {

                        this._x = Math.atan2(-m23, m33);
                        this._y = 0;

                    }

                } else {

                    console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);

                }

                this._order = order;

                if (update !== false) this.onChangeCallback();

                return this;

            },

            setFromQuaternion: function () {

                var matrix = new Matrix4();

                return function setFromQuaternion(q, order, update) {

                    matrix.makeRotationFromQuaternion(q);

                    return this.setFromRotationMatrix(matrix, order, update);

                };

            }(),

            setFromVector3: function (v, order) {

                return this.set(v.x, v.y, v.z, order || this._order);

            },

            reorder: function () {

                // WARNING: this discards revolution information -bhouston

                var q = new Quaternion();

                return function reorder(newOrder) {

                    q.setFromEuler(this);

                    return this.setFromQuaternion(q, newOrder);

                };

            }(),

            equals: function (euler) {

                return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);

            },

            fromArray: function (array) {

                this._x = array[0];
                this._y = array[1];
                this._z = array[2];
                if (array[3] !== undefined) this._order = array[3];

                this.onChangeCallback();

                return this;

            },

            toArray: function (array, offset) {

                if (array === undefined) array = [];
                if (offset === undefined) offset = 0;

                array[offset] = this._x;
                array[offset + 1] = this._y;
                array[offset + 2] = this._z;
                array[offset + 3] = this._order;

                return array;

            },

            toVector3: function (optionalResult) {

                if (optionalResult) {

                    return optionalResult.set(this._x, this._y, this._z);

                } else {

                    return new Vector3(this._x, this._y, this._z);

                }

            },

            onChange: function (callback) {

                this.onChangeCallback = callback;

                return this;

            },

            onChangeCallback: function () {
            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function Layers() {

            this.mask = 1 | 0;

        }

        Object.assign(Layers.prototype, {

            set: function (channel) {

                this.mask = 1 << channel | 0;

            },

            enable: function (channel) {

                this.mask |= 1 << channel | 0;

            },

            toggle: function (channel) {

                this.mask ^= 1 << channel | 0;

            },

            disable: function (channel) {

                this.mask &= ~(1 << channel | 0);

            },

            test: function (layers) {

                return (this.mask & layers.mask) !== 0;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         * @author WestLangley / http://github.com/WestLangley
         * @author elephantatwork / www.elephantatwork.ch
         */

        var object3DId = 0;

        function Object3D() {

            Object.defineProperty(this, 'id', {value: object3DId++});

            this.uuid = _Math.generateUUID();

            this.name = '';
            this.type = 'Object3D';

            this.parent = null;
            this.children = [];

            this.up = Object3D.DefaultUp.clone();

            var position = new Vector3();
            var rotation = new Euler();
            var quaternion = new Quaternion();
            var scale = new Vector3(1, 1, 1);

            function onRotationChange() {

                quaternion.setFromEuler(rotation, false);

            }

            function onQuaternionChange() {

                rotation.setFromQuaternion(quaternion, undefined, false);

            }

            rotation.onChange(onRotationChange);
            quaternion.onChange(onQuaternionChange);

            Object.defineProperties(this, {
                position: {
                    enumerable: true,
                    value: position
                },
                rotation: {
                    enumerable: true,
                    value: rotation
                },
                quaternion: {
                    enumerable: true,
                    value: quaternion
                },
                scale: {
                    enumerable: true,
                    value: scale
                },
                modelViewMatrix: {
                    value: new Matrix4()
                },
                normalMatrix: {
                    value: new Matrix3()
                }
            });

            this.matrix = new Matrix4();
            this.matrixWorld = new Matrix4();

            this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
            this.matrixWorldNeedsUpdate = false;

            this.layers = new Layers();
            this.visible = true;

            this.castShadow = false;
            this.receiveShadow = false;

            this.frustumCulled = true;
            this.renderOrder = 0;

            this.userData = {};

        }

        Object3D.DefaultUp = new Vector3(0, 1, 0);
        Object3D.DefaultMatrixAutoUpdate = true;

        Object.assign(Object3D.prototype, EventDispatcher.prototype, {

            isObject3D: true,

            onBeforeRender: function () {
            },
            onAfterRender: function () {
            },

            applyMatrix: function (matrix) {

                this.matrix.multiplyMatrices(matrix, this.matrix);

                this.matrix.decompose(this.position, this.quaternion, this.scale);

            },

            applyQuaternion: function (q) {

                this.quaternion.premultiply(q);

                return this;

            },

            setRotationFromAxisAngle: function (axis, angle) {

                // assumes axis is normalized

                this.quaternion.setFromAxisAngle(axis, angle);

            },

            setRotationFromEuler: function (euler) {

                this.quaternion.setFromEuler(euler, true);

            },

            setRotationFromMatrix: function (m) {

                // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

                this.quaternion.setFromRotationMatrix(m);

            },

            setRotationFromQuaternion: function (q) {

                // assumes q is normalized

                this.quaternion.copy(q);

            },

            rotateOnAxis: function () {

                // rotate object on axis in object space
                // axis is assumed to be normalized

                var q1 = new Quaternion();

                return function rotateOnAxis(axis, angle) {

                    q1.setFromAxisAngle(axis, angle);

                    this.quaternion.multiply(q1);

                    return this;

                };

            }(),

            rotateOnWorldAxis: function () {

                // rotate object on axis in world space
                // axis is assumed to be normalized
                // method assumes no rotated parent

                var q1 = new Quaternion();

                return function rotateOnWorldAxis(axis, angle) {

                    q1.setFromAxisAngle(axis, angle);

                    this.quaternion.premultiply(q1);

                    return this;

                };

            }(),

            rotateX: function () {

                var v1 = new Vector3(1, 0, 0);

                return function rotateX(angle) {

                    return this.rotateOnAxis(v1, angle);

                };

            }(),

            rotateY: function () {

                var v1 = new Vector3(0, 1, 0);

                return function rotateY(angle) {

                    return this.rotateOnAxis(v1, angle);

                };

            }(),

            rotateZ: function () {

                var v1 = new Vector3(0, 0, 1);

                return function rotateZ(angle) {

                    return this.rotateOnAxis(v1, angle);

                };

            }(),

            translateOnAxis: function () {

                // translate object by distance along axis in object space
                // axis is assumed to be normalized

                var v1 = new Vector3();

                return function translateOnAxis(axis, distance) {

                    v1.copy(axis).applyQuaternion(this.quaternion);

                    this.position.add(v1.multiplyScalar(distance));

                    return this;

                };

            }(),

            translateX: function () {

                var v1 = new Vector3(1, 0, 0);

                return function translateX(distance) {

                    return this.translateOnAxis(v1, distance);

                };

            }(),

            translateY: function () {

                var v1 = new Vector3(0, 1, 0);

                return function translateY(distance) {

                    return this.translateOnAxis(v1, distance);

                };

            }(),

            translateZ: function () {

                var v1 = new Vector3(0, 0, 1);

                return function translateZ(distance) {

                    return this.translateOnAxis(v1, distance);

                };

            }(),

            localToWorld: function (vector) {

                return vector.applyMatrix4(this.matrixWorld);

            },

            worldToLocal: function () {

                var m1 = new Matrix4();

                return function worldToLocal(vector) {

                    return vector.applyMatrix4(m1.getInverse(this.matrixWorld));

                };

            }(),

            lookAt: function () {

                // This method does not support objects with rotated and/or translated parent(s)

                var m1 = new Matrix4();
                var vector = new Vector3();

                return function lookAt(x, y, z) {

                    if (x.isVector3) {

                        vector.copy(x);

                    } else {

                        vector.set(x, y, z);

                    }

                    if (this.isCamera) {

                        m1.lookAt(this.position, vector, this.up);

                    } else {

                        m1.lookAt(vector, this.position, this.up);

                    }

                    this.quaternion.setFromRotationMatrix(m1);

                };

            }(),

            add: function (object) {

                //object.matrixAutoUpdate = false;

                if (object && object.parent == this) {
                    return this;
                }

                if (arguments.length > 1) {

                    for (var i = 0; i < arguments.length; i++) {

                        this.add(arguments[i]);

                    }

                    return this;

                }

                if (object === this) {

                    console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                    return this;

                }

                if ((object && object.isObject3D)) {

                    if (object.parent !== null) {

                        object.parent.remove(object);

                    }

                    object.parent = this;
                    object.dispatchEvent({type: 'added'});

                    this.children.push(object);

                } else {

                    console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);

                }

                return this;

            },

            remove: function (object) {

                if (arguments.length > 1) {

                    for (var i = 0; i < arguments.length; i++) {

                        this.remove(arguments[i]);

                    }

                    return this;

                }

                var index = this.children.indexOf(object);

                if (index !== -1) {

                    object.parent = null;

                    object.dispatchEvent({type: 'removed'});

                    this.children.splice(index, 1);

                }

                return this;

            },

            getObjectById: function (id) {

                return this.getObjectByProperty('id', id);

            },

            getObjectByName: function (name) {

                return this.getObjectByProperty('name', name);

            },

            getObjectByProperty: function (name, value) {

                if (this[name] === value) return this;

                for (var i = 0, l = this.children.length; i < l; i++) {

                    var child = this.children[i];
                    var object = child.getObjectByProperty(name, value);

                    if (object !== undefined) {

                        return object;

                    }

                }

                return undefined;

            },

            getWorldPosition: function (optionalTarget) {

                var result = optionalTarget || new Vector3();

                this.updateMatrixWorld(true);

                return result.setFromMatrixPosition(this.matrixWorld);

            },

            getWorldQuaternion: function () {

                var position = new Vector3();
                var scale = new Vector3();

                return function getWorldQuaternion(optionalTarget) {

                    var result = optionalTarget || new Quaternion();

                    this.updateMatrixWorld(true);

                    this.matrixWorld.decompose(position, result, scale);

                    return result;

                };

            }(),

            getWorldRotation: function () {

                var quaternion = new Quaternion();

                return function getWorldRotation(optionalTarget) {

                    var result = optionalTarget || new Euler();

                    this.getWorldQuaternion(quaternion);

                    return result.setFromQuaternion(quaternion, this.rotation.order, false);

                };

            }(),

            getWorldScale: function () {

                var position = new Vector3();
                var quaternion = new Quaternion();

                return function getWorldScale(optionalTarget) {

                    var result = optionalTarget || new Vector3();

                    this.updateMatrixWorld(true);

                    this.matrixWorld.decompose(position, quaternion, result);

                    return result;

                };

            }(),

            getWorldDirection: function () {

                var quaternion = new Quaternion();

                return function getWorldDirection(optionalTarget) {

                    var result = optionalTarget || new Vector3();

                    this.getWorldQuaternion(quaternion);

                    return result.set(0, 0, 1).applyQuaternion(quaternion);

                };

            }(),

            raycast: function () {
            },

            traverse: function (callback) {

                callback(this);

                var children = this.children;

                for (var i = 0, l = children.length; i < l; i++) {

                    children[i].traverse(callback);

                }

            },

            traverseVisible: function (callback) {

                if (this.visible === false) return;

                callback(this);

                var children = this.children;

                for (var i = 0, l = children.length; i < l; i++) {

                    children[i].traverseVisible(callback);

                }

            },

            traverseAncestors: function (callback) {

                var parent = this.parent;

                if (parent !== null) {

                    callback(parent);

                    parent.traverseAncestors(callback);

                }

            },

            updateMatrix: function () {

                this.matrix.compose(this.position, this.quaternion, this.scale);

                this.matrixWorldNeedsUpdate = true;

            },

            updateMatrixWorld: function (force) {

                if (this.matrixAutoUpdate) this.updateMatrix();

                if (this.matrixWorldNeedsUpdate || force) {

                    if (this.parent === null) {

                        this.matrixWorld.copy(this.matrix);

                    } else {

                        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);

                    }

                    this.matrixWorldNeedsUpdate = false;

                    force = true;

                }

                // update children

                var children = this.children;

                for (var i = 0, l = children.length; i < l; i++) {

                    children[i].updateMatrixWorld(force);

                }

            },

            toJSON: function (meta) {

                // meta is a string when called from JSON.stringify
                var isRootObject = (meta === undefined || typeof meta === 'string');

                var output = {};

                // meta is a hash used to collect geometries, materials.
                // not providing it implies that this is the root object
                // being serialized.
                if (isRootObject) {

                    // initialize meta obj
                    meta = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {}
                    };

                    output.metadata = {
                        version: 4.5,
                        type: 'Object',
                        generator: 'Object3D.toJSON'
                    };

                }

                // standard Object3D serialization

                var object = {};

                object.uuid = this.uuid;
                object.type = this.type;

                if (this.name !== '') object.name = this.name;
                if (this.castShadow === true) object.castShadow = true;
                if (this.receiveShadow === true) object.receiveShadow = true;
                if (this.visible === false) object.visible = false;
                if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;

                object.matrix = this.matrix.toArray();

                //

                function serialize(library, element) {

                    if (library[element.uuid] === undefined) {

                        library[element.uuid] = element.toJSON(meta);

                    }

                    return element.uuid;

                }

                if (this.geometry !== undefined) {

                    object.geometry = serialize(meta.geometries, this.geometry);

                }

                if (this.material !== undefined) {

                    if (Array.isArray(this.material)) {

                        var uuids = [];

                        for (var i = 0, l = this.material.length; i < l; i++) {

                            uuids.push(serialize(meta.materials, this.material[i]));

                        }

                        object.material = uuids;

                    } else {

                        object.material = serialize(meta.materials, this.material);

                    }

                }

                //

                if (this.children.length > 0) {

                    object.children = [];

                    for (var i = 0; i < this.children.length; i++) {

                        object.children.push(this.children[i].toJSON(meta).object);

                    }

                }

                if (isRootObject) {

                    var geometries = extractFromCache(meta.geometries);
                    var materials = extractFromCache(meta.materials);
                    var textures = extractFromCache(meta.textures);
                    var images = extractFromCache(meta.images);

                    if (geometries.length > 0) output.geometries = geometries;
                    if (materials.length > 0) output.materials = materials;
                    if (textures.length > 0) output.textures = textures;
                    if (images.length > 0) output.images = images;

                }

                output.object = object;

                return output;

                // extract data from the cache hash
                // remove metadata on each item
                // and return as array
                function extractFromCache(cache) {

                    var values = [];
                    for (var key in cache) {

                        var data = cache[key];
                        delete data.metadata;
                        values.push(data);

                    }
                    return values;

                }

            },

            clone: function (recursive) {

                return new this.constructor().copy(this, recursive);

            },

            copy: function (source, recursive) {

                if (recursive === undefined) recursive = true;

                this.name = source.name;

                this.up.copy(source.up);

                this.position.copy(source.position);
                this.quaternion.copy(source.quaternion);
                this.scale.copy(source.scale);

                this.matrix.copy(source.matrix);
                this.matrixWorld.copy(source.matrixWorld);

                this.matrixAutoUpdate = source.matrixAutoUpdate;
                this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

                this.layers.mask = source.layers.mask;
                this.visible = source.visible;

                this.castShadow = source.castShadow;
                this.receiveShadow = source.receiveShadow;

                this.frustumCulled = source.frustumCulled;
                this.renderOrder = source.renderOrder;

                this.userData = JSON.parse(JSON.stringify(source.userData));

                if (recursive === true) {

                    for (var i = 0; i < source.children.length; i++) {

                        var child = source.children[i];
                        this.add(child.clone());

                    }

                }

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author mikael emtinger / http://gomo.se/
         * @author WestLangley / http://github.com/WestLangley
         */

        function Camera() {

            Object3D.call(this);

            this.type = 'Camera';

            this.matrixWorldInverse = new Matrix4();
            this.projectionMatrix = new Matrix4();

        }

        Camera.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Camera,

            isCamera: true,

            copy: function (source, recursive) {

                Object3D.prototype.copy.call(this, source, recursive);

                this.matrixWorldInverse.copy(source.matrixWorldInverse);
                this.projectionMatrix.copy(source.projectionMatrix);

                return this;

            },

            getWorldDirection: function () {

                var quaternion = new Quaternion();

                return function getWorldDirection(optionalTarget) {

                    var result = optionalTarget || new Vector3();

                    this.getWorldQuaternion(quaternion);

                    return result.set(0, 0, -1).applyQuaternion(quaternion);

                };

            }(),

            updateMatrixWorld: function (force) {

                Object3D.prototype.updateMatrixWorld.call(this, force);

                this.matrixWorldInverse.getInverse(this.matrixWorld);

            },

            clone: function () {

                return new this.constructor().copy(this);

            }

        });

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author arose / http://github.com/arose
         */

        function OrthographicCamera(left, right, top, bottom, near, far) {

            Camera.call(this);

            this.type = 'OrthographicCamera';

            this.zoom = 1;
            this.view = null;

            this.left = left;
            this.right = right;
            this.top = top;
            this.bottom = bottom;

            this.near = (near !== undefined) ? near : 0.1;
            this.far = (far !== undefined) ? far : 2000;

            this.updateProjectionMatrix();

        }

        OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {

            constructor: OrthographicCamera,

            isOrthographicCamera: true,

            copy: function (source, recursive) {

                Camera.prototype.copy.call(this, source, recursive);

                this.left = source.left;
                this.right = source.right;
                this.top = source.top;
                this.bottom = source.bottom;
                this.near = source.near;
                this.far = source.far;

                this.zoom = source.zoom;
                this.view = source.view === null ? null : Object.assign({}, source.view);

                return this;

            },

            setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {

                if (this.view === null) {

                    this.view = {
                        enabled: true,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    };

                }

                this.view.enabled = true;
                this.view.fullWidth = fullWidth;
                this.view.fullHeight = fullHeight;
                this.view.offsetX = x;
                this.view.offsetY = y;
                this.view.width = width;
                this.view.height = height;

                this.updateProjectionMatrix();

            },

            clearViewOffset: function () {

                if (this.view !== null) {

                    this.view.enabled = false;

                }

                this.updateProjectionMatrix();

            },

            updateProjectionMatrix: function () {

                var dx = (this.right - this.left) / (2 * this.zoom);
                var dy = (this.top - this.bottom) / (2 * this.zoom);
                var cx = (this.right + this.left) / 2;
                var cy = (this.top + this.bottom) / 2;

                var left = cx - dx;
                var right = cx + dx;
                var top = cy + dy;
                var bottom = cy - dy;

                if (this.view !== null && this.view.enabled) {

                    var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
                    var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
                    var scaleW = (this.right - this.left) / this.view.width;
                    var scaleH = (this.top - this.bottom) / this.view.height;

                    left += scaleW * (this.view.offsetX / zoomW);
                    right = left + scaleW * (this.view.width / zoomW);
                    top -= scaleH * (this.view.offsetY / zoomH);
                    bottom = top - scaleH * (this.view.height / zoomH);

                }

                this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);

            },

            toJSON: function (meta) {

                var data = Object3D.prototype.toJSON.call(this, meta);

                data.object.zoom = this.zoom;
                data.object.left = this.left;
                data.object.right = this.right;
                data.object.top = this.top;
                data.object.bottom = this.bottom;
                data.object.near = this.near;
                data.object.far = this.far;

                if (this.view !== null) data.object.view = Object.assign({}, this.view);

                return data;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        function Face3(a, b, c, normal, color, materialIndex) {

            this.a = a;
            this.b = b;
            this.c = c;

            this.normal = (normal && normal.isVector3) ? normal : new Vector3();
            this.vertexNormals = Array.isArray(normal) ? normal : [];

            this.color = (color && color.isColor) ? color : new Color();
            this.vertexColors = Array.isArray(color) ? color : [];

            this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

        }

        Object.assign(Face3.prototype, {

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (source) {

                this.a = source.a;
                this.b = source.b;
                this.c = source.c;

                this.normal.copy(source.normal);
                this.color.copy(source.color);

                this.materialIndex = source.materialIndex;

                for (var i = 0, il = source.vertexNormals.length; i < il; i++) {

                    this.vertexNormals[i] = source.vertexNormals[i].clone();

                }

                for (var i = 0, il = source.vertexColors.length; i < il; i++) {

                    this.vertexColors[i] = source.vertexColors[i].clone();

                }

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author kile / http://kile.stravaganza.org/
         * @author alteredq / http://alteredqualia.com/
         * @author mikael emtinger / http://gomo.se/
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * @author bhouston / http://clara.io
         */

        var geometryId = 0; // Geometry uses even numbers as Id

        function Geometry() {

            Object.defineProperty(this, 'id', {value: geometryId += 2});

            this.uuid = _Math.generateUUID();

            this.name = '';
            this.type = 'Geometry';

            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];

            this.morphTargets = [];
            this.morphNormals = [];

            this.skinWeights = [];
            this.skinIndices = [];

            this.lineDistances = [];

            this.boundingBox = null;
            this.boundingSphere = null;

            // update flags

            this.elementsNeedUpdate = false;
            this.verticesNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.lineDistancesNeedUpdate = false;
            this.groupsNeedUpdate = false;

        }

        Object.assign(Geometry.prototype, EventDispatcher.prototype, {

            isGeometry: true,

            applyMatrix: function (matrix) {

                var normalMatrix = new Matrix3().getNormalMatrix(matrix);

                for (var i = 0, il = this.vertices.length; i < il; i++) {

                    var vertex = this.vertices[i];
                    vertex.applyMatrix4(matrix);

                }

                for (var i = 0, il = this.faces.length; i < il; i++) {

                    var face = this.faces[i];
                    face.normal.applyMatrix3(normalMatrix).normalize();

                    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {

                        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();

                    }

                }

                if (this.boundingBox !== null) {

                    this.computeBoundingBox();

                }

                if (this.boundingSphere !== null) {

                    this.computeBoundingSphere();

                }

                this.verticesNeedUpdate = true;
                this.normalsNeedUpdate = true;

                return this;

            },

            rotateX: function () {

                // rotate geometry around world x-axis

                var m1 = new Matrix4();

                return function rotateX(angle) {

                    m1.makeRotationX(angle);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            rotateY: function () {

                // rotate geometry around world y-axis

                var m1 = new Matrix4();

                return function rotateY(angle) {

                    m1.makeRotationY(angle);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            rotateZ: function () {

                // rotate geometry around world z-axis

                var m1 = new Matrix4();

                return function rotateZ(angle) {

                    m1.makeRotationZ(angle);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            translate: function () {

                // translate geometry

                var m1 = new Matrix4();

                return function translate(x, y, z) {

                    m1.makeTranslation(x, y, z);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            scale: function () {

                // scale geometry

                var m1 = new Matrix4();

                return function scale(x, y, z) {

                    m1.makeScale(x, y, z);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            lookAt: function () {

                var obj = new Object3D();

                return function lookAt(vector) {

                    obj.lookAt(vector);

                    obj.updateMatrix();

                    this.applyMatrix(obj.matrix);

                };

            }(),

            fromBufferGeometry: function (geometry) {

                var scope = this;

                var indices = geometry.index !== null ? geometry.index.array : undefined;
                var attributes = geometry.attributes;

                var positions = attributes.position.array;
                var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
                var colors = attributes.color !== undefined ? attributes.color.array : undefined;
                var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
                var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

                if (uvs2 !== undefined) this.faceVertexUvs[1] = [];

                var tempNormals = [];
                var tempUVs = [];
                var tempUVs2 = [];

                for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {

                    scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));

                    if (normals !== undefined) {

                        tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));

                    }

                    if (colors !== undefined) {

                        scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));

                    }

                    if (uvs !== undefined) {

                        tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));

                    }

                    if (uvs2 !== undefined) {

                        tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));

                    }

                }

                function addFace(a, b, c, materialIndex) {

                    var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
                    var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];

                    var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);

                    scope.faces.push(face);

                    if (uvs !== undefined) {

                        scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);

                    }

                    if (uvs2 !== undefined) {

                        scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);

                    }

                }

                var groups = geometry.groups;

                if (groups.length > 0) {

                    for (var i = 0; i < groups.length; i++) {

                        var group = groups[i];

                        var start = group.start;
                        var count = group.count;

                        for (var j = start, jl = start + count; j < jl; j += 3) {

                            if (indices !== undefined) {

                                addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);

                            } else {

                                addFace(j, j + 1, j + 2, group.materialIndex);

                            }

                        }

                    }

                } else {

                    if (indices !== undefined) {

                        for (var i = 0; i < indices.length; i += 3) {

                            addFace(indices[i], indices[i + 1], indices[i + 2]);

                        }

                    } else {

                        for (var i = 0; i < positions.length / 3; i += 3) {

                            addFace(i, i + 1, i + 2);

                        }

                    }

                }

                this.computeFaceNormals();

                if (geometry.boundingBox !== null) {

                    this.boundingBox = geometry.boundingBox.clone();

                }

                if (geometry.boundingSphere !== null) {

                    this.boundingSphere = geometry.boundingSphere.clone();

                }

                return this;

            },

            center: function () {

                this.computeBoundingBox();

                var offset = this.boundingBox.getCenter().negate();

                this.translate(offset.x, offset.y, offset.z);

                return offset;

            },

            normalize: function () {

                this.computeBoundingSphere();

                var center = this.boundingSphere.center;
                var radius = this.boundingSphere.radius;

                var s = radius === 0 ? 1 : 1.0 / radius;

                var matrix = new Matrix4();
                matrix.set(
                    s, 0, 0, -s * center.x,
                    0, s, 0, -s * center.y,
                    0, 0, s, -s * center.z,
                    0, 0, 0, 1
                );

                this.applyMatrix(matrix);

                return this;

            },

            computeFaceNormals: function () {

                var cb = new Vector3(), ab = new Vector3();

                for (var f = 0, fl = this.faces.length; f < fl; f++) {

                    var face = this.faces[f];

                    var vA = this.vertices[face.a];
                    var vB = this.vertices[face.b];
                    var vC = this.vertices[face.c];

                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.cross(ab);

                    cb.normalize();

                    face.normal.copy(cb);

                }

            },

            computeVertexNormals: function (areaWeighted) {

                if (areaWeighted === undefined) areaWeighted = true;

                var v, vl, f, fl, face, vertices;

                vertices = new Array(this.vertices.length);

                for (v = 0, vl = this.vertices.length; v < vl; v++) {

                    vertices[v] = new Vector3();

                }

                if (areaWeighted) {

                    // vertex normals weighted by triangle areas
                    // http://www.iquilezles.org/www/articles/normals/normals.htm

                    var vA, vB, vC;
                    var cb = new Vector3(), ab = new Vector3();

                    for (f = 0, fl = this.faces.length; f < fl; f++) {

                        face = this.faces[f];

                        vA = this.vertices[face.a];
                        vB = this.vertices[face.b];
                        vC = this.vertices[face.c];

                        cb.subVectors(vC, vB);
                        ab.subVectors(vA, vB);
                        cb.cross(ab);

                        vertices[face.a].add(cb);
                        vertices[face.b].add(cb);
                        vertices[face.c].add(cb);

                    }

                } else {

                    this.computeFaceNormals();

                    for (f = 0, fl = this.faces.length; f < fl; f++) {

                        face = this.faces[f];

                        vertices[face.a].add(face.normal);
                        vertices[face.b].add(face.normal);
                        vertices[face.c].add(face.normal);

                    }

                }

                for (v = 0, vl = this.vertices.length; v < vl; v++) {

                    vertices[v].normalize();

                }

                for (f = 0, fl = this.faces.length; f < fl; f++) {

                    face = this.faces[f];

                    var vertexNormals = face.vertexNormals;

                    if (vertexNormals.length === 3) {

                        vertexNormals[0].copy(vertices[face.a]);
                        vertexNormals[1].copy(vertices[face.b]);
                        vertexNormals[2].copy(vertices[face.c]);

                    } else {

                        vertexNormals[0] = vertices[face.a].clone();
                        vertexNormals[1] = vertices[face.b].clone();
                        vertexNormals[2] = vertices[face.c].clone();

                    }

                }

                if (this.faces.length > 0) {

                    this.normalsNeedUpdate = true;

                }

            },

            computeFlatVertexNormals: function () {

                var f, fl, face;

                this.computeFaceNormals();

                for (f = 0, fl = this.faces.length; f < fl; f++) {

                    face = this.faces[f];

                    var vertexNormals = face.vertexNormals;

                    if (vertexNormals.length === 3) {

                        vertexNormals[0].copy(face.normal);
                        vertexNormals[1].copy(face.normal);
                        vertexNormals[2].copy(face.normal);

                    } else {

                        vertexNormals[0] = face.normal.clone();
                        vertexNormals[1] = face.normal.clone();
                        vertexNormals[2] = face.normal.clone();

                    }

                }

                if (this.faces.length > 0) {

                    this.normalsNeedUpdate = true;

                }

            },

            computeMorphNormals: function () {

                var i, il, f, fl, face;

                // save original normals
                // - create temp variables on first access
                //   otherwise just copy (for faster repeated calls)

                for (f = 0, fl = this.faces.length; f < fl; f++) {

                    face = this.faces[f];

                    if (!face.__originalFaceNormal) {

                        face.__originalFaceNormal = face.normal.clone();

                    } else {

                        face.__originalFaceNormal.copy(face.normal);

                    }

                    if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

                    for (i = 0, il = face.vertexNormals.length; i < il; i++) {

                        if (!face.__originalVertexNormals[i]) {

                            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();

                        } else {

                            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);

                        }

                    }

                }

                // use temp geometry to compute face and vertex normals for each morph

                var tmpGeo = new Geometry();
                tmpGeo.faces = this.faces;

                for (i = 0, il = this.morphTargets.length; i < il; i++) {

                    // create on first access

                    if (!this.morphNormals[i]) {

                        this.morphNormals[i] = {};
                        this.morphNormals[i].faceNormals = [];
                        this.morphNormals[i].vertexNormals = [];

                        var dstNormalsFace = this.morphNormals[i].faceNormals;
                        var dstNormalsVertex = this.morphNormals[i].vertexNormals;

                        var faceNormal, vertexNormals;

                        for (f = 0, fl = this.faces.length; f < fl; f++) {

                            faceNormal = new Vector3();
                            vertexNormals = {a: new Vector3(), b: new Vector3(), c: new Vector3()};

                            dstNormalsFace.push(faceNormal);
                            dstNormalsVertex.push(vertexNormals);

                        }

                    }

                    var morphNormals = this.morphNormals[i];

                    // set vertices to morph target

                    tmpGeo.vertices = this.morphTargets[i].vertices;

                    // compute morph normals

                    tmpGeo.computeFaceNormals();
                    tmpGeo.computeVertexNormals();

                    // store morph normals

                    var faceNormal, vertexNormals;

                    for (f = 0, fl = this.faces.length; f < fl; f++) {

                        face = this.faces[f];

                        faceNormal = morphNormals.faceNormals[f];
                        vertexNormals = morphNormals.vertexNormals[f];

                        faceNormal.copy(face.normal);

                        vertexNormals.a.copy(face.vertexNormals[0]);
                        vertexNormals.b.copy(face.vertexNormals[1]);
                        vertexNormals.c.copy(face.vertexNormals[2]);

                    }

                }

                // restore original normals

                for (f = 0, fl = this.faces.length; f < fl; f++) {

                    face = this.faces[f];

                    face.normal = face.__originalFaceNormal;
                    face.vertexNormals = face.__originalVertexNormals;

                }

            },

            computeLineDistances: function () {

                var d = 0;
                var vertices = this.vertices;

                for (var i = 0, il = vertices.length; i < il; i++) {

                    if (i > 0) {

                        d += vertices[i].distanceTo(vertices[i - 1]);

                    }

                    this.lineDistances[i] = d;

                }

            },

            computeBoundingBox: function () {

                if (this.boundingBox === null) {

                    this.boundingBox = new Box3();

                }

                this.boundingBox.setFromPoints(this.vertices);

            },

            computeBoundingSphere: function () {

                if (this.boundingSphere === null) {

                    this.boundingSphere = new Sphere();

                }

                this.boundingSphere.setFromPoints(this.vertices);

            },

            merge: function (geometry, matrix, materialIndexOffset) {

                if (!(geometry && geometry.isGeometry)) {

                    console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
                    return;

                }

                var normalMatrix,
                    vertexOffset = this.vertices.length,
                    vertices1 = this.vertices,
                    vertices2 = geometry.vertices,
                    faces1 = this.faces,
                    faces2 = geometry.faces,
                    uvs1 = this.faceVertexUvs[0],
                    uvs2 = geometry.faceVertexUvs[0],
                    colors1 = this.colors,
                    colors2 = geometry.colors;

                if (materialIndexOffset === undefined) materialIndexOffset = 0;

                if (matrix !== undefined) {

                    normalMatrix = new Matrix3().getNormalMatrix(matrix);

                }

                // vertices

                for (var i = 0, il = vertices2.length; i < il; i++) {

                    var vertex = vertices2[i];

                    var vertexCopy = vertex.clone();

                    if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);

                    vertices1.push(vertexCopy);

                }

                // colors

                for (var i = 0, il = colors2.length; i < il; i++) {

                    colors1.push(colors2[i].clone());

                }

                // faces

                for (i = 0, il = faces2.length; i < il; i++) {

                    var face = faces2[i], faceCopy, normal, color,
                        faceVertexNormals = face.vertexNormals,
                        faceVertexColors = face.vertexColors;

                    faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                    faceCopy.normal.copy(face.normal);

                    if (normalMatrix !== undefined) {

                        faceCopy.normal.applyMatrix3(normalMatrix).normalize();

                    }

                    for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {

                        normal = faceVertexNormals[j].clone();

                        if (normalMatrix !== undefined) {

                            normal.applyMatrix3(normalMatrix).normalize();

                        }

                        faceCopy.vertexNormals.push(normal);

                    }

                    faceCopy.color.copy(face.color);

                    for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {

                        color = faceVertexColors[j];
                        faceCopy.vertexColors.push(color.clone());

                    }

                    faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

                    faces1.push(faceCopy);

                }

                // uvs

                for (i = 0, il = uvs2.length; i < il; i++) {

                    var uv = uvs2[i], uvCopy = [];

                    if (uv === undefined) {

                        continue;

                    }

                    for (var j = 0, jl = uv.length; j < jl; j++) {

                        uvCopy.push(uv[j].clone());

                    }

                    uvs1.push(uvCopy);

                }

            },

            mergeMesh: function (mesh) {

                if (!(mesh && mesh.isMesh)) {

                    console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
                    return;

                }

                mesh.matrixAutoUpdate && mesh.updateMatrix();

                this.merge(mesh.geometry, mesh.matrix);

            },

            /*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

            mergeVertices: function () {

                var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
                var unique = [], changes = [];

                var v, key;
                var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
                var precision = Math.pow(10, precisionPoints);
                var i, il, face;
                var indices, j, jl;

                for (i = 0, il = this.vertices.length; i < il; i++) {

                    v = this.vertices[i];
                    key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

                    if (verticesMap[key] === undefined) {

                        verticesMap[key] = i;
                        unique.push(this.vertices[i]);
                        changes[i] = unique.length - 1;

                    } else {

                        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                        changes[i] = changes[verticesMap[key]];

                    }

                }


                // if faces are completely degenerate after merging vertices, we
                // have to remove them from the geometry.
                var faceIndicesToRemove = [];

                for (i = 0, il = this.faces.length; i < il; i++) {

                    face = this.faces[i];

                    face.a = changes[face.a];
                    face.b = changes[face.b];
                    face.c = changes[face.c];

                    indices = [face.a, face.b, face.c];

                    // if any duplicate vertices are found in a Face3
                    // we have to remove the face as nothing can be saved
                    for (var n = 0; n < 3; n++) {

                        if (indices[n] === indices[(n + 1) % 3]) {

                            faceIndicesToRemove.push(i);
                            break;

                        }

                    }

                }

                for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {

                    var idx = faceIndicesToRemove[i];

                    this.faces.splice(idx, 1);

                    for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {

                        this.faceVertexUvs[j].splice(idx, 1);

                    }

                }

                // Use unique set of vertices

                var diff = this.vertices.length - unique.length;
                this.vertices = unique;
                return diff;

            },

            setFromPoints: function (points) {

                this.vertices = [];

                for (var i = 0, l = points.length; i < l; i++) {

                    var point = points[i];
                    this.vertices.push(new Vector3(point.x, point.y, point.z || 0));

                }

                return this;

            },

            sortFacesByMaterialIndex: function () {

                var faces = this.faces;
                var length = faces.length;

                // tag faces

                for (var i = 0; i < length; i++) {

                    faces[i]._id = i;

                }

                // sort faces

                function materialIndexSort(a, b) {

                    return a.materialIndex - b.materialIndex;

                }

                faces.sort(materialIndexSort);

                // sort uvs

                var uvs1 = this.faceVertexUvs[0];
                var uvs2 = this.faceVertexUvs[1];

                var newUvs1, newUvs2;

                if (uvs1 && uvs1.length === length) newUvs1 = [];
                if (uvs2 && uvs2.length === length) newUvs2 = [];

                for (var i = 0; i < length; i++) {

                    var id = faces[i]._id;

                    if (newUvs1) newUvs1.push(uvs1[id]);
                    if (newUvs2) newUvs2.push(uvs2[id]);

                }

                if (newUvs1) this.faceVertexUvs[0] = newUvs1;
                if (newUvs2) this.faceVertexUvs[1] = newUvs2;

            },

            toJSON: function () {

                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'Geometry',
                        generator: 'Geometry.toJSON'
                    }
                };

                // standard Geometry serialization

                data.uuid = this.uuid;
                data.type = this.type;
                if (this.name !== '') data.name = this.name;

                if (this.parameters !== undefined) {

                    var parameters = this.parameters;

                    for (var key in parameters) {

                        if (parameters[key] !== undefined) data[key] = parameters[key];

                    }

                    return data;

                }

                var vertices = [];

                for (var i = 0; i < this.vertices.length; i++) {

                    var vertex = this.vertices[i];
                    vertices.push(vertex.x, vertex.y, vertex.z);

                }

                var faces = [];
                var normals = [];
                var normalsHash = {};
                var colors = [];
                var colorsHash = {};
                var uvs = [];
                var uvsHash = {};

                for (var i = 0; i < this.faces.length; i++) {

                    var face = this.faces[i];

                    var hasMaterial = true;
                    var hasFaceUv = false; // deprecated
                    var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                    var hasFaceNormal = face.normal.length() > 0;
                    var hasFaceVertexNormal = face.vertexNormals.length > 0;
                    var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                    var hasFaceVertexColor = face.vertexColors.length > 0;

                    var faceType = 0;

                    faceType = setBit(faceType, 0, 0); // isQuad
                    faceType = setBit(faceType, 1, hasMaterial);
                    faceType = setBit(faceType, 2, hasFaceUv);
                    faceType = setBit(faceType, 3, hasFaceVertexUv);
                    faceType = setBit(faceType, 4, hasFaceNormal);
                    faceType = setBit(faceType, 5, hasFaceVertexNormal);
                    faceType = setBit(faceType, 6, hasFaceColor);
                    faceType = setBit(faceType, 7, hasFaceVertexColor);

                    faces.push(faceType);
                    faces.push(face.a, face.b, face.c);
                    faces.push(face.materialIndex);

                    if (hasFaceVertexUv) {

                        var faceVertexUvs = this.faceVertexUvs[0][i];

                        faces.push(
                            getUvIndex(faceVertexUvs[0]),
                            getUvIndex(faceVertexUvs[1]),
                            getUvIndex(faceVertexUvs[2])
                        );

                    }

                    if (hasFaceNormal) {

                        faces.push(getNormalIndex(face.normal));

                    }

                    if (hasFaceVertexNormal) {

                        var vertexNormals = face.vertexNormals;

                        faces.push(
                            getNormalIndex(vertexNormals[0]),
                            getNormalIndex(vertexNormals[1]),
                            getNormalIndex(vertexNormals[2])
                        );

                    }

                    if (hasFaceColor) {

                        faces.push(getColorIndex(face.color));

                    }

                    if (hasFaceVertexColor) {

                        var vertexColors = face.vertexColors;

                        faces.push(
                            getColorIndex(vertexColors[0]),
                            getColorIndex(vertexColors[1]),
                            getColorIndex(vertexColors[2])
                        );

                    }

                }

                function setBit(value, position, enabled) {

                    return enabled ? value | (1 << position) : value & (~(1 << position));

                }

                function getNormalIndex(normal) {

                    var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

                    if (normalsHash[hash] !== undefined) {

                        return normalsHash[hash];

                    }

                    normalsHash[hash] = normals.length / 3;
                    normals.push(normal.x, normal.y, normal.z);

                    return normalsHash[hash];

                }

                function getColorIndex(color) {

                    var hash = color.r.toString() + color.g.toString() + color.b.toString();

                    if (colorsHash[hash] !== undefined) {

                        return colorsHash[hash];

                    }

                    colorsHash[hash] = colors.length;
                    colors.push(color.getHex());

                    return colorsHash[hash];

                }

                function getUvIndex(uv) {

                    var hash = uv.x.toString() + uv.y.toString();

                    if (uvsHash[hash] !== undefined) {

                        return uvsHash[hash];

                    }

                    uvsHash[hash] = uvs.length / 2;
                    uvs.push(uv.x, uv.y);

                    return uvsHash[hash];

                }

                data.data = {};

                data.data.vertices = vertices;
                data.data.normals = normals;
                if (colors.length > 0) data.data.colors = colors;
                if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility
                data.data.faces = faces;

                return data;

            },

            clone: function () {

                /*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

                return new Geometry().copy(this);

            },

            copy: function (source) {

                var i, il, j, jl, k, kl;

                // reset

                this.vertices = [];
                this.colors = [];
                this.faces = [];
                this.faceVertexUvs = [[]];
                this.morphTargets = [];
                this.morphNormals = [];
                this.skinWeights = [];
                this.skinIndices = [];
                this.lineDistances = [];
                this.boundingBox = null;
                this.boundingSphere = null;

                // name

                this.name = source.name;

                // vertices

                var vertices = source.vertices;

                for (i = 0, il = vertices.length; i < il; i++) {

                    this.vertices.push(vertices[i].clone());

                }

                // colors

                var colors = source.colors;

                for (i = 0, il = colors.length; i < il; i++) {

                    this.colors.push(colors[i].clone());

                }

                // faces

                var faces = source.faces;

                for (i = 0, il = faces.length; i < il; i++) {

                    this.faces.push(faces[i].clone());

                }

                // face vertex uvs

                for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {

                    var faceVertexUvs = source.faceVertexUvs[i];

                    if (this.faceVertexUvs[i] === undefined) {

                        this.faceVertexUvs[i] = [];

                    }

                    for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {

                        var uvs = faceVertexUvs[j], uvsCopy = [];

                        for (k = 0, kl = uvs.length; k < kl; k++) {

                            var uv = uvs[k];

                            uvsCopy.push(uv.clone());

                        }

                        this.faceVertexUvs[i].push(uvsCopy);

                    }

                }

                // morph targets

                var morphTargets = source.morphTargets;

                for (i = 0, il = morphTargets.length; i < il; i++) {

                    var morphTarget = {};
                    morphTarget.name = morphTargets[i].name;

                    // vertices

                    if (morphTargets[i].vertices !== undefined) {

                        morphTarget.vertices = [];

                        for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {

                            morphTarget.vertices.push(morphTargets[i].vertices[j].clone());

                        }

                    }

                    // normals

                    if (morphTargets[i].normals !== undefined) {

                        morphTarget.normals = [];

                        for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {

                            morphTarget.normals.push(morphTargets[i].normals[j].clone());

                        }

                    }

                    this.morphTargets.push(morphTarget);

                }

                // morph normals

                var morphNormals = source.morphNormals;

                for (i = 0, il = morphNormals.length; i < il; i++) {

                    var morphNormal = {};

                    // vertex normals

                    if (morphNormals[i].vertexNormals !== undefined) {

                        morphNormal.vertexNormals = [];

                        for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {

                            var srcVertexNormal = morphNormals[i].vertexNormals[j];
                            var destVertexNormal = {};

                            destVertexNormal.a = srcVertexNormal.a.clone();
                            destVertexNormal.b = srcVertexNormal.b.clone();
                            destVertexNormal.c = srcVertexNormal.c.clone();

                            morphNormal.vertexNormals.push(destVertexNormal);

                        }

                    }

                    // face normals

                    if (morphNormals[i].faceNormals !== undefined) {

                        morphNormal.faceNormals = [];

                        for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {

                            morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());

                        }

                    }

                    this.morphNormals.push(morphNormal);

                }

                // skin weights

                var skinWeights = source.skinWeights;

                for (i = 0, il = skinWeights.length; i < il; i++) {

                    this.skinWeights.push(skinWeights[i].clone());

                }

                // skin indices

                var skinIndices = source.skinIndices;

                for (i = 0, il = skinIndices.length; i < il; i++) {

                    this.skinIndices.push(skinIndices[i].clone());

                }

                // line distances

                var lineDistances = source.lineDistances;

                for (i = 0, il = lineDistances.length; i < il; i++) {

                    this.lineDistances.push(lineDistances[i]);

                }

                // bounding box

                var boundingBox = source.boundingBox;

                if (boundingBox !== null) {

                    this.boundingBox = boundingBox.clone();

                }

                // bounding sphere

                var boundingSphere = source.boundingSphere;

                if (boundingSphere !== null) {

                    this.boundingSphere = boundingSphere.clone();

                }

                // update flags

                this.elementsNeedUpdate = source.elementsNeedUpdate;
                this.verticesNeedUpdate = source.verticesNeedUpdate;
                this.uvsNeedUpdate = source.uvsNeedUpdate;
                this.normalsNeedUpdate = source.normalsNeedUpdate;
                this.colorsNeedUpdate = source.colorsNeedUpdate;
                this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
                this.groupsNeedUpdate = source.groupsNeedUpdate;

                return this;

            },

            dispose: function () {

                this.dispatchEvent({type: 'dispose'});

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function BufferAttribute(array, itemSize, normalized) {

            if (Array.isArray(array)) {

                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');

            }

            this.uuid = _Math.generateUUID();
            this.name = '';

            this.array = array;
            this.itemSize = itemSize;
            this.count = array !== undefined ? array.length / itemSize : 0;
            this.normalized = normalized === true;

            this.dynamic = false;
            this.updateRange = {offset: 0, count: -1};

            this.onUploadCallback = function () {
            };

            this.version = 0;

        }

        Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {

            set: function (value) {

                if (value === true) this.version++;

            }

        });

        Object.assign(BufferAttribute.prototype, {

            isBufferAttribute: true,

            setArray: function (array) {

                if (Array.isArray(array)) {

                    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');

                }

                this.count = array !== undefined ? array.length / this.itemSize : 0;
                this.array = array;

            },

            setDynamic: function (value) {

                this.dynamic = value;

                return this;

            },

            copy: function (source) {

                this.array = new source.array.constructor(source.array);
                this.itemSize = source.itemSize;
                this.count = source.count;
                this.normalized = source.normalized;

                this.dynamic = source.dynamic;

                return this;

            },

            copyAt: function (index1, attribute, index2) {

                index1 *= this.itemSize;
                index2 *= attribute.itemSize;

                for (var i = 0, l = this.itemSize; i < l; i++) {

                    this.array[index1 + i] = attribute.array[index2 + i];

                }

                return this;

            },

            copyArray: function (array) {

                this.array.set(array);

                return this;

            },

            copyColorsArray: function (colors) {

                var array = this.array, offset = 0;

                for (var i = 0, l = colors.length; i < l; i++) {

                    var color = colors[i];

                    if (color === undefined) {

                        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                        color = new Color();

                    }

                    array[offset++] = color.r;
                    array[offset++] = color.g;
                    array[offset++] = color.b;

                }

                return this;

            },

            copyIndicesArray: function (indices) {

                var array = this.array, offset = 0;

                for (var i = 0, l = indices.length; i < l; i++) {

                    var index = indices[i];

                    array[offset++] = index.a;
                    array[offset++] = index.b;
                    array[offset++] = index.c;

                }

                return this;

            },

            copyVector2sArray: function (vectors) {

                var array = this.array, offset = 0;

                for (var i = 0, l = vectors.length; i < l; i++) {

                    var vector = vectors[i];

                    if (vector === undefined) {

                        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                        vector = new Vector2();

                    }

                    array[offset++] = vector.x;
                    array[offset++] = vector.y;

                }

                return this;

            },

            copyVector3sArray: function (vectors) {

                var array = this.array, offset = 0;

                for (var i = 0, l = vectors.length; i < l; i++) {

                    var vector = vectors[i];

                    if (vector === undefined) {

                        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                        vector = new Vector3();

                    }

                    array[offset++] = vector.x;
                    array[offset++] = vector.y;
                    array[offset++] = vector.z;

                }

                return this;

            },

            copyVector4sArray: function (vectors) {

                var array = this.array, offset = 0;

                for (var i = 0, l = vectors.length; i < l; i++) {

                    var vector = vectors[i];

                    if (vector === undefined) {

                        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                        vector = new Vector4();

                    }

                    array[offset++] = vector.x;
                    array[offset++] = vector.y;
                    array[offset++] = vector.z;
                    array[offset++] = vector.w;

                }

                return this;

            },

            set: function (value, offset) {

                if (offset === undefined) offset = 0;

                this.array.set(value, offset);

                return this;

            },

            getX: function (index) {

                return this.array[index * this.itemSize];

            },

            setX: function (index, x) {

                this.array[index * this.itemSize] = x;

                return this;

            },

            getY: function (index) {

                return this.array[index * this.itemSize + 1];

            },

            setY: function (index, y) {

                this.array[index * this.itemSize + 1] = y;

                return this;

            },

            getZ: function (index) {

                return this.array[index * this.itemSize + 2];

            },

            setZ: function (index, z) {

                this.array[index * this.itemSize + 2] = z;

                return this;

            },

            getW: function (index) {

                return this.array[index * this.itemSize + 3];

            },

            setW: function (index, w) {

                this.array[index * this.itemSize + 3] = w;

                return this;

            },

            setXY: function (index, x, y) {

                index *= this.itemSize;

                this.array[index + 0] = x;
                this.array[index + 1] = y;

                return this;

            },

            setXYZ: function (index, x, y, z) {

                index *= this.itemSize;

                this.array[index + 0] = x;
                this.array[index + 1] = y;
                this.array[index + 2] = z;

                return this;

            },

            setXYZW: function (index, x, y, z, w) {

                index *= this.itemSize;

                this.array[index + 0] = x;
                this.array[index + 1] = y;
                this.array[index + 2] = z;
                this.array[index + 3] = w;

                return this;

            },

            onUpload: function (callback) {

                this.onUploadCallback = callback;

                return this;

            },

            clone: function () {

                return new this.constructor(this.array, this.itemSize).copy(this);

            }

        });

        //

        function Int8BufferAttribute(array, itemSize, normalized) {

            BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);

        }

        Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


        function Uint8BufferAttribute(array, itemSize, normalized) {

            BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);

        }

        Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


        function Uint8ClampedBufferAttribute(array, itemSize, normalized) {

            BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);

        }

        Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


        function Int16BufferAttribute(array, itemSize, normalized) {

            BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);

        }

        Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


        function Uint16BufferAttribute(array, itemSize, normalized) {

            BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);

        }

        Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


        function Int32BufferAttribute(array, itemSize, normalized) {

            BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);

        }

        Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


        function Uint32BufferAttribute(array, itemSize, normalized) {

            BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);

        }

        Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


        function Float32BufferAttribute(array, itemSize, normalized) {

            BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);

        }

        Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


        function Float64BufferAttribute(array, itemSize, normalized) {

            BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);

        }

        Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
        Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function DirectGeometry() {

            this.indices = [];
            this.vertices = [];
            this.normals = [];
            this.colors = [];
            this.uvs = [];
            this.uvs2 = [];

            this.groups = [];

            this.morphTargets = {};

            this.skinWeights = [];
            this.skinIndices = [];

            // this.lineDistances = [];

            this.boundingBox = null;
            this.boundingSphere = null;

            // update flags

            this.verticesNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.groupsNeedUpdate = false;

        }

        Object.assign(DirectGeometry.prototype, {

            computeGroups: function (geometry) {

                var group;
                var groups = [];
                var materialIndex = undefined;

                var faces = geometry.faces;

                for (var i = 0; i < faces.length; i++) {

                    var face = faces[i];

                    // materials

                    if (face.materialIndex !== materialIndex) {

                        materialIndex = face.materialIndex;

                        if (group !== undefined) {

                            group.count = (i * 3) - group.start;
                            groups.push(group);

                        }

                        group = {
                            start: i * 3,
                            materialIndex: materialIndex
                        };

                    }

                }

                if (group !== undefined) {

                    group.count = (i * 3) - group.start;
                    groups.push(group);

                }

                this.groups = groups;

            },

            fromGeometry: function (geometry) {

                var faces = geometry.faces;
                var vertices = geometry.vertices;
                var faceVertexUvs = geometry.faceVertexUvs;

                var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
                var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;

                // morphs

                var morphTargets = geometry.morphTargets;
                var morphTargetsLength = morphTargets.length;

                var morphTargetsPosition;

                if (morphTargetsLength > 0) {

                    morphTargetsPosition = [];

                    for (var i = 0; i < morphTargetsLength; i++) {

                        morphTargetsPosition[i] = [];

                    }

                    this.morphTargets.position = morphTargetsPosition;

                }

                var morphNormals = geometry.morphNormals;
                var morphNormalsLength = morphNormals.length;

                var morphTargetsNormal;

                if (morphNormalsLength > 0) {

                    morphTargetsNormal = [];

                    for (var i = 0; i < morphNormalsLength; i++) {

                        morphTargetsNormal[i] = [];

                    }

                    this.morphTargets.normal = morphTargetsNormal;

                }

                // skins

                var skinIndices = geometry.skinIndices;
                var skinWeights = geometry.skinWeights;

                var hasSkinIndices = skinIndices.length === vertices.length;
                var hasSkinWeights = skinWeights.length === vertices.length;

                //

                for (var i = 0; i < faces.length; i++) {

                    var face = faces[i];

                    this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);

                    var vertexNormals = face.vertexNormals;

                    if (vertexNormals.length === 3) {

                        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);

                    } else {

                        var normal = face.normal;

                        this.normals.push(normal, normal, normal);

                    }

                    var vertexColors = face.vertexColors;

                    if (vertexColors.length === 3) {

                        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);

                    } else {

                        var color = face.color;

                        this.colors.push(color, color, color);

                    }

                    if (hasFaceVertexUv === true) {

                        var vertexUvs = faceVertexUvs[0][i];

                        if (vertexUvs !== undefined) {

                            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);

                        } else {

                            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);

                            this.uvs.push(new Vector2(), new Vector2(), new Vector2());

                        }

                    }

                    if (hasFaceVertexUv2 === true) {

                        var vertexUvs = faceVertexUvs[1][i];

                        if (vertexUvs !== undefined) {

                            this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);

                        } else {

                            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);

                            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());

                        }

                    }

                    // morphs

                    for (var j = 0; j < morphTargetsLength; j++) {

                        var morphTarget = morphTargets[j].vertices;

                        morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);

                    }

                    for (var j = 0; j < morphNormalsLength; j++) {

                        var morphNormal = morphNormals[j].vertexNormals[i];

                        morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);

                    }

                    // skins

                    if (hasSkinIndices) {

                        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);

                    }

                    if (hasSkinWeights) {

                        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);

                    }

                }

                this.computeGroups(geometry);

                this.verticesNeedUpdate = geometry.verticesNeedUpdate;
                this.normalsNeedUpdate = geometry.normalsNeedUpdate;
                this.colorsNeedUpdate = geometry.colorsNeedUpdate;
                this.uvsNeedUpdate = geometry.uvsNeedUpdate;
                this.groupsNeedUpdate = geometry.groupsNeedUpdate;

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function arrayMax(array) {

            if (array.length === 0) return -Infinity;

            var max = array[0];

            for (var i = 1, l = array.length; i < l; ++i) {

                if (array[i] > max) max = array[i];

            }

            return max;

        }

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         */

        var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

        function BufferGeometry() {

            Object.defineProperty(this, 'id', {value: bufferGeometryId += 2});

            this.uuid = _Math.generateUUID();

            this.name = '';
            this.type = 'BufferGeometry';

            this.index = null;
            this.attributes = {};

            this.morphAttributes = {};

            this.groups = [];

            this.boundingBox = null;
            this.boundingSphere = null;

            this.drawRange = {start: 0, count: Infinity};

        }

        Object.assign(BufferGeometry.prototype, EventDispatcher.prototype, {

            isBufferGeometry: true,

            getIndex: function () {

                return this.index;

            },

            setIndex: function (index) {

                if (Array.isArray(index)) {

                    this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);

                } else {

                    this.index = index;

                }

            },

            addAttribute: function (name, attribute) {

                if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {

                    console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');

                    this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));

                    return;

                }

                if (name === 'index') {

                    console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
                    this.setIndex(attribute);

                    return;

                }

                this.attributes[name] = attribute;

                return this;

            },

            getAttribute: function (name) {

                return this.attributes[name];

            },

            removeAttribute: function (name) {

                delete this.attributes[name];

                return this;

            },

            addGroup: function (start, count, materialIndex) {

                this.groups.push({

                    start: start,
                    count: count,
                    materialIndex: materialIndex !== undefined ? materialIndex : 0

                });

            },

            clearGroups: function () {

                this.groups = [];

            },

            setDrawRange: function (start, count) {

                this.drawRange.start = start;
                this.drawRange.count = count;

            },

            applyMatrix: function (matrix) {

                var position = this.attributes.position;

                if (position !== undefined) {

                    matrix.applyToBufferAttribute(position);
                    position.needsUpdate = true;

                }

                var normal = this.attributes.normal;

                if (normal !== undefined) {

                    var normalMatrix = new Matrix3().getNormalMatrix(matrix);

                    normalMatrix.applyToBufferAttribute(normal);
                    normal.needsUpdate = true;

                }

                if (this.boundingBox !== null) {

                    this.computeBoundingBox();

                }

                if (this.boundingSphere !== null) {

                    this.computeBoundingSphere();

                }

                return this;

            },

            rotateX: function () {

                // rotate geometry around world x-axis

                var m1 = new Matrix4();

                return function rotateX(angle) {

                    m1.makeRotationX(angle);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            rotateY: function () {

                // rotate geometry around world y-axis

                var m1 = new Matrix4();

                return function rotateY(angle) {

                    m1.makeRotationY(angle);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            rotateZ: function () {

                // rotate geometry around world z-axis

                var m1 = new Matrix4();

                return function rotateZ(angle) {

                    m1.makeRotationZ(angle);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            translate: function () {

                // translate geometry

                var m1 = new Matrix4();

                return function translate(x, y, z) {

                    m1.makeTranslation(x, y, z);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            scale: function () {

                // scale geometry

                var m1 = new Matrix4();

                return function scale(x, y, z) {

                    m1.makeScale(x, y, z);

                    this.applyMatrix(m1);

                    return this;

                };

            }(),

            lookAt: function () {

                var obj = new Object3D();

                return function lookAt(vector) {

                    obj.lookAt(vector);

                    obj.updateMatrix();

                    this.applyMatrix(obj.matrix);

                };

            }(),

            center: function () {

                this.computeBoundingBox();

                var offset = this.boundingBox.getCenter().negate();

                this.translate(offset.x, offset.y, offset.z);

                return offset;

            },

            setFromObject: function (object) {

                // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

                var geometry = object.geometry;

                if (object.isPoints || object.isLine) {

                    var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
                    var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);

                    this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
                    this.addAttribute('color', colors.copyColorsArray(geometry.colors));

                    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {

                        var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);

                        this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));

                    }

                    if (geometry.boundingSphere !== null) {

                        this.boundingSphere = geometry.boundingSphere.clone();

                    }

                    if (geometry.boundingBox !== null) {

                        this.boundingBox = geometry.boundingBox.clone();

                    }

                } else if (object.isMesh) {

                    if (geometry && geometry.isGeometry) {

                        this.fromGeometry(geometry);

                    }

                }

                return this;

            },

            setFromPoints: function (points) {

                var position = [];

                for (var i = 0, l = points.length; i < l; i++) {

                    var point = points[i];
                    position.push(point.x, point.y, point.z || 0);

                }

                this.addAttribute('position', new Float32BufferAttribute(position, 3));

                return this;

            },

            updateFromObject: function (object) {

                var geometry = object.geometry;

                if (object.isMesh) {

                    var direct = geometry.__directGeometry;

                    if (geometry.elementsNeedUpdate === true) {

                        direct = undefined;
                        geometry.elementsNeedUpdate = false;

                    }

                    if (direct === undefined) {

                        return this.fromGeometry(geometry);

                    }

                    direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                    direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                    direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                    direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                    direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

                    geometry.verticesNeedUpdate = false;
                    geometry.normalsNeedUpdate = false;
                    geometry.colorsNeedUpdate = false;
                    geometry.uvsNeedUpdate = false;
                    geometry.groupsNeedUpdate = false;

                    geometry = direct;

                }

                var attribute;

                if (geometry.verticesNeedUpdate === true) {

                    attribute = this.attributes.position;

                    if (attribute !== undefined) {

                        attribute.copyVector3sArray(geometry.vertices);
                        attribute.needsUpdate = true;

                    }

                    geometry.verticesNeedUpdate = false;

                }

                if (geometry.normalsNeedUpdate === true) {

                    attribute = this.attributes.normal;

                    if (attribute !== undefined) {

                        attribute.copyVector3sArray(geometry.normals);
                        attribute.needsUpdate = true;

                    }

                    geometry.normalsNeedUpdate = false;

                }

                if (geometry.colorsNeedUpdate === true) {

                    attribute = this.attributes.color;

                    if (attribute !== undefined) {

                        attribute.copyColorsArray(geometry.colors);
                        attribute.needsUpdate = true;

                    }

                    geometry.colorsNeedUpdate = false;

                }

                if (geometry.uvsNeedUpdate) {

                    attribute = this.attributes.uv;

                    if (attribute !== undefined) {

                        attribute.copyVector2sArray(geometry.uvs);
                        attribute.needsUpdate = true;

                    }

                    geometry.uvsNeedUpdate = false;

                }

                if (geometry.lineDistancesNeedUpdate) {

                    attribute = this.attributes.lineDistance;

                    if (attribute !== undefined) {

                        attribute.copyArray(geometry.lineDistances);
                        attribute.needsUpdate = true;

                    }

                    geometry.lineDistancesNeedUpdate = false;

                }

                if (geometry.groupsNeedUpdate) {

                    geometry.computeGroups(object.geometry);
                    this.groups = geometry.groups;

                    geometry.groupsNeedUpdate = false;

                }

                return this;

            },

            fromGeometry: function (geometry) {

                geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);

                return this.fromDirectGeometry(geometry.__directGeometry);

            },

            fromDirectGeometry: function (geometry) {

                var positions = new Float32Array(geometry.vertices.length * 3);
                this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

                if (geometry.normals.length > 0) {

                    var normals = new Float32Array(geometry.normals.length * 3);
                    this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));

                }

                if (geometry.colors.length > 0) {

                    var colors = new Float32Array(geometry.colors.length * 3);
                    this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));

                }

                if (geometry.uvs.length > 0) {

                    var uvs = new Float32Array(geometry.uvs.length * 2);
                    this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));

                }

                if (geometry.uvs2.length > 0) {

                    var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                    this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));

                }

                if (geometry.indices.length > 0) {

                    var TypeArray = arrayMax(geometry.indices) > 65535 ? Uint32Array : Uint16Array;
                    var indices = new TypeArray(geometry.indices.length * 3);
                    this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));

                }

                // groups

                this.groups = geometry.groups;

                // morphs

                for (var name in geometry.morphTargets) {

                    var array = [];
                    var morphTargets = geometry.morphTargets[name];

                    for (var i = 0, l = morphTargets.length; i < l; i++) {

                        var morphTarget = morphTargets[i];

                        var attribute = new Float32BufferAttribute(morphTarget.length * 3, 3);

                        array.push(attribute.copyVector3sArray(morphTarget));

                    }

                    this.morphAttributes[name] = array;

                }

                // skinning

                if (geometry.skinIndices.length > 0) {

                    var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
                    this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));

                }

                if (geometry.skinWeights.length > 0) {

                    var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
                    this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));

                }

                //

                if (geometry.boundingSphere !== null) {

                    this.boundingSphere = geometry.boundingSphere.clone();

                }

                if (geometry.boundingBox !== null) {

                    this.boundingBox = geometry.boundingBox.clone();

                }

                return this;

            },

            computeBoundingBox: function () {

                if (this.boundingBox === null) {

                    this.boundingBox = new Box3();

                }

                var position = this.attributes.position;

                if (position !== undefined) {

                    this.boundingBox.setFromBufferAttribute(position);

                } else {

                    this.boundingBox.makeEmpty();

                }

                if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {

                    console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);

                }

            },

            computeBoundingSphere: function () {

                var box = new Box3();
                var vector = new Vector3();

                return function computeBoundingSphere() {

                    if (this.boundingSphere === null) {

                        this.boundingSphere = new Sphere();

                    }

                    var position = this.attributes.position;

                    if (position) {

                        var center = this.boundingSphere.center;

                        box.setFromBufferAttribute(position);
                        box.getCenter(center);

                        // hoping to find a boundingSphere with a radius smaller than the
                        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

                        var maxRadiusSq = 0;

                        for (var i = 0, il = position.count; i < il; i++) {

                            vector.x = position.getX(i);
                            vector.y = position.getY(i);
                            vector.z = position.getZ(i);
                            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));

                        }

                        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

                        if (isNaN(this.boundingSphere.radius)) {

                            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);

                        }

                    }

                };

            }(),

            computeFaceNormals: function () {

                // backwards compatibility

            },

            computeVertexNormals: function () {

                var index = this.index;
                var attributes = this.attributes;
                var groups = this.groups;

                if (attributes.position) {

                    var positions = attributes.position.array;

                    if (attributes.normal === undefined) {

                        this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));

                    } else {

                        // reset existing normals to zero

                        var array = attributes.normal.array;

                        for (var i = 0, il = array.length; i < il; i++) {

                            array[i] = 0;

                        }

                    }

                    var normals = attributes.normal.array;

                    var vA, vB, vC;
                    var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
                    var cb = new Vector3(), ab = new Vector3();

                    // indexed elements

                    if (index) {

                        var indices = index.array;

                        if (groups.length === 0) {

                            this.addGroup(0, indices.length);

                        }

                        for (var j = 0, jl = groups.length; j < jl; ++j) {

                            var group = groups[j];

                            var start = group.start;
                            var count = group.count;

                            for (var i = start, il = start + count; i < il; i += 3) {

                                vA = indices[i + 0] * 3;
                                vB = indices[i + 1] * 3;
                                vC = indices[i + 2] * 3;

                                pA.fromArray(positions, vA);
                                pB.fromArray(positions, vB);
                                pC.fromArray(positions, vC);

                                cb.subVectors(pC, pB);
                                ab.subVectors(pA, pB);
                                cb.cross(ab);

                                normals[vA] += cb.x;
                                normals[vA + 1] += cb.y;
                                normals[vA + 2] += cb.z;

                                normals[vB] += cb.x;
                                normals[vB + 1] += cb.y;
                                normals[vB + 2] += cb.z;

                                normals[vC] += cb.x;
                                normals[vC + 1] += cb.y;
                                normals[vC + 2] += cb.z;

                            }

                        }

                    } else {

                        // non-indexed elements (unconnected triangle soup)

                        for (var i = 0, il = positions.length; i < il; i += 9) {

                            pA.fromArray(positions, i);
                            pB.fromArray(positions, i + 3);
                            pC.fromArray(positions, i + 6);

                            cb.subVectors(pC, pB);
                            ab.subVectors(pA, pB);
                            cb.cross(ab);

                            normals[i] = cb.x;
                            normals[i + 1] = cb.y;
                            normals[i + 2] = cb.z;

                            normals[i + 3] = cb.x;
                            normals[i + 4] = cb.y;
                            normals[i + 5] = cb.z;

                            normals[i + 6] = cb.x;
                            normals[i + 7] = cb.y;
                            normals[i + 8] = cb.z;

                        }

                    }

                    this.normalizeNormals();

                    attributes.normal.needsUpdate = true;

                }

            },

            merge: function (geometry, offset) {

                if (!(geometry && geometry.isBufferGeometry)) {

                    console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
                    return;

                }

                if (offset === undefined) offset = 0;

                var attributes = this.attributes;

                for (var key in attributes) {

                    if (geometry.attributes[key] === undefined) continue;

                    var attribute1 = attributes[key];
                    var attributeArray1 = attribute1.array;

                    var attribute2 = geometry.attributes[key];
                    var attributeArray2 = attribute2.array;

                    var attributeSize = attribute2.itemSize;

                    for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {

                        attributeArray1[j] = attributeArray2[i];

                    }

                }

                return this;

            },

            normalizeNormals: function () {

                var vector = new Vector3();

                return function normalizeNormals() {

                    var normals = this.attributes.normal;

                    for (var i = 0, il = normals.count; i < il; i++) {

                        vector.x = normals.getX(i);
                        vector.y = normals.getY(i);
                        vector.z = normals.getZ(i);

                        vector.normalize();

                        normals.setXYZ(i, vector.x, vector.y, vector.z);

                    }

                };

            }(),

            toNonIndexed: function () {

                if (this.index === null) {

                    console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
                    return this;

                }

                var geometry2 = new BufferGeometry();

                var indices = this.index.array;
                var attributes = this.attributes;

                for (var name in attributes) {

                    var attribute = attributes[name];

                    var array = attribute.array;
                    var itemSize = attribute.itemSize;

                    var array2 = new array.constructor(indices.length * itemSize);

                    var index = 0, index2 = 0;

                    for (var i = 0, l = indices.length; i < l; i++) {

                        index = indices[i] * itemSize;

                        for (var j = 0; j < itemSize; j++) {

                            array2[index2++] = array[index++];

                        }

                    }

                    geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));

                }

                return geometry2;

            },

            toJSON: function () {

                var data = {
                    metadata: {
                        version: 4.5,
                        type: 'BufferGeometry',
                        generator: 'BufferGeometry.toJSON'
                    }
                };

                // standard BufferGeometry serialization

                data.uuid = this.uuid;
                data.type = this.type;
                if (this.name !== '') data.name = this.name;

                if (this.parameters !== undefined) {

                    var parameters = this.parameters;

                    for (var key in parameters) {

                        if (parameters[key] !== undefined) data[key] = parameters[key];

                    }

                    return data;

                }

                data.data = {attributes: {}};

                var index = this.index;

                if (index !== null) {

                    var array = Array.prototype.slice.call(index.array);

                    data.data.index = {
                        type: index.array.constructor.name,
                        array: array
                    };

                }

                var attributes = this.attributes;

                for (var key in attributes) {

                    var attribute = attributes[key];

                    var array = Array.prototype.slice.call(attribute.array);

                    data.data.attributes[key] = {
                        itemSize: attribute.itemSize,
                        type: attribute.array.constructor.name,
                        array: array,
                        normalized: attribute.normalized
                    };

                }

                var groups = this.groups;

                if (groups.length > 0) {

                    data.data.groups = JSON.parse(JSON.stringify(groups));

                }

                var boundingSphere = this.boundingSphere;

                if (boundingSphere !== null) {

                    data.data.boundingSphere = {
                        center: boundingSphere.center.toArray(),
                        radius: boundingSphere.radius
                    };

                }

                return data;

            },

            clone: function () {

                /*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

                return new BufferGeometry().copy(this);

            },

            copy: function (source) {

                var name, i, l;

                // reset

                this.index = null;
                this.attributes = {};
                this.morphAttributes = {};
                this.groups = [];
                this.boundingBox = null;
                this.boundingSphere = null;

                // name

                this.name = source.name;

                // index

                var index = source.index;

                if (index !== null) {

                    this.setIndex(index.clone());

                }

                // attributes

                var attributes = source.attributes;

                for (name in attributes) {

                    var attribute = attributes[name];
                    this.addAttribute(name, attribute.clone());

                }

                // morph attributes

                var morphAttributes = source.morphAttributes;

                for (name in morphAttributes) {

                    var array = [];
                    var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

                    for (i = 0, l = morphAttribute.length; i < l; i++) {

                        array.push(morphAttribute[i].clone());

                    }

                    this.morphAttributes[name] = array;

                }

                // groups

                var groups = source.groups;

                for (i = 0, l = groups.length; i < l; i++) {

                    var group = groups[i];
                    this.addGroup(group.start, group.count, group.materialIndex);

                }

                // bounding box

                var boundingBox = source.boundingBox;

                if (boundingBox !== null) {

                    this.boundingBox = boundingBox.clone();

                }

                // bounding sphere

                var boundingSphere = source.boundingSphere;

                if (boundingSphere !== null) {

                    this.boundingSphere = boundingSphere.clone();

                }

                // draw range

                this.drawRange.start = source.drawRange.start;
                this.drawRange.count = source.drawRange.count;

                return this;

            },

            dispose: function () {

                this.dispatchEvent({type: 'dispose'});

            }

        });


        /**
         * @author jonobr1 / http://jonobr1.com
         * @author Mugen87 / https://github.com/Mugen87
         */

        // ShapeGeometry

        function ShapeGeometry(shapes, curveSegments) {

            Geometry.call(this);

            this.type = 'ShapeGeometry';

            if (typeof curveSegments === 'object') {

                console.warn('THREE.ShapeGeometry: Options parameter has been removed.');

                curveSegments = curveSegments.curveSegments;

            }

            this.parameters = {
                shapes: shapes,
                curveSegments: curveSegments
            };

            this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
            this.mergeVertices();

        }

        ShapeGeometry.prototype = Object.create(Geometry.prototype);
        ShapeGeometry.prototype.constructor = ShapeGeometry;

        // ShapeBufferGeometry

        function ShapeBufferGeometry(shapes, curveSegments) {

            BufferGeometry.call(this);

            this.type = 'ShapeBufferGeometry';

            this.parameters = {
                shapes: shapes,
                curveSegments: curveSegments
            };

            curveSegments = curveSegments || 12;

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var groupStart = 0;
            var groupCount = 0;

            // allow single and array values for "shapes" parameter

            if (Array.isArray(shapes) === false) {

                addShape(shapes);

            } else {

                for (var i = 0; i < shapes.length; i++) {

                    addShape(shapes[i]);

                    this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

                    groupStart += groupCount;
                    groupCount = 0;

                }

            }

            // build geometry

            this.setIndex(indices);
            this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));


            // helper functions

            function addShape(shape) {

                var i, l, shapeHole;

                var indexOffset = vertices.length / 3;
                var points = shape.extractPoints(curveSegments);

                var shapeVertices = points.shape;
                var shapeHoles = points.holes;

                // check direction of vertices

                if (ShapeUtils.isClockWise(shapeVertices) === false) {

                    shapeVertices = shapeVertices.reverse();

                    // also check if holes are in the opposite direction

                    for (i = 0, l = shapeHoles.length; i < l; i++) {

                        shapeHole = shapeHoles[i];

                        if (ShapeUtils.isClockWise(shapeHole) === true) {

                            shapeHoles[i] = shapeHole.reverse();

                        }

                    }

                }

                var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

                // join vertices of inner and outer paths to a single array

                for (i = 0, l = shapeHoles.length; i < l; i++) {

                    shapeHole = shapeHoles[i];
                    shapeVertices = shapeVertices.concat(shapeHole);

                }

                // vertices, normals, uvs

                for (i = 0, l = shapeVertices.length; i < l; i++) {

                    var vertex = shapeVertices[i];

                    vertices.push(vertex.x, vertex.y, 0);
                    normals.push(0, 0, 1);
                    uvs.push(vertex.x, vertex.y); // world uvs

                }

                // incides

                for (i = 0, l = faces.length; i < l; i++) {

                    var face = faces[i];

                    var a = face[0] + indexOffset;
                    var b = face[1] + indexOffset;
                    var c = face[2] + indexOffset;

                    indices.push(a, b, c);
                    groupCount += 3;

                }

            }

        }

        ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author Mugen87 / https://github.com/Mugen87
         */

        // BoxGeometry

        function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {

            Geometry.call(this);

            this.type = 'BoxGeometry';

            this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };

            this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
            this.mergeVertices();

        }

        BoxGeometry.prototype = Object.create(Geometry.prototype);
        BoxGeometry.prototype.constructor = BoxGeometry;

        // BoxBufferGeometry

        function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {

            BufferGeometry.call(this);

            this.type = 'BoxBufferGeometry';

            this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };

            var scope = this;

            width = width || 1;
            height = height || 1;
            depth = depth || 1;

            // segments

            widthSegments = Math.floor(widthSegments) || 1;
            heightSegments = Math.floor(heightSegments) || 1;
            depthSegments = Math.floor(depthSegments) || 1;

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var numberOfVertices = 0;
            var groupStart = 0;

            // build each side of the box geometry

            buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
            buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
            buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
            buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
            buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
            buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

            // build geometry

            this.setIndex(indices);
            this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {

                var segmentWidth = width / gridX;
                var segmentHeight = height / gridY;

                var widthHalf = width / 2;
                var heightHalf = height / 2;
                var depthHalf = depth / 2;

                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;

                var vertexCounter = 0;
                var groupCount = 0;

                var ix, iy;

                var vector = new Vector3();

                // generate vertices, normals and uvs

                for (iy = 0; iy < gridY1; iy++) {

                    var y = iy * segmentHeight - heightHalf;

                    for (ix = 0; ix < gridX1; ix++) {

                        var x = ix * segmentWidth - widthHalf;

                        // set values to correct vector component

                        vector[u] = x * udir;
                        vector[v] = y * vdir;
                        vector[w] = depthHalf;

                        // now apply vector to vertex buffer

                        vertices.push(vector.x, vector.y, vector.z);

                        // set values to correct vector component

                        vector[u] = 0;
                        vector[v] = 0;
                        vector[w] = depth > 0 ? 1 : -1;

                        // now apply vector to normal buffer

                        normals.push(vector.x, vector.y, vector.z);

                        // uvs

                        uvs.push(ix / gridX);
                        uvs.push(1 - (iy / gridY));

                        // counters

                        vertexCounter += 1;

                    }

                }

                // indices

                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment

                for (iy = 0; iy < gridY; iy++) {

                    for (ix = 0; ix < gridX; ix++) {

                        var a = numberOfVertices + ix + gridX1 * iy;
                        var b = numberOfVertices + ix + gridX1 * (iy + 1);
                        var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                        var d = numberOfVertices + (ix + 1) + gridX1 * iy;

                        // faces

                        indices.push(a, b, d);
                        indices.push(b, c, d);

                        // increase counter

                        groupCount += 6;

                    }

                }

                // add a group to the geometry. this will ensure multi material support

                scope.addGroup(groupStart, groupCount, materialIndex);

                // calculate new start value for groups

                groupStart += groupCount;

                // update total number of vertices

                numberOfVertices += vertexCounter;

            }

        }

        BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author Mugen87 / https://github.com/Mugen87
         */

        // PlaneGeometry

        function PlaneGeometry(width, height, widthSegments, heightSegments) {

            Geometry.call(this);

            this.type = 'PlaneGeometry';

            this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };

            this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
            this.mergeVertices();

        }

        PlaneGeometry.prototype = Object.create(Geometry.prototype);
        PlaneGeometry.prototype.constructor = PlaneGeometry;

        // PlaneBufferGeometry

        function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {

            BufferGeometry.call(this);

            this.type = 'PlaneBufferGeometry';

            this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };

            width = width || 1;
            height = height || 1;

            var width_half = width / 2;
            var height_half = height / 2;

            var gridX = Math.floor(widthSegments) || 1;
            var gridY = Math.floor(heightSegments) || 1;

            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;

            var segment_width = width / gridX;
            var segment_height = height / gridY;

            var ix, iy;

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // generate vertices, normals and uvs

            for (iy = 0; iy < gridY1; iy++) {

                var y = iy * segment_height - height_half;

                for (ix = 0; ix < gridX1; ix++) {

                    var x = ix * segment_width - width_half;

                    vertices.push(x, -y, 0);

                    normals.push(0, 0, 1);

                    uvs.push(ix / gridX);
                    uvs.push(1 - (iy / gridY));

                }

            }

            // indices

            for (iy = 0; iy < gridY; iy++) {

                for (ix = 0; ix < gridX; ix++) {

                    var a = ix + gridX1 * iy;
                    var b = ix + gridX1 * (iy + 1);
                    var c = (ix + 1) + gridX1 * (iy + 1);
                    var d = (ix + 1) + gridX1 * iy;

                    // faces

                    indices.push(a, b, d);
                    indices.push(b, c, d);

                }

            }

            // build geometry

            this.setIndex(indices);
            this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        }

        PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
         */

        function MeshBasicMaterial(parameters) {

            Material.call(this);

            this.type = 'MeshBasicMaterial';

            this.color = new Color(0xffffff); // emissive

            this.map = null;

            this.lightMap = null;
            this.lightMapIntensity = 1.0;

            this.aoMap = null;
            this.aoMapIntensity = 1.0;

            this.specularMap = null;

            this.alphaMap = null;

            this.envMap = null;
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;

            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';

            this.skinning = false;
            this.morphTargets = false;

            this.lights = false;

            this.setValues(parameters);

        }

        MeshBasicMaterial.prototype = Object.create(Material.prototype);
        MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

        MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

        MeshBasicMaterial.prototype.copy = function (source) {

            Material.prototype.copy.call(this, source);

            this.color.copy(source.color);

            this.map = source.map;

            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;

            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;

            this.specularMap = source.specularMap;

            this.alphaMap = source.alphaMap;

            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;

            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;

            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;

            return this;

        };

        /**
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
         */

        function ShaderMaterial(parameters) {

            Material.call(this);

            this.type = 'ShaderMaterial';

            this.defines = {};
            this.uniforms = {};

            this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
            this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

            this.linewidth = 1;

            this.wireframe = false;
            this.wireframeLinewidth = 1;

            this.fog = false; // set to use scene fog
            this.lights = false; // set to use scene lights
            this.clipping = false; // set to use user-defined clipping planes

            this.skinning = false; // set to use skinning attribute streams
            this.morphTargets = false; // set to use morph targets
            this.morphNormals = false; // set to use morph normals

            this.extensions = {
                derivatives: false, // set to use derivatives
                fragDepth: false, // set to use fragment depth values
                drawBuffers: false, // set to use draw buffers
                shaderTextureLOD: false // set to use shader texture LOD
            };

            // When rendered geometry doesn't include these attributes but the material does,
            // use these default values in WebGL. This avoids errors when buffer data is missing.
            this.defaultAttributeValues = {
                'color': [1, 1, 1],
                'uv': [0, 0],
                'uv2': [0, 0]
            };

            this.index0AttributeName = undefined;

            if (parameters !== undefined) {

                if (parameters.attributes !== undefined) {

                    console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');

                }

                this.setValues(parameters);

            }

        }

        ShaderMaterial.prototype = Object.create(Material.prototype);
        ShaderMaterial.prototype.constructor = ShaderMaterial;

        ShaderMaterial.prototype.isShaderMaterial = true;

        ShaderMaterial.prototype.copy = function (source) {

            Material.prototype.copy.call(this, source);

            this.fragmentShader = source.fragmentShader;
            this.vertexShader = source.vertexShader;

            this.uniforms = UniformsUtils.clone(source.uniforms);

            this.defines = source.defines;

            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;

            this.lights = source.lights;
            this.clipping = source.clipping;

            this.skinning = source.skinning;

            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;

            this.extensions = source.extensions;

            return this;

        };

        ShaderMaterial.prototype.toJSON = function (meta) {

            var data = Material.prototype.toJSON.call(this, meta);

            data.uniforms = this.uniforms;
            data.vertexShader = this.vertexShader;
            data.fragmentShader = this.fragmentShader;

            return data;

        };

        /**
         * @author bhouston / http://clara.io
         */

        function Ray(origin, direction) {

            this.origin = (origin !== undefined) ? origin : new Vector3();
            this.direction = (direction !== undefined) ? direction : new Vector3();

        }

        Object.assign(Ray.prototype, {

            set: function (origin, direction) {

                this.origin.copy(origin);
                this.direction.copy(direction);

                return this;

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (ray) {

                this.origin.copy(ray.origin);
                this.direction.copy(ray.direction);

                return this;

            },

            at: function (t, optionalTarget) {

                var result = optionalTarget || new Vector3();

                return result.copy(this.direction).multiplyScalar(t).add(this.origin);

            },

            lookAt: function (v) {

                this.direction.copy(v).sub(this.origin).normalize();

                return this;

            },

            recast: function () {

                var v1 = new Vector3();

                return function recast(t) {

                    this.origin.copy(this.at(t, v1));

                    return this;

                };

            }(),

            closestPointToPoint: function (point, optionalTarget) {

                var result = optionalTarget || new Vector3();
                result.subVectors(point, this.origin);
                var directionDistance = result.dot(this.direction);

                if (directionDistance < 0) {

                    return result.copy(this.origin);

                }

                return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

            },

            distanceToPoint: function (point) {

                return Math.sqrt(this.distanceSqToPoint(point));

            },

            distanceSqToPoint: function () {

                var v1 = new Vector3();

                return function distanceSqToPoint(point) {

                    var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);

                    // point behind the ray

                    if (directionDistance < 0) {

                        return this.origin.distanceToSquared(point);

                    }

                    v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

                    return v1.distanceToSquared(point);

                };

            }(),

            distanceSqToSegment: function () {

                var segCenter = new Vector3();
                var segDir = new Vector3();
                var diff = new Vector3();

                return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {

                    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
                    // It returns the min distance between the ray and the segment
                    // defined by v0 and v1
                    // It can also set two optional targets :
                    // - The closest point on the ray
                    // - The closest point on the segment

                    segCenter.copy(v0).add(v1).multiplyScalar(0.5);
                    segDir.copy(v1).sub(v0).normalize();
                    diff.copy(this.origin).sub(segCenter);

                    var segExtent = v0.distanceTo(v1) * 0.5;
                    var a01 = -this.direction.dot(segDir);
                    var b0 = diff.dot(this.direction);
                    var b1 = -diff.dot(segDir);
                    var c = diff.lengthSq();
                    var det = Math.abs(1 - a01 * a01);
                    var s0, s1, sqrDist, extDet;

                    if (det > 0) {

                        // The ray and segment are not parallel.

                        s0 = a01 * b1 - b0;
                        s1 = a01 * b0 - b1;
                        extDet = segExtent * det;

                        if (s0 >= 0) {

                            if (s1 >= -extDet) {

                                if (s1 <= extDet) {

                                    // region 0
                                    // Minimum at interior points of ray and segment.

                                    var invDet = 1 / det;
                                    s0 *= invDet;
                                    s1 *= invDet;
                                    sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;

                                } else {

                                    // region 1

                                    s1 = segExtent;
                                    s0 = Math.max(0, -(a01 * s1 + b0));
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

                                }

                            } else {

                                // region 5

                                s1 = -segExtent;
                                s0 = Math.max(0, -(a01 * s1 + b0));
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

                            }

                        } else {

                            if (s1 <= -extDet) {

                                // region 4

                                s0 = Math.max(0, -(-a01 * segExtent + b0));
                                s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

                            } else if (s1 <= extDet) {

                                // region 3

                                s0 = 0;
                                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                                sqrDist = s1 * (s1 + 2 * b1) + c;

                            } else {

                                // region 2

                                s0 = Math.max(0, -(a01 * segExtent + b0));
                                s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

                            }

                        }

                    } else {

                        // Ray and segment are parallel.

                        s1 = (a01 > 0) ? -segExtent : segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;

                    }

                    if (optionalPointOnRay) {

                        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);

                    }

                    if (optionalPointOnSegment) {

                        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);

                    }

                    return sqrDist;

                };

            }(),

            intersectSphere: function () {

                var v1 = new Vector3();

                return function intersectSphere(sphere, optionalTarget) {

                    v1.subVectors(sphere.center, this.origin);
                    var tca = v1.dot(this.direction);
                    var d2 = v1.dot(v1) - tca * tca;
                    var radius2 = sphere.radius * sphere.radius;

                    if (d2 > radius2) return null;

                    var thc = Math.sqrt(radius2 - d2);

                    // t0 = first intersect point - entrance on front of sphere
                    var t0 = tca - thc;

                    // t1 = second intersect point - exit point on back of sphere
                    var t1 = tca + thc;

                    // test to see if both t0 and t1 are behind the ray - if so, return null
                    if (t0 < 0 && t1 < 0) return null;

                    // test to see if t0 is behind the ray:
                    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
                    // in order to always return an intersect point that is in front of the ray.
                    if (t0 < 0) return this.at(t1, optionalTarget);

                    // else t0 is in front of the ray, so return the first collision point scaled by t0
                    return this.at(t0, optionalTarget);

                };

            }(),

            intersectsSphere: function (sphere) {

                return this.distanceToPoint(sphere.center) <= sphere.radius;

            },

            distanceToPlane: function (plane) {

                var denominator = plane.normal.dot(this.direction);

                if (denominator === 0) {

                    // line is coplanar, return origin
                    if (plane.distanceToPoint(this.origin) === 0) {

                        return 0;

                    }

                    // Null is preferable to undefined since undefined means.... it is undefined

                    return null;

                }

                var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

                // Return if the ray never intersects the plane

                return t >= 0 ? t : null;

            },

            intersectPlane: function (plane, optionalTarget) {

                var t = this.distanceToPlane(plane);

                if (t === null) {

                    return null;

                }

                return this.at(t, optionalTarget);

            },

            intersectsPlane: function (plane) {

                // check if the ray lies on the plane first

                var distToPoint = plane.distanceToPoint(this.origin);

                if (distToPoint === 0) {

                    return true;

                }

                var denominator = plane.normal.dot(this.direction);

                if (denominator * distToPoint < 0) {

                    return true;

                }

                // ray origin is behind the plane (and is pointing behind it)

                return false;

            },

            intersectBox: function (box, optionalTarget) {

                var tmin, tmax, tymin, tymax, tzmin, tzmax;

                var invdirx = 1 / this.direction.x,
                    invdiry = 1 / this.direction.y,
                    invdirz = 1 / this.direction.z;

                var origin = this.origin;

                if (invdirx >= 0) {

                    tmin = (box.min.x - origin.x) * invdirx;
                    tmax = (box.max.x - origin.x) * invdirx;

                } else {

                    tmin = (box.max.x - origin.x) * invdirx;
                    tmax = (box.min.x - origin.x) * invdirx;

                }

                if (invdiry >= 0) {

                    tymin = (box.min.y - origin.y) * invdiry;
                    tymax = (box.max.y - origin.y) * invdiry;

                } else {

                    tymin = (box.max.y - origin.y) * invdiry;
                    tymax = (box.min.y - origin.y) * invdiry;

                }

                if ((tmin > tymax) || (tymin > tmax)) return null;

                // These lines also handle the case where tmin or tmax is NaN
                // (result of 0 * Infinity). x !== x returns true if x is NaN

                if (tymin > tmin || tmin !== tmin) tmin = tymin;

                if (tymax < tmax || tmax !== tmax) tmax = tymax;

                if (invdirz >= 0) {

                    tzmin = (box.min.z - origin.z) * invdirz;
                    tzmax = (box.max.z - origin.z) * invdirz;

                } else {

                    tzmin = (box.max.z - origin.z) * invdirz;
                    tzmax = (box.min.z - origin.z) * invdirz;

                }

                if ((tmin > tzmax) || (tzmin > tmax)) return null;

                if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

                if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

                //return point closest to the ray (positive side)

                if (tmax < 0) return null;

                return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);

            },

            intersectsBox: (function () {

                var v = new Vector3();

                return function intersectsBox(box) {

                    return this.intersectBox(box, v) !== null;

                };

            })(),

            intersectTriangle: function () {

                // Compute the offset origin, edges, and normal.
                var diff = new Vector3();
                var edge1 = new Vector3();
                var edge2 = new Vector3();
                var normal = new Vector3();

                return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {

                    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

                    edge1.subVectors(b, a);
                    edge2.subVectors(c, a);
                    normal.crossVectors(edge1, edge2);

                    // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
                    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
                    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
                    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
                    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
                    var DdN = this.direction.dot(normal);
                    var sign;

                    if (DdN > 0) {

                        if (backfaceCulling) return null;
                        sign = 1;

                    } else if (DdN < 0) {

                        sign = -1;
                        DdN = -DdN;

                    } else {

                        return null;

                    }

                    diff.subVectors(this.origin, a);
                    var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));

                    // b1 < 0, no intersection
                    if (DdQxE2 < 0) {

                        return null;

                    }

                    var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));

                    // b2 < 0, no intersection
                    if (DdE1xQ < 0) {

                        return null;

                    }

                    // b1+b2 > 1, no intersection
                    if (DdQxE2 + DdE1xQ > DdN) {

                        return null;

                    }

                    // Line intersects triangle, check if ray does.
                    var QdN = -sign * diff.dot(normal);

                    // t < 0, no intersection
                    if (QdN < 0) {

                        return null;

                    }

                    // Ray intersects triangle.
                    return this.at(QdN / DdN, optionalTarget);

                };

            }(),

            applyMatrix4: function (matrix4) {

                this.origin.applyMatrix4(matrix4);
                this.direction.transformDirection(matrix4);

                return this;

            },

            equals: function (ray) {

                return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);

            }

        });

        /**
         * @author bhouston / http://clara.io
         */

        function Line3(start, end) {

            this.start = (start !== undefined) ? start : new Vector3();
            this.end = (end !== undefined) ? end : new Vector3();

        }

        Object.assign(Line3.prototype, {

            set: function (start, end) {

                this.start.copy(start);
                this.end.copy(end);

                return this;

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (line) {

                this.start.copy(line.start);
                this.end.copy(line.end);

                return this;

            },

            getCenter: function (optionalTarget) {

                var result = optionalTarget || new Vector3();
                return result.addVectors(this.start, this.end).multiplyScalar(0.5);

            },

            delta: function (optionalTarget) {

                var result = optionalTarget || new Vector3();
                return result.subVectors(this.end, this.start);

            },

            distanceSq: function () {

                return this.start.distanceToSquared(this.end);

            },

            distance: function () {

                return this.start.distanceTo(this.end);

            },

            at: function (t, optionalTarget) {

                var result = optionalTarget || new Vector3();

                return this.delta(result).multiplyScalar(t).add(this.start);

            },

            closestPointToPointParameter: function () {

                var startP = new Vector3();
                var startEnd = new Vector3();

                return function closestPointToPointParameter(point, clampToLine) {

                    startP.subVectors(point, this.start);
                    startEnd.subVectors(this.end, this.start);

                    var startEnd2 = startEnd.dot(startEnd);
                    var startEnd_startP = startEnd.dot(startP);

                    var t = startEnd_startP / startEnd2;

                    if (clampToLine) {

                        t = _Math.clamp(t, 0, 1);

                    }

                    return t;

                };

            }(),

            closestPointToPoint: function (point, clampToLine, optionalTarget) {

                var t = this.closestPointToPointParameter(point, clampToLine);

                var result = optionalTarget || new Vector3();

                return this.delta(result).multiplyScalar(t).add(this.start);

            },

            applyMatrix4: function (matrix) {

                this.start.applyMatrix4(matrix);
                this.end.applyMatrix4(matrix);

                return this;

            },

            equals: function (line) {

                return line.start.equals(this.start) && line.end.equals(this.end);

            }

        });

        /**
         * @author bhouston / http://clara.io
         * @author mrdoob / http://mrdoob.com/
         */

        function Triangle(a, b, c) {

            this.a = (a !== undefined) ? a : new Vector3();
            this.b = (b !== undefined) ? b : new Vector3();
            this.c = (c !== undefined) ? c : new Vector3();

        }

        Object.assign(Triangle, {

            normal: function () {

                var v0 = new Vector3();

                return function normal(a, b, c, optionalTarget) {

                    var result = optionalTarget || new Vector3();

                    result.subVectors(c, b);
                    v0.subVectors(a, b);
                    result.cross(v0);

                    var resultLengthSq = result.lengthSq();
                    if (resultLengthSq > 0) {

                        return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));

                    }

                    return result.set(0, 0, 0);

                };

            }(),

            // static/instance method to calculate barycentric coordinates
            // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
            barycoordFromPoint: function () {

                var v0 = new Vector3();
                var v1 = new Vector3();
                var v2 = new Vector3();

                return function barycoordFromPoint(point, a, b, c, optionalTarget) {

                    v0.subVectors(c, a);
                    v1.subVectors(b, a);
                    v2.subVectors(point, a);

                    var dot00 = v0.dot(v0);
                    var dot01 = v0.dot(v1);
                    var dot02 = v0.dot(v2);
                    var dot11 = v1.dot(v1);
                    var dot12 = v1.dot(v2);

                    var denom = (dot00 * dot11 - dot01 * dot01);

                    var result = optionalTarget || new Vector3();

                    // collinear or singular triangle
                    if (denom === 0) {

                        // arbitrary location outside of triangle?
                        // not sure if this is the best idea, maybe should be returning undefined
                        return result.set(-2, -1, -1);

                    }

                    var invDenom = 1 / denom;
                    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

                    // barycentric coordinates must always sum to 1
                    return result.set(1 - u - v, v, u);

                };

            }(),

            containsPoint: function () {

                var v1 = new Vector3();

                return function containsPoint(point, a, b, c) {

                    var result = Triangle.barycoordFromPoint(point, a, b, c, v1);

                    return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);

                };

            }()

        });

        Object.assign(Triangle.prototype, {

            set: function (a, b, c) {

                this.a.copy(a);
                this.b.copy(b);
                this.c.copy(c);

                return this;

            },

            setFromPointsAndIndices: function (points, i0, i1, i2) {

                this.a.copy(points[i0]);
                this.b.copy(points[i1]);
                this.c.copy(points[i2]);

                return this;

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (triangle) {

                this.a.copy(triangle.a);
                this.b.copy(triangle.b);
                this.c.copy(triangle.c);

                return this;

            },

            area: function () {

                var v0 = new Vector3();
                var v1 = new Vector3();

                return function area() {

                    v0.subVectors(this.c, this.b);
                    v1.subVectors(this.a, this.b);

                    return v0.cross(v1).length() * 0.5;

                };

            }(),

            midpoint: function (optionalTarget) {

                var result = optionalTarget || new Vector3();
                return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);

            },

            normal: function (optionalTarget) {

                return Triangle.normal(this.a, this.b, this.c, optionalTarget);

            },

            plane: function (optionalTarget) {

                var result = optionalTarget || new Plane();

                return result.setFromCoplanarPoints(this.a, this.b, this.c);

            },

            barycoordFromPoint: function (point, optionalTarget) {

                return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);

            },

            containsPoint: function (point) {

                return Triangle.containsPoint(point, this.a, this.b, this.c);

            },

            closestPointToPoint: function () {

                var plane = new Plane();
                var edgeList = [new Line3(), new Line3(), new Line3()];
                var projectedPoint = new Vector3();
                var closestPoint = new Vector3();

                return function closestPointToPoint(point, optionalTarget) {

                    var result = optionalTarget || new Vector3();
                    var minDistance = Infinity;

                    // project the point onto the plane of the triangle

                    plane.setFromCoplanarPoints(this.a, this.b, this.c);
                    plane.projectPoint(point, projectedPoint);

                    // check if the projection lies within the triangle

                    if (this.containsPoint(projectedPoint) === true) {

                        // if so, this is the closest point

                        result.copy(projectedPoint);

                    } else {

                        // if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

                        edgeList[0].set(this.a, this.b);
                        edgeList[1].set(this.b, this.c);
                        edgeList[2].set(this.c, this.a);

                        for (var i = 0; i < edgeList.length; i++) {

                            edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);

                            var distance = projectedPoint.distanceToSquared(closestPoint);

                            if (distance < minDistance) {

                                minDistance = distance;

                                result.copy(closestPoint);

                            }

                        }

                    }

                    return result;

                };

            }(),

            equals: function (triangle) {

                return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author mikael emtinger / http://gomo.se/
         * @author jonobr1 / http://jonobr1.com/
         */

        function Mesh(geometry, material) {

            Object3D.call(this);

            this.type = 'Mesh';

            this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
            this.material = material !== undefined ? material : new MeshBasicMaterial({color: Math.random() * 0xffffff});

            this.drawMode = TrianglesDrawMode;

            this.updateMorphTargets();

        }

        Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Mesh,

            isMesh: true,

            setDrawMode: function (value) {

                this.drawMode = value;

            },

            copy: function (source) {

                Object3D.prototype.copy.call(this, source);

                this.drawMode = source.drawMode;

                if (source.morphTargetInfluences !== undefined) {

                    this.morphTargetInfluences = source.morphTargetInfluences.slice();

                }

                if (source.morphTargetDictionary !== undefined) {

                    this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);

                }

                return this;

            },

            updateMorphTargets: function () {

                var geometry = this.geometry;
                var m, ml, name;

                if (geometry.isBufferGeometry) {

                    var morphAttributes = geometry.morphAttributes;
                    var keys = Object.keys(morphAttributes);

                    if (keys.length > 0) {

                        var morphAttribute = morphAttributes[keys[0]];

                        if (morphAttribute !== undefined) {

                            this.morphTargetInfluences = [];
                            this.morphTargetDictionary = {};

                            for (m = 0, ml = morphAttribute.length; m < ml; m++) {

                                name = morphAttribute[m].name || String(m);

                                this.morphTargetInfluences.push(0);
                                this.morphTargetDictionary[name] = m;

                            }

                        }

                    }

                } else {

                    var morphTargets = geometry.morphTargets;

                    if (morphTargets !== undefined && morphTargets.length > 0) {

                        this.morphTargetInfluences = [];
                        this.morphTargetDictionary = {};

                        for (m = 0, ml = morphTargets.length; m < ml; m++) {

                            name = morphTargets[m].name || String(m);

                            this.morphTargetInfluences.push(0);
                            this.morphTargetDictionary[name] = m;

                        }

                    }

                }

            },

            raycast: (function () {

                var inverseMatrix = new Matrix4();
                var ray = new Ray();
                var sphere = new Sphere();

                var vA = new Vector3();
                var vB = new Vector3();
                var vC = new Vector3();

                var tempA = new Vector3();
                var tempB = new Vector3();
                var tempC = new Vector3();

                var uvA = new Vector2();
                var uvB = new Vector2();
                var uvC = new Vector2();

                var barycoord = new Vector3();

                var intersectionPoint = new Vector3();
                var intersectionPointWorld = new Vector3();

                function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {

                    Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);

                    uv1.multiplyScalar(barycoord.x);
                    uv2.multiplyScalar(barycoord.y);
                    uv3.multiplyScalar(barycoord.z);

                    uv1.add(uv2).add(uv3);

                    return uv1.clone();

                }

                function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {

                    var intersect;

                    if (material.side === BackSide) {

                        intersect = ray.intersectTriangle(pC, pB, pA, true, point);

                    } else {

                        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);

                    }

                    if (intersect === null) return null;

                    intersectionPointWorld.copy(point);
                    intersectionPointWorld.applyMatrix4(object.matrixWorld);

                    var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);

                    if (distance < raycaster.near || distance > raycaster.far) return null;

                    return {
                        distance: distance,
                        point: intersectionPointWorld.clone(),
                        object: object
                    };

                }

                function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {

                    vA.fromBufferAttribute(position, a);
                    vB.fromBufferAttribute(position, b);
                    vC.fromBufferAttribute(position, c);

                    var intersection = checkIntersection(object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint);

                    if (intersection) {

                        if (uv) {

                            uvA.fromBufferAttribute(uv, a);
                            uvB.fromBufferAttribute(uv, b);
                            uvC.fromBufferAttribute(uv, c);

                            intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);

                        }

                        intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
                        intersection.faceIndex = a;

                    }

                    return intersection;

                }

                return function raycast(raycaster, intersects) {

                    var geometry = this.geometry;
                    var material = this.material;
                    var matrixWorld = this.matrixWorld;

                    if (material === undefined) return;

                    // Checking boundingSphere distance to ray

                    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                    sphere.copy(geometry.boundingSphere);
                    sphere.applyMatrix4(matrixWorld);

                    if (raycaster.ray.intersectsSphere(sphere) === false) return;

                    //

                    inverseMatrix.getInverse(matrixWorld);
                    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

                    // Check boundingBox before continuing

                    if (geometry.boundingBox !== null) {

                        if (ray.intersectsBox(geometry.boundingBox) === false) return;

                    }

                    var intersection;

                    if (geometry.isBufferGeometry) {

                        var a, b, c;
                        var index = geometry.index;
                        var position = geometry.attributes.position;
                        var uv = geometry.attributes.uv;
                        var i, l;

                        if (index !== null) {

                            // indexed buffer geometry

                            for (i = 0, l = index.count; i < l; i += 3) {

                                a = index.getX(i);
                                b = index.getX(i + 1);
                                c = index.getX(i + 2);

                                intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);

                                if (intersection) {

                                    intersection.faceIndex = Math.floor(i / 3); // triangle number in indices buffer semantics
                                    intersects.push(intersection);

                                }

                            }

                        } else if (position !== undefined) {

                            // non-indexed buffer geometry

                            for (i = 0, l = position.count; i < l; i += 3) {

                                a = i;
                                b = i + 1;
                                c = i + 2;

                                intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);

                                if (intersection) {

                                    intersection.index = a; // triangle number in positions buffer semantics
                                    intersects.push(intersection);

                                }

                            }

                        }

                    } else if (geometry.isGeometry) {

                        var fvA, fvB, fvC;
                        var isMultiMaterial = Array.isArray(material);

                        var vertices = geometry.vertices;
                        var faces = geometry.faces;
                        var uvs;

                        var faceVertexUvs = geometry.faceVertexUvs[0];
                        if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

                        for (var f = 0, fl = faces.length; f < fl; f++) {

                            var face = faces[f];
                            var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;

                            if (faceMaterial === undefined) continue;

                            fvA = vertices[face.a];
                            fvB = vertices[face.b];
                            fvC = vertices[face.c];

                            if (faceMaterial.morphTargets === true) {

                                var morphTargets = geometry.morphTargets;
                                var morphInfluences = this.morphTargetInfluences;

                                vA.set(0, 0, 0);
                                vB.set(0, 0, 0);
                                vC.set(0, 0, 0);

                                for (var t = 0, tl = morphTargets.length; t < tl; t++) {

                                    var influence = morphInfluences[t];

                                    if (influence === 0) continue;

                                    var targets = morphTargets[t].vertices;

                                    vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                                    vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                                    vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);

                                }

                                vA.add(fvA);
                                vB.add(fvB);
                                vC.add(fvC);

                                fvA = vA;
                                fvB = vB;
                                fvC = vC;

                            }

                            intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);

                            if (intersection) {

                                if (uvs && uvs[f]) {

                                    var uvs_f = uvs[f];
                                    uvA.copy(uvs_f[0]);
                                    uvB.copy(uvs_f[1]);
                                    uvC.copy(uvs_f[2]);

                                    intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);

                                }

                                intersection.face = face;
                                intersection.faceIndex = f;
                                intersects.push(intersection);

                            }

                        }

                    }

                };

            }()),

            clone: function () {

                return new this.constructor(this.geometry, this.material).copy(this);

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLBackground(renderer, state, geometries, premultipliedAlpha) {

            var clearColor = new Color(0x000000);
            var clearAlpha = 0;

            var planeCamera, planeMesh;
            var boxMesh;

            function render(renderList, scene, camera, forceClear) {

                var background = scene.background;

                if (background === null) {

                    setClear(clearColor, clearAlpha);

                } else if (background && background.isColor) {

                    setClear(background, 1);
                    forceClear = true;

                }

                if (renderer.autoClear || forceClear) {

                    renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);

                }

                if (background && background.isCubeTexture) {

                    if (boxMesh === undefined) {

                        boxMesh = new Mesh(
                            new BoxBufferGeometry(1, 1, 1),
                            new ShaderMaterial({
                                uniforms: ShaderLib.cube.uniforms,
                                vertexShader: ShaderLib.cube.vertexShader,
                                fragmentShader: ShaderLib.cube.fragmentShader,
                                side: BackSide,
                                depthTest: true,
                                depthWrite: false,
                                fog: false
                            })
                        );

                        boxMesh.geometry.removeAttribute('normal');
                        boxMesh.geometry.removeAttribute('uv');

                        boxMesh.onBeforeRender = function (renderer, scene, camera) {

                            this.matrixWorld.copyPosition(camera.matrixWorld);

                        };

                        geometries.update(boxMesh.geometry);

                    }

                    boxMesh.material.uniforms.tCube.value = background;

                    renderList.push(boxMesh, boxMesh.geometry, boxMesh.material, 0, null);

                } else if (background && background.isTexture) {

                    if (planeCamera === undefined) {

                        planeCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);

                        planeMesh = new Mesh(
                            new PlaneBufferGeometry(2, 2),
                            new MeshBasicMaterial({depthTest: false, depthWrite: false, fog: false})
                        );

                        geometries.update(planeMesh.geometry);

                    }

                    planeMesh.material.map = background;

                    // TODO Push this to renderList

                    renderer.renderBufferDirect(planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null);

                }

            }

            function setClear(color, alpha) {

                state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);

            }

            return {

                getClearColor: function () {

                    return clearColor;

                },
                setClearColor: function (color, alpha) {

                    clearColor.set(color);
                    clearAlpha = alpha !== undefined ? alpha : 1;
                    setClear(clearColor, clearAlpha);

                },
                getClearAlpha: function () {

                    return clearAlpha;

                },
                setClearAlpha: function (alpha) {

                    clearAlpha = alpha;
                    setClear(clearColor, clearAlpha);

                },
                render: render

            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function painterSortStable(a, b) {

            if (a.renderOrder !== b.renderOrder) {

                return a.renderOrder - b.renderOrder;

            } else if (a.program && b.program && a.program !== b.program) {

                return a.program.id - b.program.id;

            } else if (a.material.id !== b.material.id) {

                return a.material.id - b.material.id;

            } else if (a.z !== b.z) {

                return a.z - b.z;

            } else {

                return a.id - b.id;

            }

        }

        function reversePainterSortStable(a, b) {

            if (a.renderOrder !== b.renderOrder) {

                return a.renderOrder - b.renderOrder;

            }
            if (a.z !== b.z) {

                return b.z - a.z;

            } else {

                return a.id - b.id;

            }

        }

        function WebGLRenderList() {

            var renderItems = [];
            var renderItemsIndex = 0;

            var opaque = [];
            var transparent = [];

            function init() {

                renderItemsIndex = 0;

                opaque.length = 0;
                transparent.length = 0;

            }

            function push(object, geometry, material, z, group) {

                var renderItem = renderItems[renderItemsIndex];

                if (renderItem === undefined) {

                    renderItem = {
                        id: object.id,
                        object: object,
                        geometry: geometry,
                        material: material,
                        program: material.program,
                        renderOrder: object.renderOrder,
                        z: z,
                        group: group
                    };

                    renderItems[renderItemsIndex] = renderItem;

                } else {

                    renderItem.id = object.id;
                    renderItem.object = object;
                    renderItem.geometry = geometry;
                    renderItem.material = material;
                    renderItem.program = material.program;
                    renderItem.renderOrder = object.renderOrder;
                    renderItem.z = z;
                    renderItem.group = group;

                }

                (material.transparent === true ? transparent : opaque).push(renderItem);

                renderItemsIndex++;

            }

            function sort() {

                if (opaque.length > 1) opaque.sort(painterSortStable);
                if (transparent.length > 1) transparent.sort(reversePainterSortStable);

            }

            return {
                opaque: opaque,
                transparent: transparent,

                init: init,
                push: push,

                sort: sort
            };

        }

        function WebGLRenderLists() {

            var lists = {};

            function get(scene, camera) {

                var hash = scene.id + ',' + camera.id;
                var list = lists[hash];

                if (list === undefined) {

                    // console.log( 'THREE.WebGLRenderLists:', hash );

                    list = new WebGLRenderList();
                    lists[hash] = list;

                }

                return list;

            }

            function dispose() {

                lists = {};

            }

            return {
                get: get,
                dispose: dispose
            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function absNumericalSort(a, b) {

            return Math.abs(b[1]) - Math.abs(a[1]);

        }

        function WebGLMorphtargets(gl) {

            var influencesList = {};
            var morphInfluences = new Float32Array(8);

            function update(object, geometry, material, program) {

                var objectInfluences = object.morphTargetInfluences;

                var length = objectInfluences.length;

                var influences = influencesList[geometry.id];

                if (influences === undefined) {

                    // initialise list

                    influences = [];

                    for (var i = 0; i < length; i++) {

                        influences[i] = [i, 0];

                    }

                    influencesList[geometry.id] = influences;

                }

                var morphTargets = material.morphTargets && geometry.morphAttributes.position;
                var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

                // Remove current morphAttributes

                for (var i = 0; i < length; i++) {

                    var influence = influences[i];

                    if (influence[1] !== 0) {

                        if (morphTargets) geometry.removeAttribute('morphTarget' + i);
                        if (morphNormals) geometry.removeAttribute('morphNormal' + i);

                    }

                }

                // Collect influences

                for (var i = 0; i < length; i++) {

                    var influence = influences[i];

                    influence[0] = i;
                    influence[1] = objectInfluences[i];

                }

                influences.sort(absNumericalSort);

                // Add morphAttributes

                for (var i = 0; i < 8; i++) {

                    var influence = influences[i];

                    if (influence) {

                        var index = influence[0];
                        var value = influence[1];

                        if (value) {

                            if (morphTargets) geometry.addAttribute('morphTarget' + i, morphTargets[index]);
                            if (morphNormals) geometry.addAttribute('morphNormal' + i, morphNormals[index]);

                            morphInfluences[i] = value;
                            continue;

                        }

                    }

                    morphInfluences[i] = 0;

                }

                program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);

            }

            return {

                update: update

            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {

            var mode;

            function setMode(value) {

                mode = value;

            }

            var type, bytesPerElement;

            function setIndex(value) {

                type = value.type;
                bytesPerElement = value.bytesPerElement;

            }

            function render(start, count) {

                gl.drawElements(mode, count, type, start * bytesPerElement);

                infoRender.calls++;
                infoRender.vertices += count;

                if (mode === gl.TRIANGLES) infoRender.faces += count / 3;
                else if (mode === gl.POINTS) infoRender.points += count;

            }

            function renderInstances(geometry, start, count) {

                var extension = extensions.get('ANGLE_instanced_arrays');

                if (extension === null) {

                    console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;

                }

                extension.drawElementsInstancedANGLE(mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);

                infoRender.calls++;
                infoRender.vertices += count * geometry.maxInstancedCount;

                if (mode === gl.TRIANGLES) infoRender.faces += geometry.maxInstancedCount * count / 3;
                else if (mode === gl.POINTS) infoRender.points += geometry.maxInstancedCount * count;

            }

            //

            this.setMode = setMode;
            this.setIndex = setIndex;
            this.render = render;
            this.renderInstances = renderInstances;

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLBufferRenderer(gl, extensions, infoRender) {

            var mode;

            function setMode(value) {

                mode = value;

            }

            function render(start, count) {

                gl.drawArrays(mode, start, count);

                infoRender.calls++;
                infoRender.vertices += count;

                if (mode === gl.TRIANGLES) infoRender.faces += count / 3;
                else if (mode === gl.POINTS) infoRender.points += count;

            }

            function renderInstances(geometry, start, count) {

                var extension = extensions.get('ANGLE_instanced_arrays');

                if (extension === null) {

                    console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;

                }

                var position = geometry.attributes.position;

                if (position.isInterleavedBufferAttribute) {

                    count = position.data.count;

                    extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);

                } else {

                    extension.drawArraysInstancedANGLE(mode, start, count, geometry.maxInstancedCount);

                }

                infoRender.calls++;
                infoRender.vertices += count * geometry.maxInstancedCount;

                if (mode === gl.TRIANGLES) infoRender.faces += geometry.maxInstancedCount * count / 3;
                else if (mode === gl.POINTS) infoRender.points += geometry.maxInstancedCount * count;

            }

            //

            this.setMode = setMode;
            this.render = render;
            this.renderInstances = renderInstances;

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLGeometries(gl, attributes, infoMemory) {

            var geometries = {};
            var wireframeAttributes = {};

            function onGeometryDispose(event) {

                var geometry = event.target;
                var buffergeometry = geometries[geometry.id];

                if (buffergeometry.index !== null) {

                    attributes.remove(buffergeometry.index);

                }

                for (var name in buffergeometry.attributes) {

                    attributes.remove(buffergeometry.attributes[name]);

                }

                geometry.removeEventListener('dispose', onGeometryDispose);

                delete geometries[geometry.id];

                // TODO Remove duplicate code

                var attribute = wireframeAttributes[geometry.id];

                if (attribute) {

                    attributes.remove(attribute);
                    delete wireframeAttributes[geometry.id];

                }

                attribute = wireframeAttributes[buffergeometry.id];

                if (attribute) {

                    attributes.remove(attribute);
                    delete wireframeAttributes[buffergeometry.id];

                }

                //

                infoMemory.geometries--;

            }

            function get(object, geometry) {

                var buffergeometry = geometries[geometry.id];

                if (buffergeometry) return buffergeometry;

                geometry.addEventListener('dispose', onGeometryDispose);

                if (geometry.isBufferGeometry) {

                    buffergeometry = geometry;

                } else if (geometry.isGeometry) {

                    if (geometry._bufferGeometry === undefined) {

                        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);

                    }

                    buffergeometry = geometry._bufferGeometry;

                }

                geometries[geometry.id] = buffergeometry;

                infoMemory.geometries++;

                return buffergeometry;

            }

            function update(geometry) {

                var index = geometry.index;
                var geometryAttributes = geometry.attributes;

                if (index !== null) {

                    attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);

                }

                for (var name in geometryAttributes) {

                    attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);

                }

                // morph targets

                var morphAttributes = geometry.morphAttributes;

                for (var name in morphAttributes) {

                    var array = morphAttributes[name];

                    for (var i = 0, l = array.length; i < l; i++) {

                        attributes.update(array[i], gl.ARRAY_BUFFER);

                    }

                }

            }

            function getWireframeAttribute(geometry) {

                var attribute = wireframeAttributes[geometry.id];

                if (attribute) return attribute;

                var indices = [];

                var geometryIndex = geometry.index;
                var geometryAttributes = geometry.attributes;

                // console.time( 'wireframe' );

                if (geometryIndex !== null) {

                    var array = geometryIndex.array;

                    for (var i = 0, l = array.length; i < l; i += 3) {

                        var a = array[i + 0];
                        var b = array[i + 1];
                        var c = array[i + 2];

                        indices.push(a, b, b, c, c, a);

                    }

                } else {

                    var array = geometryAttributes.position.array;

                    for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {

                        var a = i + 0;
                        var b = i + 1;
                        var c = i + 2;

                        indices.push(a, b, b, c, c, a);

                    }

                }

                // console.timeEnd( 'wireframe' );

                attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);

                attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);

                wireframeAttributes[geometry.id] = attribute;

                return attribute;

            }

            return {

                get: get,
                update: update,

                getWireframeAttribute: getWireframeAttribute

            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function UniformsCache() {

            var lights = {};

            return {

                get: function (light) {

                    if (lights[light.id] !== undefined) {

                        return lights[light.id];

                    }

                    var uniforms;

                    switch (light.type) {

                        case 'DirectionalLight':
                            uniforms = {
                                direction: new Vector3(),
                                color: new Color(),

                                shadow: false,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Vector2()
                            };
                            break;

                        case 'SpotLight':
                            uniforms = {
                                position: new Vector3(),
                                direction: new Vector3(),
                                color: new Color(),
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,

                                shadow: false,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Vector2()
                            };
                            break;

                        case 'PointLight':
                            uniforms = {
                                position: new Vector3(),
                                color: new Color(),
                                distance: 0,
                                decay: 0,

                                shadow: false,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Vector2(),
                                shadowCameraNear: 1,
                                shadowCameraFar: 1000
                            };
                            break;

                        case 'HemisphereLight':
                            uniforms = {
                                direction: new Vector3(),
                                skyColor: new Color(),
                                groundColor: new Color()
                            };
                            break;

                        case 'RectAreaLight':
                            uniforms = {
                                color: new Color(),
                                position: new Vector3(),
                                halfWidth: new Vector3(),
                                halfHeight: new Vector3()
                                // TODO (abelnation): set RectAreaLight shadow uniforms
                            };
                            break;

                    }

                    lights[light.id] = uniforms;

                    return uniforms;

                }

            };

        }

        function WebGLLights() {

            var cache = new UniformsCache();

            var state = {

                hash: '',

                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []

            };

            var vector3 = new Vector3();
            var matrix4 = new Matrix4();
            var matrix42 = new Matrix4();

            function setup(lights, shadows, camera) {

                var r = 0, g = 0, b = 0;

                var directionalLength = 0;
                var pointLength = 0;
                var spotLength = 0;
                var rectAreaLength = 0;
                var hemiLength = 0;

                var viewMatrix = camera.matrixWorldInverse;

                for (var i = 0, l = lights.length; i < l; i++) {

                    var light = lights[i];

                    var color = light.color;
                    var intensity = light.intensity;
                    var distance = light.distance;

                    var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;

                    if (light.isAmbientLight) {

                        r += color.r * intensity;
                        g += color.g * intensity;
                        b += color.b * intensity;

                    } else if (light.isDirectionalLight) {

                        var uniforms = cache.get(light);

                        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                        vector3.setFromMatrixPosition(light.target.matrixWorld);
                        uniforms.direction.sub(vector3);
                        uniforms.direction.transformDirection(viewMatrix);

                        uniforms.shadow = light.castShadow;

                        if (light.castShadow) {

                            var shadow = light.shadow;

                            uniforms.shadowBias = shadow.bias;
                            uniforms.shadowRadius = shadow.radius;
                            uniforms.shadowMapSize = shadow.mapSize;

                        }

                        state.directionalShadowMap[directionalLength] = shadowMap;
                        state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                        state.directional[directionalLength] = uniforms;

                        directionalLength++;

                    } else if (light.isSpotLight) {

                        var uniforms = cache.get(light);

                        uniforms.position.setFromMatrixPosition(light.matrixWorld);
                        uniforms.position.applyMatrix4(viewMatrix);

                        uniforms.color.copy(color).multiplyScalar(intensity);
                        uniforms.distance = distance;

                        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                        vector3.setFromMatrixPosition(light.target.matrixWorld);
                        uniforms.direction.sub(vector3);
                        uniforms.direction.transformDirection(viewMatrix);

                        uniforms.coneCos = Math.cos(light.angle);
                        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                        uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;

                        uniforms.shadow = light.castShadow;

                        if (light.castShadow) {

                            var shadow = light.shadow;

                            uniforms.shadowBias = shadow.bias;
                            uniforms.shadowRadius = shadow.radius;
                            uniforms.shadowMapSize = shadow.mapSize;

                        }

                        state.spotShadowMap[spotLength] = shadowMap;
                        state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                        state.spot[spotLength] = uniforms;

                        spotLength++;

                    } else if (light.isRectAreaLight) {

                        var uniforms = cache.get(light);

                        // (a) intensity controls irradiance of entire light
                        uniforms.color
                            .copy(color)
                            .multiplyScalar(intensity / (light.width * light.height));

                        // (b) intensity controls the radiance per light area
                        // uniforms.color.copy( color ).multiplyScalar( intensity );

                        uniforms.position.setFromMatrixPosition(light.matrixWorld);
                        uniforms.position.applyMatrix4(viewMatrix);

                        // extract local rotation of light to derive width/height half vectors
                        matrix42.identity();
                        matrix4.copy(light.matrixWorld);
                        matrix4.premultiply(viewMatrix);
                        matrix42.extractRotation(matrix4);

                        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

                        uniforms.halfWidth.applyMatrix4(matrix42);
                        uniforms.halfHeight.applyMatrix4(matrix42);

                        // TODO (abelnation): RectAreaLight distance?
                        // uniforms.distance = distance;

                        state.rectArea[rectAreaLength] = uniforms;

                        rectAreaLength++;

                    } else if (light.isPointLight) {

                        var uniforms = cache.get(light);

                        uniforms.position.setFromMatrixPosition(light.matrixWorld);
                        uniforms.position.applyMatrix4(viewMatrix);

                        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                        uniforms.distance = light.distance;
                        uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;

                        uniforms.shadow = light.castShadow;

                        if (light.castShadow) {

                            var shadow = light.shadow;

                            uniforms.shadowBias = shadow.bias;
                            uniforms.shadowRadius = shadow.radius;
                            uniforms.shadowMapSize = shadow.mapSize;
                            uniforms.shadowCameraNear = shadow.camera.near;
                            uniforms.shadowCameraFar = shadow.camera.far;

                        }

                        state.pointShadowMap[pointLength] = shadowMap;
                        state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                        state.point[pointLength] = uniforms;

                        pointLength++;

                    } else if (light.isHemisphereLight) {

                        var uniforms = cache.get(light);

                        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                        uniforms.direction.transformDirection(viewMatrix);
                        uniforms.direction.normalize();

                        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

                        state.hemi[hemiLength] = uniforms;

                        hemiLength++;

                    }

                }

                state.ambient[0] = r;
                state.ambient[1] = g;
                state.ambient[2] = b;

                state.directional.length = directionalLength;
                state.spot.length = spotLength;
                state.rectArea.length = rectAreaLength;
                state.point.length = pointLength;
                state.hemi.length = hemiLength;

                // TODO (sam-g-steel) why aren't we using join
                state.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;

            }

            return {
                setup: setup,
                state: state
            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLObjects(geometries, infoRender) {

            var updateList = {};

            function update(object) {

                var frame = infoRender.frame;

                var geometry = object.geometry;
                var buffergeometry = geometries.get(object, geometry);

                // Update once per frame

                if (updateList[buffergeometry.id] !== frame) {

                    if (geometry.isGeometry) {

                        buffergeometry.updateFromObject(object);

                    }

                    geometries.update(buffergeometry);

                    updateList[buffergeometry.id] = frame;

                }

                return buffergeometry;

            }

            function clear() {

                updateList = {};

            }

            return {

                update: update,
                clear: clear

            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function addLineNumbers(string) {

            var lines = string.split('\n');

            for (var i = 0; i < lines.length; i++) {

                lines[i] = (i + 1) + ': ' + lines[i];

            }

            return lines.join('\n');

        }

        function WebGLShader(gl, type, string) {

            var shader = gl.createShader(type);

            gl.shaderSource(shader, string);
            gl.compileShader(shader);

            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {

                console.error('THREE.WebGLShader: Shader couldn\'t compile.');

            }

            if (gl.getShaderInfoLog(shader) !== '') {

                console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));

            }

            // --enable-privileged-webgl-extension
            // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

            return shader;

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        var programIdCount = 0;

        function getEncodingComponents(encoding) {

            switch (encoding) {

                case LinearEncoding:
                    return ['Linear', '( value )'];
                case sRGBEncoding:
                    return ['sRGB', '( value )'];
                case RGBEEncoding:
                    return ['RGBE', '( value )'];
                case RGBM7Encoding:
                    return ['RGBM', '( value, 7.0 )'];
                case RGBM16Encoding:
                    return ['RGBM', '( value, 16.0 )'];
                case RGBDEncoding:
                    return ['RGBD', '( value, 256.0 )'];
                case GammaEncoding:
                    return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
                default:
                    throw new Error('unsupported encoding: ' + encoding);

            }

        }

        function getTexelDecodingFunction(functionName, encoding) {

            var components = getEncodingComponents(encoding);
            return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";

        }

        function getTexelEncodingFunction(functionName, encoding) {

            var components = getEncodingComponents(encoding);
            return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";

        }

        function getToneMappingFunction(functionName, toneMapping) {

            var toneMappingName;

            switch (toneMapping) {

                case LinearToneMapping:
                    toneMappingName = "Linear";
                    break;

                case ReinhardToneMapping:
                    toneMappingName = "Reinhard";
                    break;

                case Uncharted2ToneMapping:
                    toneMappingName = "Uncharted2";
                    break;

                case CineonToneMapping:
                    toneMappingName = "OptimizedCineon";
                    break;

                default:
                    throw new Error('unsupported toneMapping: ' + toneMapping);

            }

            return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

        }

        function generateExtensions(extensions, parameters, rendererExtensions) {

            extensions = extensions || {};

            var chunks = [
                (extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '',
                (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
                (extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
                (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''
            ];

            return chunks.filter(filterEmptyLine).join('\n');

        }

        function generateDefines(defines) {

            var chunks = [];

            for (var name in defines) {

                var value = defines[name];

                if (value === false) continue;

                chunks.push('#define ' + name + ' ' + value);

            }

            return chunks.join('\n');

        }

        function fetchAttributeLocations(gl, program) {

            var attributes = {};

            var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

            for (var i = 0; i < n; i++) {

                var info = gl.getActiveAttrib(program, i);
                var name = info.name;

                // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

                attributes[name] = gl.getAttribLocation(program, name);

            }

            return attributes;

        }

        function filterEmptyLine(string) {

            return string !== '';

        }

        function replaceLightNums(string, parameters) {

            return string
                .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
                .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
                .replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
                .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
                .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);

        }

        function parseIncludes(string) {

            var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

            function replace(match, include) {

                var replace = ShaderChunk[include];

                if (replace === undefined) {

                    throw new Error('Can not resolve #include <' + include + '>');

                }

                return parseIncludes(replace);

            }

            return string.replace(pattern, replace);

        }

        function unrollLoops(string) {

            var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

            function replace(match, start, end, snippet) {

                var unroll = '';

                for (var i = parseInt(start); i < parseInt(end); i++) {

                    unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');

                }

                return unroll;

            }

            return string.replace(pattern, replace);

        }

        function WebGLProgram(renderer, extensions, code, material, shader, parameters) {

            var gl = renderer.context;

            var defines = material.defines;

            var vertexShader = shader.vertexShader;
            var fragmentShader = shader.fragmentShader;

            var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

            if (parameters.shadowMapType === PCFShadowMap) {

                shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

            } else if (parameters.shadowMapType === PCFSoftShadowMap) {

                shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

            }

            var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
            var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

            if (parameters.envMap) {

                switch (material.envMap.mapping) {

                    case CubeReflectionMapping:
                    case CubeRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                        break;

                    case CubeUVReflectionMapping:
                    case CubeUVRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                        break;

                    case EquirectangularReflectionMapping:
                    case EquirectangularRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                        break;

                    case SphericalReflectionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                        break;

                }

                switch (material.envMap.mapping) {

                    case CubeRefractionMapping:
                    case EquirectangularRefractionMapping:
                        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                        break;

                }

                switch (material.combine) {

                    case MultiplyOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                        break;

                    case MixOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                        break;

                    case AddOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                        break;

                }

            }

            var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;

            // console.log( 'building new program ' );

            //

            var customExtensions = generateExtensions(material.extensions, parameters, extensions);

            var customDefines = generateDefines(defines);

            //

            var program = gl.createProgram();

            var prefixVertex, prefixFragment;

            if (material.isRawShaderMaterial) {

                prefixVertex = [

                    customDefines

                ].filter(filterEmptyLine).join('\n');

                if (prefixVertex.length > 0) {

                    prefixVertex += '\n';

                }

                prefixFragment = [

                    customExtensions,
                    customDefines

                ].filter(filterEmptyLine).join('\n');

                if (prefixFragment.length > 0) {

                    prefixFragment += '\n';

                }

            } else {

                prefixVertex = [

                    'precision ' + parameters.precision + ' float;',
                    'precision ' + parameters.precision + ' int;',

                    '#define SHADER_NAME ' + shader.name,

                    customDefines,

                    parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

                    '#define GAMMA_FACTOR ' + gammaFactorDefine,

                    '#define MAX_BONES ' + parameters.maxBones,
                    (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                    (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',

                    parameters.map ? '#define USE_MAP' : '',
                    parameters.envMap ? '#define USE_ENVMAP' : '',
                    parameters.envMap ? '#define ' + envMapModeDefine : '',
                    parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                    parameters.aoMap ? '#define USE_AOMAP' : '',
                    parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                    parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                    parameters.normalMap ? '#define USE_NORMALMAP' : '',
                    parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                    parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                    parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                    parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                    parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                    parameters.vertexColors ? '#define USE_COLOR' : '',

                    parameters.flatShading ? '#define FLAT_SHADED' : '',

                    parameters.skinning ? '#define USE_SKINNING' : '',
                    parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

                    parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                    parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                    parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                    parameters.flipSided ? '#define FLIP_SIDED' : '',

                    '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

                    parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                    parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

                    parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

                    parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                    parameters.logarithmicDepthBuffer && extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',

                    'uniform mat4 modelMatrix;',
                    'uniform mat4 modelViewMatrix;',
                    'uniform mat4 projectionMatrix;',
                    'uniform mat4 viewMatrix;',
                    'uniform mat3 normalMatrix;',
                    'uniform vec3 cameraPosition;',

                    'attribute vec3 position;',
                    'attribute vec3 normal;',
                    'attribute vec2 uv;',

                    '#ifdef USE_COLOR',

                    '	attribute vec3 color;',

                    '#endif',

                    '#ifdef USE_MORPHTARGETS',

                    '	attribute vec3 morphTarget0;',
                    '	attribute vec3 morphTarget1;',
                    '	attribute vec3 morphTarget2;',
                    '	attribute vec3 morphTarget3;',

                    '	#ifdef USE_MORPHNORMALS',

                    '		attribute vec3 morphNormal0;',
                    '		attribute vec3 morphNormal1;',
                    '		attribute vec3 morphNormal2;',
                    '		attribute vec3 morphNormal3;',

                    '	#else',

                    '		attribute vec3 morphTarget4;',
                    '		attribute vec3 morphTarget5;',
                    '		attribute vec3 morphTarget6;',
                    '		attribute vec3 morphTarget7;',

                    '	#endif',

                    '#endif',

                    '#ifdef USE_SKINNING',

                    '	attribute vec4 skinIndex;',
                    '	attribute vec4 skinWeight;',

                    '#endif',

                    '\n'

                ].filter(filterEmptyLine).join('\n');

                prefixFragment = [

                    customExtensions,

                    'precision ' + parameters.precision + ' float;',
                    'precision ' + parameters.precision + ' int;',

                    '#define SHADER_NAME ' + shader.name,

                    customDefines,

                    parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

                    '#define GAMMA_FACTOR ' + gammaFactorDefine,

                    (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                    (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',

                    parameters.map ? '#define USE_MAP' : '',
                    parameters.envMap ? '#define USE_ENVMAP' : '',
                    parameters.envMap ? '#define ' + envMapTypeDefine : '',
                    parameters.envMap ? '#define ' + envMapModeDefine : '',
                    parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                    parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                    parameters.aoMap ? '#define USE_AOMAP' : '',
                    parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                    parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                    parameters.normalMap ? '#define USE_NORMALMAP' : '',
                    parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                    parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                    parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                    parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                    parameters.vertexColors ? '#define USE_COLOR' : '',

                    parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

                    parameters.flatShading ? '#define FLAT_SHADED' : '',

                    parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                    parameters.flipSided ? '#define FLIP_SIDED' : '',

                    '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
                    '#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),

                    parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                    parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

                    parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

                    parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

                    parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                    parameters.logarithmicDepthBuffer && extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',

                    parameters.envMap && extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',

                    'uniform mat4 viewMatrix;',
                    'uniform vec3 cameraPosition;',

                    (parameters.toneMapping !== NoToneMapping) ? "#define TONE_MAPPING" : '',
                    (parameters.toneMapping !== NoToneMapping) ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
                    (parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction("toneMapping", parameters.toneMapping) : '',

                    parameters.dithering ? '#define DITHERING' : '',

                    (parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding) ? ShaderChunk['encodings_pars_fragment'] : '', // this code is required here because it is used by the various encoding/decoding function defined below
                    parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
                    parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
                    parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
                    parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : '',

                    parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

                    '\n'

                ].filter(filterEmptyLine).join('\n');

            }

            vertexShader = parseIncludes(vertexShader);
            vertexShader = replaceLightNums(vertexShader, parameters);

            fragmentShader = parseIncludes(fragmentShader);
            fragmentShader = replaceLightNums(fragmentShader, parameters);

            if (!material.isShaderMaterial) {

                vertexShader = unrollLoops(vertexShader);
                fragmentShader = unrollLoops(fragmentShader);

            }

            var vertexGlsl = prefixVertex + vertexShader;
            var fragmentGlsl = prefixFragment + fragmentShader;

            // console.log( '*VERTEX*', vertexGlsl );
            // console.log( '*FRAGMENT*', fragmentGlsl );

            var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
            var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);

            gl.attachShader(program, glVertexShader);
            gl.attachShader(program, glFragmentShader);

            // Force a particular attribute to index 0.

            if (material.index0AttributeName !== undefined) {

                gl.bindAttribLocation(program, 0, material.index0AttributeName);

            } else if (parameters.morphTargets === true) {

                // programs with morphTargets displace position out of attribute 0
                gl.bindAttribLocation(program, 0, 'position');

            }

            gl.linkProgram(program);

            var programLog = gl.getProgramInfoLog(program);
            var vertexLog = gl.getShaderInfoLog(glVertexShader);
            var fragmentLog = gl.getShaderInfoLog(glFragmentShader);

            var runnable = true;
            var haveDiagnostics = true;

            // console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
            // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

            if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {

                runnable = false;

                console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);

            } else if (programLog !== '') {

                console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);

            } else if (vertexLog === '' || fragmentLog === '') {

                haveDiagnostics = false;

            }

            if (haveDiagnostics) {

                this.diagnostics = {

                    runnable: runnable,
                    material: material,

                    programLog: programLog,

                    vertexShader: {

                        log: vertexLog,
                        prefix: prefixVertex

                    },

                    fragmentShader: {

                        log: fragmentLog,
                        prefix: prefixFragment

                    }

                };

            }

            // clean up

            gl.deleteShader(glVertexShader);
            gl.deleteShader(glFragmentShader);

            // set up caching for uniform locations

            var cachedUniforms;

            this.getUniforms = function () {

                if (cachedUniforms === undefined) {

                    cachedUniforms = new WebGLUniforms(gl, program, renderer);

                }

                return cachedUniforms;

            };

            // set up caching for attribute locations

            var cachedAttributes;

            this.getAttributes = function () {

                if (cachedAttributes === undefined) {

                    cachedAttributes = fetchAttributeLocations(gl, program);

                }

                return cachedAttributes;

            };

            // free resource

            this.destroy = function () {

                gl.deleteProgram(program);
                this.program = undefined;

            };

            // DEPRECATED

            Object.defineProperties(this, {

                uniforms: {
                    get: function () {

                        console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
                        return this.getUniforms();

                    }
                },

                attributes: {
                    get: function () {

                        console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
                        return this.getAttributes();

                    }
                }

            });


            //

            this.id = programIdCount++;
            this.code = code;
            this.usedTimes = 1;
            this.program = program;
            this.vertexShader = glVertexShader;
            this.fragmentShader = glFragmentShader;

            return this;

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLPrograms(renderer, extensions, capabilities) {

            var programs = [];

            var shaderIDs = {
                MeshDepthMaterial: 'depth',
                MeshDistanceMaterial: 'distanceRGBA',
                MeshNormalMaterial: 'normal',
                MeshBasicMaterial: 'basic',
                MeshLambertMaterial: 'lambert',
                MeshPhongMaterial: 'phong',
                MeshToonMaterial: 'phong',
                MeshStandardMaterial: 'physical',
                MeshPhysicalMaterial: 'physical',
                LineBasicMaterial: 'basic',
                LineDashedMaterial: 'dashed',
                PointsMaterial: 'points',
                ShadowMaterial: 'shadow'
            };

            var parameterNames = [
                "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
                "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
                "roughnessMap", "metalnessMap", "gradientMap",
                "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
                "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
                "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
                "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
                "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
                "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
                "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
            ];


            function allocateBones(object) {

                var skeleton = object.skeleton;
                var bones = skeleton.bones;

                if (capabilities.floatVertexTextures) {

                    return 1024;

                } else {

                    // default for when object is not specified
                    // ( for example when prebuilding shader to be used with multiple objects )
                    //
                    //  - leave some extra space for other uniforms
                    //  - limit here is ANGLE's 254 max uniform vectors
                    //    (up to 54 should be safe)

                    var nVertexUniforms = capabilities.maxVertexUniforms;
                    var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);

                    var maxBones = Math.min(nVertexMatrices, bones.length);

                    if (maxBones < bones.length) {

                        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                        return 0;

                    }

                    return maxBones;

                }

            }

            function getTextureEncodingFromMap(map, gammaOverrideLinear) {

                var encoding;

                if (!map) {

                    encoding = LinearEncoding;

                } else if (map.isTexture) {

                    encoding = map.encoding;

                } else if (map.isWebGLRenderTarget) {

                    console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                    encoding = map.texture.encoding;

                }

                // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
                if (encoding === LinearEncoding && gammaOverrideLinear) {

                    encoding = GammaEncoding;

                }

                return encoding;

            }

            this.getParameters = function (material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {

                var shaderID = shaderIDs[material.type];

                // heuristics to create shader parameters according to lights in the scene
                // (not to blow over maxLights budget)

                var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
                var precision = capabilities.precision;

                if (material.precision !== null) {

                    precision = capabilities.getMaxPrecision(material.precision);

                    if (precision !== material.precision) {

                        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');

                    }

                }

                var currentRenderTarget = renderer.getRenderTarget();

                var parameters = {

                    shaderID: shaderID,

                    precision: precision,
                    supportsVertexTextures: capabilities.vertexTextures,
                    outputEncoding: getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, renderer.gammaOutput),
                    map: !!material.map,
                    mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                    envMap: !!material.envMap,
                    envMapMode: material.envMap && material.envMap.mapping,
                    envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                    envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === CubeUVReflectionMapping) || (material.envMap.mapping === CubeUVRefractionMapping)),
                    lightMap: !!material.lightMap,
                    aoMap: !!material.aoMap,
                    emissiveMap: !!material.emissiveMap,
                    emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                    bumpMap: !!material.bumpMap,
                    normalMap: !!material.normalMap,
                    displacementMap: !!material.displacementMap,
                    roughnessMap: !!material.roughnessMap,
                    metalnessMap: !!material.metalnessMap,
                    specularMap: !!material.specularMap,
                    alphaMap: !!material.alphaMap,

                    gradientMap: !!material.gradientMap,

                    combine: material.combine,

                    vertexColors: material.vertexColors,

                    fog: !!fog,
                    useFog: material.fog,
                    fogExp: (fog && fog.isFogExp2),

                    flatShading: material.flatShading,

                    sizeAttenuation: material.sizeAttenuation,
                    logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

                    skinning: material.skinning && maxBones > 0,
                    maxBones: maxBones,
                    useVertexTexture: capabilities.floatVertexTextures,

                    morphTargets: material.morphTargets,
                    morphNormals: material.morphNormals,
                    maxMorphTargets: renderer.maxMorphTargets,
                    maxMorphNormals: renderer.maxMorphNormals,

                    numDirLights: lights.directional.length,
                    numPointLights: lights.point.length,
                    numSpotLights: lights.spot.length,
                    numRectAreaLights: lights.rectArea.length,
                    numHemiLights: lights.hemi.length,

                    numClippingPlanes: nClipPlanes,
                    numClipIntersection: nClipIntersection,

                    dithering: material.dithering,

                    shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
                    shadowMapType: renderer.shadowMap.type,

                    toneMapping: renderer.toneMapping,
                    physicallyCorrectLights: renderer.physicallyCorrectLights,

                    premultipliedAlpha: material.premultipliedAlpha,

                    alphaTest: material.alphaTest,
                    doubleSided: material.side === DoubleSide,
                    flipSided: material.side === BackSide,

                    depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false

                };

                return parameters;

            };

            this.getProgramCode = function (material, parameters) {

                var array = [];

                if (parameters.shaderID) {

                    array.push(parameters.shaderID);

                } else {

                    array.push(material.fragmentShader);
                    array.push(material.vertexShader);

                }

                if (material.defines !== undefined) {

                    for (var name in material.defines) {

                        array.push(name);
                        array.push(material.defines[name]);

                    }

                }

                for (var i = 0; i < parameterNames.length; i++) {

                    array.push(parameters[parameterNames[i]]);

                }

                array.push(material.onBeforeCompile.toString());

                array.push(renderer.gammaOutput);

                return array.join();

            };

            this.acquireProgram = function (material, shader, parameters, code) {

                var program;

                // Check if code has been already compiled
                for (var p = 0, pl = programs.length; p < pl; p++) {

                    var programInfo = programs[p];

                    if (programInfo.code === code) {

                        program = programInfo;
                        ++program.usedTimes;

                        break;

                    }

                }

                if (program === undefined) {

                    program = new WebGLProgram(renderer, extensions, code, material, shader, parameters);
                    programs.push(program);

                }

                return program;

            };

            this.releaseProgram = function (program) {

                if (--program.usedTimes === 0) {

                    // Remove from unordered set
                    var i = programs.indexOf(program);
                    programs[i] = programs[programs.length - 1];
                    programs.pop();

                    // Free WebGL resources
                    program.destroy();

                }

            };

            // Exposed for resource monitoring & error feedback via renderer.info:
            this.programs = programs;

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, infoMemory) {

            var _isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext);

            //

            function clampToMaxSize(image, maxSize) {

                if (image.width > maxSize || image.height > maxSize) {

                    // Warning: Scaling through the canvas will only work with images that use
                    // premultiplied alpha.

                    var scale = maxSize / Math.max(image.width, image.height);

                    var canvas = document.createElement('canvas');
                    canvas.width = Math.floor(image.width * scale);
                    canvas.height = Math.floor(image.height * scale);

                    var context = canvas.getContext('2d');
                    context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);

                    console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);

                    return canvas;

                }

                return image;

            }

            function isPowerOfTwo(image) {

                return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);

            }

            function makePowerOfTwo(image) {

                if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {

                    var canvas = document.createElement('canvas');
                    canvas.width = _Math.floorPowerOfTwo(image.width);
                    canvas.height = _Math.floorPowerOfTwo(image.height);

                    var context = canvas.getContext('2d');
                    context.drawImage(image, 0, 0, canvas.width, canvas.height);

                    console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);

                    return canvas;

                }

                return image;

            }

            function textureNeedsPowerOfTwo(texture) {

                return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) ||
                    (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter);

            }

            function textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {

                return texture.generateMipmaps && isPowerOfTwo &&
                    texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

            }

            // Fallback filters for non-power-of-2 textures

            function filterFallback(f) {

                if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {

                    return _gl.NEAREST;

                }

                return _gl.LINEAR;

            }

            //

            function onTextureDispose(event) {

                var texture = event.target;

                texture.removeEventListener('dispose', onTextureDispose);

                deallocateTexture(texture);

                infoMemory.textures--;


            }

            function onRenderTargetDispose(event) {

                var renderTarget = event.target;

                renderTarget.removeEventListener('dispose', onRenderTargetDispose);

                deallocateRenderTarget(renderTarget);

                infoMemory.textures--;

            }

            //

            function deallocateTexture(texture) {

                var textureProperties = properties.get(texture);

                if (texture.image && textureProperties.__image__webglTextureCube) {

                    // cube texture

                    _gl.deleteTexture(textureProperties.__image__webglTextureCube);

                } else {

                    // 2D texture

                    if (textureProperties.__webglInit === undefined) return;

                    _gl.deleteTexture(textureProperties.__webglTexture);

                }

                // remove all webgl properties
                properties.remove(texture);

            }

            function deallocateRenderTarget(renderTarget) {

                var renderTargetProperties = properties.get(renderTarget);
                var textureProperties = properties.get(renderTarget.texture);

                if (!renderTarget) return;

                if (textureProperties.__webglTexture !== undefined) {

                    _gl.deleteTexture(textureProperties.__webglTexture);

                }

                if (renderTarget.depthTexture) {

                    renderTarget.depthTexture.dispose();

                }

                if (renderTarget.isWebGLRenderTargetCube) {

                    for (var i = 0; i < 6; i++) {

                        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);

                    }

                } else {

                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                    if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);

                }

                properties.remove(renderTarget.texture);
                properties.remove(renderTarget);

            }

            //


            function setTexture2D(texture, slot) {

                var textureProperties = properties.get(texture);

                if (texture.version > 0 && textureProperties.__version !== texture.version) {

                    var image = texture.image;

                    if (image === undefined) {

                        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);

                    } else if (image.complete === false) {

                        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);

                    } else {

                        uploadTexture(textureProperties, texture, slot);
                        return;

                    }

                }

                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);

            }

            function setTextureCube(texture, slot) {

                var textureProperties = properties.get(texture);

                if (texture.image.length === 6) {

                    if (texture.version > 0 && textureProperties.__version !== texture.version) {

                        if (!textureProperties.__image__webglTextureCube) {

                            texture.addEventListener('dispose', onTextureDispose);

                            textureProperties.__image__webglTextureCube = _gl.createTexture();

                            infoMemory.textures++;

                        }

                        state.activeTexture(_gl.TEXTURE0 + slot);
                        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);

                        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

                        var isCompressed = (texture && texture.isCompressedTexture);
                        var isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);

                        var cubeImage = [];

                        for (var i = 0; i < 6; i++) {

                            if (!isCompressed && !isDataTexture) {

                                cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);

                            } else {

                                cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];

                            }

                        }

                        var image = cubeImage[0],
                            isPowerOfTwoImage = isPowerOfTwo(image),
                            glFormat = utils.convert(texture.format),
                            glType = utils.convert(texture.type);
                        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);

                        for (var i = 0; i < 6; i++) {

                            if (!isCompressed) {

                                if (isDataTexture) {

                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

                                } else {

                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);

                                }

                            } else {

                                var mipmap, mipmaps = cubeImage[i].mipmaps;

                                for (var j = 0, jl = mipmaps.length; j < jl; j++) {

                                    mipmap = mipmaps[j];

                                    if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {

                                        if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {

                                            state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);

                                        } else {

                                            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');

                                        }

                                    } else {

                                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);

                                    }

                                }

                            }

                        }

                        if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {

                            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);

                        }

                        textureProperties.__version = texture.version;

                        if (texture.onUpdate) texture.onUpdate(texture);

                    } else {

                        state.activeTexture(_gl.TEXTURE0 + slot);
                        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);

                    }

                }

            }

            function setTextureCubeDynamic(texture, slot) {

                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);

            }

            function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
                //console.log('cnmmmmmmmmmmmbbb', textureType, texture);
                var extension;

                if (isPowerOfTwoImage) {

                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, utils.convert(texture.wrapS));
                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, utils.convert(texture.wrapT));

                    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, utils.convert(texture.magFilter));
                    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, utils.convert(texture.minFilter));

                } else {

                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

                    if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {

                        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);

                    }

                    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
                    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
                    if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                        texture.minFilter = LinearFilter;
                    }
                    if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);

                    }

                }

                extension = extensions.get('EXT_texture_filter_anisotropic');

                if (extension) {

                    if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
                    if (texture.type === HalfFloatType && extensions.get('OES_texture_half_float_linear') === null) return;

                    if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {

                        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                        properties.get(texture).__currentAnisotropy = texture.anisotropy;

                    }

                }

            }

            function uploadTexture(textureProperties, texture, slot) {

                if (textureProperties.__webglInit === undefined) {

                    textureProperties.__webglInit = true;

                    texture.addEventListener('dispose', onTextureDispose);

                    textureProperties.__webglTexture = _gl.createTexture();

                    infoMemory.textures++;

                }

                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);

                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
                _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

                var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);

                if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {

                    image = makePowerOfTwo(image);

                }

                var isPowerOfTwoImage = isPowerOfTwo(image),
                    glFormat = utils.convert(texture.format),
                    glType = utils.convert(texture.type);
                setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);

                var mipmap, mipmaps = texture.mipmaps;

                if (texture.isDepthTexture) {

                    // populate depth texture with dummy data

                    var internalFormat = _gl.DEPTH_COMPONENT;

                    if (texture.type === FloatType) {

                        if (!_isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
                        internalFormat = _gl.DEPTH_COMPONENT32F;

                    } else if (_isWebGL2) {

                        // WebGL 2.0 requires signed internalformat for glTexImage2D
                        internalFormat = _gl.DEPTH_COMPONENT16;

                    }

                    if (texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT) {

                        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {

                            console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');

                            texture.type = UnsignedShortType;
                            glType = utils.convert(texture.type);

                        }

                    }

                    // Depth stencil textures need the DEPTH_STENCIL internal format
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if (texture.format === DepthStencilFormat) {

                        internalFormat = _gl.DEPTH_STENCIL;

                        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                        if (texture.type !== UnsignedInt248Type) {

                            console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');

                            texture.type = UnsignedInt248Type;
                            glType = utils.convert(texture.type);

                        }

                    }

                    state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);

                } else if (texture.isDataTexture) {

                    // use manually created mipmaps if available
                    // if there are no manual mipmaps
                    // set 0 level mipmap and then use GL to generate other mipmap levels

                    if (mipmaps.length > 0 && isPowerOfTwoImage) {

                        for (var i = 0, il = mipmaps.length; i < il; i++) {

                            mipmap = mipmaps[i];
                            state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);

                        }

                        texture.generateMipmaps = false;

                    } else {

                        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);

                    }

                } else if (texture.isCompressedTexture) {

                    for (var i = 0, il = mipmaps.length; i < il; i++) {

                        mipmap = mipmaps[i];

                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {

                            if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {

                                state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);

                            } else {

                                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');

                            }

                        } else {

                            state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);

                        }

                    }

                } else {

                    // regular Texture (image, video, canvas)

                    // use manually created mipmaps if available
                    // if there are no manual mipmaps
                    // set 0 level mipmap and then use GL to generate other mipmap levels

                    if (mipmaps.length > 0 && isPowerOfTwoImage) {

                        for (var i = 0, il = mipmaps.length; i < il; i++) {

                            mipmap = mipmaps[i];
                            state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);

                        }

                        texture.generateMipmaps = false;

                    } else {

                        state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);

                    }

                }

                if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) _gl.generateMipmap(_gl.TEXTURE_2D);

                textureProperties.__version = texture.version;

                if (texture.onUpdate) texture.onUpdate(texture);

            }

            // Render targets

            // Setup storage for target texture and bind it to correct framebuffer
            function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {

                var glFormat = utils.convert(renderTarget.texture.format);
                var glType = utils.convert(renderTarget.texture.type);
                state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);

            }

            // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
            function setupRenderBufferStorage(renderbuffer, renderTarget) {

                _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

                if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {

                    _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);

                } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {

                    _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);

                } else {

                    // FIXME: We don't support !depth !stencil
                    _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);

                }

                _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

            }

            // Setup resources for a Depth Texture for a FBO (needs an extension)
            function setupDepthTexture(framebuffer, renderTarget) {

                var isCube = (renderTarget && renderTarget.isWebGLRenderTargetCube);
                if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

                if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {

                    throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

                }

                // upload an empty depth texture with framebuffer size
                if (!properties.get(renderTarget.depthTexture).__webglTexture ||
                    renderTarget.depthTexture.image.width !== renderTarget.width ||
                    renderTarget.depthTexture.image.height !== renderTarget.height) {

                    renderTarget.depthTexture.image.width = renderTarget.width;
                    renderTarget.depthTexture.image.height = renderTarget.height;
                    renderTarget.depthTexture.needsUpdate = true;

                }

                setTexture2D(renderTarget.depthTexture, 0);

                var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

                if (renderTarget.depthTexture.format === DepthFormat) {

                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);

                } else if (renderTarget.depthTexture.format === DepthStencilFormat) {

                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);

                } else {

                    throw new Error('Unknown depthTexture format');

                }

            }

            // Setup GL resources for a non-texture depth buffer
            function setupDepthRenderbuffer(renderTarget) {

                var renderTargetProperties = properties.get(renderTarget);

                var isCube = (renderTarget.isWebGLRenderTargetCube === true);

                if (renderTarget.depthTexture) {

                    if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');

                    setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);

                } else {

                    if (isCube) {

                        renderTargetProperties.__webglDepthbuffer = [];

                        for (var i = 0; i < 6; i++) {

                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);

                        }

                    } else {

                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);

                    }

                }

                _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);

            }

            // Set up GL resources for the render target
            function setupRenderTarget(renderTarget) {

                var renderTargetProperties = properties.get(renderTarget);
                var textureProperties = properties.get(renderTarget.texture);

                renderTarget.addEventListener('dispose', onRenderTargetDispose);

                textureProperties.__webglTexture = _gl.createTexture();

                infoMemory.textures++;

                var isCube = (renderTarget.isWebGLRenderTargetCube === true);
                var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);

                // Setup framebuffer

                if (isCube) {

                    renderTargetProperties.__webglFramebuffer = [];

                    for (var i = 0; i < 6; i++) {

                        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();

                    }

                } else {

                    renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

                }

                // Setup color buffer

                if (isCube) {

                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                    setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);

                    for (var i = 0; i < 6; i++) {

                        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);

                    }

                    if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);

                } else {

                    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                    setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);

                    if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) _gl.generateMipmap(_gl.TEXTURE_2D);
                    state.bindTexture(_gl.TEXTURE_2D, null);

                }

                // Setup depth and stencil buffers

                if (renderTarget.depthBuffer) {

                    setupDepthRenderbuffer(renderTarget);

                }

            }

            function updateRenderTargetMipmap(renderTarget) {

                var texture = renderTarget.texture;
                var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);

                if (textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {

                    var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                    var webglTexture = properties.get(texture).__webglTexture;

                    state.bindTexture(target, webglTexture);
                    _gl.generateMipmap(target);
                    state.bindTexture(target, null);

                }

            }

            this.setTexture2D = setTexture2D;
            this.setTextureCube = setTextureCube;
            this.setTextureCubeDynamic = setTextureCubeDynamic;
            this.setupRenderTarget = setupRenderTarget;
            this.updateRenderTargetMipmap = updateRenderTargetMipmap;

        }

        /**
         * @author fordacious / fordacious.github.io
         */

        function WebGLProperties() {

            var properties = {};

            function get(object) {

                var uuid = object.uuid;
                var map = properties[uuid];

                if (map === undefined) {

                    map = {};
                    properties[uuid] = map;

                }

                return map;

            }

            function remove(object) {

                delete properties[object.uuid];

            }

            function clear() {

                properties = {};

            }

            return {
                get: get,
                remove: remove,
                clear: clear
            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLState(gl, extensions, utils) {

            function ColorBuffer() {

                var locked = false;

                var color = new Vector4();
                var currentColorMask = null;
                var currentColorClear = new Vector4(0, 0, 0, 0);

                return {

                    setMask: function (colorMask) {

                        if (currentColorMask !== colorMask && !locked) {

                            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                            currentColorMask = colorMask;

                        }

                    },

                    setLocked: function (lock) {

                        locked = lock;

                    },

                    setClear: function (r, g, b, a, premultipliedAlpha) {

                        if (premultipliedAlpha === true) {

                            r *= a;
                            g *= a;
                            b *= a;

                        }

                        color.set(r, g, b, a);

                        if (currentColorClear.equals(color) === false) {

                            gl.clearColor(r, g, b, a);
                            currentColorClear.copy(color);

                        }

                    },

                    reset: function () {

                        locked = false;

                        currentColorMask = null;
                        currentColorClear.set(-1, 0, 0, 0); // set to invalid state

                    }

                };

            }

            function DepthBuffer() {

                var locked = false;

                var currentDepthMask = null;
                var currentDepthFunc = null;
                var currentDepthClear = null;

                return {

                    setTest: function (depthTest) {

                        if (depthTest) {

                            enable(gl.DEPTH_TEST);

                        } else {

                            disable(gl.DEPTH_TEST);

                        }

                    },

                    setMask: function (depthMask) {

                        if (currentDepthMask !== depthMask && !locked) {

                            gl.depthMask(depthMask);
                            currentDepthMask = depthMask;

                        }

                    },

                    setFunc: function (depthFunc) {

                        if (currentDepthFunc !== depthFunc) {

                            if (depthFunc) {

                                switch (depthFunc) {

                                    case NeverDepth:

                                        gl.depthFunc(gl.NEVER);
                                        break;

                                    case AlwaysDepth:

                                        gl.depthFunc(gl.ALWAYS);
                                        break;

                                    case LessDepth:

                                        gl.depthFunc(gl.LESS);
                                        break;

                                    case LessEqualDepth:

                                        gl.depthFunc(gl.LEQUAL);
                                        break;

                                    case EqualDepth:

                                        gl.depthFunc(gl.EQUAL);
                                        break;

                                    case GreaterEqualDepth:

                                        gl.depthFunc(gl.GEQUAL);
                                        break;

                                    case GreaterDepth:

                                        gl.depthFunc(gl.GREATER);
                                        break;

                                    case NotEqualDepth:

                                        gl.depthFunc(gl.NOTEQUAL);
                                        break;

                                    default:

                                        gl.depthFunc(gl.LEQUAL);

                                }

                            } else {

                                gl.depthFunc(gl.LEQUAL);

                            }

                            currentDepthFunc = depthFunc;

                        }

                    },

                    setLocked: function (lock) {

                        locked = lock;

                    },

                    setClear: function (depth) {

                        if (currentDepthClear !== depth) {

                            gl.clearDepth(depth);
                            currentDepthClear = depth;

                        }

                    },

                    reset: function () {

                        locked = false;

                        currentDepthMask = null;
                        currentDepthFunc = null;
                        currentDepthClear = null;

                    }

                };

            }

            function StencilBuffer() {

                var locked = false;

                var currentStencilMask = null;
                var currentStencilFunc = null;
                var currentStencilRef = null;
                var currentStencilFuncMask = null;
                var currentStencilFail = null;
                var currentStencilZFail = null;
                var currentStencilZPass = null;
                var currentStencilClear = null;

                return {

                    setTest: function (stencilTest) {

                        if (stencilTest) {

                            enable(gl.STENCIL_TEST);

                        } else {

                            disable(gl.STENCIL_TEST);

                        }

                    },

                    setMask: function (stencilMask) {

                        if (currentStencilMask !== stencilMask && !locked) {

                            gl.stencilMask(stencilMask);
                            currentStencilMask = stencilMask;

                        }

                    },

                    setFunc: function (stencilFunc, stencilRef, stencilMask) {

                        if (currentStencilFunc !== stencilFunc ||
                            currentStencilRef !== stencilRef ||
                            currentStencilFuncMask !== stencilMask) {

                            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);

                            currentStencilFunc = stencilFunc;
                            currentStencilRef = stencilRef;
                            currentStencilFuncMask = stencilMask;

                        }

                    },

                    setOp: function (stencilFail, stencilZFail, stencilZPass) {

                        if (currentStencilFail !== stencilFail ||
                            currentStencilZFail !== stencilZFail ||
                            currentStencilZPass !== stencilZPass) {

                            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);

                            currentStencilFail = stencilFail;
                            currentStencilZFail = stencilZFail;
                            currentStencilZPass = stencilZPass;

                        }

                    },

                    setLocked: function (lock) {

                        locked = lock;

                    },

                    setClear: function (stencil) {

                        if (currentStencilClear !== stencil) {

                            gl.clearStencil(stencil);
                            currentStencilClear = stencil;

                        }

                    },

                    reset: function () {

                        locked = false;

                        currentStencilMask = null;
                        currentStencilFunc = null;
                        currentStencilRef = null;
                        currentStencilFuncMask = null;
                        currentStencilFail = null;
                        currentStencilZFail = null;
                        currentStencilZPass = null;
                        currentStencilClear = null;

                    }

                };

            }

            //

            var colorBuffer = new ColorBuffer();
            var depthBuffer = new DepthBuffer();
            var stencilBuffer = new StencilBuffer();

            var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            var newAttributes = new Uint8Array(maxVertexAttributes);
            var enabledAttributes = new Uint8Array(maxVertexAttributes);
            var attributeDivisors = new Uint8Array(maxVertexAttributes);

            var capabilities = {};

            var compressedTextureFormats = null;

            var currentProgram = null;

            var currentBlending = null;
            var currentBlendEquation = null;
            var currentBlendSrc = null;
            var currentBlendDst = null;
            var currentBlendEquationAlpha = null;
            var currentBlendSrcAlpha = null;
            var currentBlendDstAlpha = null;
            var currentPremultipledAlpha = false;

            var currentFlipSided = null;
            var currentCullFace = null;

            var currentLineWidth = null;

            var currentPolygonOffsetFactor = null;
            var currentPolygonOffsetUnits = null;

            var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);

            //var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
            //var lineWidthAvailable = parseFloat( version ) >= 1.0;
            var version = '1.0';
            var lineWidthAvailable = true;

            var currentTextureSlot = null;
            var currentBoundTextures = {};

            var currentScissor = new Vector4();
            var currentViewport = new Vector4();

            function createTexture(type, target, count) {

                var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
                var texture = gl.createTexture();

                gl.bindTexture(type, texture);
                gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

                for (var i = 0; i < count; i++) {

                    gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);

                }

                return texture;

            }

            var emptyTextures = {};
            emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
            emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);

            // init

            colorBuffer.setClear(0, 0, 0, 1);
            depthBuffer.setClear(1);
            stencilBuffer.setClear(0);

            enable(gl.DEPTH_TEST);
            depthBuffer.setFunc(LessEqualDepth);

            setFlipSided(false);
            setCullFace(CullFaceBack);
            enable(gl.CULL_FACE);

            enable(gl.BLEND);
            setBlending(NormalBlending);

            //

            function initAttributes() {

                for (var i = 0, l = newAttributes.length; i < l; i++) {

                    newAttributes[i] = 0;

                }

            }

            function enableAttribute(attribute) {

                newAttributes[attribute] = 1;

                if (enabledAttributes[attribute] === 0) {

                    gl.enableVertexAttribArray(attribute);
                    enabledAttributes[attribute] = 1;

                }

                if (attributeDivisors[attribute] !== 0) {

                    var extension = extensions.get('ANGLE_instanced_arrays');

                    extension.vertexAttribDivisorANGLE(attribute, 0);
                    attributeDivisors[attribute] = 0;

                }

            }

            function enableAttributeAndDivisor(attribute, meshPerAttribute) {

                newAttributes[attribute] = 1;

                if (enabledAttributes[attribute] === 0) {

                    gl.enableVertexAttribArray(attribute);
                    enabledAttributes[attribute] = 1;

                }

                if (attributeDivisors[attribute] !== meshPerAttribute) {

                    var extension = extensions.get('ANGLE_instanced_arrays');

                    extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
                    attributeDivisors[attribute] = meshPerAttribute;

                }

            }

            function disableUnusedAttributes() {

                for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {

                    if (enabledAttributes[i] !== newAttributes[i]) {

                        gl.disableVertexAttribArray(i);
                        enabledAttributes[i] = 0;

                    }

                }

            }

            function enable(id) {

                if (capabilities[id] !== true) {

                    gl.enable(id);
                    capabilities[id] = true;

                }

            }

            function disable(id) {

                if (capabilities[id] !== false) {

                    gl.disable(id);
                    capabilities[id] = false;

                }

            }

            function getCompressedTextureFormats() {

                if (compressedTextureFormats === null) {

                    compressedTextureFormats = [];

                    if (extensions.get('WEBGL_compressed_texture_pvrtc') ||
                        extensions.get('WEBGL_compressed_texture_s3tc') ||
                        extensions.get('WEBGL_compressed_texture_etc1')) {

                        var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);

                        for (var i = 0; i < formats.length; i++) {

                            compressedTextureFormats.push(formats[i]);

                        }

                    }

                }

                return compressedTextureFormats;

            }

            function useProgram(program) {

                if (currentProgram !== program) {

                    gl.useProgram(program);

                    currentProgram = program;

                    return true;

                }

                return false;

            }

            function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {

                if (blending !== NoBlending) {

                    enable(gl.BLEND);

                } else {

                    disable(gl.BLEND);

                }

                if (blending !== CustomBlending) {

                    if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {

                        switch (blending) {

                            case AdditiveBlending:

                                if (premultipliedAlpha) {

                                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);

                                } else {

                                    gl.blendEquation(gl.FUNC_ADD);
                                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

                                }
                                break;

                            case SubtractiveBlending:

                                if (premultipliedAlpha) {

                                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                    gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);

                                } else {

                                    gl.blendEquation(gl.FUNC_ADD);
                                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);

                                }
                                break;

                            case MultiplyBlending:

                                if (premultipliedAlpha) {

                                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                    gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);

                                } else {

                                    gl.blendEquation(gl.FUNC_ADD);
                                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR);

                                }
                                break;

                            default:

                                if (premultipliedAlpha) {

                                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

                                } else {

                                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

                                }

                        }

                    }

                    currentBlendEquation = null;
                    currentBlendSrc = null;
                    currentBlendDst = null;
                    currentBlendEquationAlpha = null;
                    currentBlendSrcAlpha = null;
                    currentBlendDstAlpha = null;

                } else {

                    blendEquationAlpha = blendEquationAlpha || blendEquation;
                    blendSrcAlpha = blendSrcAlpha || blendSrc;
                    blendDstAlpha = blendDstAlpha || blendDst;

                    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {

                        gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));

                        currentBlendEquation = blendEquation;
                        currentBlendEquationAlpha = blendEquationAlpha;

                    }

                    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {

                        gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));

                        currentBlendSrc = blendSrc;
                        currentBlendDst = blendDst;
                        currentBlendSrcAlpha = blendSrcAlpha;
                        currentBlendDstAlpha = blendDstAlpha;

                    }

                }

                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;

            }

            function setMaterial(material) {

                material.side === DoubleSide
                    ? disable(gl.CULL_FACE)
                    : enable(gl.CULL_FACE);

                setFlipSided(material.side === BackSide);

                material.transparent === true
                    ? setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha)
                    : setBlending(NoBlending);

                depthBuffer.setFunc(material.depthFunc);
                depthBuffer.setTest(material.depthTest);
                depthBuffer.setMask(material.depthWrite);
                colorBuffer.setMask(material.colorWrite);

                setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);

            }

            //

            function setFlipSided(flipSided) {

                if (currentFlipSided !== flipSided) {

                    if (flipSided) {

                        gl.frontFace(gl.CW);

                    } else {

                        gl.frontFace(gl.CCW);

                    }

                    currentFlipSided = flipSided;

                }

            }

            function setCullFace(cullFace) {

                if (cullFace !== CullFaceNone) {

                    enable(gl.CULL_FACE);

                    if (cullFace !== currentCullFace) {

                        if (cullFace === CullFaceBack) {

                            gl.cullFace(gl.BACK);

                        } else if (cullFace === CullFaceFront) {

                            gl.cullFace(gl.FRONT);

                        } else {

                            gl.cullFace(gl.FRONT_AND_BACK);

                        }

                    }

                } else {

                    disable(gl.CULL_FACE);

                }

                currentCullFace = cullFace;

            }

            function setLineWidth(width) {

                if (width !== currentLineWidth) {

                    if (lineWidthAvailable) gl.lineWidth(width);

                    currentLineWidth = width;

                }

            }

            function setPolygonOffset(polygonOffset, factor, units) {

                if (polygonOffset) {

                    enable(gl.POLYGON_OFFSET_FILL);

                    if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {

                        gl.polygonOffset(factor, units);

                        currentPolygonOffsetFactor = factor;
                        currentPolygonOffsetUnits = units;

                    }

                } else {

                    disable(gl.POLYGON_OFFSET_FILL);

                }

            }

            function setScissorTest(scissorTest) {

                if (scissorTest) {

                    enable(gl.SCISSOR_TEST);

                } else {

                    disable(gl.SCISSOR_TEST);

                }

            }

            // texture

            function activeTexture(webglSlot) {

                if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

                if (currentTextureSlot !== webglSlot) {

                    gl.activeTexture(webglSlot);
                    currentTextureSlot = webglSlot;

                }

            }

            function bindTexture(webglType, webglTexture) {

                if (currentTextureSlot === null) {

                    activeTexture();

                }

                var boundTexture = currentBoundTextures[currentTextureSlot];

                if (boundTexture === undefined) {

                    boundTexture = {type: undefined, texture: undefined};
                    currentBoundTextures[currentTextureSlot] = boundTexture;

                }

                if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {

                    gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);

                    boundTexture.type = webglType;
                    boundTexture.texture = webglTexture;

                }

            }

            function compressedTexImage2D() {

                try {

                    gl.compressedTexImage2D.apply(gl, arguments);

                } catch (error) {

                    console.error('THREE.WebGLState:', error);

                }

            }

            function texImage2D() {

                try {

                    gl.texImage2D.apply(gl, arguments);

                } catch (error) {

                    console.error('THREE.WebGLState:', error);

                }

            }

            //

            function scissor(scissor) {

                if (currentScissor.equals(scissor) === false) {

                    gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                    currentScissor.copy(scissor);

                }

            }

            function viewport(viewport) {

                if (currentViewport.equals(viewport) === false) {
                    gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                    currentViewport.copy(viewport);

                }

            }

            //

            function reset() {

                for (var i = 0; i < enabledAttributes.length; i++) {

                    if (enabledAttributes[i] === 1) {

                        gl.disableVertexAttribArray(i);
                        enabledAttributes[i] = 0;

                    }

                }

                capabilities = {};

                compressedTextureFormats = null;

                currentTextureSlot = null;
                currentBoundTextures = {};

                currentProgram = null;

                currentBlending = null;

                currentFlipSided = null;
                currentCullFace = null;

                colorBuffer.reset();
                depthBuffer.reset();
                stencilBuffer.reset();

            }

            return {

                buffers: {
                    color: colorBuffer,
                    depth: depthBuffer,
                    stencil: stencilBuffer
                },

                initAttributes: initAttributes,
                enableAttribute: enableAttribute,
                enableAttributeAndDivisor: enableAttributeAndDivisor,
                disableUnusedAttributes: disableUnusedAttributes,
                enable: enable,
                disable: disable,
                getCompressedTextureFormats: getCompressedTextureFormats,

                useProgram: useProgram,

                setBlending: setBlending,
                setMaterial: setMaterial,

                setFlipSided: setFlipSided,
                setCullFace: setCullFace,

                setLineWidth: setLineWidth,
                setPolygonOffset: setPolygonOffset,

                setScissorTest: setScissorTest,

                activeTexture: activeTexture,
                bindTexture: bindTexture,
                compressedTexImage2D: compressedTexImage2D,
                texImage2D: texImage2D,

                scissor: scissor,
                viewport: viewport,

                reset: reset

            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLCapabilities(gl, extensions, parameters) {

            var maxAnisotropy;

            function getMaxAnisotropy() {

                if (maxAnisotropy !== undefined) return maxAnisotropy;

                var extension = extensions.get('EXT_texture_filter_anisotropic');

                if (extension !== null) {

                    maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);

                } else {

                    maxAnisotropy = 0;

                }

                return maxAnisotropy;

            }

            function getMaxPrecision(precision) {

                if (precision === 'highp') {

                    if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                        gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {

                        return 'highp';

                    }

                    precision = 'mediump';

                }

                if (precision === 'mediump') {

                    if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                        gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {

                        return 'mediump';

                    }

                }

                return 'lowp';

            }

            var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
            var maxPrecision = getMaxPrecision(precision);

            if (maxPrecision !== precision) {

                console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
                precision = maxPrecision;

            }

            var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

            var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);

            var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
            var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

            var vertexTextures = maxVertexTextures > 0;
            var floatFragmentTextures = !!extensions.get('OES_texture_float');
            var floatVertexTextures = vertexTextures && floatFragmentTextures;

            return {

                getMaxAnisotropy: getMaxAnisotropy,
                getMaxPrecision: getMaxPrecision,

                precision: precision,
                logarithmicDepthBuffer: logarithmicDepthBuffer,

                maxTextures: maxTextures,
                maxVertexTextures: maxVertexTextures,
                maxTextureSize: maxTextureSize,
                maxCubemapSize: maxCubemapSize,

                maxAttributes: maxAttributes,
                maxVertexUniforms: maxVertexUniforms,
                maxVaryings: maxVaryings,
                maxFragmentUniforms: maxFragmentUniforms,

                vertexTextures: vertexTextures,
                floatFragmentTextures: floatFragmentTextures,
                floatVertexTextures: floatVertexTextures

            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author greggman / http://games.greggman.com/
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * @author tschw
         */

        function PerspectiveCamera(fov, aspect, near, far) {

            Camera.call(this);

            this.type = 'PerspectiveCamera';

            this.fov = fov !== undefined ? fov : 50;
            this.zoom = 1;

            this.near = near !== undefined ? near : 0.1;
            this.far = far !== undefined ? far : 2000;
            this.focus = 10;

            this.aspect = aspect !== undefined ? aspect : 1;
            this.view = null;

            this.filmGauge = 35;	// width of the film (default in millimeters)
            this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

            this.updateProjectionMatrix();

        }

        PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {

            constructor: PerspectiveCamera,

            isPerspectiveCamera: true,

            copy: function (source, recursive) {

                Camera.prototype.copy.call(this, source, recursive);

                this.fov = source.fov;
                this.zoom = source.zoom;

                this.near = source.near;
                this.far = source.far;
                this.focus = source.focus;

                this.aspect = source.aspect;
                this.view = source.view === null ? null : Object.assign({}, source.view);

                this.filmGauge = source.filmGauge;
                this.filmOffset = source.filmOffset;

                return this;

            },

            /**
             * Sets the FOV by focal length in respect to the current .filmGauge.
             *
             * The default film gauge is 35, so that the focal length can be specified for
             * a 35mm (full frame) camera.
             *
             * Values for focal length and film gauge must have the same unit.
             */
            setFocalLength: function (focalLength) {

                // see http://www.bobatkins.com/photography/technical/field_of_view.html
                var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

                this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
                this.updateProjectionMatrix();

            },

            /**
             * Calculates the focal length from the current .fov and .filmGauge.
             */
            getFocalLength: function () {

                var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);

                return 0.5 * this.getFilmHeight() / vExtentSlope;

            },

            getEffectiveFOV: function () {

                return _Math.RAD2DEG * 2 * Math.atan(
                    Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);

            },

            getFilmWidth: function () {

                // film not completely covered in portrait format (aspect < 1)
                return this.filmGauge * Math.min(this.aspect, 1);

            },

            getFilmHeight: function () {

                // film not completely covered in landscape format (aspect > 1)
                return this.filmGauge / Math.max(this.aspect, 1);

            },

            /**
             * Sets an offset in a larger frustum. This is useful for multi-window or
             * multi-monitor/multi-machine setups.
             *
             * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
             * the monitors are in grid like this
             *
             *   +---+---+---+
             *   | A | B | C |
             *   +---+---+---+
             *   | D | E | F |
             *   +---+---+---+
             *
             * then for each monitor you would call it like this
             *
             *   var w = 1920;
             *   var h = 1080;
             *   var fullWidth = w * 3;
             *   var fullHeight = h * 2;
             *
             *   --A--
             *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
             *   --B--
             *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
             *   --C--
             *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
             *   --D--
             *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
             *   --E--
             *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
             *   --F--
             *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
             *
             *   Note there is no reason monitors have to be the same size or in a grid.
             */
            setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {

                this.aspect = fullWidth / fullHeight;

                if (this.view === null) {

                    this.view = {
                        enabled: true,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    };

                }

                this.view.enabled = true;
                this.view.fullWidth = fullWidth;
                this.view.fullHeight = fullHeight;
                this.view.offsetX = x;
                this.view.offsetY = y;
                this.view.width = width;
                this.view.height = height;

                this.updateProjectionMatrix();

            },

            clearViewOffset: function () {

                if (this.view !== null) {

                    this.view.enabled = false;

                }

                this.updateProjectionMatrix();

            },

            updateProjectionMatrix: function () {

                var near = this.near,
                    top = near * Math.tan(
                        _Math.DEG2RAD * 0.5 * this.fov) / this.zoom,
                    height = 2 * top,
                    width = this.aspect * height,
                    left = -0.5 * width,
                    view = this.view;

                if (this.view !== null && this.view.enabled) {

                    var fullWidth = view.fullWidth,
                        fullHeight = view.fullHeight;

                    left += view.offsetX * width / fullWidth;
                    top -= view.offsetY * height / fullHeight;
                    width *= view.width / fullWidth;
                    height *= view.height / fullHeight;

                }

                var skew = this.filmOffset;
                if (skew !== 0) left += near * skew / this.getFilmWidth();

                this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);

            },

            toJSON: function (meta) {

                var data = Object3D.prototype.toJSON.call(this, meta);

                data.object.fov = this.fov;
                data.object.zoom = this.zoom;

                data.object.near = this.near;
                data.object.far = this.far;
                data.object.focus = this.focus;

                data.object.aspect = this.aspect;

                if (this.view !== null) data.object.view = Object.assign({}, this.view);

                data.object.filmGauge = this.filmGauge;
                data.object.filmOffset = this.filmOffset;

                return data;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function ArrayCamera(array) {

            PerspectiveCamera.call(this);

            this.cameras = array || [];

        }

        ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {

            constructor: ArrayCamera,

            isArrayCamera: true

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebVRManager(renderer) {

            var scope = this;

            var device = null;
            var frameData = null;

            if (typeof window !== 'undefined' && 'VRFrameData' in window) {

                frameData = new window.VRFrameData();

            }

            var matrixWorldInverse = new Matrix4();

            var standingMatrix = new Matrix4();
            var standingMatrixInverse = new Matrix4();

            var cameraL = new PerspectiveCamera();
            cameraL.bounds = new Vector4(0.0, 0.0, 0.5, 1.0);
            cameraL.layers.enable(1);

            var cameraR = new PerspectiveCamera();
            cameraR.bounds = new Vector4(0.5, 0.0, 0.5, 1.0);
            cameraR.layers.enable(2);

            var cameraVR = new ArrayCamera([cameraL, cameraR]);
            cameraVR.layers.enable(1);
            cameraVR.layers.enable(2);

            //

            var currentSize, currentPixelRatio;

            function onVRDisplayPresentChange() {

                if (device !== null && device.isPresenting) {

                    var eyeParameters = device.getEyeParameters('left');
                    var renderWidth = eyeParameters.renderWidth;
                    var renderHeight = eyeParameters.renderHeight;

                    currentPixelRatio = renderer.getPixelRatio();
                    currentSize = renderer.getSize();

                    renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);

                } else if (scope.enabled) {

                    renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);

                }

            }

            if (typeof window !== 'undefined') {

                window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);

            }

            //

            this.enabled = false;
            this.standing = false;

            this.getDevice = function () {

                return device;

            };

            this.setDevice = function (value) {

                if (value !== undefined) device = value;

            };

            this.getCamera = function (camera) {

                if (device === null) return camera;

                device.depthNear = camera.near;
                device.depthFar = camera.far;

                device.getFrameData(frameData);

                //

                var pose = frameData.pose;

                if (pose.position !== null) {

                    camera.position.fromArray(pose.position);

                } else {

                    camera.position.set(0, 0, 0);

                }

                if (pose.orientation !== null) {

                    camera.quaternion.fromArray(pose.orientation);

                }

                camera.updateMatrixWorld();

                var stageParameters = device.stageParameters;

                if (this.standing && stageParameters) {

                    standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
                    standingMatrixInverse.getInverse(standingMatrix);

                    camera.matrixWorld.multiply(standingMatrix);
                    camera.matrixWorldInverse.multiply(standingMatrixInverse);

                }

                if (device.isPresenting === false) return camera;

                //

                cameraL.near = camera.near;
                cameraR.near = camera.near;

                cameraL.far = camera.far;
                cameraR.far = camera.far;

                cameraVR.matrixWorld.copy(camera.matrixWorld);
                cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);

                cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
                cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);

                if (this.standing && stageParameters) {

                    cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
                    cameraR.matrixWorldInverse.multiply(standingMatrixInverse);

                }

                var parent = camera.parent;

                if (parent !== null) {

                    matrixWorldInverse.getInverse(parent.matrixWorld);

                    cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
                    cameraR.matrixWorldInverse.multiply(matrixWorldInverse);

                }

                // envMap and Mirror needs camera.matrixWorld

                cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
                cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);

                cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
                cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);

                // HACK @mrdoob
                // https://github.com/w3c/webvr/issues/203

                cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);

                //

                var layers = device.getLayers();

                if (layers.length) {

                    var layer = layers[0];

                    if (layer.leftBounds !== null && layer.leftBounds.length === 4) {

                        cameraL.bounds.fromArray(layer.leftBounds);

                    }

                    if (layer.rightBounds !== null && layer.rightBounds.length === 4) {

                        cameraR.bounds.fromArray(layer.rightBounds);

                    }

                }

                return cameraVR;

            };

            this.getStandingMatrix = function () {

                return standingMatrix;

            };

            this.submitFrame = function () {

                if (device && device.isPresenting) device.submitFrame();

            };

            this.dispose = function () {

                window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);

            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function WebGLExtensions(gl) {

            var extensions = {};

            return {

                get: function (name) {

                    if (extensions[name] !== undefined) {

                        return extensions[name];

                    }

                    var extension;

                    switch (name) {

                        case 'WEBGL_depth_texture':
                            extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                            break;

                        case 'EXT_texture_filter_anisotropic':
                            extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                            break;

                        case 'WEBGL_compressed_texture_s3tc':
                            extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                            break;

                        case 'WEBGL_compressed_texture_pvrtc':
                            extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                            break;

                        case 'WEBGL_compressed_texture_etc1':
                            extension = gl.getExtension('WEBGL_compressed_texture_etc1');
                            break;

                        default:
                            extension = gl.getExtension(name);

                    }

                    if (extension === null) {

                        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');

                    }

                    extensions[name] = extension;

                    return extension;

                }

            };

        }

        /**
         * @author tschw
         */

        function WebGLClipping() {

            var scope = this,

                globalState = null,
                numGlobalPlanes = 0,
                localClippingEnabled = false,
                renderingShadows = false,

                plane = new Plane(),
                viewNormalMatrix = new Matrix3(),

                uniform = {value: null, needsUpdate: false};

            this.uniform = uniform;
            this.numPlanes = 0;
            this.numIntersection = 0;

            this.init = function (planes, enableLocalClipping, camera) {

                var enabled =
                    planes.length !== 0 ||
                    enableLocalClipping ||
                    // enable state of previous frame - the clipping code has to
                    // run another frame in order to reset the state:
                    numGlobalPlanes !== 0 ||
                    localClippingEnabled;

                localClippingEnabled = enableLocalClipping;

                globalState = projectPlanes(planes, camera, 0);
                numGlobalPlanes = planes.length;

                return enabled;

            };

            this.beginShadows = function () {

                renderingShadows = true;
                projectPlanes(null);

            };

            this.endShadows = function () {

                renderingShadows = false;
                resetGlobalState();

            };

            this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {

                if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {

                    // there's no local clipping

                    if (renderingShadows) {

                        // there's no global clipping

                        projectPlanes(null);

                    } else {

                        resetGlobalState();

                    }

                } else {

                    var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                        lGlobal = nGlobal * 4,

                        dstArray = cache.clippingState || null;

                    uniform.value = dstArray; // ensure unique state

                    dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

                    for (var i = 0; i !== lGlobal; ++i) {

                        dstArray[i] = globalState[i];

                    }

                    cache.clippingState = dstArray;
                    this.numIntersection = clipIntersection ? this.numPlanes : 0;
                    this.numPlanes += nGlobal;

                }


            };

            function resetGlobalState() {

                if (uniform.value !== globalState) {

                    uniform.value = globalState;
                    uniform.needsUpdate = numGlobalPlanes > 0;

                }

                scope.numPlanes = numGlobalPlanes;
                scope.numIntersection = 0;

            }

            function projectPlanes(planes, camera, dstOffset, skipTransform) {

                var nPlanes = planes !== null ? planes.length : 0,
                    dstArray = null;

                if (nPlanes !== 0) {

                    dstArray = uniform.value;

                    if (skipTransform !== true || dstArray === null) {

                        var flatSize = dstOffset + nPlanes * 4,
                            viewMatrix = camera.matrixWorldInverse;

                        viewNormalMatrix.getNormalMatrix(viewMatrix);

                        if (dstArray === null || dstArray.length < flatSize) {

                            dstArray = new Float32Array(flatSize);

                        }

                        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {

                            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);

                            plane.normal.toArray(dstArray, i4);
                            dstArray[i4 + 3] = plane.constant;

                        }

                    }

                    uniform.value = dstArray;
                    uniform.needsUpdate = true;

                }

                scope.numPlanes = nPlanes;

                return dstArray;

            }

        }

        /**
         * @author thespite / http://www.twitter.com/thespite
         */

        function WebGLUtils(gl, extensions) {

            function convert(p) {

                var extension;

                if (p === RepeatWrapping) return gl.REPEAT;
                if (p === ClampToEdgeWrapping) return gl.CLAMP_TO_EDGE;
                if (p === MirroredRepeatWrapping) return gl.MIRRORED_REPEAT;

                if (p === NearestFilter) return gl.NEAREST;
                if (p === NearestMipMapNearestFilter) return gl.NEAREST_MIPMAP_NEAREST;
                if (p === NearestMipMapLinearFilter) return gl.NEAREST_MIPMAP_LINEAR;

                if (p === LinearFilter) return gl.LINEAR;
                if (p === LinearMipMapNearestFilter) return gl.LINEAR_MIPMAP_NEAREST;
                if (p === LinearMipMapLinearFilter) return gl.LINEAR_MIPMAP_LINEAR;

                if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
                if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
                if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
                if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;

                if (p === ByteType) return gl.BYTE;
                if (p === ShortType) return gl.SHORT;
                if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
                if (p === IntType) return gl.INT;
                if (p === UnsignedIntType) return gl.UNSIGNED_INT;
                if (p === FloatType) return gl.FLOAT;

                if (p === HalfFloatType) {

                    extension = extensions.get('OES_texture_half_float');

                    if (extension !== null) return extension.HALF_FLOAT_OES;

                }

                if (p === AlphaFormat) return gl.ALPHA;
                if (p === RGBFormat) return gl.RGB;
                if (p === RGBAFormat) return gl.RGBA;
                if (p === LuminanceFormat) return gl.LUMINANCE;
                if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
                if (p === DepthFormat) return gl.DEPTH_COMPONENT;
                if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;

                if (p === AddEquation) return gl.FUNC_ADD;
                if (p === SubtractEquation) return gl.FUNC_SUBTRACT;
                if (p === ReverseSubtractEquation) return gl.FUNC_REVERSE_SUBTRACT;

                if (p === ZeroFactor) return gl.ZERO;
                if (p === OneFactor) return gl.ONE;
                if (p === SrcColorFactor) return gl.SRC_COLOR;
                if (p === OneMinusSrcColorFactor) return gl.ONE_MINUS_SRC_COLOR;
                if (p === SrcAlphaFactor) return gl.SRC_ALPHA;
                if (p === OneMinusSrcAlphaFactor) return gl.ONE_MINUS_SRC_ALPHA;
                if (p === DstAlphaFactor) return gl.DST_ALPHA;
                if (p === OneMinusDstAlphaFactor) return gl.ONE_MINUS_DST_ALPHA;

                if (p === DstColorFactor) return gl.DST_COLOR;
                if (p === OneMinusDstColorFactor) return gl.ONE_MINUS_DST_COLOR;
                if (p === SrcAlphaSaturateFactor) return gl.SRC_ALPHA_SATURATE;

                if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
                    p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {

                    extension = extensions.get('WEBGL_compressed_texture_s3tc');

                    if (extension !== null) {

                        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                    }

                }

                if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
                    p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {

                    extension = extensions.get('WEBGL_compressed_texture_pvrtc');

                    if (extension !== null) {

                        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                    }

                }

                if (p === RGB_ETC1_Format) {

                    extension = extensions.get('WEBGL_compressed_texture_etc1');

                    if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;

                }

                if (p === MinEquation || p === MaxEquation) {

                    extension = extensions.get('EXT_blend_minmax');

                    if (extension !== null) {

                        if (p === MinEquation) return extension.MIN_EXT;
                        if (p === MaxEquation) return extension.MAX_EXT;

                    }

                }

                if (p === UnsignedInt248Type) {

                    extension = extensions.get('WEBGL_depth_texture');

                    if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;

                }

                return 0;

            }

            return {convert: convert};

        }

        /**
         * @author supereggbert / http://www.paulbrunt.co.uk/
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         * @author szimek / https://github.com/szimek/
         * @author tschw
         */

        function WebGLRenderer(parameters) {

            console.log('THREE.WebGLRenderer', REVISION);

            parameters = parameters || {};

            var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'),
                _context = parameters.context !== undefined ? parameters.context : null,

                _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
                _depth = parameters.depth !== undefined ? parameters.depth : true,
                _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
                _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
                _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
                _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

            var lightsArray = [];
            var shadowsArray = [];

            var currentRenderList = null;

            var spritesArray = [];
            var flaresArray = [];

            // public properties

            this.domElement = _canvas;
            this.context = null;

            // clearing

            this.autoClear = true;
            this.autoClearColor = true;
            this.autoClearDepth = true;
            this.autoClearStencil = true;

            // scene graph

            this.sortObjects = true;

            // user-defined clipping

            this.clippingPlanes = [];
            this.localClippingEnabled = false;

            // physically based shading

            this.gammaFactor = 2.0;	// for backwards compatibility
            this.gammaInput = false;
            this.gammaOutput = false;

            // physical lights

            this.physicallyCorrectLights = false;

            // tone mapping

            this.toneMapping = LinearToneMapping;
            this.toneMappingExposure = 1.0;
            this.toneMappingWhitePoint = 1.0;

            // morphs

            this.maxMorphTargets = 8;
            this.maxMorphNormals = 4;

            // internal properties

            var _this = this,

                _isContextLost = false,

                // internal state cache

                _currentRenderTarget = null,
                _currentFramebuffer = null,
                _currentMaterialId = -1,
                _currentGeometryProgram = '',

                _currentCamera = null,
                _currentArrayCamera = null,

                _currentViewport = new Vector4(),
                _currentScissor = new Vector4(),
                _currentScissorTest = null,

                //

                _usedTextureUnits = 0,

                //

                _width = _canvas.width,
                _height = _canvas.height,

                _pixelRatio = 1,

                _viewport = new Vector4(0, 0, _width, _height),
                _scissor = new Vector4(0, 0, _width, _height),
                _scissorTest = false,

                // frustum

                _frustum = new Frustum(),

                // clipping

                _clipping = new WebGLClipping(),
                _clippingEnabled = false,
                _localClippingEnabled = false,

                // camera matrices cache

                _projScreenMatrix = new Matrix4(),

                _vector3 = new Vector3(),

                // info

                _infoMemory = {
                    geometries: 0,
                    textures: 0
                },

                _infoRender = {

                    frame: 0,
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0

                };

            this.info = {

                render: _infoRender,
                memory: _infoMemory,
                programs: null

            };

            function getTargetPixelRatio() {

                return _currentRenderTarget === null ? _pixelRatio : 1;

            }

            // initialize

            var _gl;

            try {

                var contextAttributes = {
                    alpha: _alpha,
                    depth: _depth,
                    stencil: _stencil,
                    antialias: _antialias,
                    premultipliedAlpha: _premultipliedAlpha,
                    preserveDrawingBuffer: _preserveDrawingBuffer
                };

                _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

                if (_gl === null) {

                    if (_canvas.getContext('webgl') !== null) {

                        throw 'Error creating WebGL context with your selected attributes.';

                    } else {

                        throw 'Error creating WebGL context.';

                    }

                }

                // Some experimental-webgl implementations do not have getShaderPrecisionFormat

                if (_gl.getShaderPrecisionFormat === undefined) {

                    _gl.getShaderPrecisionFormat = function () {

                        return {'rangeMin': 1, 'rangeMax': 1, 'precision': 1};

                    };

                }

                _canvas.addEventListener('webglcontextlost', onContextLost, false);
                _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

            } catch (error) {

                console.error('THREE.WebGLRenderer: ' + error);

            }

            var extensions, capabilities, state;
            var properties, textures, attributes, geometries, objects, lights;
            var programCache, renderLists;

            var background, morphtargets, bufferRenderer, indexedBufferRenderer;
            var flareRenderer, spriteRenderer;

            var utils;

            function initGLContext() {

                extensions = new WebGLExtensions(_gl);
                extensions.get('WEBGL_depth_texture');
                extensions.get('OES_texture_float');
                extensions.get('OES_texture_float_linear');
                extensions.get('OES_texture_half_float');
                extensions.get('OES_texture_half_float_linear');
                extensions.get('OES_standard_derivatives');
                extensions.get('OES_element_index_uint');
                extensions.get('ANGLE_instanced_arrays');

                utils = new WebGLUtils(_gl, extensions);

                capabilities = new WebGLCapabilities(_gl, extensions, parameters);

                state = new WebGLState(_gl, extensions, utils);
                state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
                state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));

                properties = new WebGLProperties();
                textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, _infoMemory);
                attributes = new WebGLAttributes(_gl);
                geometries = new WebGLGeometries(_gl, attributes, _infoMemory);
                objects = new WebGLObjects(geometries, _infoRender);
                morphtargets = new WebGLMorphtargets(_gl);
                programCache = new WebGLPrograms(_this, extensions, capabilities);
                lights = new WebGLLights();
                renderLists = new WebGLRenderLists();

                background = new WebGLBackground(_this, state, geometries, _premultipliedAlpha);

                bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender);
                indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);

                flareRenderer = new WebGLFlareRenderer(_this, _gl, state, textures, capabilities);
                spriteRenderer = new WebGLSpriteRenderer(_this, _gl, state, textures, capabilities);

                _this.info.programs = programCache.programs;

                _this.context = _gl;
                _this.capabilities = capabilities;
                _this.extensions = extensions;
                _this.properties = properties;
                _this.renderLists = renderLists;
                _this.state = state;

            }

            initGLContext();

            // vr

            var vr = new WebVRManager(_this);

            this.vr = vr;

            // shadow map

            var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);

            this.shadowMap = shadowMap;

            // API

            this.getContext = function () {

                return _gl;

            };

            this.getContextAttributes = function () {

                return _gl.getContextAttributes();

            };

            this.forceContextLoss = function () {

                var extension = extensions.get('WEBGL_lose_context');
                if (extension) extension.loseContext();

            };

            this.forceContextRestore = function () {

                var extension = extensions.get('WEBGL_lose_context');
                if (extension) extension.restoreContext();

            };

            this.getPixelRatio = function () {

                return _pixelRatio;

            };

            this.setPixelRatio = function (value) {

                if (value === undefined) return;

                _pixelRatio = value;

                this.setSize(_width, _height, false);

            };

            this.getSize = function () {

                return {
                    width: _width,
                    height: _height
                };

            };

            this.setSize = function (width, height, updateStyle) {

                var device = vr.getDevice();

                if (device && device.isPresenting) {

                    console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                    return;

                }

                _width = width;
                _height = height;

                _canvas.width = width * _pixelRatio;
                _canvas.height = height * _pixelRatio;

                if (updateStyle !== false) {

                    _canvas.style.width = width + 'px';
                    _canvas.style.height = height + 'px';

                }

                this.setViewport(0, 0, width, height);

            };

            this.getDrawingBufferSize = function () {

                return {
                    width: _width * _pixelRatio,
                    height: _height * _pixelRatio
                };

            };

            this.setDrawingBufferSize = function (width, height, pixelRatio) {

                _width = width;
                _height = height;

                _pixelRatio = pixelRatio;

                _canvas.width = width * pixelRatio;
                _canvas.height = height * pixelRatio;

                this.setViewport(0, 0, width, height);

            };

            this.setViewport = function (x, y, width, height) {

                _viewport.set(x, _height - y - height, width, height);
                state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));

            };

            this.setScissor = function (x, y, width, height) {

                _scissor.set(x, _height - y - height, width, height);
                state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));

            };

            this.setScissorTest = function (boolean) {

                state.setScissorTest(_scissorTest = boolean);

            };

            // Clearing

            this.getClearColor = function () {

                return background.getClearColor();

            };

            this.setClearColor = function () {

                background.setClearColor.apply(background, arguments);

            };

            this.getClearAlpha = function () {

                return background.getClearAlpha();

            };

            this.setClearAlpha = function () {

                background.setClearAlpha.apply(background, arguments);

            };

            this.clear = function (color, depth, stencil) {

                var bits = 0;

                if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
                if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
                if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

                _gl.clear(bits);

            };

            this.clearColor = function () {

                this.clear(true, false, false);

            };

            this.clearDepth = function () {

                this.clear(false, true, false);

            };

            this.clearStencil = function () {

                this.clear(false, false, true);

            };

            this.clearTarget = function (renderTarget, color, depth, stencil) {

                this.setRenderTarget(renderTarget);
                this.clear(color, depth, stencil);

            };

            //

            this.dispose = function () {

                _canvas.removeEventListener('webglcontextlost', onContextLost, false);
                _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

                renderLists.dispose();

                vr.dispose();

            };

            // Events

            function onContextLost(event) {

                event.preventDefault();

                console.log('THREE.WebGLRenderer: Context Lost.');

                _isContextLost = true;

            }

            function onContextRestore(/* event */) {

                console.log('THREE.WebGLRenderer: Context Restored.');

                _isContextLost = false;

                initGLContext();

            }

            function onMaterialDispose(event) {

                var material = event.target;

                material.removeEventListener('dispose', onMaterialDispose);

                deallocateMaterial(material);

            }

            // Buffer deallocation

            function deallocateMaterial(material) {

                releaseMaterialProgramReference(material);

                properties.remove(material);

            }


            function releaseMaterialProgramReference(material) {

                var programInfo = properties.get(material).program;

                material.program = undefined;

                if (programInfo !== undefined) {

                    programCache.releaseProgram(programInfo);

                }

            }

            // Buffer rendering

            function renderObjectImmediate(object, program, material) {

                object.render(function (object) {

                    _this.renderBufferImmediate(object, program, material);

                });

            }

            this.renderBufferImmediate = function (object, program, material) {

                state.initAttributes();

                var buffers = properties.get(object);

                if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
                if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
                if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
                if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();

                var programAttributes = program.getAttributes();

                if (object.hasPositions) {

                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
                    _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

                    state.enableAttribute(programAttributes.position);
                    _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);

                }

                if (object.hasNormals) {

                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

                    if (!material.isMeshPhongMaterial &&
                        !material.isMeshStandardMaterial &&
                        !material.isMeshNormalMaterial &&
                        material.flatShading === true) {

                        for (var i = 0, l = object.count * 3; i < l; i += 9) {

                            var array = object.normalArray;

                            var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                            var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                            var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;

                            array[i + 0] = nx;
                            array[i + 1] = ny;
                            array[i + 2] = nz;

                            array[i + 3] = nx;
                            array[i + 4] = ny;
                            array[i + 5] = nz;

                            array[i + 6] = nx;
                            array[i + 7] = ny;
                            array[i + 8] = nz;

                        }

                    }

                    _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

                    state.enableAttribute(programAttributes.normal);

                    _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);

                }

                if (object.hasUvs && material.map) {

                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
                    _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

                    state.enableAttribute(programAttributes.uv);

                    _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);

                }

                if (object.hasColors && material.vertexColors !== NoColors) {

                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
                    _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

                    state.enableAttribute(programAttributes.color);

                    _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);

                }

                state.disableUnusedAttributes();

                _gl.drawArrays(_gl.TRIANGLES, 0, object.count);

                object.count = 0;

            };

            this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {

                state.setMaterial(material);

                var program = setProgram(camera, fog, material, object);
                var geometryProgram = geometry.id + '_' + program.id + '_' + (material.wireframe === true);

                var updateBuffers = false;

                if (geometryProgram !== _currentGeometryProgram) {

                    _currentGeometryProgram = geometryProgram;
                    updateBuffers = true;

                }

                if (object.morphTargetInfluences) {

                    morphtargets.update(object, geometry, material, program);

                    updateBuffers = true;

                }

                //

                var index = geometry.index;
                var position = geometry.attributes.position;
                var rangeFactor = 1;

                if (material.wireframe === true) {

                    index = geometries.getWireframeAttribute(geometry);
                    rangeFactor = 2;

                }

                var attribute;
                var renderer = bufferRenderer;

                if (index !== null) {

                    attribute = attributes.get(index);

                    renderer = indexedBufferRenderer;
                    renderer.setIndex(attribute);

                }

                if (updateBuffers) {

                    setupVertexAttributes(material, program, geometry);

                    if (index !== null) {

                        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer);

                    }

                }

                //

                var dataCount = 0;

                if (index !== null) {

                    dataCount = index.count;

                } else if (position !== undefined) {

                    dataCount = position.count;

                }

                var rangeStart = geometry.drawRange.start * rangeFactor;
                var rangeCount = geometry.drawRange.count * rangeFactor;

                var groupStart = group !== null ? group.start * rangeFactor : 0;
                var groupCount = group !== null ? group.count * rangeFactor : Infinity;

                var drawStart = Math.max(rangeStart, groupStart);
                var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;

                var drawCount = Math.max(0, drawEnd - drawStart + 1);

                if (drawCount === 0) return;

                //

                if (object.isMesh) {

                    if (material.wireframe === true) {

                        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                        renderer.setMode(_gl.LINES);

                    } else {

                        switch (object.drawMode) {

                            case TrianglesDrawMode:
                                renderer.setMode(_gl.TRIANGLES);
                                break;

                            case TriangleStripDrawMode:
                                renderer.setMode(_gl.TRIANGLE_STRIP);
                                break;

                            case TriangleFanDrawMode:
                                renderer.setMode(_gl.TRIANGLE_FAN);
                                break;

                        }

                    }


                } else if (object.isLine) {

                    var lineWidth = material.linewidth;

                    if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

                    state.setLineWidth(lineWidth * getTargetPixelRatio());

                    if (object.isLineSegments) {

                        renderer.setMode(_gl.LINES);

                    } else if (object.isLineLoop) {

                        renderer.setMode(_gl.LINE_LOOP);

                    } else {

                        renderer.setMode(_gl.LINE_STRIP);

                    }

                } else if (object.isPoints) {

                    renderer.setMode(_gl.POINTS);

                }

                if (geometry && geometry.isInstancedBufferGeometry) {

                    if (geometry.maxInstancedCount > 0) {

                        renderer.renderInstances(geometry, drawStart, drawCount);

                    }

                } else {

                    renderer.render(drawStart, drawCount);

                }

            };

            function setupVertexAttributes(material, program, geometry, startIndex) {

                if (geometry && geometry.isInstancedBufferGeometry) {

                    if (extensions.get('ANGLE_instanced_arrays') === null) {

                        console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                        return;

                    }

                }

                if (startIndex === undefined) startIndex = 0;

                state.initAttributes();

                var geometryAttributes = geometry.attributes;

                var programAttributes = program.getAttributes();

                var materialDefaultAttributeValues = material.defaultAttributeValues;

                for (var name in programAttributes) {

                    var programAttribute = programAttributes[name];

                    if (programAttribute >= 0) {

                        var geometryAttribute = geometryAttributes[name];

                        if (geometryAttribute !== undefined) {

                            var normalized = geometryAttribute.normalized;
                            var size = geometryAttribute.itemSize;

                            var attribute = attributes.get(geometryAttribute);

                            // TODO Attribute may not be available on context restore

                            if (attribute === undefined) continue;

                            var buffer = attribute.buffer;
                            var type = attribute.type;
                            var bytesPerElement = attribute.bytesPerElement;

                            if (geometryAttribute.isInterleavedBufferAttribute) {

                                var data = geometryAttribute.data;
                                var stride = data.stride;
                                var offset = geometryAttribute.offset;

                                if (data && data.isInstancedInterleavedBuffer) {

                                    state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

                                    if (geometry.maxInstancedCount === undefined) {

                                        geometry.maxInstancedCount = data.meshPerAttribute * data.count;

                                    }

                                } else {

                                    state.enableAttribute(programAttribute);

                                }

                                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                                _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, (startIndex * stride + offset) * bytesPerElement);

                            } else {

                                if (geometryAttribute.isInstancedBufferAttribute) {

                                    state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

                                    if (geometry.maxInstancedCount === undefined) {

                                        geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

                                    }

                                } else {

                                    state.enableAttribute(programAttribute);

                                }

                                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                                _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement);

                            }

                        } else if (materialDefaultAttributeValues !== undefined) {

                            var value = materialDefaultAttributeValues[name];

                            if (value !== undefined) {

                                switch (value.length) {

                                    case 2:
                                        _gl.vertexAttrib2fv(programAttribute, value);
                                        break;

                                    case 3:
                                        _gl.vertexAttrib3fv(programAttribute, value);
                                        break;

                                    case 4:
                                        _gl.vertexAttrib4fv(programAttribute, value);
                                        break;

                                    default:
                                        _gl.vertexAttrib1fv(programAttribute, value);

                                }

                            }

                        }

                    }

                }

                state.disableUnusedAttributes();

            }

            // Compile

            this.compile = function (scene, camera) {

                lightsArray.length = 0;
                shadowsArray.length = 0;

                scene.traverse(function (object) {

                    if (object.isLight) {

                        lightsArray.push(object);

                        if (object.castShadow) {

                            shadowsArray.push(object);

                        }

                    }

                });

                lights.setup(lightsArray, shadowsArray, camera);

                scene.traverse(function (object) {

                    if (object.material) {

                        if (Array.isArray(object.material)) {

                            for (var i = 0; i < object.material.length; i++) {

                                initMaterial(object.material[i], scene.fog, object);

                            }

                        } else {

                            initMaterial(object.material, scene.fog, object);

                        }

                    }

                });

            };

            // Animation Loop

            var isAnimating = false;
            var onAnimationFrame = null;

            function start() {

                if (isAnimating) return;
                (vr.getDevice() || window).requestAnimationFrame(loop);
                isAnimating = true;

            }

            function loop(time) {

                if (onAnimationFrame !== null) onAnimationFrame(time);
                (vr.getDevice() || window).requestAnimationFrame(loop);

            }

            this.animate = function (callback) {

                onAnimationFrame = callback;
                start();

            };

            // Rendering

            this.render = function (scene, camera, renderTarget, forceClear) {

                if (!(camera && camera.isCamera)) {

                    console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                    return;

                }

                if (_isContextLost) return;

                // reset caching for this frame

                _currentGeometryProgram = '';
                _currentMaterialId = -1;
                _currentCamera = null;

                // update scene graph

                if (scene.autoUpdate === true) scene.updateMatrixWorld();

                // update camera matrices and frustum

                if (camera.parent === null) camera.updateMatrixWorld();

                if (vr.enabled) {

                    camera = vr.getCamera(camera);

                }

                _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                _frustum.setFromMatrix(_projScreenMatrix);

                lightsArray.length = 0;
                shadowsArray.length = 0;

                spritesArray.length = 0;
                flaresArray.length = 0;

                _localClippingEnabled = this.localClippingEnabled;
                _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);

                currentRenderList = renderLists.get(scene, camera);
                currentRenderList.init();

                projectObject(scene, camera, _this.sortObjects);

                if (_this.sortObjects === true) {

                    currentRenderList.sort();

                }

                //

                if (_clippingEnabled) _clipping.beginShadows();

                shadowMap.render(shadowsArray, scene, camera);

                lights.setup(lightsArray, shadowsArray, camera);

                if (_clippingEnabled) _clipping.endShadows();

                //

                _infoRender.frame++;
                _infoRender.calls = 0;
                _infoRender.vertices = 0;
                _infoRender.faces = 0;
                _infoRender.points = 0;

                if (renderTarget === undefined) {

                    renderTarget = null;

                }

                this.setRenderTarget(renderTarget);

                //

                background.render(currentRenderList, scene, camera, forceClear);

                // render scene

                var opaqueObjects = currentRenderList.opaque;
                var transparentObjects = currentRenderList.transparent;

                if (scene.overrideMaterial) {

                    var overrideMaterial = scene.overrideMaterial;

                    if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                    if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);

                } else {

                    // opaque pass (front-to-back order)

                    if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera);

                    // transparent pass (back-to-front order)

                    if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);

                }

                // custom renderers

                spriteRenderer.render(spritesArray, scene, camera);
                flareRenderer.render(flaresArray, scene, camera, _currentViewport);

                // Generate mipmap if we're using any kind of mipmap filtering

                if (renderTarget) {

                    textures.updateRenderTargetMipmap(renderTarget);

                }

                // Ensure depth buffer writing is enabled so it can be cleared on next render

                state.buffers.depth.setTest(true);
                state.buffers.depth.setMask(true);
                state.buffers.color.setMask(true);

                state.setPolygonOffset(false);

                if (vr.enabled) {

                    vr.submitFrame();

                }

                // _gl.finish();

            };

            /*
		// TODO Duplicated code (Frustum)

		var _sphere = new Sphere();

		function isObjectViewable( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere ).
			applyMatrix4( object.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSpriteViewable( sprite ) {

			_sphere.center.set( 0, 0, 0 );
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4( sprite.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSphereViewable( sphere ) {

			if ( ! _frustum.intersectsSphere( sphere ) ) return false;

			var numPlanes = _clipping.numPlanes;

			if ( numPlanes === 0 ) return true;

			var planes = _this.clippingPlanes,

				center = sphere.center,
				negRad = - sphere.radius,
				i = 0;

			do {

				// out when deeper than radius in the negative halfspace
				if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

			} while ( ++ i !== numPlanes );

			return true;

		}
		*/

            function projectObject(object, camera, sortObjects) {

                if (object.visible === false) return;

                var visible = object.layers.test(camera.layers);

                if (visible) {

                    if (object.isLight) {

                        lightsArray.push(object);

                        if (object.castShadow) {

                            shadowsArray.push(object);

                        }

                    } else if (object.isSprite) {

                        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {

                            spritesArray.push(object);

                        }

                    } else if (object.isLensFlare) {

                        flaresArray.push(object);

                    } else if (object.isImmediateRenderObject) {

                        if (sortObjects) {

                            _vector3.setFromMatrixPosition(object.matrixWorld)
                                .applyMatrix4(_projScreenMatrix);

                        }

                        currentRenderList.push(object, null, object.material, _vector3.z, null);

                    } else if (object.isMesh || object.isLine || object.isPoints) {

                        if (object.isSkinnedMesh) {

                            object.skeleton.update();

                        }

                        if (!object.frustumCulled || _frustum.intersectsObject(object)) {

                            if (sortObjects) {

                                _vector3.setFromMatrixPosition(object.matrixWorld)
                                    .applyMatrix4(_projScreenMatrix);

                            }

                            var geometry = objects.update(object);
                            var material = object.material;

                            if (Array.isArray(material)) {

                                var groups = geometry.groups;

                                for (var i = 0, l = groups.length; i < l; i++) {

                                    var group = groups[i];
                                    var groupMaterial = material[group.materialIndex];

                                    if (groupMaterial && groupMaterial.visible) {

                                        currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);

                                    }

                                }

                            } else if (material.visible) {

                                currentRenderList.push(object, geometry, material, _vector3.z, null);

                            }

                        }

                    }

                }

                var children = object.children;

                for (var i = 0, l = children.length; i < l; i++) {

                    projectObject(children[i], camera, sortObjects);

                }

            }

            function renderObjects(renderList, scene, camera, overrideMaterial) {

                for (var i = 0, l = renderList.length; i < l; i++) {

                    var renderItem = renderList[i];

                    var object = renderItem.object;
                    var geometry = renderItem.geometry;
                    var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                    var group = renderItem.group;

                    if (camera.isArrayCamera) {

                        _currentArrayCamera = camera;

                        var cameras = camera.cameras;

                        for (var j = 0, jl = cameras.length; j < jl; j++) {

                            var camera2 = cameras[j];

                            if (object.layers.test(camera2.layers)) {

                                var bounds = camera2.bounds;

                                var x = bounds.x * _width;
                                var y = bounds.y * _height;
                                var width = bounds.z * _width;
                                var height = bounds.w * _height;

                                state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio));

                                renderObject(object, scene, camera2, geometry, material, group);

                            }

                        }

                    } else {

                        _currentArrayCamera = null;

                        renderObject(object, scene, camera, geometry, material, group);

                    }

                }

            }

            function renderObject(object, scene, camera, geometry, material, group) {

                object.onBeforeRender(_this, scene, camera, geometry, material, group);

                object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

                if (object.isImmediateRenderObject) {

                    state.setMaterial(material);

                    var program = setProgram(camera, scene.fog, material, object);

                    _currentGeometryProgram = '';

                    renderObjectImmediate(object, program, material);

                } else {

                    _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);

                }

                object.onAfterRender(_this, scene, camera, geometry, material, group);

            }

            function initMaterial(material, fog, object) {

                var materialProperties = properties.get(material);

                var parameters = programCache.getParameters(
                    material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);

                var code = programCache.getProgramCode(material, parameters);

                var program = materialProperties.program;
                var programChange = true;

                if (program === undefined) {

                    // new material
                    material.addEventListener('dispose', onMaterialDispose);

                } else if (program.code !== code) {

                    // changed glsl or parameters
                    releaseMaterialProgramReference(material);

                } else if (parameters.shaderID !== undefined) {

                    // same glsl and uniform list
                    return;

                } else {

                    // only rebuild uniform list
                    programChange = false;

                }

                if (programChange) {

                    if (parameters.shaderID) {

                        var shader = ShaderLib[parameters.shaderID];

                        materialProperties.shader = {
                            name: material.type,
                            uniforms: UniformsUtils.clone(shader.uniforms),
                            vertexShader: shader.vertexShader,
                            fragmentShader: shader.fragmentShader
                        };

                    } else {

                        materialProperties.shader = {
                            name: material.type,
                            uniforms: material.uniforms,
                            vertexShader: material.vertexShader,
                            fragmentShader: material.fragmentShader
                        };

                    }

                    material.onBeforeCompile(materialProperties.shader);

                    program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);

                    materialProperties.program = program;
                    material.program = program;

                }

                var programAttributes = program.getAttributes();

                if (material.morphTargets) {

                    material.numSupportedMorphTargets = 0;

                    for (var i = 0; i < _this.maxMorphTargets; i++) {

                        if (programAttributes['morphTarget' + i] >= 0) {

                            material.numSupportedMorphTargets++;

                        }

                    }

                }

                if (material.morphNormals) {

                    material.numSupportedMorphNormals = 0;

                    for (var i = 0; i < _this.maxMorphNormals; i++) {

                        if (programAttributes['morphNormal' + i] >= 0) {

                            material.numSupportedMorphNormals++;

                        }

                    }

                }

                var uniforms = materialProperties.shader.uniforms;

                if (!material.isShaderMaterial &&
                    !material.isRawShaderMaterial ||
                    material.clipping === true) {

                    materialProperties.numClippingPlanes = _clipping.numPlanes;
                    materialProperties.numIntersection = _clipping.numIntersection;
                    uniforms.clippingPlanes = _clipping.uniform;

                }

                materialProperties.fog = fog;

                // store the light setup it was created for

                materialProperties.lightsHash = lights.state.hash;

                if (material.lights) {

                    // wire up the material to this renderer's lighting state

                    uniforms.ambientLightColor.value = lights.state.ambient;
                    uniforms.directionalLights.value = lights.state.directional;
                    uniforms.spotLights.value = lights.state.spot;
                    uniforms.rectAreaLights.value = lights.state.rectArea;
                    uniforms.pointLights.value = lights.state.point;
                    uniforms.hemisphereLights.value = lights.state.hemi;

                    uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                    uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                    uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                    uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                    uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                    uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
                    // TODO (abelnation): add area lights shadow info to uniforms

                }

                var progUniforms = materialProperties.program.getUniforms(),
                    uniformsList =
                        WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);

                materialProperties.uniformsList = uniformsList;

            }

            function setProgram(camera, fog, material, object) {

                _usedTextureUnits = 0;

                var materialProperties = properties.get(material);

                if (_clippingEnabled) {

                    if (_localClippingEnabled || camera !== _currentCamera) {

                        var useCache =
                            camera === _currentCamera &&
                            material.id === _currentMaterialId;

                        // we might want to call this function with some ClippingGroup
                        // object instead of the material, once it becomes feasible
                        // (#8465, #8379)
                        _clipping.setState(
                            material.clippingPlanes, material.clipIntersection, material.clipShadows,
                            camera, materialProperties, useCache);

                    }

                }

                if (material.needsUpdate === false) {

                    if (materialProperties.program === undefined) {

                        material.needsUpdate = true;

                    } else if (material.fog && materialProperties.fog !== fog) {

                        material.needsUpdate = true;

                    } else if (material.lights && materialProperties.lightsHash !== lights.state.hash) {

                        material.needsUpdate = true;

                    } else if (materialProperties.numClippingPlanes !== undefined &&
                        (materialProperties.numClippingPlanes !== _clipping.numPlanes ||
                            materialProperties.numIntersection !== _clipping.numIntersection)) {

                        material.needsUpdate = true;

                    }

                }

                if (material.needsUpdate) {

                    initMaterial(material, fog, object);
                    material.needsUpdate = false;

                }

                var refreshProgram = false;
                var refreshMaterial = false;
                var refreshLights = false;

                var program = materialProperties.program,
                    p_uniforms = program.getUniforms(),
                    m_uniforms = materialProperties.shader.uniforms;

                if (state.useProgram(program.program)) {

                    refreshProgram = true;
                    refreshMaterial = true;
                    refreshLights = true;

                }

                if (material.id !== _currentMaterialId) {

                    _currentMaterialId = material.id;

                    refreshMaterial = true;

                }

                if (refreshProgram || camera !== _currentCamera) {

                    p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

                    if (capabilities.logarithmicDepthBuffer) {

                        p_uniforms.setValue(_gl, 'logDepthBufFC',
                            2.0 / (Math.log(camera.far + 1.0) / Math.LN2));

                    }

                    // Avoid unneeded uniform updates per ArrayCamera's sub-camera

                    if (_currentCamera !== (_currentArrayCamera || camera)) {

                        _currentCamera = (_currentArrayCamera || camera);

                        // lighting uniforms depend on the camera so enforce an update
                        // now, in case this material supports lights - or later, when
                        // the next material that does gets activated:

                        refreshMaterial = true;		// set to true on material change
                        refreshLights = true;		// remains set until update done

                    }

                    // load material specific uniforms
                    // (shader material also gets them for the sake of genericity)

                    if (material.isShaderMaterial ||
                        material.isMeshPhongMaterial ||
                        material.isMeshStandardMaterial ||
                        material.envMap) {

                        var uCamPos = p_uniforms.map.cameraPosition;

                        if (uCamPos !== undefined) {

                            uCamPos.setValue(_gl,
                                _vector3.setFromMatrixPosition(camera.matrixWorld));

                        }

                    }

                    if (material.isMeshPhongMaterial ||
                        material.isMeshLambertMaterial ||
                        material.isMeshBasicMaterial ||
                        material.isMeshStandardMaterial ||
                        material.isShaderMaterial ||
                        material.skinning) {

                        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);

                    }

                }

                // skinning uniforms must be set even if material didn't change
                // auto-setting of texture unit for bone texture must go before other textures
                // not sure why, but otherwise weird things happen

                if (material.skinning) {

                    p_uniforms.setOptional(_gl, object, 'bindMatrix');
                    p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');

                    var skeleton = object.skeleton;

                    if (skeleton) {

                        var bones = skeleton.bones;

                        if (capabilities.floatVertexTextures) {

                            if (skeleton.boneTexture === undefined) {

                                // layout (1 matrix = 4 pixels)
                                //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                                //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                                //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                                //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                                //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


                                var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                                size = _Math.ceilPowerOfTwo(size);
                                size = Math.max(size, 4);

                                var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                                boneMatrices.set(skeleton.boneMatrices); // copy current values

                                var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);

                                skeleton.boneMatrices = boneMatrices;
                                skeleton.boneTexture = boneTexture;
                                skeleton.boneTextureSize = size;

                            }

                            p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture);
                            p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);

                        } else {

                            p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');

                        }

                    }

                }

                if (refreshMaterial) {

                    p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                    p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);

                    if (material.lights) {

                        // the current material requires lighting info

                        // note: all lighting uniforms are always set correctly
                        // they simply reference the renderer's state for their
                        // values
                        //
                        // use the current material's .needsUpdate flags to set
                        // the GL state when required

                        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);

                    }

                    // refresh uniforms common to several materials

                    if (fog && material.fog) {

                        refreshUniformsFog(m_uniforms, fog);

                    }

                    if (material.isMeshBasicMaterial) {

                        refreshUniformsCommon(m_uniforms, material);

                    } else if (material.isMeshLambertMaterial) {

                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsLambert(m_uniforms, material);

                    } else if (material.isMeshPhongMaterial) {

                        refreshUniformsCommon(m_uniforms, material);

                        if (material.isMeshToonMaterial) {

                            refreshUniformsToon(m_uniforms, material);

                        } else {

                            refreshUniformsPhong(m_uniforms, material);

                        }

                    } else if (material.isMeshStandardMaterial) {

                        refreshUniformsCommon(m_uniforms, material);

                        if (material.isMeshPhysicalMaterial) {

                            refreshUniformsPhysical(m_uniforms, material);

                        } else {

                            refreshUniformsStandard(m_uniforms, material);

                        }

                    } else if (material.isMeshDepthMaterial) {

                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsDepth(m_uniforms, material);

                    } else if (material.isMeshDistanceMaterial) {

                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsDistance(m_uniforms, material);

                    } else if (material.isMeshNormalMaterial) {

                        refreshUniformsCommon(m_uniforms, material);
                        refreshUniformsNormal(m_uniforms, material);

                    } else if (material.isLineBasicMaterial) {

                        refreshUniformsLine(m_uniforms, material);

                        if (material.isLineDashedMaterial) {

                            refreshUniformsDash(m_uniforms, material);

                        }

                    } else if (material.isPointsMaterial) {

                        refreshUniformsPoints(m_uniforms, material);

                    } else if (material.isShadowMaterial) {

                        m_uniforms.color.value = material.color;
                        m_uniforms.opacity.value = material.opacity;

                    }

                    // RectAreaLight Texture
                    // TODO (mrdoob): Find a nicer implementation

                    if (m_uniforms.ltcMat !== undefined) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
                    if (m_uniforms.ltcMag !== undefined) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;

                    WebGLUniforms.upload(
                        _gl, materialProperties.uniformsList, m_uniforms, _this);

                }


                // common matrices

                p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
                p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
                p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

                return program;

            }

            // Uniforms (refresh uniforms objects)

            function refreshUniformsCommon(uniforms, material) {

                uniforms.opacity.value = material.opacity;

                if (material.color) {

                    uniforms.diffuse.value = material.color;

                }

                if (material.emissive) {

                    uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);

                }

                if (material.map) {

                    uniforms.map.value = material.map;

                }

                if (material.alphaMap) {

                    uniforms.alphaMap.value = material.alphaMap;

                }

                if (material.specularMap) {

                    uniforms.specularMap.value = material.specularMap;

                }

                if (material.envMap) {

                    uniforms.envMap.value = material.envMap;

                    // don't flip CubeTexture envMaps, flip everything else:
                    //  WebGLRenderTargetCube will be flipped for backwards compatibility
                    //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
                    // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
                    uniforms.flipEnvMap.value = (!(material.envMap && material.envMap.isCubeTexture)) ? 1 : -1;

                    uniforms.reflectivity.value = material.reflectivity;
                    uniforms.refractionRatio.value = material.refractionRatio;

                }

                if (material.lightMap) {

                    uniforms.lightMap.value = material.lightMap;
                    uniforms.lightMapIntensity.value = material.lightMapIntensity;

                }

                if (material.aoMap) {

                    uniforms.aoMap.value = material.aoMap;
                    uniforms.aoMapIntensity.value = material.aoMapIntensity;

                }

                // uv repeat and offset setting priorities
                // 1. color map
                // 2. specular map
                // 3. normal map
                // 4. bump map
                // 5. alpha map
                // 6. emissive map

                var uvScaleMap;

                if (material.map) {

                    uvScaleMap = material.map;

                } else if (material.specularMap) {

                    uvScaleMap = material.specularMap;

                } else if (material.displacementMap) {

                    uvScaleMap = material.displacementMap;

                } else if (material.normalMap) {

                    uvScaleMap = material.normalMap;

                } else if (material.bumpMap) {

                    uvScaleMap = material.bumpMap;

                } else if (material.roughnessMap) {

                    uvScaleMap = material.roughnessMap;

                } else if (material.metalnessMap) {

                    uvScaleMap = material.metalnessMap;

                } else if (material.alphaMap) {

                    uvScaleMap = material.alphaMap;

                } else if (material.emissiveMap) {

                    uvScaleMap = material.emissiveMap;

                }

                if (uvScaleMap !== undefined) {

                    // backwards compatibility
                    if (uvScaleMap.isWebGLRenderTarget) {

                        uvScaleMap = uvScaleMap.texture;

                    }

                    if (uvScaleMap.matrixAutoUpdate === true) {

                        var offset = uvScaleMap.offset;
                        var repeat = uvScaleMap.repeat;
                        var rotation = uvScaleMap.rotation;
                        var center = uvScaleMap.center;

                        uvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);

                    }

                    uniforms.uvTransform.value.copy(uvScaleMap.matrix);

                }

            }

            function refreshUniformsLine(uniforms, material) {

                uniforms.diffuse.value = material.color;
                uniforms.opacity.value = material.opacity;

            }

            function refreshUniformsDash(uniforms, material) {

                uniforms.dashSize.value = material.dashSize;
                uniforms.totalSize.value = material.dashSize + material.gapSize;
                uniforms.scale.value = material.scale;

            }

            function refreshUniformsPoints(uniforms, material) {

                uniforms.diffuse.value = material.color;
                uniforms.opacity.value = material.opacity;
                uniforms.size.value = material.size * _pixelRatio;
                uniforms.scale.value = _height * 0.5;

                uniforms.map.value = material.map;

                if (material.map !== null) {

                    if (material.map.matrixAutoUpdate === true) {

                        var offset = material.map.offset;
                        var repeat = material.map.repeat;
                        var rotation = material.map.rotation;
                        var center = material.map.center;

                        material.map.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);

                    }

                    uniforms.uvTransform.value.copy(material.map.matrix);

                }

            }

            function refreshUniformsFog(uniforms, fog) {

                uniforms.fogColor.value = fog.color;

                if (fog.isFog) {

                    uniforms.fogNear.value = fog.near;
                    uniforms.fogFar.value = fog.far;

                } else if (fog.isFogExp2) {

                    uniforms.fogDensity.value = fog.density;

                }

            }

            function refreshUniformsLambert(uniforms, material) {

                if (material.emissiveMap) {

                    uniforms.emissiveMap.value = material.emissiveMap;

                }

            }

            function refreshUniformsPhong(uniforms, material) {

                uniforms.specular.value = material.specular;
                uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

                if (material.emissiveMap) {

                    uniforms.emissiveMap.value = material.emissiveMap;

                }

                if (material.bumpMap) {

                    uniforms.bumpMap.value = material.bumpMap;
                    uniforms.bumpScale.value = material.bumpScale;

                }

                if (material.normalMap) {

                    uniforms.normalMap.value = material.normalMap;
                    uniforms.normalScale.value.copy(material.normalScale);

                }

                if (material.displacementMap) {

                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;

                }

            }

            function refreshUniformsToon(uniforms, material) {

                refreshUniformsPhong(uniforms, material);

                if (material.gradientMap) {

                    uniforms.gradientMap.value = material.gradientMap;

                }

            }

            function refreshUniformsStandard(uniforms, material) {

                uniforms.roughness.value = material.roughness;
                uniforms.metalness.value = material.metalness;

                if (material.roughnessMap) {

                    uniforms.roughnessMap.value = material.roughnessMap;

                }

                if (material.metalnessMap) {

                    uniforms.metalnessMap.value = material.metalnessMap;

                }

                if (material.emissiveMap) {

                    uniforms.emissiveMap.value = material.emissiveMap;

                }

                if (material.bumpMap) {

                    uniforms.bumpMap.value = material.bumpMap;
                    uniforms.bumpScale.value = material.bumpScale;

                }

                if (material.normalMap) {

                    uniforms.normalMap.value = material.normalMap;
                    uniforms.normalScale.value.copy(material.normalScale);

                }

                if (material.displacementMap) {

                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;

                }

                if (material.envMap) {

                    //uniforms.envMap.value = material.envMap; // part of uniforms common
                    uniforms.envMapIntensity.value = material.envMapIntensity;

                }

            }

            function refreshUniformsPhysical(uniforms, material) {

                uniforms.clearCoat.value = material.clearCoat;
                uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

                refreshUniformsStandard(uniforms, material);

            }

            function refreshUniformsDepth(uniforms, material) {

                if (material.displacementMap) {

                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;

                }

            }

            function refreshUniformsDistance(uniforms, material) {

                if (material.displacementMap) {

                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;

                }

                uniforms.referencePosition.value.copy(material.referencePosition);
                uniforms.nearDistance.value = material.nearDistance;
                uniforms.farDistance.value = material.farDistance;

            }

            function refreshUniformsNormal(uniforms, material) {

                if (material.bumpMap) {

                    uniforms.bumpMap.value = material.bumpMap;
                    uniforms.bumpScale.value = material.bumpScale;

                }

                if (material.normalMap) {

                    uniforms.normalMap.value = material.normalMap;
                    uniforms.normalScale.value.copy(material.normalScale);

                }

                if (material.displacementMap) {

                    uniforms.displacementMap.value = material.displacementMap;
                    uniforms.displacementScale.value = material.displacementScale;
                    uniforms.displacementBias.value = material.displacementBias;

                }

            }

            // If uniforms are marked as clean, they don't need to be loaded to the GPU.

            function markUniformsLightsNeedsUpdate(uniforms, value) {

                uniforms.ambientLightColor.needsUpdate = value;

                uniforms.directionalLights.needsUpdate = value;
                uniforms.pointLights.needsUpdate = value;
                uniforms.spotLights.needsUpdate = value;
                uniforms.rectAreaLights.needsUpdate = value;
                uniforms.hemisphereLights.needsUpdate = value;

            }

            // GL state setting

            this.setFaceCulling = function (cullFace, frontFaceDirection) {

                state.setCullFace(cullFace);
                state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);

            };

            // Textures

            function allocTextureUnit() {

                var textureUnit = _usedTextureUnits;

                if (textureUnit >= capabilities.maxTextures) {

                    console.warn('THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);

                }

                _usedTextureUnits += 1;

                return textureUnit;

            }

            this.allocTextureUnit = allocTextureUnit;

            // this.setTexture2D = setTexture2D;
            this.setTexture2D = (function () {

                var warned = false;

                // backwards compatibility: peel texture.texture
                return function setTexture2D(texture, slot) {

                    if (texture && texture.isWebGLRenderTarget) {

                        if (!warned) {

                            console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                            warned = true;

                        }

                        texture = texture.texture;

                    }

                    textures.setTexture2D(texture, slot);

                };

            }());

            this.setTexture = (function () {

                var warned = false;

                return function setTexture(texture, slot) {

                    if (!warned) {

                        console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                        warned = true;

                    }

                    textures.setTexture2D(texture, slot);

                };

            }());

            this.setTextureCube = (function () {

                var warned = false;

                return function setTextureCube(texture, slot) {

                    // backwards compatibility: peel texture.texture
                    if (texture && texture.isWebGLRenderTargetCube) {

                        if (!warned) {

                            console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                            warned = true;

                        }

                        texture = texture.texture;

                    }

                    // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
                    // TODO: unify these code paths
                    if ((texture && texture.isCubeTexture) ||
                        (Array.isArray(texture.image) && texture.image.length === 6)) {

                        // CompressedTexture can have Array in image :/

                        // this function alone should take care of cube textures
                        textures.setTextureCube(texture, slot);

                    } else {

                        // assumed: texture property of THREE.WebGLRenderTargetCube

                        textures.setTextureCubeDynamic(texture, slot);

                    }

                };

            }());

            this.getRenderTarget = function () {

                return _currentRenderTarget;

            };

            this.setRenderTarget = function (renderTarget) {

                _currentRenderTarget = renderTarget;

                if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {

                    textures.setupRenderTarget(renderTarget);

                }

                var framebuffer = null;
                var isCube = false;

                if (renderTarget) {

                    var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

                    if (renderTarget.isWebGLRenderTargetCube) {

                        framebuffer = __webglFramebuffer[renderTarget.activeCubeFace];
                        isCube = true;

                    } else {

                        framebuffer = __webglFramebuffer;

                    }

                    _currentViewport.copy(renderTarget.viewport);
                    _currentScissor.copy(renderTarget.scissor);
                    _currentScissorTest = renderTarget.scissorTest;

                } else {

                    _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
                    _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
                    _currentScissorTest = _scissorTest;

                }

                if (_currentFramebuffer !== framebuffer) {

                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                    _currentFramebuffer = framebuffer;

                }

                state.viewport(_currentViewport);
                state.scissor(_currentScissor);
                state.setScissorTest(_currentScissorTest);

                if (isCube) {

                    var textureProperties = properties.get(renderTarget.texture);
                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);

                }

            };

            this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {

                if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {

                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                    return;

                }

                var framebuffer = properties.get(renderTarget).__webglFramebuffer;

                if (framebuffer) {

                    var restore = false;

                    if (framebuffer !== _currentFramebuffer) {

                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

                        restore = true;

                    }

                    try {

                        var texture = renderTarget.texture;
                        var textureFormat = texture.format;
                        var textureType = texture.type;

                        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {

                            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                            return;

                        }

                        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
                            !(textureType === FloatType && (extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
                            !(textureType === HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {

                            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                            return;

                        }

                        if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {

                            // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

                            if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {

                                _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);

                            }

                        } else {

                            console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');

                        }

                    } finally {

                        if (restore) {

                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);

                        }

                    }

                }

            };

        }

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        function FogExp2(color, density) {

            this.name = '';

            this.color = new Color(color);
            this.density = (density !== undefined) ? density : 0.00025;

        }

        FogExp2.prototype.isFogExp2 = true;

        FogExp2.prototype.clone = function () {

            return new FogExp2(this.color.getHex(), this.density);

        };

        FogExp2.prototype.toJSON = function (/* meta */) {

            return {
                type: 'FogExp2',
                color: this.color.getHex(),
                density: this.density
            };

        };

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        function Fog(color, near, far) {

            this.name = '';

            this.color = new Color(color);

            this.near = (near !== undefined) ? near : 1;
            this.far = (far !== undefined) ? far : 1000;

        }

        Fog.prototype.isFog = true;

        Fog.prototype.clone = function () {

            return new Fog(this.color.getHex(), this.near, this.far);

        };

        Fog.prototype.toJSON = function (/* meta */) {

            return {
                type: 'Fog',
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            };

        };

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function Scene() {

            Object3D.call(this);

            this.type = 'Scene';

            this.background = null;
            this.fog = null;
            this.overrideMaterial = null;

            this.autoUpdate = true; // checked by the renderer

        }

        Scene.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Scene,

            copy: function (source, recursive) {

                Object3D.prototype.copy.call(this, source, recursive);

                if (source.background !== null) this.background = source.background.clone();
                if (source.fog !== null) this.fog = source.fog.clone();
                if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();

                this.autoUpdate = source.autoUpdate;
                this.matrixAutoUpdate = source.matrixAutoUpdate;

                return this;

            },

            toJSON: function (meta) {

                var data = Object3D.prototype.toJSON.call(this, meta);

                if (this.background !== null) data.object.background = this.background.toJSON(meta);
                if (this.fog !== null) data.object.fog = this.fog.toJSON();

                return data;

            }

        });

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         */

        function LensFlare(texture, size, distance, blending, color) {

            Object3D.call(this);

            this.lensFlares = [];

            this.positionScreen = new Vector3();
            this.customUpdateCallback = undefined;

            if (texture !== undefined) {

                this.add(texture, size, distance, blending, color);

            }

        }

        LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: LensFlare,

            isLensFlare: true,

            copy: function (source) {

                Object3D.prototype.copy.call(this, source);

                this.positionScreen.copy(source.positionScreen);
                this.customUpdateCallback = source.customUpdateCallback;

                for (var i = 0, l = source.lensFlares.length; i < l; i++) {

                    this.lensFlares.push(source.lensFlares[i]);

                }

                return this;

            },

            add: function (texture, size, distance, blending, color, opacity) {

                if (size === undefined) size = -1;
                if (distance === undefined) distance = 0;
                if (opacity === undefined) opacity = 1;
                if (color === undefined) color = new Color(0xffffff);
                if (blending === undefined) blending = NormalBlending;

                distance = Math.min(distance, Math.max(0, distance));

                this.lensFlares.push({
                    texture: texture,	// THREE.Texture
                    size: size, 		// size in pixels (-1 = use texture.width)
                    distance: distance, 	// distance (0-1) from light source (0=at light source)
                    x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
                    scale: 1, 		// scale
                    rotation: 0, 		// rotation
                    opacity: opacity,	// opacity
                    color: color,		// color
                    blending: blending	// blending
                });

            },

            /*
		 * Update lens flares update positions on all flares based on the screen position
		 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
		 */

            updateLensFlares: function () {

                var f, fl = this.lensFlares.length;
                var flare;
                var vecX = -this.positionScreen.x * 2;
                var vecY = -this.positionScreen.y * 2;

                for (f = 0; f < fl; f++) {

                    flare = this.lensFlares[f];

                    flare.x = this.positionScreen.x + vecX * flare.distance;
                    flare.y = this.positionScreen.y + vecY * flare.distance;

                    flare.wantedRotation = flare.x * Math.PI * 0.25;
                    flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;

                }

            }

        });

        /**
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2()
	 * }
         */

        function SpriteMaterial(parameters) {

            Material.call(this);

            this.type = 'SpriteMaterial';

            this.color = new Color(0xffffff);
            this.map = null;

            this.rotation = 0;

            this.fog = false;
            this.lights = false;

            this.setValues(parameters);

        }

        SpriteMaterial.prototype = Object.create(Material.prototype);
        SpriteMaterial.prototype.constructor = SpriteMaterial;
        SpriteMaterial.prototype.isSpriteMaterial = true;

        SpriteMaterial.prototype.copy = function (source) {

            Material.prototype.copy.call(this, source);

            this.color.copy(source.color);
            this.map = source.map;

            this.rotation = source.rotation;

            return this;

        };

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         */

        function Sprite(material) {

            Object3D.call(this);

            this.type = 'Sprite';

            this.material = (material !== undefined) ? material : new SpriteMaterial();

        }

        Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Sprite,

            isSprite: true,

            raycast: (function () {

                var intersectPoint = new Vector3();
                var worldPosition = new Vector3();
                var worldScale = new Vector3();

                return function raycast(raycaster, intersects) {

                    worldPosition.setFromMatrixPosition(this.matrixWorld);
                    raycaster.ray.closestPointToPoint(worldPosition, intersectPoint);

                    worldScale.setFromMatrixScale(this.matrixWorld);
                    var guessSizeSq = worldScale.x * worldScale.y / 4;

                    if (worldPosition.distanceToSquared(intersectPoint) > guessSizeSq) return;

                    var distance = raycaster.ray.origin.distanceTo(intersectPoint);

                    if (distance < raycaster.near || distance > raycaster.far) return;

                    intersects.push({

                        distance: distance,
                        point: intersectPoint.clone(),
                        face: null,
                        object: this

                    });

                };

            }()),

            clone: function () {

                return new this.constructor(this.material).copy(this);

            }

        });

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         */

        function LOD() {

            Object3D.call(this);

            this.type = 'LOD';

            Object.defineProperties(this, {
                levels: {
                    enumerable: true,
                    value: []
                }
            });

        }

        LOD.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: LOD,

            copy: function (source) {

                Object3D.prototype.copy.call(this, source, false);

                var levels = source.levels;

                for (var i = 0, l = levels.length; i < l; i++) {

                    var level = levels[i];

                    this.addLevel(level.object.clone(), level.distance);

                }

                return this;

            },

            addLevel: function (object, distance) {

                if (distance === undefined) distance = 0;

                distance = Math.abs(distance);

                var levels = this.levels;

                for (var l = 0; l < levels.length; l++) {

                    if (distance < levels[l].distance) {

                        break;

                    }

                }

                levels.splice(l, 0, {distance: distance, object: object});

                this.add(object);

            },

            getObjectForDistance: function (distance) {

                var levels = this.levels;

                for (var i = 1, l = levels.length; i < l; i++) {

                    if (distance < levels[i].distance) {

                        break;

                    }

                }

                return levels[i - 1].object;

            },

            raycast: (function () {

                var matrixPosition = new Vector3();

                return function raycast(raycaster, intersects) {

                    matrixPosition.setFromMatrixPosition(this.matrixWorld);

                    var distance = raycaster.ray.origin.distanceTo(matrixPosition);

                    this.getObjectForDistance(distance).raycast(raycaster, intersects);

                };

            }()),

            update: function () {

                var v1 = new Vector3();
                var v2 = new Vector3();

                return function update(camera) {

                    var levels = this.levels;

                    if (levels.length > 1) {

                        v1.setFromMatrixPosition(camera.matrixWorld);
                        v2.setFromMatrixPosition(this.matrixWorld);

                        var distance = v1.distanceTo(v2);

                        levels[0].object.visible = true;

                        for (var i = 1, l = levels.length; i < l; i++) {

                            if (distance >= levels[i].distance) {

                                levels[i - 1].object.visible = false;
                                levels[i].object.visible = true;

                            } else {

                                break;

                            }

                        }

                        for (; i < l; i++) {

                            levels[i].object.visible = false;

                        }

                    }

                };

            }(),

            toJSON: function (meta) {

                var data = Object3D.prototype.toJSON.call(this, meta);

                data.object.levels = [];

                var levels = this.levels;

                for (var i = 0, l = levels.length; i < l; i++) {

                    var level = levels[i];

                    data.object.levels.push({
                        object: level.object.uuid,
                        distance: level.distance
                    });

                }

                return data;

            }

        });

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         * @author michael guerrero / http://realitymeltdown.com
         * @author ikerr / http://verold.com
         */

        function Skeleton(bones, boneInverses) {

            // copy the bone array

            bones = bones || [];

            this.bones = bones.slice(0);
            this.boneMatrices = new Float32Array(this.bones.length * 16);

            // use the supplied bone inverses or calculate the inverses

            if (boneInverses === undefined) {

                this.calculateInverses();

            } else {

                if (this.bones.length === boneInverses.length) {

                    this.boneInverses = boneInverses.slice(0);

                } else {

                    console.warn('THREE.Skeleton boneInverses is the wrong length.');

                    this.boneInverses = [];

                    for (var i = 0, il = this.bones.length; i < il; i++) {

                        this.boneInverses.push(new Matrix4());

                    }

                }

            }

        }

        Object.assign(Skeleton.prototype, {

            calculateInverses: function () {

                this.boneInverses = [];

                for (var i = 0, il = this.bones.length; i < il; i++) {

                    var inverse = new Matrix4();

                    if (this.bones[i]) {

                        inverse.getInverse(this.bones[i].matrixWorld);

                    }

                    this.boneInverses.push(inverse);

                }

            },

            pose: function () {

                var bone, i, il;

                // recover the bind-time world matrices

                for (i = 0, il = this.bones.length; i < il; i++) {

                    bone = this.bones[i];

                    if (bone) {

                        bone.matrixWorld.getInverse(this.boneInverses[i]);

                    }

                }

                // compute the local matrices, positions, rotations and scales

                for (i = 0, il = this.bones.length; i < il; i++) {

                    bone = this.bones[i];

                    if (bone) {

                        if (bone.parent && bone.parent.isBone) {

                            bone.matrix.getInverse(bone.parent.matrixWorld);
                            bone.matrix.multiply(bone.matrixWorld);

                        } else {

                            bone.matrix.copy(bone.matrixWorld);

                        }

                        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);

                    }

                }

            },

            update: (function () {

                var offsetMatrix = new Matrix4();
                var identityMatrix = new Matrix4();

                return function update() {

                    var bones = this.bones;
                    var boneInverses = this.boneInverses;
                    var boneMatrices = this.boneMatrices;
                    var boneTexture = this.boneTexture;

                    // flatten bone matrices to array

                    for (var i = 0, il = bones.length; i < il; i++) {

                        // compute the offset between the current and the original transform

                        var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;

                        offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                        offsetMatrix.toArray(boneMatrices, i * 16);

                    }

                    if (boneTexture !== undefined) {

                        boneTexture.needsUpdate = true;

                    }

                };

            })(),

            clone: function () {

                return new Skeleton(this.bones, this.boneInverses);

            }

        });

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         * @author ikerr / http://verold.com
         */

        function Bone() {

            Object3D.call(this);

            this.type = 'Bone';

        }

        Bone.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Bone,

            isBone: true

        });

        /**
         * @author mikael emtinger / http://gomo.se/
         * @author alteredq / http://alteredqualia.com/
         * @author ikerr / http://verold.com
         */

        function SkinnedMesh(geometry, material) {

            Mesh.call(this, geometry, material);

            this.type = 'SkinnedMesh';

            this.bindMode = 'attached';
            this.bindMatrix = new Matrix4();
            this.bindMatrixInverse = new Matrix4();

            var bones = this.initBones();
            var skeleton = new Skeleton(bones);

            this.bind(skeleton, this.matrixWorld);

            this.normalizeSkinWeights();

        }

        SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {

            constructor: SkinnedMesh,

            isSkinnedMesh: true,

            initBones: function () {

                var bones = [], bone, gbone;
                var i, il;

                if (this.geometry && this.geometry.bones !== undefined) {

                    // first, create array of 'Bone' objects from geometry data

                    for (i = 0, il = this.geometry.bones.length; i < il; i++) {

                        gbone = this.geometry.bones[i];

                        // create new 'Bone' object

                        bone = new Bone();
                        bones.push(bone);

                        // apply values

                        bone.name = gbone.name;
                        bone.position.fromArray(gbone.pos);
                        bone.quaternion.fromArray(gbone.rotq);
                        if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);

                    }

                    // second, create bone hierarchy

                    for (i = 0, il = this.geometry.bones.length; i < il; i++) {

                        gbone = this.geometry.bones[i];

                        if ((gbone.parent !== -1) && (gbone.parent !== null) && (bones[gbone.parent] !== undefined)) {

                            // subsequent bones in the hierarchy

                            bones[gbone.parent].add(bones[i]);

                        } else {

                            // topmost bone, immediate child of the skinned mesh

                            this.add(bones[i]);

                        }

                    }

                }

                // now the bones are part of the scene graph and children of the skinned mesh.
                // let's update the corresponding matrices

                this.updateMatrixWorld(true);

                return bones;

            },

            bind: function (skeleton, bindMatrix) {

                this.skeleton = skeleton;

                if (bindMatrix === undefined) {

                    this.updateMatrixWorld(true);

                    this.skeleton.calculateInverses();

                    bindMatrix = this.matrixWorld;

                }

                this.bindMatrix.copy(bindMatrix);
                this.bindMatrixInverse.getInverse(bindMatrix);

            },

            pose: function () {

                this.skeleton.pose();

            },

            normalizeSkinWeights: function () {

                var scale, i;

                if (this.geometry && this.geometry.isGeometry) {

                    for (i = 0; i < this.geometry.skinWeights.length; i++) {

                        var sw = this.geometry.skinWeights[i];

                        scale = 1.0 / sw.manhattanLength();

                        if (scale !== Infinity) {

                            sw.multiplyScalar(scale);

                        } else {

                            sw.set(1, 0, 0, 0); // do something reasonable

                        }

                    }

                } else if (this.geometry && this.geometry.isBufferGeometry) {

                    var vec = new Vector4();

                    var skinWeight = this.geometry.attributes.skinWeight;

                    for (i = 0; i < skinWeight.count; i++) {

                        vec.x = skinWeight.getX(i);
                        vec.y = skinWeight.getY(i);
                        vec.z = skinWeight.getZ(i);
                        vec.w = skinWeight.getW(i);

                        scale = 1.0 / vec.manhattanLength();

                        if (scale !== Infinity) {

                            vec.multiplyScalar(scale);

                        } else {

                            vec.set(1, 0, 0, 0); // do something reasonable

                        }

                        skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);

                    }

                }

            },

            updateMatrixWorld: function (force) {

                Mesh.prototype.updateMatrixWorld.call(this, force);

                if (this.bindMode === 'attached') {

                    this.bindMatrixInverse.getInverse(this.matrixWorld);

                } else if (this.bindMode === 'detached') {

                    this.bindMatrixInverse.getInverse(this.bindMatrix);

                } else {

                    console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);

                }

            },

            clone: function () {

                return new this.constructor(this.geometry, this.material).copy(this);

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
         */

        function LineBasicMaterial(parameters) {

            Material.call(this);

            this.type = 'LineBasicMaterial';

            this.color = new Color(0xffffff);

            this.linewidth = 1;
            this.linecap = 'round';
            this.linejoin = 'round';

            this.lights = false;

            this.setValues(parameters);

        }

        LineBasicMaterial.prototype = Object.create(Material.prototype);
        LineBasicMaterial.prototype.constructor = LineBasicMaterial;

        LineBasicMaterial.prototype.isLineBasicMaterial = true;

        LineBasicMaterial.prototype.copy = function (source) {

            Material.prototype.copy.call(this, source);

            this.color.copy(source.color);

            this.linewidth = source.linewidth;
            this.linecap = source.linecap;
            this.linejoin = source.linejoin;

            return this;

        };

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function Line(geometry, material, mode) {

            if (mode === 1) {

                console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
                return new LineSegments(geometry, material);

            }

            Object3D.call(this);

            this.type = 'Line';

            this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
            this.material = material !== undefined ? material : new LineBasicMaterial({color: Math.random() * 0xffffff});

        }

        Line.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Line,

            isLine: true,

            raycast: (function () {

                var inverseMatrix = new Matrix4();
                var ray = new Ray();
                var sphere = new Sphere();

                return function raycast(raycaster, intersects) {

                    var precision = raycaster.linePrecision;
                    var precisionSq = precision * precision;

                    var geometry = this.geometry;
                    var matrixWorld = this.matrixWorld;

                    // Checking boundingSphere distance to ray

                    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                    sphere.copy(geometry.boundingSphere);
                    sphere.applyMatrix4(matrixWorld);

                    if (raycaster.ray.intersectsSphere(sphere) === false) return;

                    //

                    inverseMatrix.getInverse(matrixWorld);
                    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

                    var vStart = new Vector3();
                    var vEnd = new Vector3();
                    var interSegment = new Vector3();
                    var interRay = new Vector3();
                    var step = (this && this.isLineSegments) ? 2 : 1;

                    if (geometry.isBufferGeometry) {

                        var index = geometry.index;
                        var attributes = geometry.attributes;
                        var positions = attributes.position.array;

                        if (index !== null) {

                            var indices = index.array;

                            for (var i = 0, l = indices.length - 1; i < l; i += step) {

                                var a = indices[i];
                                var b = indices[i + 1];

                                vStart.fromArray(positions, a * 3);
                                vEnd.fromArray(positions, b * 3);

                                var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

                                if (distSq > precisionSq) continue;

                                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

                                var distance = raycaster.ray.origin.distanceTo(interRay);

                                if (distance < raycaster.near || distance > raycaster.far) continue;

                                intersects.push({

                                    distance: distance,
                                    // What do we want? intersection point on the ray or on the segment??
                                    // point: raycaster.ray.at( distance ),
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this

                                });

                            }

                        } else {

                            for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {

                                vStart.fromArray(positions, 3 * i);
                                vEnd.fromArray(positions, 3 * i + 3);

                                var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

                                if (distSq > precisionSq) continue;

                                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

                                var distance = raycaster.ray.origin.distanceTo(interRay);

                                if (distance < raycaster.near || distance > raycaster.far) continue;

                                intersects.push({

                                    distance: distance,
                                    // What do we want? intersection point on the ray or on the segment??
                                    // point: raycaster.ray.at( distance ),
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this

                                });

                            }

                        }

                    } else if (geometry.isGeometry) {

                        var vertices = geometry.vertices;
                        var nbVertices = vertices.length;

                        for (var i = 0; i < nbVertices - 1; i += step) {

                            var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

                            if (distSq > precisionSq) continue;

                            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

                            var distance = raycaster.ray.origin.distanceTo(interRay);

                            if (distance < raycaster.near || distance > raycaster.far) continue;

                            intersects.push({

                                distance: distance,
                                // What do we want? intersection point on the ray or on the segment??
                                // point: raycaster.ray.at( distance ),
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this

                            });

                        }

                    }

                };

            }()),

            clone: function () {

                return new this.constructor(this.geometry, this.material).copy(this);

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function LineSegments(geometry, material) {

            Line.call(this, geometry, material);

            this.type = 'LineSegments';

        }

        LineSegments.prototype = Object.assign(Object.create(Line.prototype), {

            constructor: LineSegments,

            isLineSegments: true

        });

        /**
         * @author mgreter / http://github.com/mgreter
         */

        function LineLoop(geometry, material) {

            Line.call(this, geometry, material);

            this.type = 'LineLoop';

        }

        LineLoop.prototype = Object.assign(Object.create(Line.prototype), {

            constructor: LineLoop,

            isLineLoop: true,

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 * }
         */

        function PointsMaterial(parameters) {

            Material.call(this);

            this.type = 'PointsMaterial';

            this.color = new Color(0xffffff);

            this.map = null;

            this.size = 1;
            this.sizeAttenuation = true;

            this.lights = false;

            this.setValues(parameters);

        }

        PointsMaterial.prototype = Object.create(Material.prototype);
        PointsMaterial.prototype.constructor = PointsMaterial;

        PointsMaterial.prototype.isPointsMaterial = true;

        PointsMaterial.prototype.copy = function (source) {

            Material.prototype.copy.call(this, source);

            this.color.copy(source.color);

            this.map = source.map;

            this.size = source.size;
            this.sizeAttenuation = source.sizeAttenuation;

            return this;

        };

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function Points(geometry, material) {

            Object3D.call(this);

            this.type = 'Points';

            this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
            this.material = material !== undefined ? material : new PointsMaterial({color: Math.random() * 0xffffff});

        }

        Points.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Points,

            isPoints: true,

            raycast: (function () {

                var inverseMatrix = new Matrix4();
                var ray = new Ray();
                var sphere = new Sphere();

                return function raycast(raycaster, intersects) {

                    var object = this;
                    var geometry = this.geometry;
                    var matrixWorld = this.matrixWorld;
                    var threshold = raycaster.params.Points.threshold;

                    // Checking boundingSphere distance to ray

                    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                    sphere.copy(geometry.boundingSphere);
                    sphere.applyMatrix4(matrixWorld);
                    sphere.radius += threshold;

                    if (raycaster.ray.intersectsSphere(sphere) === false) return;

                    //

                    inverseMatrix.getInverse(matrixWorld);
                    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

                    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                    var localThresholdSq = localThreshold * localThreshold;
                    var position = new Vector3();

                    function testPoint(point, index) {

                        var rayPointDistanceSq = ray.distanceSqToPoint(point);

                        if (rayPointDistanceSq < localThresholdSq) {

                            var intersectPoint = ray.closestPointToPoint(point);
                            intersectPoint.applyMatrix4(matrixWorld);

                            var distance = raycaster.ray.origin.distanceTo(intersectPoint);

                            if (distance < raycaster.near || distance > raycaster.far) return;

                            intersects.push({

                                distance: distance,
                                distanceToRay: Math.sqrt(rayPointDistanceSq),
                                point: intersectPoint.clone(),
                                index: index,
                                face: null,
                                object: object

                            });

                        }

                    }

                    if (geometry.isBufferGeometry) {

                        var index = geometry.index;
                        var attributes = geometry.attributes;
                        var positions = attributes.position.array;

                        if (index !== null) {

                            var indices = index.array;

                            for (var i = 0, il = indices.length; i < il; i++) {

                                var a = indices[i];

                                position.fromArray(positions, a * 3);

                                testPoint(position, a);

                            }

                        } else {

                            for (var i = 0, l = positions.length / 3; i < l; i++) {

                                position.fromArray(positions, i * 3);

                                testPoint(position, i);

                            }

                        }

                    } else {

                        var vertices = geometry.vertices;

                        for (var i = 0, l = vertices.length; i < l; i++) {

                            testPoint(vertices[i], i);

                        }

                    }

                };

            }()),

            clone: function () {

                return new this.constructor(this.geometry, this.material).copy(this);

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function Group() {

            Object3D.call(this);

            this.type = 'Group';

        }

        Group.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Group

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

            Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

            this.generateMipmaps = false;

            var scope = this;

            function update() {

                if (video.readyState >= video.HAVE_CURRENT_DATA) {

                    scope.needsUpdate = true;

                }

                requestAnimationFrame(update);

            }

            requestAnimationFrame(update);

        }

        VideoTexture.prototype = Object.create(Texture.prototype);
        VideoTexture.prototype.constructor = VideoTexture;

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

            Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

            this.image = {width: width, height: height};
            this.mipmaps = mipmaps;

            // no flipping for cube textures
            // (also flipping doesn't work for compressed textures )

            this.flipY = false;

            // can't generate mipmaps for compressed textures
            // mips must be embedded in DDS files

            this.generateMipmaps = false;

        }

        CompressedTexture.prototype = Object.create(Texture.prototype);
        CompressedTexture.prototype.constructor = CompressedTexture;

        CompressedTexture.prototype.isCompressedTexture = true;

        /**
         * @author Matt DesLauriers / @mattdesl
         * @author atix / arthursilber.de
         */

        function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {

            format = format !== undefined ? format : DepthFormat;

            if (format !== DepthFormat && format !== DepthStencilFormat) {

                throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');

            }

            if (type === undefined && format === DepthFormat) type = UnsignedShortType;
            if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;

            Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

            this.image = {width: width, height: height};

            this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
            this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

            this.flipY = false;
            this.generateMipmaps = false;

        }

        DepthTexture.prototype = Object.create(Texture.prototype);
        DepthTexture.prototype.constructor = DepthTexture;
        DepthTexture.prototype.isDepthTexture = true;


        /**
         * @author zz85 / https://github.com/zz85
         * @author Mugen87 / https://github.com/Mugen87
         *
         * Parametric Surfaces Geometry
         * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
         */

        // ParametricGeometry

        function ParametricGeometry(func, slices, stacks) {

            Geometry.call(this);

            this.type = 'ParametricGeometry';

            this.parameters = {
                func: func,
                slices: slices,
                stacks: stacks
            };

            this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
            this.mergeVertices();

        }

        ParametricGeometry.prototype = Object.create(Geometry.prototype);
        ParametricGeometry.prototype.constructor = ParametricGeometry;

        // ParametricBufferGeometry

        function ParametricBufferGeometry(func, slices, stacks) {

            BufferGeometry.call(this);

            this.type = 'ParametricBufferGeometry';

            this.parameters = {
                func: func,
                slices: slices,
                stacks: stacks
            };

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            var EPS = 0.00001;

            var normal = new Vector3();

            var p0 = new Vector3(), p1 = new Vector3();
            var pu = new Vector3(), pv = new Vector3();

            var i, j;

            // generate vertices, normals and uvs

            var sliceCount = slices + 1;

            for (i = 0; i <= stacks; i++) {

                var v = i / stacks;

                for (j = 0; j <= slices; j++) {

                    var u = j / slices;

                    // vertex

                    p0 = func(u, v, p0);
                    vertices.push(p0.x, p0.y, p0.z);

                    // normal

                    // approximate tangent vectors via finite differences

                    if (u - EPS >= 0) {

                        p1 = func(u - EPS, v, p1);
                        pu.subVectors(p0, p1);

                    } else {

                        p1 = func(u + EPS, v, p1);
                        pu.subVectors(p1, p0);

                    }

                    if (v - EPS >= 0) {

                        p1 = func(u, v - EPS, p1);
                        pv.subVectors(p0, p1);

                    } else {

                        p1 = func(u, v + EPS, p1);
                        pv.subVectors(p1, p0);

                    }

                    // cross product of tangent vectors returns surface normal

                    normal.crossVectors(pu, pv).normalize();
                    normals.push(normal.x, normal.y, normal.z);

                    // uv

                    uvs.push(u, v);

                }

            }

            // generate indices

            for (i = 0; i < stacks; i++) {

                for (j = 0; j < slices; j++) {

                    var a = i * sliceCount + j;
                    var b = i * sliceCount + j + 1;
                    var c = (i + 1) * sliceCount + j + 1;
                    var d = (i + 1) * sliceCount + j;

                    // faces one and two

                    indices.push(a, b, d);
                    indices.push(b, c, d);

                }

            }

            // build geometry

            this.setIndex(indices);
            this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        }

        ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

        /**
         * @author clockworkgeek / https://github.com/clockworkgeek
         * @author timothypratley / https://github.com/timothypratley
         * @author WestLangley / http://github.com/WestLangley
         * @author Mugen87 / https://github.com/Mugen87
         */

        // PolyhedronGeometry

        function PolyhedronGeometry(vertices, indices, radius, detail) {

            Geometry.call(this);

            this.type = 'PolyhedronGeometry';

            this.parameters = {
                vertices: vertices,
                indices: indices,
                radius: radius,
                detail: detail
            };

            this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
            this.mergeVertices();

        }

        PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
        PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

        // PolyhedronBufferGeometry

        function PolyhedronBufferGeometry(vertices, indices, radius, detail) {

            BufferGeometry.call(this);

            this.type = 'PolyhedronBufferGeometry';

            this.parameters = {
                vertices: vertices,
                indices: indices,
                radius: radius,
                detail: detail
            };

            radius = radius || 1;
            detail = detail || 0;

            // default buffer data

            var vertexBuffer = [];
            var uvBuffer = [];

            // the subdivision creates the vertex buffer data

            subdivide(detail);

            // all vertices should lie on a conceptual sphere with a given radius

            appplyRadius(radius);

            // finally, create the uv data

            generateUVs();

            // build non-indexed geometry

            this.addAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
            this.addAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

            if (detail === 0) {

                this.computeVertexNormals(); // flat normals

            } else {

                this.normalizeNormals(); // smooth normals

            }

            // helper functions

            function subdivide(detail) {

                var a = new Vector3();
                var b = new Vector3();
                var c = new Vector3();

                // iterate over all faces and apply a subdivison with the given detail value

                for (var i = 0; i < indices.length; i += 3) {

                    // get the vertices of the face

                    getVertexByIndex(indices[i + 0], a);
                    getVertexByIndex(indices[i + 1], b);
                    getVertexByIndex(indices[i + 2], c);

                    // perform subdivision

                    subdivideFace(a, b, c, detail);

                }

            }

            function subdivideFace(a, b, c, detail) {

                var cols = Math.pow(2, detail);

                // we use this multidimensional array as a data structure for creating the subdivision

                var v = [];

                var i, j;

                // construct all of the vertices for this subdivision

                for (i = 0; i <= cols; i++) {

                    v[i] = [];

                    var aj = a.clone().lerp(c, i / cols);
                    var bj = b.clone().lerp(c, i / cols);

                    var rows = cols - i;

                    for (j = 0; j <= rows; j++) {

                        if (j === 0 && i === cols) {

                            v[i][j] = aj;

                        } else {

                            v[i][j] = aj.clone().lerp(bj, j / rows);

                        }

                    }

                }

                // construct all of the faces

                for (i = 0; i < cols; i++) {

                    for (j = 0; j < 2 * (cols - i) - 1; j++) {

                        var k = Math.floor(j / 2);

                        if (j % 2 === 0) {

                            pushVertex(v[i][k + 1]);
                            pushVertex(v[i + 1][k]);
                            pushVertex(v[i][k]);

                        } else {

                            pushVertex(v[i][k + 1]);
                            pushVertex(v[i + 1][k + 1]);
                            pushVertex(v[i + 1][k]);

                        }

                    }

                }

            }

            function appplyRadius(radius) {

                var vertex = new Vector3();

                // iterate over the entire buffer and apply the radius to each vertex

                for (var i = 0; i < vertexBuffer.length; i += 3) {

                    vertex.x = vertexBuffer[i + 0];
                    vertex.y = vertexBuffer[i + 1];
                    vertex.z = vertexBuffer[i + 2];

                    vertex.normalize().multiplyScalar(radius);

                    vertexBuffer[i + 0] = vertex.x;
                    vertexBuffer[i + 1] = vertex.y;
                    vertexBuffer[i + 2] = vertex.z;

                }

            }

            function generateUVs() {

                var vertex = new Vector3();

                for (var i = 0; i < vertexBuffer.length; i += 3) {

                    vertex.x = vertexBuffer[i + 0];
                    vertex.y = vertexBuffer[i + 1];
                    vertex.z = vertexBuffer[i + 2];

                    var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                    var v = inclination(vertex) / Math.PI + 0.5;
                    uvBuffer.push(u, 1 - v);

                }

                correctUVs();

                correctSeam();

            }

            function correctSeam() {

                // handle case when face straddles the seam, see #3269

                for (var i = 0; i < uvBuffer.length; i += 6) {

                    // uv data of a single face

                    var x0 = uvBuffer[i + 0];
                    var x1 = uvBuffer[i + 2];
                    var x2 = uvBuffer[i + 4];

                    var max = Math.max(x0, x1, x2);
                    var min = Math.min(x0, x1, x2);

                    // 0.9 is somewhat arbitrary

                    if (max > 0.9 && min < 0.1) {

                        if (x0 < 0.2) uvBuffer[i + 0] += 1;
                        if (x1 < 0.2) uvBuffer[i + 2] += 1;
                        if (x2 < 0.2) uvBuffer[i + 4] += 1;

                    }

                }

            }

            function pushVertex(vertex) {

                vertexBuffer.push(vertex.x, vertex.y, vertex.z);

            }

            function getVertexByIndex(index, vertex) {

                var stride = index * 3;

                vertex.x = vertices[stride + 0];
                vertex.y = vertices[stride + 1];
                vertex.z = vertices[stride + 2];

            }

            function correctUVs() {

                var a = new Vector3();
                var b = new Vector3();
                var c = new Vector3();

                var centroid = new Vector3();

                var uvA = new Vector2();
                var uvB = new Vector2();
                var uvC = new Vector2();

                for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {

                    a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                    b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                    c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);

                    uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                    uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                    uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);

                    centroid.copy(a).add(b).add(c).divideScalar(3);

                    var azi = azimuth(centroid);

                    correctUV(uvA, j + 0, a, azi);
                    correctUV(uvB, j + 2, b, azi);
                    correctUV(uvC, j + 4, c, azi);

                }

            }

            function correctUV(uv, stride, vector, azimuth) {

                if ((azimuth < 0) && (uv.x === 1)) {

                    uvBuffer[stride] = uv.x - 1;

                }

                if ((vector.x === 0) && (vector.z === 0)) {

                    uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;

                }

            }

            // Angle around the Y axis, counter-clockwise when looking from above.

            function azimuth(vector) {

                return Math.atan2(vector.z, -vector.x);

            }


            // Angle above the XZ plane.

            function inclination(vector) {

                return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));

            }

        }

        PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

        /**
         * @author timothypratley / https://github.com/timothypratley
         * @author Mugen87 / https://github.com/Mugen87
         */

        // TetrahedronGeometry

        function TetrahedronGeometry(radius, detail) {

            Geometry.call(this);

            this.type = 'TetrahedronGeometry';

            this.parameters = {
                radius: radius,
                detail: detail
            };

            this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
            this.mergeVertices();

        }

        TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
        TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

        // TetrahedronBufferGeometry

        function TetrahedronBufferGeometry(radius, detail) {

            var vertices = [
                1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
            ];

            var indices = [
                2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
            ];

            PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

            this.type = 'TetrahedronBufferGeometry';

            this.parameters = {
                radius: radius,
                detail: detail
            };

        }

        TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
        TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

        /**
         * @author timothypratley / https://github.com/timothypratley
         * @author Mugen87 / https://github.com/Mugen87
         */

        // OctahedronGeometry

        function OctahedronGeometry(radius, detail) {

            Geometry.call(this);

            this.type = 'OctahedronGeometry';

            this.parameters = {
                radius: radius,
                detail: detail
            };

            this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
            this.mergeVertices();

        }

        OctahedronGeometry.prototype = Object.create(Geometry.prototype);
        OctahedronGeometry.prototype.constructor = OctahedronGeometry;

        // OctahedronBufferGeometry

        function OctahedronBufferGeometry(radius, detail) {

            var vertices = [
                1, 0, 0, -1, 0, 0, 0, 1, 0,
                0, -1, 0, 0, 0, 1, 0, 0, -1
            ];

            var indices = [
                0, 2, 4, 0, 4, 3, 0, 3, 5,
                0, 5, 2, 1, 2, 5, 1, 5, 3,
                1, 3, 4, 1, 4, 2
            ];

            PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

            this.type = 'OctahedronBufferGeometry';

            this.parameters = {
                radius: radius,
                detail: detail
            };

        }

        OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
        OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

        /**
         * @author timothypratley / https://github.com/timothypratley
         * @author Mugen87 / https://github.com/Mugen87
         */

        // IcosahedronGeometry

        function IcosahedronGeometry(radius, detail) {

            Geometry.call(this);

            this.type = 'IcosahedronGeometry';

            this.parameters = {
                radius: radius,
                detail: detail
            };

            this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
            this.mergeVertices();

        }

        IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
        IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

        // IcosahedronBufferGeometry

        function IcosahedronBufferGeometry(radius, detail) {

            var t = (1 + Math.sqrt(5)) / 2;

            var vertices = [
                -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
                0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
                t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
            ];

            var indices = [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
                1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
                3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
                4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
            ];

            PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

            this.type = 'IcosahedronBufferGeometry';

            this.parameters = {
                radius: radius,
                detail: detail
            };

        }

        IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
        IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;


        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         */

        var ShapeUtils = {

            // calculate area of the contour polygon

            area: function (contour) {

                var n = contour.length;
                var a = 0.0;

                for (var p = n - 1, q = 0; q < n; p = q++) {

                    a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;

                }

                return a * 0.5;

            },

            triangulate: (function () {

                /**
                 * This code is a quick port of code written in C++ which was submitted to
                 * flipcode.com by John W. Ratcliff  // July 22, 2000
                 * See original code and more information here:
                 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
                 *
                 * ported to actionscript by Zevan Rosser
                 * www.actionsnippet.com
                 *
                 * ported to javascript by Joshua Koo
                 * http://www.lab4games.net/zz85/blog
                 *
                 */

                function snip(contour, u, v, w, n, verts) {

                    var p;
                    var ax, ay, bx, by;
                    var cx, cy, px, py;

                    ax = contour[verts[u]].x;
                    ay = contour[verts[u]].y;

                    bx = contour[verts[v]].x;
                    by = contour[verts[v]].y;

                    cx = contour[verts[w]].x;
                    cy = contour[verts[w]].y;

                    if ((bx - ax) * (cy - ay) - (by - ay) * (cx - ax) <= 0) return false;

                    var aX, aY, bX, bY, cX, cY;
                    var apx, apy, bpx, bpy, cpx, cpy;
                    var cCROSSap, bCROSScp, aCROSSbp;

                    aX = cx - bx;
                    aY = cy - by;
                    bX = ax - cx;
                    bY = ay - cy;
                    cX = bx - ax;
                    cY = by - ay;

                    for (p = 0; p < n; p++) {

                        px = contour[verts[p]].x;
                        py = contour[verts[p]].y;

                        if (((px === ax) && (py === ay)) ||
                            ((px === bx) && (py === by)) ||
                            ((px === cx) && (py === cy))) continue;

                        apx = px - ax;
                        apy = py - ay;
                        bpx = px - bx;
                        bpy = py - by;
                        cpx = px - cx;
                        cpy = py - cy;

                        // see if p is inside triangle abc

                        aCROSSbp = aX * bpy - aY * bpx;
                        cCROSSap = cX * apy - cY * apx;
                        bCROSScp = bX * cpy - bY * cpx;

                        if ((aCROSSbp >= -Number.EPSILON) && (bCROSScp >= -Number.EPSILON) && (cCROSSap >= -Number.EPSILON)) return false;

                    }

                    return true;

                }

                // takes in an contour array and returns

                return function triangulate(contour, indices) {

                    var n = contour.length;

                    if (n < 3) return null;

                    var result = [],
                        verts = [],
                        vertIndices = [];

                    /* we want a counter-clockwise polygon in verts */

                    var u, v, w;

                    if (ShapeUtils.area(contour) > 0.0) {

                        for (v = 0; v < n; v++) verts[v] = v;

                    } else {

                        for (v = 0; v < n; v++) verts[v] = (n - 1) - v;

                    }

                    var nv = n;

                    /*  remove nv - 2 vertices, creating 1 triangle every time */

                    var count = 2 * nv;
                    /* error detection */

                    for (v = nv - 1; nv > 2;) {

                        /* if we loop, it is probably a non-simple polygon */

                        if ((count--) <= 0) {

                            //** Triangulate: ERROR - probable bad polygon!

                            //throw ( "Warning, unable to triangulate polygon!" );
                            //return null;
                            // Sometimes warning is fine, especially polygons are triangulated in reverse.
                            console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');

                            if (indices) return vertIndices;
                            return result;

                        }

                        /* three consecutive vertices in current polygon, <u,v,w> */

                        u = v;
                        if (nv <= u) u = 0;
                        /* previous */
                        v = u + 1;
                        if (nv <= v) v = 0;
                        /* new v    */
                        w = v + 1;
                        if (nv <= w) w = 0;
                        /* next     */

                        if (snip(contour, u, v, w, nv, verts)) {

                            var a, b, c, s, t;

                            /* true names of the vertices */

                            a = verts[u];
                            b = verts[v];
                            c = verts[w];

                            /* output Triangle */

                            result.push([contour[a],
                                contour[b],
                                contour[c]]);


                            vertIndices.push([verts[u], verts[v], verts[w]]);

                            /* remove v from the remaining polygon */

                            for (s = v, t = v + 1; t < nv; s++, t++) {

                                verts[s] = verts[t];

                            }

                            nv--;

                            /* reset error detection counter */

                            count = 2 * nv;

                        }

                    }

                    if (indices) return vertIndices;
                    return result;

                };

            })(),

            triangulateShape: function (contour, holes) {

                function removeDupEndPts(points) {

                    var l = points.length;

                    if (l > 2 && points[l - 1].equals(points[0])) {

                        points.pop();

                    }

                }

                removeDupEndPts(contour);
                holes.forEach(removeDupEndPts);

                function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {

                    // inOtherPt needs to be collinear to the inSegment
                    if (inSegPt1.x !== inSegPt2.x) {

                        if (inSegPt1.x < inSegPt2.x) {

                            return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));

                        } else {

                            return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));

                        }

                    } else {

                        if (inSegPt1.y < inSegPt2.y) {

                            return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));

                        } else {

                            return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));

                        }

                    }

                }

                function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {

                    var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
                    var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

                    var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
                    var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

                    var limit = seg1dy * seg2dx - seg1dx * seg2dy;
                    var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

                    if (Math.abs(limit) > Number.EPSILON) {

                        // not parallel

                        var perpSeg2;
                        if (limit > 0) {

                            if ((perpSeg1 < 0) || (perpSeg1 > limit)) return [];
                            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                            if ((perpSeg2 < 0) || (perpSeg2 > limit)) return [];

                        } else {

                            if ((perpSeg1 > 0) || (perpSeg1 < limit)) return [];
                            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                            if ((perpSeg2 > 0) || (perpSeg2 < limit)) return [];

                        }

                        // i.e. to reduce rounding errors
                        // intersection at endpoint of segment#1?
                        if (perpSeg2 === 0) {

                            if ((inExcludeAdjacentSegs) &&
                                ((perpSeg1 === 0) || (perpSeg1 === limit))) return [];
                            return [inSeg1Pt1];

                        }
                        if (perpSeg2 === limit) {

                            if ((inExcludeAdjacentSegs) &&
                                ((perpSeg1 === 0) || (perpSeg1 === limit))) return [];
                            return [inSeg1Pt2];

                        }
                        // intersection at endpoint of segment#2?
                        if (perpSeg1 === 0) return [inSeg2Pt1];
                        if (perpSeg1 === limit) return [inSeg2Pt2];

                        // return real intersection point
                        var factorSeg1 = perpSeg2 / limit;
                        return [{x: inSeg1Pt1.x + factorSeg1 * seg1dx, y: inSeg1Pt1.y + factorSeg1 * seg1dy}];

                    } else {

                        // parallel or collinear
                        if ((perpSeg1 !== 0) ||
                            (seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy)) return [];

                        // they are collinear or degenerate
                        var seg1Pt = ((seg1dx === 0) && (seg1dy === 0));	// segment1 is just a point?
                        var seg2Pt = ((seg2dx === 0) && (seg2dy === 0));	// segment2 is just a point?
                        // both segments are points
                        if (seg1Pt && seg2Pt) {

                            if ((inSeg1Pt1.x !== inSeg2Pt1.x) ||
                                (inSeg1Pt1.y !== inSeg2Pt1.y)) return [];	// they are distinct  points
                            return [inSeg1Pt1];	// they are the same point

                        }
                        // segment#1  is a single point
                        if (seg1Pt) {

                            if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1)) return [];		// but not in segment#2
                            return [inSeg1Pt1];

                        }
                        // segment#2  is a single point
                        if (seg2Pt) {

                            if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1)) return [];		// but not in segment#1
                            return [inSeg2Pt1];

                        }

                        // they are collinear segments, which might overlap
                        var seg1min, seg1max, seg1minVal, seg1maxVal;
                        var seg2min, seg2max, seg2minVal, seg2maxVal;
                        if (seg1dx !== 0) {

                            // the segments are NOT on a vertical line
                            if (inSeg1Pt1.x < inSeg1Pt2.x) {

                                seg1min = inSeg1Pt1;
                                seg1minVal = inSeg1Pt1.x;
                                seg1max = inSeg1Pt2;
                                seg1maxVal = inSeg1Pt2.x;

                            } else {

                                seg1min = inSeg1Pt2;
                                seg1minVal = inSeg1Pt2.x;
                                seg1max = inSeg1Pt1;
                                seg1maxVal = inSeg1Pt1.x;

                            }
                            if (inSeg2Pt1.x < inSeg2Pt2.x) {

                                seg2min = inSeg2Pt1;
                                seg2minVal = inSeg2Pt1.x;
                                seg2max = inSeg2Pt2;
                                seg2maxVal = inSeg2Pt2.x;

                            } else {

                                seg2min = inSeg2Pt2;
                                seg2minVal = inSeg2Pt2.x;
                                seg2max = inSeg2Pt1;
                                seg2maxVal = inSeg2Pt1.x;

                            }

                        } else {

                            // the segments are on a vertical line
                            if (inSeg1Pt1.y < inSeg1Pt2.y) {

                                seg1min = inSeg1Pt1;
                                seg1minVal = inSeg1Pt1.y;
                                seg1max = inSeg1Pt2;
                                seg1maxVal = inSeg1Pt2.y;

                            } else {

                                seg1min = inSeg1Pt2;
                                seg1minVal = inSeg1Pt2.y;
                                seg1max = inSeg1Pt1;
                                seg1maxVal = inSeg1Pt1.y;

                            }
                            if (inSeg2Pt1.y < inSeg2Pt2.y) {

                                seg2min = inSeg2Pt1;
                                seg2minVal = inSeg2Pt1.y;
                                seg2max = inSeg2Pt2;
                                seg2maxVal = inSeg2Pt2.y;

                            } else {

                                seg2min = inSeg2Pt2;
                                seg2minVal = inSeg2Pt2.y;
                                seg2max = inSeg2Pt1;
                                seg2maxVal = inSeg2Pt1.y;

                            }

                        }
                        if (seg1minVal <= seg2minVal) {

                            if (seg1maxVal < seg2minVal) return [];
                            if (seg1maxVal === seg2minVal) {

                                if (inExcludeAdjacentSegs) return [];
                                return [seg2min];

                            }
                            if (seg1maxVal <= seg2maxVal) return [seg2min, seg1max];
                            return [seg2min, seg2max];

                        } else {

                            if (seg1minVal > seg2maxVal) return [];
                            if (seg1minVal === seg2maxVal) {

                                if (inExcludeAdjacentSegs) return [];
                                return [seg1min];

                            }
                            if (seg1maxVal <= seg2maxVal) return [seg1min, seg1max];
                            return [seg1min, seg2max];

                        }

                    }

                }

                function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {

                    // The order of legs is important

                    // translation of all points, so that Vertex is at (0,0)
                    var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
                    var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
                    var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;

                    // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
                    var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
                    var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

                    if (Math.abs(from2toAngle) > Number.EPSILON) {

                        // angle != 180 deg.

                        var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                        // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

                        if (from2toAngle > 0) {

                            // main angle < 180 deg.
                            return ((from2otherAngle >= 0) && (other2toAngle >= 0));

                        } else {

                            // main angle > 180 deg.
                            return ((from2otherAngle >= 0) || (other2toAngle >= 0));

                        }

                    } else {

                        // angle == 180 deg.
                        // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
                        return (from2otherAngle > 0);

                    }

                }


                function removeHoles(contour, holes) {

                    var shape = contour.concat(); // work on this shape
                    var hole;

                    function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {

                        // Check if hole point lies within angle around shape point
                        var lastShapeIdx = shape.length - 1;

                        var prevShapeIdx = inShapeIdx - 1;
                        if (prevShapeIdx < 0) prevShapeIdx = lastShapeIdx;

                        var nextShapeIdx = inShapeIdx + 1;
                        if (nextShapeIdx > lastShapeIdx) nextShapeIdx = 0;

                        var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                        if (!insideAngle) {

                            // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
                            return false;

                        }

                        // Check if shape point lies within angle around hole point
                        var lastHoleIdx = hole.length - 1;

                        var prevHoleIdx = inHoleIdx - 1;
                        if (prevHoleIdx < 0) prevHoleIdx = lastHoleIdx;

                        var nextHoleIdx = inHoleIdx + 1;
                        if (nextHoleIdx > lastHoleIdx) nextHoleIdx = 0;

                        insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
                        if (!insideAngle) {

                            // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
                            return false;

                        }

                        return true;

                    }

                    function intersectsShapeEdge(inShapePt, inHolePt) {

                        // checks for intersections with shape edges
                        var sIdx, nextIdx, intersection;
                        for (sIdx = 0; sIdx < shape.length; sIdx++) {

                            nextIdx = sIdx + 1;
                            nextIdx %= shape.length;
                            intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
                            if (intersection.length > 0) return true;

                        }

                        return false;

                    }

                    var indepHoles = [];

                    function intersectsHoleEdge(inShapePt, inHolePt) {

                        // checks for intersections with hole edges
                        var ihIdx, chkHole,
                            hIdx, nextIdx, intersection;
                        for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {

                            chkHole = holes[indepHoles[ihIdx]];
                            for (hIdx = 0; hIdx < chkHole.length; hIdx++) {

                                nextIdx = hIdx + 1;
                                nextIdx %= chkHole.length;
                                intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                                if (intersection.length > 0) return true;

                            }

                        }
                        return false;

                    }

                    var holeIndex, shapeIndex,
                        shapePt, holePt,
                        holeIdx, cutKey, failedCuts = [],
                        tmpShape1, tmpShape2,
                        tmpHole1, tmpHole2;

                    for (var h = 0, hl = holes.length; h < hl; h++) {

                        indepHoles.push(h);

                    }

                    var minShapeIndex = 0;
                    var counter = indepHoles.length * 2;
                    while (indepHoles.length > 0) {

                        counter--;
                        if (counter < 0) {

                            console.log('THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!');
                            break;

                        }

                        // search for shape-vertex and hole-vertex,
                        // which can be connected without intersections
                        for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {

                            shapePt = shape[shapeIndex];
                            holeIndex = -1;

                            // search for hole which can be reached without intersections
                            for (var h = 0; h < indepHoles.length; h++) {

                                holeIdx = indepHoles[h];

                                // prevent multiple checks
                                cutKey = shapePt.x + ':' + shapePt.y + ':' + holeIdx;
                                if (failedCuts[cutKey] !== undefined) continue;

                                hole = holes[holeIdx];
                                for (var h2 = 0; h2 < hole.length; h2++) {

                                    holePt = hole[h2];
                                    if (!isCutLineInsideAngles(shapeIndex, h2)) continue;
                                    if (intersectsShapeEdge(shapePt, holePt)) continue;
                                    if (intersectsHoleEdge(shapePt, holePt)) continue;

                                    holeIndex = h2;
                                    indepHoles.splice(h, 1);

                                    tmpShape1 = shape.slice(0, shapeIndex + 1);
                                    tmpShape2 = shape.slice(shapeIndex);
                                    tmpHole1 = hole.slice(holeIndex);
                                    tmpHole2 = hole.slice(0, holeIndex + 1);

                                    shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);

                                    minShapeIndex = shapeIndex;

                                    // Debug only, to show the selected cuts
                                    // glob_CutLines.push( [ shapePt, holePt ] );

                                    break;

                                }
                                if (holeIndex >= 0) break;		// hole-vertex found

                                failedCuts[cutKey] = true;			// remember failure

                            }
                            if (holeIndex >= 0) break;		// hole-vertex found

                        }

                    }

                    return shape;
                    /* shape with no holes */

                }


                var i, il, f, face,
                    key, index,
                    allPointsMap = {};

                // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

                var allpoints = contour.concat();

                for (var h = 0, hl = holes.length; h < hl; h++) {

                    Array.prototype.push.apply(allpoints, holes[h]);

                }

                //console.log( "allpoints",allpoints, allpoints.length );

                // prepare all points map

                for (i = 0, il = allpoints.length; i < il; i++) {

                    key = allpoints[i].x + ':' + allpoints[i].y;

                    if (allPointsMap[key] !== undefined) {

                        console.warn('THREE.ShapeUtils: Duplicate point', key, i);

                    }

                    allPointsMap[key] = i;

                }

                // remove holes by cutting paths to holes and adding them to the shape
                var shapeWithoutHoles = removeHoles(contour, holes);

                var triangles = ShapeUtils.triangulate(shapeWithoutHoles, false); // True returns indices for points of spooled shape
                //console.log( "triangles",triangles, triangles.length );

                // check all face vertices against all points map

                for (i = 0, il = triangles.length; i < il; i++) {

                    face = triangles[i];

                    for (f = 0; f < 3; f++) {

                        key = face[f].x + ':' + face[f].y;

                        index = allPointsMap[key];

                        if (index !== undefined) {

                            face[f] = index;

                        }

                    }

                }

                return triangles.concat();

            },

            isClockWise: function (pts) {

                return ShapeUtils.area(pts) < 0;

            }

        };

        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         *
         * Creates extruded geometry from a path shape.
         *
         * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *  frames: <Object> // containing arrays of tangents, normals, binormals
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
         */

        // ExtrudeGeometry

        function ExtrudeGeometry(shapes, options) {

            Geometry.call(this);

            this.type = 'ExtrudeGeometry';

            this.parameters = {
                shapes: shapes,
                options: options
            };

            this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
            this.mergeVertices();

        }

        ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
        ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

        // ExtrudeBufferGeometry

        function ExtrudeBufferGeometry(shapes, options) {

            if (typeof (shapes) === "undefined") {

                return;

            }

            BufferGeometry.call(this);

            this.type = 'ExtrudeBufferGeometry';

            shapes = Array.isArray(shapes) ? shapes : [shapes];

            this.addShapeList(shapes, options);

            this.computeVertexNormals();

            // can't really use automatic vertex normals
            // as then front and back sides get smoothed too
            // should do separate smoothing just for sides

            //this.computeVertexNormals();

            //console.log( "took", ( Date.now() - startTime ) );

        }

        ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

        ExtrudeBufferGeometry.prototype.getArrays = function () {

            var positionAttribute = this.getAttribute("position");
            var verticesArray = positionAttribute ? Array.prototype.slice.call(positionAttribute.array) : [];

            var uvAttribute = this.getAttribute("uv");
            var uvArray = uvAttribute ? Array.prototype.slice.call(uvAttribute.array) : [];

            var IndexAttribute = this.index;
            var indicesArray = IndexAttribute ? Array.prototype.slice.call(IndexAttribute.array) : [];

            return {
                position: verticesArray,
                uv: uvArray,
                index: indicesArray
            };

        };

        ExtrudeBufferGeometry.prototype.addShapeList = function (shapes, options) {

            var sl = shapes.length;
            options.arrays = this.getArrays();

            for (var s = 0; s < sl; s++) {

                var shape = shapes[s];
                this.addShape(shape, options);

            }

            this.setIndex(options.arrays.index);
            this.addAttribute('position', new Float32BufferAttribute(options.arrays.position, 3));
            this.addAttribute('uv', new Float32BufferAttribute(options.arrays.uv, 2));

        };

        ExtrudeBufferGeometry.prototype.addShape = function (shape, options) {

            var arrays = options.arrays ? options.arrays : this.getArrays();
            var verticesArray = arrays.position;
            var indicesArray = arrays.index;
            var uvArray = arrays.uv;

            var placeholder = [];


            var amount = options.amount !== undefined ? options.amount : 100;

            var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
            var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
            var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

            var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

            var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

            var steps = options.steps !== undefined ? options.steps : 1;

            var extrudePath = options.extrudePath;
            var extrudePts, extrudeByPath = false;

            // Use default WorldUVGenerator if no UV generators are specified.
            var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

            var splineTube, binormal, normal, position2;
            if (extrudePath) {

                extrudePts = extrudePath.getSpacedPoints(steps);

                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion

                // SETUP TNB variables

                // TODO1 - have a .isClosed in spline?

                splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames(steps, false);

                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

                binormal = new Vector3();
                normal = new Vector3();
                position2 = new Vector3();

            }

            // Safeguards if bevels are not enabled

            if (!bevelEnabled) {

                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;

            }

            // Variables initialization

            var ahole, h, hl; // looping of holes
            var scope = this;

            var shapePoints = shape.extractPoints(curveSegments);

            var vertices = shapePoints.shape;
            var holes = shapePoints.holes;

            var reverse = !ShapeUtils.isClockWise(vertices);

            if (reverse) {

                vertices = vertices.reverse();

                // Maybe we should also check if holes are in the opposite direction, just to be safe ...

                for (h = 0, hl = holes.length; h < hl; h++) {

                    ahole = holes[h];

                    if (ShapeUtils.isClockWise(ahole)) {

                        holes[h] = ahole.reverse();

                    }

                }

            }


            var faces = ShapeUtils.triangulateShape(vertices, holes);

            /* Vertices */

            var contour = vertices; // vertices has all points but contour has only points of circumference

            for (h = 0, hl = holes.length; h < hl; h++) {

                ahole = holes[h];

                vertices = vertices.concat(ahole);

            }


            function scalePt2(pt, vec, size) {

                if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");

                return vec.clone().multiplyScalar(size).add(pt);

            }

            var b, bs, t, z,
                vert, vlen = vertices.length,
                face, flen = faces.length;


            // Find directions for point movement


            function getBevelVec(inPt, inPrev, inNext) {

                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.

                var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html

                var v_prev_x = inPt.x - inPrev.x,
                    v_prev_y = inPt.y - inPrev.y;
                var v_next_x = inNext.x - inPt.x,
                    v_next_y = inNext.y - inPt.y;

                var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);

                // check for collinear edges
                var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);

                if (Math.abs(collinear0) > Number.EPSILON) {

                    // not collinear

                    // length of vectors for normalizing

                    var v_prev_len = Math.sqrt(v_prev_lensq);
                    var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

                    // shift adjacent points by unit vectors to the left

                    var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                    var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);

                    var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                    var ptNextShift_y = (inNext.y + v_next_x / v_next_len);

                    // scaling factor for v_prev to intersection point

                    var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                        (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                        (v_prev_x * v_next_y - v_prev_y * v_next_x);

                    // vector from inPt to intersection point

                    v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                    v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);

                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                    if (v_trans_lensq <= 2) {

                        return new Vector2(v_trans_x, v_trans_y);

                    } else {

                        shrink_by = Math.sqrt(v_trans_lensq / 2);

                    }

                } else {

                    // handle special case of collinear edges

                    var direction_eq = false; // assumes: opposite
                    if (v_prev_x > Number.EPSILON) {

                        if (v_next_x > Number.EPSILON) {

                            direction_eq = true;

                        }

                    } else {

                        if (v_prev_x < -Number.EPSILON) {

                            if (v_next_x < -Number.EPSILON) {

                                direction_eq = true;

                            }

                        } else {

                            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {

                                direction_eq = true;

                            }

                        }

                    }

                    if (direction_eq) {

                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);

                    } else {

                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);

                    }

                }

                return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);

            }


            var contourMovements = [];

            for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

                if (j === il) j = 0;
                if (k === il) k = 0;

                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)

                contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);

            }

            var holesMovements = [],
                oneHoleMovements, verticesMovements = contourMovements.concat();

            for (h = 0, hl = holes.length; h < hl; h++) {

                ahole = holes[h];

                oneHoleMovements = [];

                for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

                    if (j === il) j = 0;
                    if (k === il) k = 0;

                    //  (j)---(i)---(k)
                    oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);

                }

                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);

            }


            // Loop bevelSegments, 1 for the front, 1 for the back

            for (b = 0; b < bevelSegments; b++) {

                //for ( b = bevelSegments; b > 0; b -- ) {

                t = b / bevelSegments;
                z = bevelThickness * Math.cos(t * Math.PI / 2);
                bs = bevelSize * Math.sin(t * Math.PI / 2);

                // contract shape

                for (i = 0, il = contour.length; i < il; i++) {

                    vert = scalePt2(contour[i], contourMovements[i], bs);

                    v(vert.x, vert.y, -z);

                }

                // expand holes

                for (h = 0, hl = holes.length; h < hl; h++) {

                    ahole = holes[h];
                    oneHoleMovements = holesMovements[h];

                    for (i = 0, il = ahole.length; i < il; i++) {

                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

                        v(vert.x, vert.y, -z);

                    }

                }

            }

            bs = bevelSize;

            // Back facing vertices

            for (i = 0; i < vlen; i++) {

                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

                if (!extrudeByPath) {

                    v(vert.x, vert.y, 0);

                } else {

                    // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

                    normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);

                    position2.copy(extrudePts[0]).add(normal).add(binormal);

                    v(position2.x, position2.y, position2.z);

                }

            }

            // Add stepped vertices...
            // Including front facing vertices

            var s;

            for (s = 1; s <= steps; s++) {

                for (i = 0; i < vlen; i++) {

                    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

                    if (!extrudeByPath) {

                        v(vert.x, vert.y, amount / steps * s);

                    } else {

                        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                        normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);

                        position2.copy(extrudePts[s]).add(normal).add(binormal);

                        v(position2.x, position2.y, position2.z);

                    }

                }

            }


            // Add bevel segments planes

            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for (b = bevelSegments - 1; b >= 0; b--) {

                t = b / bevelSegments;
                z = bevelThickness * Math.cos(t * Math.PI / 2);
                bs = bevelSize * Math.sin(t * Math.PI / 2);

                // contract shape

                for (i = 0, il = contour.length; i < il; i++) {

                    vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert.x, vert.y, amount + z);

                }

                // expand holes

                for (h = 0, hl = holes.length; h < hl; h++) {

                    ahole = holes[h];
                    oneHoleMovements = holesMovements[h];

                    for (i = 0, il = ahole.length; i < il; i++) {

                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

                        if (!extrudeByPath) {

                            v(vert.x, vert.y, amount + z);

                        } else {

                            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);

                        }

                    }

                }

            }

            /* Faces */

            // Top and bottom faces

            buildLidFaces();

            // Sides faces

            buildSideFaces();


            /////  Internal functions

            function buildLidFaces() {

                var start = verticesArray.length / 3;

                if (bevelEnabled) {

                    var layer = 0; // steps + 1
                    var offset = vlen * layer;

                    // Bottom faces

                    for (i = 0; i < flen; i++) {

                        face = faces[i];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);

                    }

                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;

                    // Top faces

                    for (i = 0; i < flen; i++) {

                        face = faces[i];
                        f3(face[0] + offset, face[1] + offset, face[2] + offset);

                    }

                } else {

                    // Bottom faces

                    for (i = 0; i < flen; i++) {

                        face = faces[i];
                        f3(face[2], face[1], face[0]);

                    }

                    // Top faces

                    for (i = 0; i < flen; i++) {

                        face = faces[i];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);

                    }

                }

                scope.addGroup(start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0);

            }

            // Create faces for the z-sides of the shape

            function buildSideFaces() {

                var start = verticesArray.length / 3;
                var layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;

                for (h = 0, hl = holes.length; h < hl; h++) {

                    ahole = holes[h];
                    sidewalls(ahole, layeroffset);

                    //, true
                    layeroffset += ahole.length;

                }


                scope.addGroup(start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1);


            }

            function sidewalls(contour, layeroffset) {

                var j, k;
                i = contour.length;

                while (--i >= 0) {

                    j = i;
                    k = i - 1;
                    if (k < 0) k = contour.length - 1;

                    //console.log('b', i,j, i-1, k,vertices.length);

                    var s = 0,
                        sl = steps + bevelSegments * 2;

                    for (s = 0; s < sl; s++) {

                        var slen1 = vlen * s;
                        var slen2 = vlen * (s + 1);

                        var a = layeroffset + j + slen1,
                            b = layeroffset + k + slen1,
                            c = layeroffset + k + slen2,
                            d = layeroffset + j + slen2;

                        f4(a, b, c, d);

                    }

                }

            }

            function v(x, y, z) {

                placeholder.push(x);
                placeholder.push(y);
                placeholder.push(z);

            }


            function f3(a, b, c) {

                addVertex(a);
                addVertex(b);
                addVertex(c);

                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);

                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[2]);

            }

            function f4(a, b, c, d) {

                addVertex(a);
                addVertex(b);
                addVertex(d);

                addVertex(b);
                addVertex(c);
                addVertex(d);


                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);

                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[3]);

                addUV(uvs[1]);
                addUV(uvs[2]);
                addUV(uvs[3]);

            }

            function addVertex(index) {

                indicesArray.push(verticesArray.length / 3);
                verticesArray.push(placeholder[index * 3 + 0]);
                verticesArray.push(placeholder[index * 3 + 1]);
                verticesArray.push(placeholder[index * 3 + 2]);

            }


            function addUV(vector2) {

                uvArray.push(vector2.x);
                uvArray.push(vector2.y);

            }

            if (!options.arrays) {

                this.setIndex(indicesArray);
                this.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));
                this.addAttribute('uv', new Float32BufferAttribute(options.arrays.uv, 2));

            }

        };

        ExtrudeGeometry.WorldUVGenerator = {

            generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {

                var a_x = vertices[indexA * 3];
                var a_y = vertices[indexA * 3 + 1];
                var b_x = vertices[indexB * 3];
                var b_y = vertices[indexB * 3 + 1];
                var c_x = vertices[indexC * 3];
                var c_y = vertices[indexC * 3 + 1];

                return [
                    new Vector2(a_x, a_y),
                    new Vector2(b_x, b_y),
                    new Vector2(c_x, c_y)
                ];

            },

            generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {

                var a_x = vertices[indexA * 3];
                var a_y = vertices[indexA * 3 + 1];
                var a_z = vertices[indexA * 3 + 2];
                var b_x = vertices[indexB * 3];
                var b_y = vertices[indexB * 3 + 1];
                var b_z = vertices[indexB * 3 + 2];
                var c_x = vertices[indexC * 3];
                var c_y = vertices[indexC * 3 + 1];
                var c_z = vertices[indexC * 3 + 2];
                var d_x = vertices[indexD * 3];
                var d_y = vertices[indexD * 3 + 1];
                var d_z = vertices[indexD * 3 + 2];

                if (Math.abs(a_y - b_y) < 0.01) {

                    return [
                        new Vector2(a_x, 1 - a_z),
                        new Vector2(b_x, 1 - b_z),
                        new Vector2(c_x, 1 - c_z),
                        new Vector2(d_x, 1 - d_z)
                    ];

                } else {

                    return [
                        new Vector2(a_y, 1 - a_z),
                        new Vector2(b_y, 1 - b_z),
                        new Vector2(c_y, 1 - c_z),
                        new Vector2(d_y, 1 - d_z)
                    ];

                }

            }
        };

        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * @author alteredq / http://alteredqualia.com/
         *
         * Text = 3D Text
         *
         * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
         */

        // TextGeometry

        function TextGeometry(text, parameters) {

            Geometry.call(this);

            this.type = 'TextGeometry';

            this.parameters = {
                text: text,
                parameters: parameters
            };

            this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
            this.mergeVertices();

        }

        TextGeometry.prototype = Object.create(Geometry.prototype);
        TextGeometry.prototype.constructor = TextGeometry;

        // TextBufferGeometry

        function TextBufferGeometry(text, parameters) {

            parameters = parameters || {};

            var font = parameters.font;

            if (!(font && font.isFont)) {

                console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                return new Geometry();

            }

            var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);

            // translate parameters to ExtrudeGeometry API

            parameters.amount = parameters.height !== undefined ? parameters.height : 50;

            // defaults

            if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
            if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
            if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

            ExtrudeBufferGeometry.call(this, shapes, parameters);

            this.type = 'TextBufferGeometry';

        }

        TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
        TextBufferGeometry.prototype.constructor = TextBufferGeometry;

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author benaadams / https://twitter.com/ben_a_adams
         * @author Mugen87 / https://github.com/Mugen87
         */

        // SphereGeometry

        function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {

            Geometry.call(this);

            this.type = 'SphereGeometry';

            this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

            this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
            this.mergeVertices();

        }

        SphereGeometry.prototype = Object.create(Geometry.prototype);
        SphereGeometry.prototype.constructor = SphereGeometry;

        // SphereBufferGeometry

        function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {

            BufferGeometry.call(this);

            this.type = 'SphereBufferGeometry';

            this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

            radius = radius || 1;

            widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
            heightSegments = Math.max(2, Math.floor(heightSegments) || 6);

            phiStart = phiStart !== undefined ? phiStart : 0;
            phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

            var thetaEnd = thetaStart + thetaLength;

            var ix, iy;

            var index = 0;
            var grid = [];

            var vertex = new Vector3();
            var normal = new Vector3();

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // generate vertices, normals and uvs

            for (iy = 0; iy <= heightSegments; iy++) {

                var verticesRow = [];

                var v = iy / heightSegments;

                for (ix = 0; ix <= widthSegments; ix++) {

                    var u = ix / widthSegments;

                    // vertex

                    vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                    vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);

                    vertices.push(vertex.x, vertex.y, vertex.z);

                    // normal

                    normal.set(vertex.x, vertex.y, vertex.z).normalize();
                    normals.push(normal.x, normal.y, normal.z);

                    // uv

                    uvs.push(u, 1 - v);

                    verticesRow.push(index++);

                }

                grid.push(verticesRow);

            }

            // indices

            for (iy = 0; iy < heightSegments; iy++) {

                for (ix = 0; ix < widthSegments; ix++) {

                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];

                    if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                    if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);

                }

            }

            // build geometry

            this.setIndex(indices);
            this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        }

        SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

        /**
         * @author Kaleb Murphy
         * @author Mugen87 / https://github.com/Mugen87
         */

        // RingGeometry

        function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {

            Geometry.call(this);

            this.type = 'RingGeometry';

            this.parameters = {
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                thetaSegments: thetaSegments,
                phiSegments: phiSegments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

            this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
            this.mergeVertices();

        }

        RingGeometry.prototype = Object.create(Geometry.prototype);
        RingGeometry.prototype.constructor = RingGeometry;

        // RingBufferGeometry

        function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {

            BufferGeometry.call(this);

            this.type = 'RingBufferGeometry';

            this.parameters = {
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                thetaSegments: thetaSegments,
                phiSegments: phiSegments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

            innerRadius = innerRadius || 0.5;
            outerRadius = outerRadius || 1;

            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

            thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
            phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // some helper variables

            var segment;
            var radius = innerRadius;
            var radiusStep = ((outerRadius - innerRadius) / phiSegments);
            var vertex = new Vector3();
            var uv = new Vector2();
            var j, i;

            // generate vertices, normals and uvs

            for (j = 0; j <= phiSegments; j++) {

                for (i = 0; i <= thetaSegments; i++) {

                    // values are generate from the inside of the ring to the outside

                    segment = thetaStart + i / thetaSegments * thetaLength;

                    // vertex

                    vertex.x = radius * Math.cos(segment);
                    vertex.y = radius * Math.sin(segment);

                    vertices.push(vertex.x, vertex.y, vertex.z);

                    // normal

                    normals.push(0, 0, 1);

                    // uv

                    uv.x = (vertex.x / outerRadius + 1) / 2;
                    uv.y = (vertex.y / outerRadius + 1) / 2;

                    uvs.push(uv.x, uv.y);

                }

                // increase the radius for next row of vertices

                radius += radiusStep;

            }

            // indices

            for (j = 0; j < phiSegments; j++) {

                var thetaSegmentLevel = j * (thetaSegments + 1);

                for (i = 0; i < thetaSegments; i++) {

                    segment = i + thetaSegmentLevel;

                    var a = segment;
                    var b = segment + thetaSegments + 1;
                    var c = segment + thetaSegments + 2;
                    var d = segment + 1;

                    // faces

                    indices.push(a, b, d);
                    indices.push(b, c, d);

                }

            }

            // build geometry

            this.setIndex(indices);
            this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        }

        RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        RingBufferGeometry.prototype.constructor = RingBufferGeometry;


        /**
         * @author mrdoob / http://mrdoob.com/
         * @author Mugen87 / https://github.com/Mugen87
         */

        // CylinderGeometry

        function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

            Geometry.call(this);

            this.type = 'CylinderGeometry';

            this.parameters = {
                radiusTop: radiusTop,
                radiusBottom: radiusBottom,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

            this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
            this.mergeVertices();

        }

        CylinderGeometry.prototype = Object.create(Geometry.prototype);
        CylinderGeometry.prototype.constructor = CylinderGeometry;

        // CylinderBufferGeometry

        function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

            BufferGeometry.call(this);

            this.type = 'CylinderBufferGeometry';

            this.parameters = {
                radiusTop: radiusTop,
                radiusBottom: radiusBottom,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

            var scope = this;

            radiusTop = radiusTop !== undefined ? radiusTop : 1;
            radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
            height = height || 1;

            radialSegments = Math.floor(radialSegments) || 8;
            heightSegments = Math.floor(heightSegments) || 1;

            openEnded = openEnded !== undefined ? openEnded : false;
            thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
            thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var index = 0;
            var indexArray = [];
            var halfHeight = height / 2;
            var groupStart = 0;

            // generate geometry

            generateTorso();

            if (openEnded === false) {

                if (radiusTop > 0) generateCap(true);
                if (radiusBottom > 0) generateCap(false);

            }

            // build geometry

            this.setIndex(indices);
            this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

            function generateTorso() {

                var x, y;
                var normal = new Vector3();
                var vertex = new Vector3();

                var groupCount = 0;

                // this will be used to calculate the normal
                var slope = (radiusBottom - radiusTop) / height;

                // generate vertices, normals and uvs

                for (y = 0; y <= heightSegments; y++) {

                    var indexRow = [];

                    var v = y / heightSegments;

                    // calculate the radius of the current row

                    var radius = v * (radiusBottom - radiusTop) + radiusTop;

                    for (x = 0; x <= radialSegments; x++) {

                        var u = x / radialSegments;

                        var theta = u * thetaLength + thetaStart;

                        var sinTheta = Math.sin(theta);
                        var cosTheta = Math.cos(theta);

                        // vertex

                        vertex.x = radius * sinTheta;
                        vertex.y = -v * height + halfHeight;
                        vertex.z = radius * cosTheta;
                        vertices.push(vertex.x, vertex.y, vertex.z);

                        // normal

                        normal.set(sinTheta, slope, cosTheta).normalize();
                        normals.push(normal.x, normal.y, normal.z);

                        // uv

                        uvs.push(u, 1 - v);

                        // save index of vertex in respective row

                        indexRow.push(index++);

                    }

                    // now save vertices of the row in our index array

                    indexArray.push(indexRow);

                }

                // generate indices

                for (x = 0; x < radialSegments; x++) {

                    for (y = 0; y < heightSegments; y++) {

                        // we use the index array to access the correct indices

                        var a = indexArray[y][x];
                        var b = indexArray[y + 1][x];
                        var c = indexArray[y + 1][x + 1];
                        var d = indexArray[y][x + 1];

                        // faces

                        indices.push(a, b, d);
                        indices.push(b, c, d);

                        // update group counter

                        groupCount += 6;

                    }

                }

                // add a group to the geometry. this will ensure multi material support

                scope.addGroup(groupStart, groupCount, 0);

                // calculate new start value for groups

                groupStart += groupCount;

            }

            function generateCap(top) {

                var x, centerIndexStart, centerIndexEnd;

                var uv = new Vector2();
                var vertex = new Vector3();

                var groupCount = 0;

                var radius = (top === true) ? radiusTop : radiusBottom;
                var sign = (top === true) ? 1 : -1;

                // save the index of the first center vertex
                centerIndexStart = index;

                // first we generate the center vertex data of the cap.
                // because the geometry needs one set of uvs per face,
                // we must generate a center vertex per face/segment

                for (x = 1; x <= radialSegments; x++) {

                    // vertex

                    vertices.push(0, halfHeight * sign, 0);

                    // normal

                    normals.push(0, sign, 0);

                    // uv

                    uvs.push(0.5, 0.5);

                    // increase index

                    index++;

                }

                // save the index of the last center vertex

                centerIndexEnd = index;

                // now we generate the surrounding vertices, normals and uvs

                for (x = 0; x <= radialSegments; x++) {

                    var u = x / radialSegments;
                    var theta = u * thetaLength + thetaStart;

                    var cosTheta = Math.cos(theta);
                    var sinTheta = Math.sin(theta);

                    // vertex

                    vertex.x = radius * sinTheta;
                    vertex.y = halfHeight * sign;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);

                    // normal

                    normals.push(0, sign, 0);

                    // uv

                    uv.x = (cosTheta * 0.5) + 0.5;
                    uv.y = (sinTheta * 0.5 * sign) + 0.5;
                    uvs.push(uv.x, uv.y);

                    // increase index

                    index++;

                }

                // generate indices

                for (x = 0; x < radialSegments; x++) {

                    var c = centerIndexStart + x;
                    var i = centerIndexEnd + x;

                    if (top === true) {

                        // face top

                        indices.push(i, i + 1, c);

                    } else {

                        // face bottom

                        indices.push(i + 1, i, c);

                    }

                    groupCount += 3;

                }

                // add a group to the geometry. this will ensure multi material support

                scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

                // calculate new start value for groups

                groupStart += groupCount;

            }

        }

        CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

        /**
         * @author abelnation / http://github.com/abelnation
         */

        // ConeGeometry

        function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

            CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);

            this.type = 'ConeGeometry';

            this.parameters = {
                radius: radius,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

        }

        ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
        ConeGeometry.prototype.constructor = ConeGeometry;

        // ConeBufferGeometry

        function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

            CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);

            this.type = 'ConeBufferGeometry';

            this.parameters = {
                radius: radius,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

        }

        ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
        ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

        /**
         * @author benaadams / https://twitter.com/ben_a_adams
         * @author Mugen87 / https://github.com/Mugen87
         * @author hughes
         */

        // CircleGeometry

        function CircleGeometry(radius, segments, thetaStart, thetaLength) {

            Geometry.call(this);

            this.type = 'CircleGeometry';

            this.parameters = {
                radius: radius,
                segments: segments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

            this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
            this.mergeVertices();

        }

        CircleGeometry.prototype = Object.create(Geometry.prototype);
        CircleGeometry.prototype.constructor = CircleGeometry;

        // CircleBufferGeometry

        function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {

            BufferGeometry.call(this);

            this.type = 'CircleBufferGeometry';

            this.parameters = {
                radius: radius,
                segments: segments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };

            radius = radius || 1;
            segments = segments !== undefined ? Math.max(3, segments) : 8;

            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

            // buffers

            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];

            // helper variables

            var i, s;
            var vertex = new Vector3();
            var uv = new Vector2();

            // center point

            vertices.push(0, 0, 0);
            normals.push(0, 0, 1);
            uvs.push(0.5, 0.5);

            for (s = 0, i = 3; s <= segments; s++, i += 3) {

                var segment = thetaStart + s / segments * thetaLength;

                // vertex

                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);

                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal

                normals.push(0, 0, 1);

                // uvs

                uv.x = (vertices[i] / radius + 1) / 2;
                uv.y = (vertices[i + 1] / radius + 1) / 2;

                uvs.push(uv.x, uv.y);

            }

            // indices

            for (i = 1; i <= segments; i++) {

                indices.push(i, i + 1, 0);

            }

            // build geometry

            this.setIndex(indices);
            this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        }

        CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
        CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;


        var Geometries = Object.freeze({
            ParametricGeometry: ParametricGeometry,
            ParametricBufferGeometry: ParametricBufferGeometry,
            TetrahedronGeometry: TetrahedronGeometry,
            TetrahedronBufferGeometry: TetrahedronBufferGeometry,
            OctahedronGeometry: OctahedronGeometry,
            OctahedronBufferGeometry: OctahedronBufferGeometry,
            IcosahedronGeometry: IcosahedronGeometry,
            IcosahedronBufferGeometry: IcosahedronBufferGeometry,
            PolyhedronGeometry: PolyhedronGeometry,
            PolyhedronBufferGeometry: PolyhedronBufferGeometry,
            TextGeometry: TextGeometry,
            TextBufferGeometry: TextBufferGeometry,
            SphereGeometry: SphereGeometry,
            SphereBufferGeometry: SphereBufferGeometry,
            RingGeometry: RingGeometry,
            RingBufferGeometry: RingBufferGeometry,
            PlaneGeometry: PlaneGeometry,
            PlaneBufferGeometry: PlaneBufferGeometry,
            ExtrudeGeometry: ExtrudeGeometry,
            ExtrudeBufferGeometry: ExtrudeBufferGeometry,
            ConeGeometry: ConeGeometry,
            ConeBufferGeometry: ConeBufferGeometry,
            CylinderGeometry: CylinderGeometry,
            CylinderBufferGeometry: CylinderBufferGeometry,
            CircleGeometry: CircleGeometry,
            CircleBufferGeometry: CircleBufferGeometry,
            BoxGeometry: BoxGeometry,
            BoxBufferGeometry: BoxBufferGeometry,
            ShapeGeometry: ShapeGeometry,
            ShapeBufferGeometry: ShapeBufferGeometry,
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         *
         * parameters = {
	 *  color: <THREE.Color>,
	 *  opacity: <float>
	 * }
         */

        function ShadowMaterial(parameters) {

            Material.call(this);

            this.type = 'ShadowMaterial';

            this.color = new Color(0x000000);
            this.opacity = 1.0;

            this.lights = true;
            this.transparent = true;

            this.setValues(parameters);

        }

        ShadowMaterial.prototype = Object.create(Material.prototype);
        ShadowMaterial.prototype.constructor = ShadowMaterial;

        ShadowMaterial.prototype.isShadowMaterial = true;

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function RawShaderMaterial(parameters) {

            ShaderMaterial.call(this, parameters);

            this.type = 'RawShaderMaterial';

        }

        RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
        RawShaderMaterial.prototype.constructor = RawShaderMaterial;

        RawShaderMaterial.prototype.isRawShaderMaterial = true;

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
         */

        function MeshPhongMaterial(parameters) {

            Material.call(this);

            this.type = 'MeshPhongMaterial';

            this.color = new Color(0xffffff); // diffuse
            this.specular = new Color(0x111111);
            this.shininess = 30;

            this.map = null;

            this.lightMap = null;
            this.lightMapIntensity = 1.0;

            this.aoMap = null;
            this.aoMapIntensity = 1.0;

            this.emissive = new Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;

            this.bumpMap = null;
            this.bumpScale = 1;

            this.normalMap = null;
            this.normalScale = new Vector2(1, 1);

            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;

            this.specularMap = null;

            this.alphaMap = null;

            this.envMap = null;
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;

            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';

            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;

            this.setValues(parameters);

        }

        MeshPhongMaterial.prototype = Object.create(Material.prototype);
        MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

        MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

        MeshPhongMaterial.prototype.copy = function (source) {

            Material.prototype.copy.call(this, source);

            this.color.copy(source.color);
            this.specular.copy(source.specular);
            this.shininess = source.shininess;

            this.map = source.map;

            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;

            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;

            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;

            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;

            this.normalMap = source.normalMap;
            this.normalScale.copy(source.normalScale);

            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;

            this.specularMap = source.specularMap;

            this.alphaMap = source.alphaMap;

            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;

            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;

            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;

            return this;

        };


        function MeshLambertMaterial(parameters) {

            Material.call(this);

            this.type = 'MeshLambertMaterial';

            this.color = new Color(0xffffff); // diffuse

            this.map = null;

            this.lightMap = null;
            this.lightMapIntensity = 1.0;

            this.aoMap = null;
            this.aoMapIntensity = 1.0;

            this.emissive = new Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;

            this.specularMap = null;

            this.alphaMap = null;

            this.envMap = null;
            this.combine = MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;

            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';

            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;

            this.setValues(parameters);

        }

        MeshLambertMaterial.prototype = Object.create(Material.prototype);
        MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

        MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

        MeshLambertMaterial.prototype.copy = function (source) {

            Material.prototype.copy.call(this, source);

            this.color.copy(source.color);

            this.map = source.map;

            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;

            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;

            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;

            this.specularMap = source.specularMap;

            this.alphaMap = source.alphaMap;

            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;

            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;

            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;

            return this;

        };

        /**
         * @author alteredq / http://alteredqualia.com/
         *
         * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
         */

        function LineDashedMaterial(parameters) {

            LineBasicMaterial.call(this);

            this.type = 'LineDashedMaterial';

            this.scale = 1;
            this.dashSize = 3;
            this.gapSize = 1;

            this.setValues(parameters);

        }

        LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
        LineDashedMaterial.prototype.constructor = LineDashedMaterial;

        LineDashedMaterial.prototype.isLineDashedMaterial = true;

        LineDashedMaterial.prototype.copy = function (source) {

            LineBasicMaterial.prototype.copy.call(this, source);

            this.scale = source.scale;
            this.dashSize = source.dashSize;
            this.gapSize = source.gapSize;

            return this;

        };


        var Materials = Object.freeze({
            ShadowMaterial: ShadowMaterial,
            SpriteMaterial: SpriteMaterial,
            MeshPhongMaterial: MeshPhongMaterial,
            MeshLambertMaterial: MeshLambertMaterial,
            MeshBasicMaterial: MeshBasicMaterial,
            Material: Material
        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        var Cache = {

            enabled: false,

            files: {},

            add: function (key, file) {

                if (this.enabled === false) return;

                // console.log( 'THREE.Cache', 'Adding key:', key );

                this.files[key] = file;

            },

            get: function (key) {

                if (this.enabled === false) return;

                // console.log( 'THREE.Cache', 'Checking key:', key );

                return this.files[key];

            },

            remove: function (key) {

                delete this.files[key];

            },

            clear: function () {

                this.files = {};

            }

        };

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function LoadingManager(onLoad, onProgress, onError) {

            var scope = this;

            var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

            this.onStart = undefined;
            this.onLoad = onLoad;
            this.onProgress = onProgress;
            this.onError = onError;

            this.itemStart = function (url) {

                itemsTotal++;

                if (isLoading === false) {

                    if (scope.onStart !== undefined) {

                        scope.onStart(url, itemsLoaded, itemsTotal);

                    }

                }

                isLoading = true;

            };

            this.itemEnd = function (url) {

                itemsLoaded++;

                if (scope.onProgress !== undefined) {

                    scope.onProgress(url, itemsLoaded, itemsTotal);

                }

                if (itemsLoaded === itemsTotal) {

                    isLoading = false;

                    if (scope.onLoad !== undefined) {

                        scope.onLoad();

                    }

                }

            };

            this.itemError = function (url) {

                if (scope.onError !== undefined) {

                    scope.onError(url);

                }

            };

        }

        var DefaultLoadingManager = new LoadingManager();

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        var loading = {};

        function FileLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

        }

        Object.assign(FileLoader.prototype, {

            load: function (url, onLoad, onProgress, onError) {

                if (url === undefined) url = '';

                if (this.path !== undefined) url = this.path + url;

                var scope = this;

                var cached = Cache.get(url);

                if (cached !== undefined) {

                    scope.manager.itemStart(url);

                    setTimeout(function () {

                        if (onLoad) onLoad(cached);

                        scope.manager.itemEnd(url);

                    }, 0);

                    return cached;

                }

                // Check if request is duplicate

                if (loading[url] !== undefined) {

                    loading[url].push({

                        onLoad: onLoad,
                        onProgress: onProgress,
                        onError: onError

                    });

                    return;

                }

                // Check for data: URI
                var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
                var dataUriRegexResult = url.match(dataUriRegex);

                // Safari can not handle Data URIs through XMLHttpRequest so process manually
                if (dataUriRegexResult) {

                    var mimeType = dataUriRegexResult[1];
                    var isBase64 = !!dataUriRegexResult[2];
                    var data = dataUriRegexResult[3];

                    data = window.decodeURIComponent(data);

                    if (isBase64) data = window.atob(data);

                    try {

                        var response;
                        var responseType = (this.responseType || '').toLowerCase();

                        switch (responseType) {

                            case 'arraybuffer':
                            case 'blob':

                                var view = new Uint8Array(data.length);

                                for (var i = 0; i < data.length; i++) {

                                    view[i] = data.charCodeAt(i);

                                }

                                if (responseType === 'blob') {

                                    response = new Blob([view.buffer], {type: mimeType});

                                } else {

                                    response = view.buffer;

                                }

                                break;

                            case 'document':

                                var parser = new DOMParser();
                                response = parser.parseFromString(data, mimeType);

                                break;

                            case 'json':

                                response = JSON.parse(data);

                                break;

                            default: // 'text' or other

                                response = data;

                                break;

                        }

                        // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                        window.setTimeout(function () {

                            if (onLoad) onLoad(response);

                            scope.manager.itemEnd(url);

                        }, 0);

                    } catch (error) {

                        // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                        window.setTimeout(function () {

                            if (onError) onError(error);

                            scope.manager.itemEnd(url);
                            scope.manager.itemError(url);

                        }, 0);

                    }

                } else {

                    // Initialise array for duplicate requests

                    loading[url] = [];

                    loading[url].push({

                        onLoad: onLoad,
                        onProgress: onProgress,
                        onError: onError

                    });

                    var request = new XMLHttpRequest();

                    request.open('GET', url, true);

                    request.addEventListener('load', function (event) {

                        var response = event.target.response;

                        Cache.add(url, response);

                        var callbacks = loading[url];

                        delete loading[url];

                        if (this.status === 200) {

                            for (var i = 0, il = callbacks.length; i < il; i++) {

                                var callback = callbacks[i];
                                if (callback.onLoad) callback.onLoad(response);

                            }

                            scope.manager.itemEnd(url);

                        } else if (this.status === 0) {

                            // Some browsers return HTTP Status 0 when using non-http protocol
                            // e.g. 'file://' or 'data://'. Handle as success.

                            console.warn('THREE.FileLoader: HTTP Status 0 received.');

                            for (var i = 0, il = callbacks.length; i < il; i++) {

                                var callback = callbacks[i];
                                if (callback.onLoad) callback.onLoad(response);

                            }

                            scope.manager.itemEnd(url);

                        } else {

                            for (var i = 0, il = callbacks.length; i < il; i++) {

                                var callback = callbacks[i];
                                if (callback.onError) callback.onError(event);

                            }

                            scope.manager.itemEnd(url);
                            scope.manager.itemError(url);

                        }

                    }, false);

                    request.addEventListener('progress', function (event) {

                        var callbacks = loading[url];

                        for (var i = 0, il = callbacks.length; i < il; i++) {

                            var callback = callbacks[i];
                            if (callback.onProgress) callback.onProgress(event);

                        }

                    }, false);

                    request.addEventListener('error', function (event) {

                        var callbacks = loading[url];

                        for (var i = 0, il = callbacks.length; i < il; i++) {

                            var callback = callbacks[i];
                            if (callback.onError) callback.onError(event);

                        }

                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);

                    }, false);

                    if (this.responseType !== undefined) request.responseType = this.responseType;
                    if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;

                    if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

                    for (var header in this.requestHeader) {

                        request.setRequestHeader(header, this.requestHeader[header]);

                    }

                    request.send(null);

                }

                scope.manager.itemStart(url);

                return request;

            },

            setPath: function (value) {

                this.path = value;
                return this;

            },

            setResponseType: function (value) {

                this.responseType = value;
                return this;

            },

            setWithCredentials: function (value) {

                this.withCredentials = value;
                return this;

            },

            setMimeType: function (value) {

                this.mimeType = value;
                return this;

            },

            setRequestHeader: function (value) {

                this.requestHeader = value;
                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         *
         * Abstract Base class to block based textures loader (dds, pvr, ...)
         */

        function CompressedTextureLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

            // override in sub classes
            this._parser = null;

        }

        Object.assign(CompressedTextureLoader.prototype, {

            load: function (url, onLoad, onProgress, onError) {

                var scope = this;

                var images = [];

                var texture = new CompressedTexture();
                texture.image = images;

                var loader = new FileLoader(this.manager);
                loader.setPath(this.path);
                loader.setResponseType('arraybuffer');

                function loadTexture(i) {

                    loader.load(url[i], function (buffer) {

                        var texDatas = scope._parser(buffer, true);

                        images[i] = {
                            width: texDatas.width,
                            height: texDatas.height,
                            format: texDatas.format,
                            mipmaps: texDatas.mipmaps
                        };

                        loaded += 1;

                        if (loaded === 6) {

                            if (texDatas.mipmapCount === 1)
                                texture.minFilter = LinearFilter;

                            texture.format = texDatas.format;
                            texture.needsUpdate = true;

                            if (onLoad) onLoad(texture);

                        }

                    }, onProgress, onError);

                }

                if (Array.isArray(url)) {

                    var loaded = 0;

                    for (var i = 0, il = url.length; i < il; ++i) {

                        loadTexture(i);

                    }

                } else {

                    // compressed cubemap texture stored in a single DDS file

                    loader.load(url, function (buffer) {

                        var texDatas = scope._parser(buffer, true);

                        if (texDatas.isCubemap) {

                            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

                            for (var f = 0; f < faces; f++) {

                                images[f] = {mipmaps: []};

                                for (var i = 0; i < texDatas.mipmapCount; i++) {

                                    images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                    images[f].format = texDatas.format;
                                    images[f].width = texDatas.width;
                                    images[f].height = texDatas.height;

                                }

                            }

                        } else {

                            texture.image.width = texDatas.width;
                            texture.image.height = texDatas.height;
                            texture.mipmaps = texDatas.mipmaps;

                        }

                        if (texDatas.mipmapCount === 1) {

                            texture.minFilter = LinearFilter;

                        }

                        texture.format = texDatas.format;
                        texture.needsUpdate = true;

                        if (onLoad) onLoad(texture);

                    }, onProgress, onError);

                }

                return texture;

            },

            setPath: function (value) {

                this.path = value;
                return this;

            }

        });

        /**
         * @author Nikos M. / https://github.com/foo123/
         *
         * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
         */

        function DataTextureLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

            // override in sub classes
            this._parser = null;

        }

        Object.assign(DataTextureLoader.prototype, {

            load: function (url, onLoad, onProgress, onError) {

                var scope = this;

                var texture = new DataTexture();

                var loader = new FileLoader(this.manager);
                loader.setResponseType('arraybuffer');

                loader.load(url, function (buffer) {

                    var texData = scope._parser(buffer);

                    if (!texData) return;

                    if (undefined !== texData.image) {

                        texture.image = texData.image;

                    } else if (undefined !== texData.data) {

                        texture.image.width = texData.width;
                        texture.image.height = texData.height;
                        texture.image.data = texData.data;

                    }

                    texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
                    texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

                    texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
                    texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

                    texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

                    if (undefined !== texData.format) {

                        texture.format = texData.format;

                    }
                    if (undefined !== texData.type) {

                        texture.type = texData.type;

                    }

                    if (undefined !== texData.mipmaps) {

                        texture.mipmaps = texData.mipmaps;

                    }

                    if (1 === texData.mipmapCount) {

                        texture.minFilter = LinearFilter;

                    }

                    texture.needsUpdate = true;

                    if (onLoad) onLoad(texture, texData);

                }, onProgress, onError);


                return texture;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function ImageLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

        }

        Object.assign(ImageLoader.prototype, {

            crossOrigin: 'Anonymous',

            load: function (url, onLoad, onProgress, onError) {

                if (url === undefined) url = '';

                if (this.path !== undefined) url = this.path + url;

                var scope = this;

                var cached = Cache.get(url);

                if (cached !== undefined) {

                    scope.manager.itemStart(url);

                    setTimeout(function () {

                        if (onLoad) onLoad(cached);

                        scope.manager.itemEnd(url);

                    }, 0);

                    return cached;

                }

                var image = document.createElement('img');

                image.addEventListener('load', function () {

                    Cache.add(url, this);

                    if (onLoad) onLoad(this);

                    scope.manager.itemEnd(url);

                }, false);

                /*
			image.addEventListener( 'progress', function ( event ) {

				if ( onProgress ) onProgress( event );

			}, false );
			*/

                image.addEventListener('error', function (event) {

                    if (onError) onError(event);

                    scope.manager.itemEnd(url);
                    scope.manager.itemError(url);

                }, false);

                if (url.substr(0, 5) !== 'data:') {

                    if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;

                }

                scope.manager.itemStart(url);

                image.src = url;

                return image;

            },

            setCrossOrigin: function (value) {

                this.crossOrigin = value;
                return this;

            },

            setPath: function (value) {

                this.path = value;
                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function CubeTextureLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

        }

        Object.assign(CubeTextureLoader.prototype, {

            crossOrigin: 'Anonymous',

            load: function (urls, onLoad, onProgress, onError) {

                var texture = new CubeTexture();

                var loader = new ImageLoader(this.manager);
                loader.setCrossOrigin(this.crossOrigin);
                loader.setPath(this.path);

                var loaded = 0;

                function loadTexture(i) {

                    loader.load(urls[i], function (image) {

                        texture.images[i] = image;

                        loaded++;

                        if (loaded === 6) {

                            texture.needsUpdate = true;

                            if (onLoad) onLoad(texture);

                        }

                    }, undefined, onError);

                }

                for (var i = 0; i < urls.length; ++i) {

                    loadTexture(i);

                }

                return texture;

            },

            setCrossOrigin: function (value) {

                this.crossOrigin = value;
                return this;

            },

            setPath: function (value) {

                this.path = value;
                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function TextureLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

        }

        Object.assign(TextureLoader.prototype, {

            crossOrigin: 'Anonymous',

            load: function (url, onLoad, onProgress, onError) {

                var loader = new ImageLoader(this.manager);
                loader.setCrossOrigin(this.crossOrigin);
                loader.setPath(this.path);

                var texture = new Texture();
                texture.path = url;
                texture.image = loader.load(url, function () {

                    // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
                    var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;

                    texture.format = isJPEG ? RGBFormat : RGBAFormat;
                    texture.needsUpdate = true;

                    if (onLoad !== undefined) {

                        onLoad(texture);

                    }

                }, onProgress, onError);

                return texture;

            },

            setCrossOrigin: function (value) {

                this.crossOrigin = value;
                return this;

            },

            setPath: function (value) {

                this.path = value;
                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        function Light(color, intensity) {

            Object3D.call(this);

            this.type = 'Light';

            this.color = new Color(color);
            this.intensity = intensity !== undefined ? intensity : 1;

            this.receiveShadow = undefined;

        }

        Light.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Light,

            isLight: true,

            copy: function (source) {

                Object3D.prototype.copy.call(this, source);

                this.color.copy(source.color);
                this.intensity = source.intensity;

                return this;

            },

            toJSON: function (meta) {

                var data = Object3D.prototype.toJSON.call(this, meta);

                data.object.color = this.color.getHex();
                data.object.intensity = this.intensity;

                if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();

                if (this.distance !== undefined) data.object.distance = this.distance;
                if (this.angle !== undefined) data.object.angle = this.angle;
                if (this.decay !== undefined) data.object.decay = this.decay;
                if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;

                if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();

                return data;

            }

        });

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function HemisphereLight(skyColor, groundColor, intensity) {

            Light.call(this, skyColor, intensity);

            this.type = 'HemisphereLight';

            this.castShadow = undefined;

            this.position.copy(Object3D.DefaultUp);
            this.updateMatrix();

            this.groundColor = new Color(groundColor);

        }

        HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {

            constructor: HemisphereLight,

            isHemisphereLight: true,

            copy: function (source) {

                Light.prototype.copy.call(this, source);

                this.groundColor.copy(source.groundColor);

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function LightShadow(camera) {

            this.camera = camera;

            this.bias = 0;
            this.radius = 1;

            this.mapSize = new Vector2(512, 512);

            this.map = null;
            this.matrix = new Matrix4();

        }

        Object.assign(LightShadow.prototype, {

            copy: function (source) {

                this.camera = source.camera.clone();

                this.bias = source.bias;
                this.radius = source.radius;

                this.mapSize.copy(source.mapSize);

                return this;

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            toJSON: function () {

                var object = {};

                if (this.bias !== 0) object.bias = this.bias;
                if (this.radius !== 1) object.radius = this.radius;
                if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();

                object.camera = this.camera.toJSON(false).object;
                delete object.camera.matrix;

                return object;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function SpotLightShadow() {

            LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));

        }

        SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {

            constructor: SpotLightShadow,

            isSpotLightShadow: true,

            update: function (light) {

                var camera = this.camera;

                var fov = _Math.RAD2DEG * 2 * light.angle;
                var aspect = this.mapSize.width / this.mapSize.height;
                var far = light.distance || camera.far;

                if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {

                    camera.fov = fov;
                    camera.aspect = aspect;
                    camera.far = far;
                    camera.updateProjectionMatrix();

                }

            }

        });

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function SpotLight(color, intensity, distance, angle, penumbra, decay) {

            Light.call(this, color, intensity);

            this.type = 'SpotLight';

            this.position.copy(Object3D.DefaultUp);
            this.updateMatrix();

            this.target = new Object3D();

            Object.defineProperty(this, 'power', {
                get: function () {

                    // intensity = power per solid angle.
                    // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
                    return this.intensity * Math.PI;

                },
                set: function (power) {

                    // intensity = power per solid angle.
                    // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
                    this.intensity = power / Math.PI;

                }
            });

            this.distance = (distance !== undefined) ? distance : 0;
            this.angle = (angle !== undefined) ? angle : Math.PI / 3;
            this.penumbra = (penumbra !== undefined) ? penumbra : 0;
            this.decay = (decay !== undefined) ? decay : 1;	// for physically correct lights, should be 2.

            this.shadow = new SpotLightShadow();

        }

        SpotLight.prototype = Object.assign(Object.create(Light.prototype), {

            constructor: SpotLight,

            isSpotLight: true,

            copy: function (source) {

                Light.prototype.copy.call(this, source);

                this.distance = source.distance;
                this.angle = source.angle;
                this.penumbra = source.penumbra;
                this.decay = source.decay;

                this.target = source.target.clone();

                this.shadow = source.shadow.clone();

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */


        function PointLight(color, intensity, distance, decay) {

            Light.call(this, color, intensity);

            this.type = 'PointLight';

            Object.defineProperty(this, 'power', {
                get: function () {

                    // intensity = power per solid angle.
                    // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
                    return this.intensity * 4 * Math.PI;

                },
                set: function (power) {

                    // intensity = power per solid angle.
                    // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
                    this.intensity = power / (4 * Math.PI);

                }
            });

            this.distance = (distance !== undefined) ? distance : 0;
            this.decay = (decay !== undefined) ? decay : 1;	// for physically correct lights, should be 2.

            this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));

        }

        PointLight.prototype = Object.assign(Object.create(Light.prototype), {

            constructor: PointLight,

            isPointLight: true,

            copy: function (source) {

                Light.prototype.copy.call(this, source);

                this.distance = source.distance;
                this.decay = source.decay;

                this.shadow = source.shadow.clone();

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function DirectionalLightShadow() {

            LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));

        }

        DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {

            constructor: DirectionalLightShadow

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        function DirectionalLight(color, intensity) {

            Light.call(this, color, intensity);

            this.type = 'DirectionalLight';

            this.position.copy(Object3D.DefaultUp);
            this.updateMatrix();

            this.target = new Object3D();

            this.shadow = new DirectionalLightShadow();

        }

        DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {

            constructor: DirectionalLight,

            isDirectionalLight: true,

            copy: function (source) {

                Light.prototype.copy.call(this, source);

                this.target = source.target.clone();

                this.shadow = source.shadow.clone();

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function AmbientLight(color, intensity) {

            Light.call(this, color, intensity);

            this.type = 'AmbientLight';

            this.castShadow = undefined;

        }

        AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {

            constructor: AmbientLight,

            isAmbientLight: true

        });

        /**
         * @author abelnation / http://github.com/abelnation
         */

        function RectAreaLight(color, intensity, width, height) {

            Light.call(this, color, intensity);

            this.type = 'RectAreaLight';

            this.position.set(0, 1, 0);
            this.updateMatrix();

            this.width = (width !== undefined) ? width : 10;
            this.height = (height !== undefined) ? height : 10;

            // TODO (abelnation): distance/decay

            // TODO (abelnation): update method for RectAreaLight to update transform to lookat target

            // TODO (abelnation): shadows

        }

        // TODO (abelnation): RectAreaLight update when light shape is changed
        RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {

            constructor: RectAreaLight,

            isRectAreaLight: true,

            copy: function (source) {

                Light.prototype.copy.call(this, source);

                this.width = source.width;
                this.height = source.height;

                return this;

            },

            toJSON: function (meta) {

                var data = Light.prototype.toJSON.call(this, meta);

                data.object.width = this.width;
                data.object.height = this.height;

                return data;

            }

        });

        /**
         * @author tschw
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         */

        var AnimationUtils = {

            // same as Array.prototype.slice, but also works on typed arrays
            arraySlice: function (array, from, to) {

                if (AnimationUtils.isTypedArray(array)) {

                    // in ios9 array.subarray(from, undefined) will return empty array
                    // but array.subarray(from) or array.subarray(from, len) is correct
                    return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));

                }

                return array.slice(from, to);

            },

            // converts an array to a specific type
            convertArray: function (array, type, forceClone) {

                if (!array || // let 'undefined' and 'null' pass
                    !forceClone && array.constructor === type) return array;

                if (typeof type.BYTES_PER_ELEMENT === 'number') {

                    return new type(array); // create typed array

                }

                return Array.prototype.slice.call(array); // create Array

            },

            isTypedArray: function (object) {

                return ArrayBuffer.isView(object) &&
                    !(object instanceof DataView);

            },

            // returns an array by which times and values can be sorted
            getKeyframeOrder: function (times) {

                function compareTime(i, j) {

                    return times[i] - times[j];

                }

                var n = times.length;
                var result = new Array(n);
                for (var i = 0; i !== n; ++i) result[i] = i;

                result.sort(compareTime);

                return result;

            },

            // uses the array previously returned by 'getKeyframeOrder' to sort data
            sortedArray: function (values, stride, order) {

                var nValues = values.length;
                var result = new values.constructor(nValues);

                for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {

                    var srcOffset = order[i] * stride;

                    for (var j = 0; j !== stride; ++j) {

                        result[dstOffset++] = values[srcOffset + j];

                    }

                }

                return result;

            },

            // function for parsing AOS keyframe formats
            flattenJSON: function (jsonKeys, times, values, valuePropertyName) {

                var i = 1, key = jsonKeys[0];

                while (key !== undefined && key[valuePropertyName] === undefined) {

                    key = jsonKeys[i++];

                }

                if (key === undefined) return; // no data

                var value = key[valuePropertyName];
                if (value === undefined) return; // no data

                if (Array.isArray(value)) {

                    do {

                        value = key[valuePropertyName];

                        if (value !== undefined) {

                            times.push(key.time);
                            values.push.apply(values, value); // push all elements

                        }

                        key = jsonKeys[i++];

                    } while (key !== undefined);

                } else if (value.toArray !== undefined) {

                    // ...assume THREE.Math-ish

                    do {

                        value = key[valuePropertyName];

                        if (value !== undefined) {

                            times.push(key.time);
                            value.toArray(values, values.length);

                        }

                        key = jsonKeys[i++];

                    } while (key !== undefined);

                } else {

                    // otherwise push as-is

                    do {

                        value = key[valuePropertyName];

                        if (value !== undefined) {

                            times.push(key.time);
                            values.push(value);

                        }

                        key = jsonKeys[i++];

                    } while (key !== undefined);

                }

            }

        };

        /**
         * Abstract base class of interpolants over parametric samples.
         *
         * The parameter domain is one dimensional, typically the time or a path
         * along a curve defined by the data.
         *
         * The sample values can have any dimensionality and derived classes may
         * apply special interpretations to the data.
         *
         * This class provides the interval seek in a Template Method, deferring
         * the actual interpolation to derived classes.
         *
         * Time complexity is O(1) for linear access crossing at most two points
         * and O(log N) for random access, where N is the number of positions.
         *
         * References:
         *
         *        http://www.oodesign.com/template-method-pattern.html
         *
         * @author tschw
         */

        function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

            this.parameterPositions = parameterPositions;
            this._cachedIndex = 0;

            this.resultBuffer = resultBuffer !== undefined ?
                resultBuffer : new sampleValues.constructor(sampleSize);
            this.sampleValues = sampleValues;
            this.valueSize = sampleSize;

        }

        Object.assign(Interpolant.prototype, {

            evaluate: function (t) {

                var pp = this.parameterPositions,
                    i1 = this._cachedIndex,

                    t1 = pp[i1],
                    t0 = pp[i1 - 1];

                validate_interval: {

                    seek: {

                        var right;

                        linear_scan: {

                            //- See http://jsperf.com/comparison-to-undefined/3
                            //- slower code:
                            //-
                            //- 				if ( t >= t1 || t1 === undefined ) {
                            forward_scan: if (!(t < t1)) {

                                for (var giveUpAt = i1 + 2; ;) {

                                    if (t1 === undefined) {

                                        if (t < t0) break forward_scan;

                                        // after end

                                        i1 = pp.length;
                                        this._cachedIndex = i1;
                                        return this.afterEnd_(i1 - 1, t, t0);

                                    }

                                    if (i1 === giveUpAt) break; // this loop

                                    t0 = t1;
                                    t1 = pp[++i1];

                                    if (t < t1) {

                                        // we have arrived at the sought interval
                                        break seek;

                                    }

                                }

                                // prepare binary search on the right side of the index
                                right = pp.length;
                                break linear_scan;

                            }

                            //- slower code:
                            //-					if ( t < t0 || t0 === undefined ) {
                            if (!(t >= t0)) {

                                // looping?

                                var t1global = pp[1];

                                if (t < t1global) {

                                    i1 = 2; // + 1, using the scan for the details
                                    t0 = t1global;

                                }

                                // linear reverse scan

                                for (var giveUpAt = i1 - 2; ;) {

                                    if (t0 === undefined) {

                                        // before start

                                        this._cachedIndex = 0;
                                        return this.beforeStart_(0, t, t1);

                                    }

                                    if (i1 === giveUpAt) break; // this loop

                                    t1 = t0;
                                    t0 = pp[--i1 - 1];

                                    if (t >= t0) {

                                        // we have arrived at the sought interval
                                        break seek;

                                    }

                                }

                                // prepare binary search on the left side of the index
                                right = i1;
                                i1 = 0;
                                break linear_scan;

                            }

                            // the interval is valid

                            break validate_interval;

                        } // linear scan

                        // binary search

                        while (i1 < right) {

                            var mid = (i1 + right) >>> 1;

                            if (t < pp[mid]) {

                                right = mid;

                            } else {

                                i1 = mid + 1;

                            }

                        }

                        t1 = pp[i1];
                        t0 = pp[i1 - 1];

                        // check boundary cases, again

                        if (t0 === undefined) {

                            this._cachedIndex = 0;
                            return this.beforeStart_(0, t, t1);

                        }

                        if (t1 === undefined) {

                            i1 = pp.length;
                            this._cachedIndex = i1;
                            return this.afterEnd_(i1 - 1, t0, t);

                        }

                    } // seek

                    this._cachedIndex = i1;

                    this.intervalChanged_(i1, t0, t1);

                } // validate_interval

                return this.interpolate_(i1, t0, t, t1);

            },

            settings: null, // optional, subclass-specific settings structure
            // Note: The indirection allows central control of many interpolants.

            // --- Protected interface

            DefaultSettings_: {},

            getSettings_: function () {

                return this.settings || this.DefaultSettings_;

            },

            copySampleValue_: function (index) {

                // copies a sample value to the result buffer

                var result = this.resultBuffer,
                    values = this.sampleValues,
                    stride = this.valueSize,
                    offset = index * stride;

                for (var i = 0; i !== stride; ++i) {

                    result[i] = values[offset + i];

                }

                return result;

            },

            // Template methods for derived classes:

            interpolate_: function (/* i1, t0, t, t1 */) {

                throw new Error('call to abstract method');
                // implementations shall return this.resultBuffer

            },

            intervalChanged_: function (/* i1, t0, t1 */) {

                // empty

            }

        });

        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(Interpolant.prototype, {

            //( 0, t, t0 ), returns this.resultBuffer
            beforeStart_: Interpolant.prototype.copySampleValue_,

            //( N-1, tN-1, t ), returns this.resultBuffer
            afterEnd_: Interpolant.prototype.copySampleValue_,

        });

        /**
         * Fast and simple cubic spline interpolant.
         *
         * It was derived from a Hermitian construction setting the first derivative
         * at each sample position to the linear slope between neighboring positions
         * over their parameter interval.
         *
         * @author tschw
         */

        function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

            Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

            this._weightPrev = -0;
            this._offsetPrev = -0;
            this._weightNext = -0;
            this._offsetNext = -0;

        }

        CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

            constructor: CubicInterpolant,

            DefaultSettings_: {

                endingStart: ZeroCurvatureEnding,
                endingEnd: ZeroCurvatureEnding

            },

            intervalChanged_: function (i1, t0, t1) {

                var pp = this.parameterPositions,
                    iPrev = i1 - 2,
                    iNext = i1 + 1,

                    tPrev = pp[iPrev],
                    tNext = pp[iNext];

                if (tPrev === undefined) {

                    switch (this.getSettings_().endingStart) {

                        case ZeroSlopeEnding:

                            // f'(t0) = 0
                            iPrev = i1;
                            tPrev = 2 * t0 - t1;

                            break;

                        case WrapAroundEnding:

                            // use the other end of the curve
                            iPrev = pp.length - 2;
                            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];

                            break;

                        default: // ZeroCurvatureEnding

                            // f''(t0) = 0 a.k.a. Natural Spline
                            iPrev = i1;
                            tPrev = t1;

                    }

                }

                if (tNext === undefined) {

                    switch (this.getSettings_().endingEnd) {

                        case ZeroSlopeEnding:

                            // f'(tN) = 0
                            iNext = i1;
                            tNext = 2 * t1 - t0;

                            break;

                        case WrapAroundEnding:

                            // use the other end of the curve
                            iNext = 1;
                            tNext = t1 + pp[1] - pp[0];

                            break;

                        default: // ZeroCurvatureEnding

                            // f''(tN) = 0, a.k.a. Natural Spline
                            iNext = i1 - 1;
                            tNext = t0;

                    }

                }

                var halfDt = (t1 - t0) * 0.5,
                    stride = this.valueSize;

                this._weightPrev = halfDt / (t0 - tPrev);
                this._weightNext = halfDt / (tNext - t1);
                this._offsetPrev = iPrev * stride;
                this._offsetNext = iNext * stride;

            },

            interpolate_: function (i1, t0, t, t1) {

                var result = this.resultBuffer,
                    values = this.sampleValues,
                    stride = this.valueSize,

                    o1 = i1 * stride, o0 = o1 - stride,
                    oP = this._offsetPrev, oN = this._offsetNext,
                    wP = this._weightPrev, wN = this._weightNext,

                    p = (t - t0) / (t1 - t0),
                    pp = p * p,
                    ppp = pp * p;

                // evaluate polynomials

                var sP = -wP * ppp + 2 * wP * pp - wP * p;
                var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
                var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
                var sN = wN * ppp - wN * pp;

                // combine data linearly

                for (var i = 0; i !== stride; ++i) {

                    result[i] =
                        sP * values[oP + i] +
                        s0 * values[o0 + i] +
                        s1 * values[o1 + i] +
                        sN * values[oN + i];

                }

                return result;

            }

        });

        /**
         * @author tschw
         */

        function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

            Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

        }

        LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

            constructor: LinearInterpolant,

            interpolate_: function (i1, t0, t, t1) {

                var result = this.resultBuffer,
                    values = this.sampleValues,
                    stride = this.valueSize,

                    offset1 = i1 * stride,
                    offset0 = offset1 - stride,

                    weight1 = (t - t0) / (t1 - t0),
                    weight0 = 1 - weight1;

                for (var i = 0; i !== stride; ++i) {

                    result[i] =
                        values[offset0 + i] * weight0 +
                        values[offset1 + i] * weight1;

                }

                return result;

            }

        });

        /**
         *
         * Interpolant that evaluates to the sample value at the position preceeding
         * the parameter.
         *
         * @author tschw
         */

        function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

            Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

        }

        DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

            constructor: DiscreteInterpolant,

            interpolate_: function (i1 /*, t0, t, t1 */) {

                return this.copySampleValue_(i1 - 1);

            }

        });

        var KeyframeTrackPrototype;

        KeyframeTrackPrototype = {

            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,

            DefaultInterpolation: InterpolateLinear,

            InterpolantFactoryMethodDiscrete: function (result) {

                return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);

            },

            InterpolantFactoryMethodLinear: function (result) {

                return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);

            },

            InterpolantFactoryMethodSmooth: function (result) {

                return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);

            },

            setInterpolation: function (interpolation) {

                var factoryMethod;

                switch (interpolation) {

                    case InterpolateDiscrete:

                        factoryMethod = this.InterpolantFactoryMethodDiscrete;

                        break;

                    case InterpolateLinear:

                        factoryMethod = this.InterpolantFactoryMethodLinear;

                        break;

                    case InterpolateSmooth:

                        factoryMethod = this.InterpolantFactoryMethodSmooth;

                        break;

                }

                if (factoryMethod === undefined) {

                    var message = "unsupported interpolation for " +
                        this.ValueTypeName + " keyframe track named " + this.name;

                    if (this.createInterpolant === undefined) {

                        // fall back to default, unless the default itself is messed up
                        if (interpolation !== this.DefaultInterpolation) {

                            this.setInterpolation(this.DefaultInterpolation);

                        } else {

                            throw new Error(message); // fatal, in this case

                        }

                    }

                    console.warn('THREE.KeyframeTrackPrototype:', message);
                    return;

                }

                this.createInterpolant = factoryMethod;

            },

            getInterpolation: function () {

                switch (this.createInterpolant) {

                    case this.InterpolantFactoryMethodDiscrete:

                        return InterpolateDiscrete;

                    case this.InterpolantFactoryMethodLinear:

                        return InterpolateLinear;

                    case this.InterpolantFactoryMethodSmooth:

                        return InterpolateSmooth;

                }

            },

            getValueSize: function () {

                return this.values.length / this.times.length;

            },

            // move all keyframes either forwards or backwards in time
            shift: function (timeOffset) {

                if (timeOffset !== 0.0) {

                    var times = this.times;

                    for (var i = 0, n = times.length; i !== n; ++i) {

                        times[i] += timeOffset;

                    }

                }

                return this;

            },

            // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
            scale: function (timeScale) {

                if (timeScale !== 1.0) {

                    var times = this.times;

                    for (var i = 0, n = times.length; i !== n; ++i) {

                        times[i] *= timeScale;

                    }

                }

                return this;

            },

            // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
            // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
            trim: function (startTime, endTime) {

                var times = this.times,
                    nKeys = times.length,
                    from = 0,
                    to = nKeys - 1;

                while (from !== nKeys && times[from] < startTime) ++from;
                while (to !== -1 && times[to] > endTime) --to;

                ++to; // inclusive -> exclusive bound

                if (from !== 0 || to !== nKeys) {

                    // empty tracks are forbidden, so keep at least one keyframe
                    if (from >= to) to = Math.max(to, 1), from = to - 1;

                    var stride = this.getValueSize();
                    this.times = AnimationUtils.arraySlice(times, from, to);
                    this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);

                }

                return this;

            },

            // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
            validate: function () {

                var valid = true;

                var valueSize = this.getValueSize();
                if (valueSize - Math.floor(valueSize) !== 0) {

                    console.error('THREE.KeyframeTrackPrototype: Invalid value size in track.', this);
                    valid = false;

                }

                var times = this.times,
                    values = this.values,

                    nKeys = times.length;

                if (nKeys === 0) {

                    console.error('THREE.KeyframeTrackPrototype: Track is empty.', this);
                    valid = false;

                }

                var prevTime = null;

                for (var i = 0; i !== nKeys; i++) {

                    var currTime = times[i];

                    if (typeof currTime === 'number' && isNaN(currTime)) {

                        console.error('THREE.KeyframeTrackPrototype: Time is not a valid number.', this, i, currTime);
                        valid = false;
                        break;

                    }

                    if (prevTime !== null && prevTime > currTime) {

                        console.error('THREE.KeyframeTrackPrototype: Out of order keys.', this, i, currTime, prevTime);
                        valid = false;
                        break;

                    }

                    prevTime = currTime;

                }

                if (values !== undefined) {

                    if (AnimationUtils.isTypedArray(values)) {

                        for (var i = 0, n = values.length; i !== n; ++i) {

                            var value = values[i];

                            if (isNaN(value)) {

                                console.error('THREE.KeyframeTrackPrototype: Value is not a valid number.', this, i, value);
                                valid = false;
                                break;

                            }

                        }

                    }

                }

                return valid;

            },

            // removes equivalent sequential keys as common in morph target sequences
            // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
            optimize: function () {

                var times = this.times,
                    values = this.values,
                    stride = this.getValueSize(),

                    smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

                    writeIndex = 1,
                    lastIndex = times.length - 1;

                for (var i = 1; i < lastIndex; ++i) {

                    var keep = false;

                    var time = times[i];
                    var timeNext = times[i + 1];

                    // remove adjacent keyframes scheduled at the same time

                    if (time !== timeNext && (i !== 1 || time !== time[0])) {

                        if (!smoothInterpolation) {

                            // remove unnecessary keyframes same as their neighbors

                            var offset = i * stride,
                                offsetP = offset - stride,
                                offsetN = offset + stride;

                            for (var j = 0; j !== stride; ++j) {

                                var value = values[offset + j];

                                if (value !== values[offsetP + j] ||
                                    value !== values[offsetN + j]) {

                                    keep = true;
                                    break;

                                }

                            }

                        } else keep = true;

                    }

                    // in-place compaction

                    if (keep) {

                        if (i !== writeIndex) {

                            times[writeIndex] = times[i];

                            var readOffset = i * stride,
                                writeOffset = writeIndex * stride;

                            for (var j = 0; j !== stride; ++j)

                                values[writeOffset + j] = values[readOffset + j];

                        }

                        ++writeIndex;

                    }

                }

                // flush last keyframe (compaction looks ahead)

                if (lastIndex > 0) {

                    times[writeIndex] = times[lastIndex];

                    for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)

                        values[writeOffset + j] = values[readOffset + j];

                    ++writeIndex;

                }

                if (writeIndex !== times.length) {

                    this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                    this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);

                }

                return this;

            }

        };

        function KeyframeTrackConstructor(name, times, values, interpolation) {

            if (name === undefined) throw new Error('track name is undefined');

            if (times === undefined || times.length === 0) {

                throw new Error('no keyframes in track named ' + name);

            }

            this.name = name;

            this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
            this.values = AnimationUtils.convertArray(values, this.ValueBufferType);

            this.setInterpolation(interpolation || this.DefaultInterpolation);

            this.validate();
            this.optimize();

        }

        /**
         *
         * A Track of vectored keyframe values.
         *
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function VectorKeyframeTrack(name, times, values, interpolation) {

            KeyframeTrackConstructor.call(this, name, times, values, interpolation);

        }

        VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

            constructor: VectorKeyframeTrack,

            ValueTypeName: 'vector'

            // ValueBufferType is inherited

            // DefaultInterpolation is inherited

        });

        /**
         * Spherical linear unit quaternion interpolant.
         *
         * @author tschw
         */

        function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

            Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

        }

        QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

            constructor: QuaternionLinearInterpolant,

            interpolate_: function (i1, t0, t, t1) {

                var result = this.resultBuffer,
                    values = this.sampleValues,
                    stride = this.valueSize,

                    offset = i1 * stride,

                    alpha = (t - t0) / (t1 - t0);

                for (var end = offset + stride; offset !== end; offset += 4) {

                    Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);

                }

                return result;

            }

        });

        /**
         *
         * A Track of quaternion keyframe values.
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function QuaternionKeyframeTrack(name, times, values, interpolation) {

            KeyframeTrackConstructor.call(this, name, times, values, interpolation);

        }

        QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

            constructor: QuaternionKeyframeTrack,

            ValueTypeName: 'quaternion',

            // ValueBufferType is inherited

            DefaultInterpolation: InterpolateLinear,

            InterpolantFactoryMethodLinear: function (result) {

                return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);

            },

            InterpolantFactoryMethodSmooth: undefined // not yet implemented

        });

        /**
         *
         * A Track of numeric keyframe values.
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function NumberKeyframeTrack(name, times, values, interpolation) {

            KeyframeTrackConstructor.call(this, name, times, values, interpolation);

        }

        NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

            constructor: NumberKeyframeTrack,

            ValueTypeName: 'number'

            // ValueBufferType is inherited

            // DefaultInterpolation is inherited

        });

        /**
         *
         * A Track that interpolates Strings
         *
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function StringKeyframeTrack(name, times, values, interpolation) {

            KeyframeTrackConstructor.call(this, name, times, values, interpolation);

        }

        StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

            constructor: StringKeyframeTrack,

            ValueTypeName: 'string',
            ValueBufferType: Array,

            DefaultInterpolation: InterpolateDiscrete,

            InterpolantFactoryMethodLinear: undefined,

            InterpolantFactoryMethodSmooth: undefined

        });

        /**
         *
         * A Track of Boolean keyframe values.
         *
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function BooleanKeyframeTrack(name, times, values) {

            KeyframeTrackConstructor.call(this, name, times, values);

        }

        BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

            constructor: BooleanKeyframeTrack,

            ValueTypeName: 'bool',
            ValueBufferType: Array,

            DefaultInterpolation: InterpolateDiscrete,

            InterpolantFactoryMethodLinear: undefined,
            InterpolantFactoryMethodSmooth: undefined

            // Note: Actually this track could have a optimized / compressed
            // representation of a single value and a custom interpolant that
            // computes "firstValue ^ isOdd( index )".

        });

        /**
         *
         * A Track of keyframe values that represent color.
         *
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function ColorKeyframeTrack(name, times, values, interpolation) {

            KeyframeTrackConstructor.call(this, name, times, values, interpolation);

        }

        ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

            constructor: ColorKeyframeTrack,

            ValueTypeName: 'color'

            // ValueBufferType is inherited

            // DefaultInterpolation is inherited


            // Note: Very basic implementation and nothing special yet.
            // However, this is the place for color space parameterization.

        });

        /**
         *
         * A timed sequence of keyframes for a specific property.
         *
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function KeyframeTrack(name, times, values, interpolation) {

            KeyframeTrackConstructor.apply(this, name, times, values, interpolation);

        }

        KeyframeTrack.prototype = KeyframeTrackPrototype;
        KeyframeTrackPrototype.constructor = KeyframeTrack;

        // Static methods:

        Object.assign(KeyframeTrack, {

            // Serialization (in static context, because of constructor invocation
            // and automatic invocation of .toJSON):

            parse: function (json) {

                if (json.type === undefined) {

                    throw new Error('track type undefined, can not parse');

                }

                var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);

                if (json.times === undefined) {

                    var times = [], values = [];

                    AnimationUtils.flattenJSON(json.keys, times, values, 'value');

                    json.times = times;
                    json.values = values;

                }

                // derived classes can define a static parse method
                if (trackType.parse !== undefined) {

                    return trackType.parse(json);

                } else {

                    // by default, we assume a constructor compatible with the base
                    return new trackType(json.name, json.times, json.values, json.interpolation);

                }

            },

            toJSON: function (track) {

                var trackType = track.constructor;

                var json;

                // derived classes can define a static toJSON method
                if (trackType.toJSON !== undefined) {

                    json = trackType.toJSON(track);

                } else {

                    // by default, we assume the data can be serialized as-is
                    json = {

                        'name': track.name,
                        'times': AnimationUtils.convertArray(track.times, Array),
                        'values': AnimationUtils.convertArray(track.values, Array)

                    };

                    var interpolation = track.getInterpolation();

                    if (interpolation !== track.DefaultInterpolation) {

                        json.interpolation = interpolation;

                    }

                }

                json.type = track.ValueTypeName; // mandatory

                return json;

            },

            _getTrackTypeForValueTypeName: function (typeName) {

                switch (typeName.toLowerCase()) {

                    case 'scalar':
                    case 'double':
                    case 'float':
                    case 'number':
                    case 'integer':

                        return NumberKeyframeTrack;

                    case 'vector':
                    case 'vector2':
                    case 'vector3':
                    case 'vector4':

                        return VectorKeyframeTrack;

                    case 'color':

                        return ColorKeyframeTrack;

                    case 'quaternion':

                        return QuaternionKeyframeTrack;

                    case 'bool':
                    case 'boolean':

                        return BooleanKeyframeTrack;

                    case 'string':

                        return StringKeyframeTrack;

                }

                throw new Error('Unsupported typeName: ' + typeName);

            }

        });

        /**
         *
         * Reusable set of Tracks that represent an animation.
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         */

        function AnimationClip(name, duration, tracks) {

            this.name = name;
            this.tracks = tracks;
            this.duration = (duration !== undefined) ? duration : -1;

            this.uuid = _Math.generateUUID();

            // this means it should figure out its duration by scanning the tracks
            if (this.duration < 0) {

                this.resetDuration();

            }

            this.optimize();

        }

        Object.assign(AnimationClip, {

            parse: function (json) {

                var tracks = [],
                    jsonTracks = json.tracks,
                    frameTime = 1.0 / (json.fps || 1.0);

                for (var i = 0, n = jsonTracks.length; i !== n; ++i) {

                    tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));

                }

                return new AnimationClip(json.name, json.duration, tracks);

            },

            toJSON: function (clip) {

                var tracks = [],
                    clipTracks = clip.tracks;

                var json = {

                    'name': clip.name,
                    'duration': clip.duration,
                    'tracks': tracks

                };

                for (var i = 0, n = clipTracks.length; i !== n; ++i) {

                    tracks.push(KeyframeTrack.toJSON(clipTracks[i]));

                }

                return json;

            },

            CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {

                var numMorphTargets = morphTargetSequence.length;
                var tracks = [];

                for (var i = 0; i < numMorphTargets; i++) {

                    var times = [];
                    var values = [];

                    times.push(
                        (i + numMorphTargets - 1) % numMorphTargets,
                        i,
                        (i + 1) % numMorphTargets);

                    values.push(0, 1, 0);

                    var order = AnimationUtils.getKeyframeOrder(times);
                    times = AnimationUtils.sortedArray(times, 1, order);
                    values = AnimationUtils.sortedArray(values, 1, order);

                    // if there is a key at the first frame, duplicate it as the
                    // last frame as well for perfect loop.
                    if (!noLoop && times[0] === 0) {

                        times.push(numMorphTargets);
                        values.push(values[0]);

                    }

                    tracks.push(
                        new NumberKeyframeTrack(
                            '.morphTargetInfluences[' + morphTargetSequence[i].name + ']',
                            times, values
                        ).scale(1.0 / fps));

                }

                return new AnimationClip(name, -1, tracks);

            },

            findByName: function (objectOrClipArray, name) {

                var clipArray = objectOrClipArray;

                if (!Array.isArray(objectOrClipArray)) {

                    var o = objectOrClipArray;
                    clipArray = o.geometry && o.geometry.animations || o.animations;

                }

                for (var i = 0; i < clipArray.length; i++) {

                    if (clipArray[i].name === name) {

                        return clipArray[i];

                    }

                }

                return null;

            },

            CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {

                var animationToMorphTargets = {};

                // tested with https://regex101.com/ on trick sequences
                // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
                var pattern = /^([\w-]*?)([\d]+)$/;

                // sort morph target names into animation groups based
                // patterns like Walk_001, Walk_002, Run_001, Run_002
                for (var i = 0, il = morphTargets.length; i < il; i++) {

                    var morphTarget = morphTargets[i];
                    var parts = morphTarget.name.match(pattern);

                    if (parts && parts.length > 1) {

                        var name = parts[1];

                        var animationMorphTargets = animationToMorphTargets[name];
                        if (!animationMorphTargets) {

                            animationToMorphTargets[name] = animationMorphTargets = [];

                        }

                        animationMorphTargets.push(morphTarget);

                    }

                }

                var clips = [];

                for (var name in animationToMorphTargets) {

                    clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));

                }

                return clips;

            },

            // parse the animation.hierarchy format
            parseAnimation: function (animation, bones) {

                if (!animation) {

                    console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                    return null;

                }

                var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {

                    // only return track if there are actually keys.
                    if (animationKeys.length !== 0) {

                        var times = [];
                        var values = [];

                        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);

                        // empty keys are filtered out, so check again
                        if (times.length !== 0) {

                            destTracks.push(new trackType(trackName, times, values));

                        }

                    }

                };

                var tracks = [];

                var clipName = animation.name || 'default';
                // automatic length determination in AnimationClip.
                var duration = animation.length || -1;
                var fps = animation.fps || 30;

                var hierarchyTracks = animation.hierarchy || [];

                for (var h = 0; h < hierarchyTracks.length; h++) {

                    var animationKeys = hierarchyTracks[h].keys;

                    // skip empty tracks
                    if (!animationKeys || animationKeys.length === 0) continue;

                    // process morph targets
                    if (animationKeys[0].morphTargets) {

                        // figure out all morph targets used in this track
                        var morphTargetNames = {};

                        for (var k = 0; k < animationKeys.length; k++) {

                            if (animationKeys[k].morphTargets) {

                                for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {

                                    morphTargetNames[animationKeys[k].morphTargets[m]] = -1;

                                }

                            }

                        }

                        // create a track for each morph target with all zero
                        // morphTargetInfluences except for the keys in which
                        // the morphTarget is named.
                        for (var morphTargetName in morphTargetNames) {

                            var times = [];
                            var values = [];

                            for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {

                                var animationKey = animationKeys[k];

                                times.push(animationKey.time);
                                values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);

                            }

                            tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));

                        }

                        duration = morphTargetNames.length * (fps || 1.0);

                    } else {

                        // ...assume skeletal animation

                        var boneName = '.bones[' + bones[h].name + ']';

                        addNonemptyTrack(
                            VectorKeyframeTrack, boneName + '.position',
                            animationKeys, 'pos', tracks);

                        addNonemptyTrack(
                            QuaternionKeyframeTrack, boneName + '.quaternion',
                            animationKeys, 'rot', tracks);

                        addNonemptyTrack(
                            VectorKeyframeTrack, boneName + '.scale',
                            animationKeys, 'scl', tracks);

                    }

                }

                if (tracks.length === 0) {

                    return null;

                }

                var clip = new AnimationClip(clipName, duration, tracks);

                return clip;

            }

        });

        Object.assign(AnimationClip.prototype, {

            resetDuration: function () {

                var tracks = this.tracks, duration = 0;

                for (var i = 0, n = tracks.length; i !== n; ++i) {

                    var track = this.tracks[i];

                    duration = Math.max(duration, track.times[track.times.length - 1]);

                }

                this.duration = duration;

            },

            trim: function () {

                for (var i = 0; i < this.tracks.length; i++) {

                    this.tracks[i].trim(0, this.duration);

                }

                return this;

            },

            optimize: function () {

                for (var i = 0; i < this.tracks.length; i++) {

                    this.tracks[i].optimize();

                }

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function MaterialLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
            this.textures = {};

        }

        Object.assign(MaterialLoader.prototype, {

            load: function (url, onLoad, onProgress, onError) {

                var scope = this;

                var loader = new FileLoader(scope.manager);
                loader.load(url, function (text) {

                    onLoad(scope.parse(JSON.parse(text)));

                }, onProgress, onError);

            },

            setTextures: function (value) {

                this.textures = value;

            },

            parse: function (json) {

                var textures = this.textures;

                function getTexture(name) {

                    if (textures[name] === undefined) {

                        console.warn('THREE.MaterialLoader: Undefined texture', name);

                    }

                    return textures[name];

                }

                var material = new Materials[json.type]();

                if (json.uuid !== undefined) material.uuid = json.uuid;
                if (json.name !== undefined) material.name = json.name;
                if (json.color !== undefined) material.color.setHex(json.color);
                if (json.roughness !== undefined) material.roughness = json.roughness;
                if (json.metalness !== undefined) material.metalness = json.metalness;
                if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
                if (json.specular !== undefined) material.specular.setHex(json.specular);
                if (json.shininess !== undefined) material.shininess = json.shininess;
                if (json.clearCoat !== undefined) material.clearCoat = json.clearCoat;
                if (json.clearCoatRoughness !== undefined) material.clearCoatRoughness = json.clearCoatRoughness;
                if (json.uniforms !== undefined) material.uniforms = json.uniforms;
                if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
                if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
                if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
                if (json.fog !== undefined) material.fog = json.fog;
                if (json.flatShading !== undefined) material.flatShading = json.flatShading;
                if (json.blending !== undefined) material.blending = json.blending;
                if (json.side !== undefined) material.side = json.side;
                if (json.opacity !== undefined) material.opacity = json.opacity;
                if (json.transparent !== undefined) material.transparent = json.transparent;
                if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
                if (json.depthTest !== undefined) material.depthTest = json.depthTest;
                if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
                if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
                if (json.wireframe !== undefined) material.wireframe = json.wireframe;
                if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
                if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
                if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;

                if (json.rotation !== undefined) material.rotation = json.rotation;

                if (json.linewidth !== 1) material.linewidth = json.linewidth;
                if (json.dashSize !== undefined) material.dashSize = json.dashSize;
                if (json.gapSize !== undefined) material.gapSize = json.gapSize;
                if (json.scale !== undefined) material.scale = json.scale;

                if (json.skinning !== undefined) material.skinning = json.skinning;
                if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
                if (json.dithering !== undefined) material.dithering = json.dithering;

                if (json.visible !== undefined) material.visible = json.visible;
                if (json.userData !== undefined) material.userData = json.userData;

                // Deprecated

                if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading

                // for PointsMaterial

                if (json.size !== undefined) material.size = json.size;
                if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

                // maps

                if (json.map !== undefined) material.map = getTexture(json.map);

                if (json.alphaMap !== undefined) {

                    material.alphaMap = getTexture(json.alphaMap);
                    material.transparent = true;

                }

                if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
                if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;

                if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
                if (json.normalScale !== undefined) {

                    var normalScale = json.normalScale;

                    if (Array.isArray(normalScale) === false) {

                        // Blender exporter used to export a scalar. See #7459

                        normalScale = [normalScale, normalScale];

                    }

                    material.normalScale = new Vector2().fromArray(normalScale);

                }

                if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
                if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
                if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;

                if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
                if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);

                if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
                if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;

                if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);

                if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);

                if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;

                if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
                if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;

                if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
                if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;

                if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);

                return material;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function BufferGeometryLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

        }

        Object.assign(BufferGeometryLoader.prototype, {

            load: function (url, onLoad, onProgress, onError) {

                var scope = this;

                var loader = new FileLoader(scope.manager);
                loader.load(url, function (text) {

                    onLoad(scope.parse(JSON.parse(text)));

                }, onProgress, onError);

            },

            parse: function (json) {

                var geometry = new BufferGeometry();

                var index = json.data.index;

                if (index !== undefined) {

                    var typedArray = new TYPED_ARRAYS[index.type](index.array);
                    geometry.setIndex(new BufferAttribute(typedArray, 1));

                }

                var attributes = json.data.attributes;

                for (var key in attributes) {

                    var attribute = attributes[key];
                    var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);

                    geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));

                }

                var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

                if (groups !== undefined) {

                    for (var i = 0, n = groups.length; i !== n; ++i) {

                        var group = groups[i];

                        geometry.addGroup(group.start, group.count, group.materialIndex);

                    }

                }

                var boundingSphere = json.data.boundingSphere;

                if (boundingSphere !== undefined) {

                    var center = new Vector3();

                    if (boundingSphere.center !== undefined) {

                        center.fromArray(boundingSphere.center);

                    }

                    geometry.boundingSphere = new Sphere(center, boundingSphere.radius);

                }

                return geometry;

            }

        });

        var TYPED_ARRAYS = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            // Workaround for IE11 pre KB2929437. See #11440
            Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function Loader() {

            this.onLoadStart = function () {
            };
            this.onLoadProgress = function () {
            };
            this.onLoadComplete = function () {
            };

        }

        Loader.Handlers = {

            handlers: [],

            add: function (regex, loader) {

                this.handlers.push(regex, loader);

            },

            get: function (file) {

                var handlers = this.handlers;

                for (var i = 0, l = handlers.length; i < l; i += 2) {

                    var regex = handlers[i];
                    var loader = handlers[i + 1];

                    if (regex.test(file)) {

                        return loader;

                    }

                }

                return null;

            }

        };

        Object.assign(Loader.prototype, {

            crossOrigin: undefined,

            extractUrlBase: function (url) {

                var parts = url.split('/');

                if (parts.length === 1) return './';

                parts.pop();

                return parts.join('/') + '/';

            },

            initMaterials: function (materials, texturePath, crossOrigin) {

                var array = [];

                for (var i = 0; i < materials.length; ++i) {

                    array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);

                }

                return array;

            },

            createMaterial: (function () {

                var BlendingMode = {
                    NoBlending: NoBlending,
                    NormalBlending: NormalBlending,
                    AdditiveBlending: AdditiveBlending,
                    SubtractiveBlending: SubtractiveBlending,
                    MultiplyBlending: MultiplyBlending,
                    CustomBlending: CustomBlending
                };

                var color = new Color();
                var textureLoader = new TextureLoader();
                var materialLoader = new MaterialLoader();

                return function createMaterial(m, texturePath, crossOrigin) {

                    // convert from old material format

                    var textures = {};

                    function loadTexture(path, repeat, offset, wrap, anisotropy) {

                        var fullPath = texturePath + path;
                        var loader = Loader.Handlers.get(fullPath);

                        var texture;

                        if (loader !== null) {

                            texture = loader.load(fullPath);

                        } else {

                            textureLoader.setCrossOrigin(crossOrigin);
                            texture = textureLoader.load(fullPath);

                        }

                        if (repeat !== undefined) {

                            texture.repeat.fromArray(repeat);

                            if (repeat[0] !== 1) texture.wrapS = RepeatWrapping;
                            if (repeat[1] !== 1) texture.wrapT = RepeatWrapping;

                        }

                        if (offset !== undefined) {

                            texture.offset.fromArray(offset);

                        }

                        if (wrap !== undefined) {

                            if (wrap[0] === 'repeat') texture.wrapS = RepeatWrapping;
                            if (wrap[0] === 'mirror') texture.wrapS = MirroredRepeatWrapping;

                            if (wrap[1] === 'repeat') texture.wrapT = RepeatWrapping;
                            if (wrap[1] === 'mirror') texture.wrapT = MirroredRepeatWrapping;

                        }

                        if (anisotropy !== undefined) {

                            texture.anisotropy = anisotropy;

                        }

                        var uuid = _Math.generateUUID();

                        textures[uuid] = texture;

                        return uuid;

                    }

                    //

                    var json = {
                        uuid: _Math.generateUUID(),
                        type: 'MeshLambertMaterial'
                    };

                    for (var name in m) {

                        var value = m[name];

                        switch (name) {

                            case 'DbgColor':
                            case 'DbgIndex':
                            case 'opticalDensity':
                            case 'illumination':
                                break;
                            case 'DbgName':
                                json.name = value;
                                break;
                            case 'blending':
                                json.blending = BlendingMode[value];
                                break;
                            case 'colorAmbient':
                            case 'mapAmbient':
                                console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
                                break;
                            case 'colorDiffuse':
                                json.color = color.fromArray(value).getHex();
                                break;
                            case 'colorSpecular':
                                json.specular = color.fromArray(value).getHex();
                                break;
                            case 'colorEmissive':
                                json.emissive = color.fromArray(value).getHex();
                                break;
                            case 'specularCoef':
                                json.shininess = value;
                                break;
                            case 'shading':
                                if (value.toLowerCase() === 'basic') json.type = 'MeshBasicMaterial';
                                if (value.toLowerCase() === 'phong') json.type = 'MeshPhongMaterial';
                                if (value.toLowerCase() === 'standard') json.type = 'MeshStandardMaterial';
                                break;
                            case 'mapDiffuse':
                                json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                                break;
                            case 'mapDiffuseRepeat':
                            case 'mapDiffuseOffset':
                            case 'mapDiffuseWrap':
                            case 'mapDiffuseAnisotropy':
                                break;
                            case 'mapEmissive':
                                json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                                break;
                            case 'mapEmissiveRepeat':
                            case 'mapEmissiveOffset':
                            case 'mapEmissiveWrap':
                            case 'mapEmissiveAnisotropy':
                                break;
                            case 'mapLight':
                                json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                                break;
                            case 'mapLightRepeat':
                            case 'mapLightOffset':
                            case 'mapLightWrap':
                            case 'mapLightAnisotropy':
                                break;
                            case 'mapAO':
                                json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                                break;
                            case 'mapAORepeat':
                            case 'mapAOOffset':
                            case 'mapAOWrap':
                            case 'mapAOAnisotropy':
                                break;
                            case 'mapBump':
                                json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                                break;
                            case 'mapBumpScale':
                                json.bumpScale = value;
                                break;
                            case 'mapBumpRepeat':
                            case 'mapBumpOffset':
                            case 'mapBumpWrap':
                            case 'mapBumpAnisotropy':
                                break;
                            case 'mapNormal':
                                json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                                break;
                            case 'mapNormalFactor':
                                json.normalScale = [value, value];
                                break;
                            case 'mapNormalRepeat':
                            case 'mapNormalOffset':
                            case 'mapNormalWrap':
                            case 'mapNormalAnisotropy':
                                break;
                            case 'mapSpecular':
                                json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                                break;
                            case 'mapSpecularRepeat':
                            case 'mapSpecularOffset':
                            case 'mapSpecularWrap':
                            case 'mapSpecularAnisotropy':
                                break;
                            case 'mapMetalness':
                                json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                                break;
                            case 'mapMetalnessRepeat':
                            case 'mapMetalnessOffset':
                            case 'mapMetalnessWrap':
                            case 'mapMetalnessAnisotropy':
                                break;
                            case 'mapRoughness':
                                json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                                break;
                            case 'mapRoughnessRepeat':
                            case 'mapRoughnessOffset':
                            case 'mapRoughnessWrap':
                            case 'mapRoughnessAnisotropy':
                                break;
                            case 'mapAlpha':
                                json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                                break;
                            case 'mapAlphaRepeat':
                            case 'mapAlphaOffset':
                            case 'mapAlphaWrap':
                            case 'mapAlphaAnisotropy':
                                break;
                            case 'flipSided':
                                json.side = BackSide;
                                break;
                            case 'doubleSided':
                                json.side = DoubleSide;
                                break;
                            case 'transparency':
                                console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
                                json.opacity = value;
                                break;
                            case 'depthTest':
                            case 'depthWrite':
                            case 'colorWrite':
                            case 'opacity':
                            case 'reflectivity':
                            case 'transparent':
                            case 'visible':
                            case 'wireframe':
                                json[name] = value;
                                break;
                            case 'vertexColors':
                                if (value === true) json.vertexColors = VertexColors;
                                if (value === 'face') json.vertexColors = FaceColors;
                                break;
                            default:
                                console.error('THREE.Loader.createMaterial: Unsupported', name, value);
                                break;

                        }

                    }

                    if (json.type === 'MeshBasicMaterial') delete json.emissive;
                    if (json.type !== 'MeshPhongMaterial') delete json.specular;

                    if (json.opacity < 1) json.transparent = true;

                    materialLoader.setTextures(textures);

                    return materialLoader.parse(json);

                };

            })()

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author alteredq / http://alteredqualia.com/
         */

        function JSONLoader(manager) {

            if (typeof manager === 'boolean') {

                console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
                manager = undefined;

            }

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

            this.withCredentials = false;

        }

        Object.assign(JSONLoader.prototype, {

            load: function (url, onLoad, onProgress, onError) {

                var scope = this;

                var texturePath = this.texturePath && (typeof this.texturePath === "string") ? this.texturePath : Loader.prototype.extractUrlBase(url);

                var loader = new FileLoader(this.manager);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function (text) {

                    var json = JSON.parse(text);
                    var metadata = json.metadata;

                    if (metadata !== undefined) {

                        var type = metadata.type;

                        if (type !== undefined) {

                            if (type.toLowerCase() === 'object') {

                                console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                                return;

                            }

                            if (type.toLowerCase() === 'scene') {

                                console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
                                return;

                            }

                        }

                    }

                    var object = scope.parse(json, texturePath);
                    onLoad(object.geometry, object.materials);

                }, onProgress, onError);

            },

            setTexturePath: function (value) {

                this.texturePath = value;

            },

            parse: (function () {

                function parseModel(json, geometry) {

                    function isBitSet(value, position) {

                        return value & (1 << position);

                    }

                    var i, j, fi,

                        offset, zLength,

                        colorIndex, normalIndex, uvIndex, materialIndex,

                        type,
                        isQuad,
                        hasMaterial,
                        hasFaceVertexUv,
                        hasFaceNormal, hasFaceVertexNormal,
                        hasFaceColor, hasFaceVertexColor,

                        vertex, face, faceA, faceB, hex, normal,

                        uvLayer, uv, u, v,

                        faces = json.faces,
                        vertices = json.vertices,
                        normals = json.normals,
                        colors = json.colors,

                        scale = json.scale,

                        nUvLayers = 0;


                    if (json.uvs !== undefined) {

                        // disregard empty arrays

                        for (i = 0; i < json.uvs.length; i++) {

                            if (json.uvs[i].length) nUvLayers++;

                        }

                        for (i = 0; i < nUvLayers; i++) {

                            geometry.faceVertexUvs[i] = [];

                        }

                    }

                    offset = 0;
                    zLength = vertices.length;

                    while (offset < zLength) {

                        vertex = new Vector3();

                        vertex.x = vertices[offset++] * scale;
                        vertex.y = vertices[offset++] * scale;
                        vertex.z = vertices[offset++] * scale;

                        geometry.vertices.push(vertex);

                    }

                    offset = 0;
                    zLength = faces.length;

                    while (offset < zLength) {

                        type = faces[offset++];

                        isQuad = isBitSet(type, 0);
                        hasMaterial = isBitSet(type, 1);
                        hasFaceVertexUv = isBitSet(type, 3);
                        hasFaceNormal = isBitSet(type, 4);
                        hasFaceVertexNormal = isBitSet(type, 5);
                        hasFaceColor = isBitSet(type, 6);
                        hasFaceVertexColor = isBitSet(type, 7);

                        // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                        if (isQuad) {

                            faceA = new Face3();
                            faceA.a = faces[offset];
                            faceA.b = faces[offset + 1];
                            faceA.c = faces[offset + 3];

                            faceB = new Face3();
                            faceB.a = faces[offset + 1];
                            faceB.b = faces[offset + 2];
                            faceB.c = faces[offset + 3];

                            offset += 4;

                            if (hasMaterial) {

                                materialIndex = faces[offset++];
                                faceA.materialIndex = materialIndex;
                                faceB.materialIndex = materialIndex;

                            }

                            // to get face <=> uv index correspondence

                            fi = geometry.faces.length;

                            if (hasFaceVertexUv) {

                                for (i = 0; i < nUvLayers; i++) {

                                    uvLayer = json.uvs[i];

                                    geometry.faceVertexUvs[i][fi] = [];
                                    geometry.faceVertexUvs[i][fi + 1] = [];

                                    for (j = 0; j < 4; j++) {

                                        uvIndex = faces[offset++];

                                        u = uvLayer[uvIndex * 2];
                                        v = uvLayer[uvIndex * 2 + 1];

                                        uv = new Vector2(u, v);

                                        if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);
                                        if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);

                                    }

                                }

                            }

                            if (hasFaceNormal) {

                                normalIndex = faces[offset++] * 3;

                                faceA.normal.set(
                                    normals[normalIndex++],
                                    normals[normalIndex++],
                                    normals[normalIndex]
                                );

                                faceB.normal.copy(faceA.normal);

                            }

                            if (hasFaceVertexNormal) {

                                for (i = 0; i < 4; i++) {

                                    normalIndex = faces[offset++] * 3;

                                    normal = new Vector3(
                                        normals[normalIndex++],
                                        normals[normalIndex++],
                                        normals[normalIndex]
                                    );


                                    if (i !== 2) faceA.vertexNormals.push(normal);
                                    if (i !== 0) faceB.vertexNormals.push(normal);

                                }

                            }


                            if (hasFaceColor) {

                                colorIndex = faces[offset++];
                                hex = colors[colorIndex];

                                faceA.color.setHex(hex);
                                faceB.color.setHex(hex);

                            }


                            if (hasFaceVertexColor) {

                                for (i = 0; i < 4; i++) {

                                    colorIndex = faces[offset++];
                                    hex = colors[colorIndex];

                                    if (i !== 2) faceA.vertexColors.push(new Color(hex));
                                    if (i !== 0) faceB.vertexColors.push(new Color(hex));

                                }

                            }

                            geometry.faces.push(faceA);
                            geometry.faces.push(faceB);

                        } else {

                            face = new Face3();
                            face.a = faces[offset++];
                            face.b = faces[offset++];
                            face.c = faces[offset++];

                            if (hasMaterial) {

                                materialIndex = faces[offset++];
                                face.materialIndex = materialIndex;

                            }

                            // to get face <=> uv index correspondence

                            fi = geometry.faces.length;

                            if (hasFaceVertexUv) {

                                for (i = 0; i < nUvLayers; i++) {

                                    uvLayer = json.uvs[i];

                                    geometry.faceVertexUvs[i][fi] = [];

                                    for (j = 0; j < 3; j++) {

                                        uvIndex = faces[offset++];

                                        u = uvLayer[uvIndex * 2];
                                        v = uvLayer[uvIndex * 2 + 1];

                                        uv = new Vector2(u, v);

                                        geometry.faceVertexUvs[i][fi].push(uv);

                                    }

                                }

                            }

                            if (hasFaceNormal) {

                                normalIndex = faces[offset++] * 3;

                                face.normal.set(
                                    normals[normalIndex++],
                                    normals[normalIndex++],
                                    normals[normalIndex]
                                );

                            }

                            if (hasFaceVertexNormal) {

                                for (i = 0; i < 3; i++) {

                                    normalIndex = faces[offset++] * 3;

                                    normal = new Vector3(
                                        normals[normalIndex++],
                                        normals[normalIndex++],
                                        normals[normalIndex]
                                    );

                                    face.vertexNormals.push(normal);

                                }

                            }


                            if (hasFaceColor) {

                                colorIndex = faces[offset++];
                                face.color.setHex(colors[colorIndex]);

                            }


                            if (hasFaceVertexColor) {

                                for (i = 0; i < 3; i++) {

                                    colorIndex = faces[offset++];
                                    face.vertexColors.push(new Color(colors[colorIndex]));

                                }

                            }

                            geometry.faces.push(face);

                        }

                    }

                }

                function parseSkin(json, geometry) {

                    var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;

                    if (json.skinWeights) {

                        for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {

                            var x = json.skinWeights[i];
                            var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
                            var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
                            var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;

                            geometry.skinWeights.push(new Vector4(x, y, z, w));

                        }

                    }

                    if (json.skinIndices) {

                        for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {

                            var a = json.skinIndices[i];
                            var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
                            var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
                            var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;

                            geometry.skinIndices.push(new Vector4(a, b, c, d));

                        }

                    }

                    geometry.bones = json.bones;

                    if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {

                        console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                            geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');

                    }

                }

                function parseMorphing(json, geometry) {

                    var scale = json.scale;

                    if (json.morphTargets !== undefined) {

                        for (var i = 0, l = json.morphTargets.length; i < l; i++) {

                            geometry.morphTargets[i] = {};
                            geometry.morphTargets[i].name = json.morphTargets[i].name;
                            geometry.morphTargets[i].vertices = [];

                            var dstVertices = geometry.morphTargets[i].vertices;
                            var srcVertices = json.morphTargets[i].vertices;

                            for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {

                                var vertex = new Vector3();
                                vertex.x = srcVertices[v] * scale;
                                vertex.y = srcVertices[v + 1] * scale;
                                vertex.z = srcVertices[v + 2] * scale;

                                dstVertices.push(vertex);

                            }

                        }

                    }

                    if (json.morphColors !== undefined && json.morphColors.length > 0) {

                        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');

                        var faces = geometry.faces;
                        var morphColors = json.morphColors[0].colors;

                        for (var i = 0, l = faces.length; i < l; i++) {

                            faces[i].color.fromArray(morphColors, i * 3);

                        }

                    }

                }

                function parseAnimations(json, geometry) {

                    var outputAnimations = [];

                    // parse old style Bone/Hierarchy animations
                    var animations = [];

                    if (json.animation !== undefined) {

                        animations.push(json.animation);

                    }

                    if (json.animations !== undefined) {

                        if (json.animations.length) {

                            animations = animations.concat(json.animations);

                        } else {

                            animations.push(json.animations);

                        }

                    }

                    for (var i = 0; i < animations.length; i++) {

                        var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                        if (clip) outputAnimations.push(clip);

                    }

                    // parse implicit morph animations
                    if (geometry.morphTargets) {

                        // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
                        var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                        outputAnimations = outputAnimations.concat(morphAnimationClips);

                    }

                    if (outputAnimations.length > 0) geometry.animations = outputAnimations;

                }

                return function (json, texturePath) {

                    if (json.data !== undefined) {

                        // Geometry 4.0 spec
                        json = json.data;

                    }

                    if (json.scale !== undefined) {

                        json.scale = 1.0 / json.scale;

                    } else {

                        json.scale = 1.0;

                    }

                    var geometry = new Geometry();

                    parseModel(json, geometry);
                    parseSkin(json, geometry);
                    parseMorphing(json, geometry);
                    parseAnimations(json, geometry);

                    geometry.computeFaceNormals();
                    geometry.computeBoundingSphere();

                    if (json.materials === undefined || json.materials.length === 0) {

                        return {geometry: geometry};

                    } else {

                        var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);

                        return {geometry: geometry, materials: materials};

                    }

                };

            })()

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function ObjectLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
            this.texturePath = '';

        }

        Object.assign(ObjectLoader.prototype, {

            load: function (url, onLoad, onProgress, onError) {

                if (this.texturePath === '') {

                    this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);

                }

                var scope = this;

                var loader = new FileLoader(scope.manager);
                loader.load(url, function (text) {

                    var json = null;

                    try {

                        json = JSON.parse(text);

                    } catch (error) {

                        if (onError !== undefined) onError(error);

                        console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);

                        return;

                    }

                    var metadata = json.metadata;

                    if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {

                        console.error('THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.');
                        return;

                    }

                    scope.parse(json, onLoad);

                }, onProgress, onError);

            },

            setTexturePath: function (value) {

                this.texturePath = value;

            },

            setCrossOrigin: function (value) {

                this.crossOrigin = value;

            },

            parse: function (json, onLoad) {

                var geometries = this.parseGeometries(json.geometries);

                var images = this.parseImages(json.images, function () {

                    if (onLoad !== undefined) onLoad(object);

                });

                var textures = this.parseTextures(json.textures, images);
                var materials = this.parseMaterials(json.materials, textures);

                var object = this.parseObject(json.object, geometries, materials);

                if (json.animations) {

                    object.animations = this.parseAnimations(json.animations);

                }

                if (json.images === undefined || json.images.length === 0) {

                    if (onLoad !== undefined) onLoad(object);

                }

                return object;

            },

            parseGeometries: function (json) {

                var geometries = {};

                if (json !== undefined) {

                    var geometryLoader = new JSONLoader();
                    var bufferGeometryLoader = new BufferGeometryLoader();

                    for (var i = 0, l = json.length; i < l; i++) {

                        var geometry;
                        var data = json[i];

                        switch (data.type) {

                            case 'PlaneGeometry':
                            case 'PlaneBufferGeometry':

                                geometry = new Geometries[data.type](
                                    data.width,
                                    data.height,
                                    data.widthSegments,
                                    data.heightSegments
                                );

                                break;

                            case 'BoxGeometry':
                            case 'BoxBufferGeometry':
                            case 'CubeGeometry': // backwards compatible

                                geometry = new Geometries[data.type](
                                    data.width,
                                    data.height,
                                    data.depth,
                                    data.widthSegments,
                                    data.heightSegments,
                                    data.depthSegments
                                );

                                break;

                            case 'CircleGeometry':
                            case 'CircleBufferGeometry':

                                geometry = new Geometries[data.type](
                                    data.radius,
                                    data.segments,
                                    data.thetaStart,
                                    data.thetaLength
                                );

                                break;

                            case 'CylinderGeometry':
                            case 'CylinderBufferGeometry':

                                geometry = new Geometries[data.type](
                                    data.radiusTop,
                                    data.radiusBottom,
                                    data.height,
                                    data.radialSegments,
                                    data.heightSegments,
                                    data.openEnded,
                                    data.thetaStart,
                                    data.thetaLength
                                );

                                break;

                            case 'ConeGeometry':
                            case 'ConeBufferGeometry':

                                geometry = new Geometries[data.type](
                                    data.radius,
                                    data.height,
                                    data.radialSegments,
                                    data.heightSegments,
                                    data.openEnded,
                                    data.thetaStart,
                                    data.thetaLength
                                );

                                break;

                            case 'SphereGeometry':
                            case 'SphereBufferGeometry':

                                geometry = new Geometries[data.type](
                                    data.radius,
                                    data.widthSegments,
                                    data.heightSegments,
                                    data.phiStart,
                                    data.phiLength,
                                    data.thetaStart,
                                    data.thetaLength
                                );

                                break;

                            case 'IcosahedronGeometry':
                            case 'IcosahedronBufferGeometry':
                            case 'OctahedronGeometry':
                            case 'OctahedronBufferGeometry':
                            case 'TetrahedronGeometry':
                            case 'TetrahedronBufferGeometry':

                                geometry = new Geometries[data.type](
                                    data.radius,
                                    data.detail
                                );

                                break;

                            case 'RingGeometry':
                            case 'RingBufferGeometry':

                                geometry = new Geometries[data.type](
                                    data.innerRadius,
                                    data.outerRadius,
                                    data.thetaSegments,
                                    data.phiSegments,
                                    data.thetaStart,
                                    data.thetaLength
                                );

                                break;

                            case 'BufferGeometry':

                                geometry = bufferGeometryLoader.parse(data);

                                break;

                            case 'Geometry':

                                geometry = geometryLoader.parse(data, this.texturePath).geometry;

                                break;

                            default:

                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');

                                continue;

                        }

                        geometry.uuid = data.uuid;

                        if (data.name !== undefined) geometry.name = data.name;

                        geometries[data.uuid] = geometry;

                    }

                }

                return geometries;

            },

            parseMaterials: function (json, textures) {

                var materials = {};

                if (json !== undefined) {

                    var loader = new MaterialLoader();
                    loader.setTextures(textures);

                    for (var i = 0, l = json.length; i < l; i++) {

                        var data = json[i];

                        if (data.type === 'MultiMaterial') {

                            // Deprecated

                            var array = [];

                            for (var j = 0; j < data.materials.length; j++) {

                                array.push(loader.parse(data.materials[j]));

                            }

                            materials[data.uuid] = array;

                        } else {

                            materials[data.uuid] = loader.parse(data);

                        }

                    }

                }

                return materials;

            },

            parseAnimations: function (json) {

                var animations = [];

                for (var i = 0; i < json.length; i++) {

                    var clip = AnimationClip.parse(json[i]);

                    animations.push(clip);

                }

                return animations;

            },

            parseImages: function (json, onLoad) {

                var scope = this;
                var images = {};

                function loadImage(url) {

                    scope.manager.itemStart(url);

                    return loader.load(url, function () {

                        scope.manager.itemEnd(url);

                    }, undefined, function () {

                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);

                    });

                }

                if (json !== undefined && json.length > 0) {

                    var manager = new LoadingManager(onLoad);

                    var loader = new ImageLoader(manager);
                    loader.setCrossOrigin(this.crossOrigin);

                    for (var i = 0, l = json.length; i < l; i++) {

                        var image = json[i];
                        var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;

                        images[image.uuid] = loadImage(path);

                    }

                }

                return images;

            },

            parseTextures: function (json, images) {

                function parseConstant(value, type) {

                    if (typeof value === 'number') return value;

                    console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);

                    return type[value];

                }

                var textures = {};

                if (json !== undefined) {

                    for (var i = 0, l = json.length; i < l; i++) {

                        var data = json[i];

                        if (data.image === undefined) {

                            console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);

                        }

                        if (images[data.image] === undefined) {

                            console.warn('THREE.ObjectLoader: Undefined image', data.image);

                        }

                        var texture = new Texture(images[data.image]);
                        texture.needsUpdate = true;

                        texture.uuid = data.uuid;

                        if (data.name !== undefined) texture.name = data.name;

                        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);

                        if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                        if (data.center !== undefined) texture.center.fromArray(data.center);
                        if (data.rotation !== undefined) texture.rotation = data.rotation;

                        if (data.wrap !== undefined) {

                            texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                            texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);

                        }

                        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;

                        if (data.flipY !== undefined) texture.flipY = data.flipY;

                        textures[data.uuid] = texture;

                    }

                }

                return textures;

            },

            parseObject: function () {

                var matrix = new Matrix4();

                return function parseObject(data, geometries, materials) {

                    var object;

                    function getGeometry(name) {

                        if (geometries[name] === undefined) {

                            console.warn('THREE.ObjectLoader: Undefined geometry', name);

                        }

                        return geometries[name];

                    }

                    function getMaterial(name) {

                        if (name === undefined) return undefined;

                        if (Array.isArray(name)) {

                            var array = [];

                            for (var i = 0, l = name.length; i < l; i++) {

                                var uuid = name[i];

                                if (materials[uuid] === undefined) {

                                    console.warn('THREE.ObjectLoader: Undefined material', uuid);

                                }

                                array.push(materials[uuid]);

                            }

                            return array;

                        }

                        if (materials[name] === undefined) {

                            console.warn('THREE.ObjectLoader: Undefined material', name);

                        }

                        return materials[name];

                    }

                    switch (data.type) {

                        case 'Scene':

                            object = new Scene();

                            if (data.background !== undefined) {

                                if (Number.isInteger(data.background)) {

                                    object.background = new Color(data.background);

                                }

                            }

                            if (data.fog !== undefined) {

                                if (data.fog.type === 'Fog') {

                                    object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);

                                } else if (data.fog.type === 'FogExp2') {

                                    object.fog = new FogExp2(data.fog.color, data.fog.density);

                                }

                            }

                            break;

                        case 'PerspectiveCamera':

                            object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);

                            if (data.focus !== undefined) object.focus = data.focus;
                            if (data.zoom !== undefined) object.zoom = data.zoom;
                            if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                            if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                            if (data.view !== undefined) object.view = Object.assign({}, data.view);

                            break;

                        case 'OrthographicCamera':

                            object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);

                            break;

                        case 'AmbientLight':

                            object = new AmbientLight(data.color, data.intensity);

                            break;

                        case 'DirectionalLight':

                            object = new DirectionalLight(data.color, data.intensity);

                            break;

                        case 'PointLight':

                            object = new PointLight(data.color, data.intensity, data.distance, data.decay);

                            break;

                        case 'RectAreaLight':

                            object = new RectAreaLight(data.color, data.intensity, data.width, data.height);

                            break;

                        case 'SpotLight':

                            object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);

                            break;

                        case 'HemisphereLight':

                            object = new HemisphereLight(data.color, data.groundColor, data.intensity);

                            break;

                        case 'SkinnedMesh':

                            console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

                        case 'Mesh':

                            var geometry = getGeometry(data.geometry);
                            var material = getMaterial(data.material);

                            if (geometry.bones && geometry.bones.length > 0) {

                                object = new SkinnedMesh(geometry, material);

                            } else {

                                object = new Mesh(geometry, material);

                            }

                            break;

                        case 'LOD':

                            object = new LOD();

                            break;

                        case 'Line':

                            object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);

                            break;

                        case 'LineLoop':

                            object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));

                            break;

                        case 'LineSegments':

                            object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));

                            break;

                        case 'PointCloud':
                        case 'Points':

                            object = new Points(getGeometry(data.geometry), getMaterial(data.material));

                            break;

                        case 'Sprite':

                            object = new Sprite(getMaterial(data.material));

                            break;

                        case 'Group':

                            object = new Group();

                            break;

                        default:

                            object = new Object3D();

                    }

                    object.uuid = data.uuid;

                    if (data.name !== undefined) object.name = data.name;
                    if (data.matrix !== undefined) {

                        matrix.fromArray(data.matrix);
                        matrix.decompose(object.position, object.quaternion, object.scale);

                    } else {

                        if (data.position !== undefined) object.position.fromArray(data.position);
                        if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                        if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
                        if (data.scale !== undefined) object.scale.fromArray(data.scale);

                    }

                    if (data.castShadow !== undefined) object.castShadow = data.castShadow;
                    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

                    if (data.shadow) {

                        if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
                        if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
                        if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
                        if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);

                    }

                    if (data.visible !== undefined) object.visible = data.visible;
                    if (data.userData !== undefined) object.userData = data.userData;

                    if (data.children !== undefined) {

                        var children = data.children;

                        for (var i = 0; i < children.length; i++) {

                            object.add(this.parseObject(children[i], geometries, materials));

                        }

                    }

                    if (data.type === 'LOD') {

                        var levels = data.levels;

                        for (var l = 0; l < levels.length; l++) {

                            var level = levels[l];
                            var child = object.getObjectByProperty('uuid', level.object);

                            if (child !== undefined) {

                                object.addLevel(child, level.distance);

                            }

                        }

                    }

                    return object;

                };

            }()

        });

        var TEXTURE_MAPPING = {
            UVMapping: UVMapping,
            CubeReflectionMapping: CubeReflectionMapping,
            CubeRefractionMapping: CubeRefractionMapping,
            EquirectangularReflectionMapping: EquirectangularReflectionMapping,
            EquirectangularRefractionMapping: EquirectangularRefractionMapping,
            SphericalReflectionMapping: SphericalReflectionMapping,
            CubeUVReflectionMapping: CubeUVReflectionMapping,
            CubeUVRefractionMapping: CubeUVRefractionMapping
        };

        var TEXTURE_WRAPPING = {
            RepeatWrapping: RepeatWrapping,
            ClampToEdgeWrapping: ClampToEdgeWrapping,
            MirroredRepeatWrapping: MirroredRepeatWrapping
        };

        var TEXTURE_FILTER = {
            NearestFilter: NearestFilter,
            NearestMipMapNearestFilter: NearestMipMapNearestFilter,
            NearestMipMapLinearFilter: NearestMipMapLinearFilter,
            LinearFilter: LinearFilter,
            LinearMipMapNearestFilter: LinearMipMapNearestFilter,
            LinearMipMapLinearFilter: LinearMipMapLinearFilter
        };

        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         *
         * Bezier Curves formulas obtained from
         * http://en.wikipedia.org/wiki/Bzier_curve
         */

        function CatmullRom(t, p0, p1, p2, p3) {

            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

        }

        //

        function QuadraticBezierP0(t, p) {

            var k = 1 - t;
            return k * k * p;

        }

        function QuadraticBezierP1(t, p) {

            return 2 * (1 - t) * t * p;

        }

        function QuadraticBezierP2(t, p) {

            return t * t * p;

        }

        function QuadraticBezier(t, p0, p1, p2) {

            return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +
                QuadraticBezierP2(t, p2);

        }

        //

        function CubicBezierP0(t, p) {

            var k = 1 - t;
            return k * k * k * p;

        }

        function CubicBezierP1(t, p) {

            var k = 1 - t;
            return 3 * k * k * t * p;

        }

        function CubicBezierP2(t, p) {

            return 3 * (1 - t) * t * t * p;

        }

        function CubicBezierP3(t, p) {

            return t * t * t * p;

        }

        function CubicBezier(t, p0, p1, p2, p3) {

            return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +
                CubicBezierP3(t, p3);

        }

        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * Extensible curve object
         *
         * Some common of curve methods:
         * .getPoint( t, optionalTarget ), .getTangent( t )
         * .getPointAt( u, optionalTarget ), .getTangentAt( u )
         * .getPoints(), .getSpacedPoints()
         * .getLength()
         * .updateArcLengths()
         *
         * This following curves inherit from THREE.Curve:
         *
         * -- 2D curves --
         * THREE.ArcCurve
         * THREE.CubicBezierCurve
         * THREE.EllipseCurve
         * THREE.LineCurve
         * THREE.QuadraticBezierCurve
         * THREE.SplineCurve
         *
         * -- 3D curves --
         * THREE.CatmullRomCurve3
         * THREE.CubicBezierCurve3
         * THREE.LineCurve3
         * THREE.QuadraticBezierCurve3
         *
         * A series of curves can be represented as a THREE.CurvePath.
         *
         **/

        /**************************************************************
         *    Abstract Curve base class
         **************************************************************/

        function Curve() {

            this.arcLengthDivisions = 200;

        }

        Object.assign(Curve.prototype, {

            // Virtual base class method to overwrite and implement in subclasses
            //	- t [0 .. 1]

            getPoint: function (/* t, optionalTarget */) {

                console.warn('THREE.Curve: .getPoint() not implemented.');
                return null;

            },

            // Get point at relative position in curve according to arc length
            // - u [0 .. 1]

            getPointAt: function (u, optionalTarget) {

                var t = this.getUtoTmapping(u);
                return this.getPoint(t, optionalTarget);

            },

            // Get sequence of points using getPoint( t )

            getPoints: function (divisions) {

                if (divisions === undefined) divisions = 5;

                var points = [];

                for (var d = 0; d <= divisions; d++) {

                    points.push(this.getPoint(d / divisions));

                }

                return points;

            },

            // Get sequence of points using getPointAt( u )

            getSpacedPoints: function (divisions) {

                if (divisions === undefined) divisions = 5;

                var points = [];

                for (var d = 0; d <= divisions; d++) {

                    points.push(this.getPointAt(d / divisions));

                }

                return points;

            },

            // Get total curve arc length

            getLength: function () {

                var lengths = this.getLengths();
                return lengths[lengths.length - 1];

            },

            // Get list of cumulative segment lengths

            getLengths: function (divisions) {

                if (divisions === undefined) divisions = this.arcLengthDivisions;

                if (this.cacheArcLengths &&
                    (this.cacheArcLengths.length === divisions + 1) &&
                    !this.needsUpdate) {

                    return this.cacheArcLengths;

                }

                this.needsUpdate = false;

                var cache = [];
                var current, last = this.getPoint(0);
                var p, sum = 0;

                cache.push(0);

                for (p = 1; p <= divisions; p++) {

                    current = this.getPoint(p / divisions);
                    sum += current.distanceTo(last);
                    cache.push(sum);
                    last = current;

                }

                this.cacheArcLengths = cache;

                return cache; // { sums: cache, sum: sum }; Sum is in the last element.

            },

            updateArcLengths: function () {

                this.needsUpdate = true;
                this.getLengths();

            },

            // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

            getUtoTmapping: function (u, distance) {

                var arcLengths = this.getLengths();

                var i = 0, il = arcLengths.length;

                var targetArcLength; // The targeted u distance value to get

                if (distance) {

                    targetArcLength = distance;

                } else {

                    targetArcLength = u * arcLengths[il - 1];

                }

                // binary search for the index with largest value smaller than target u distance

                var low = 0, high = il - 1, comparison;

                while (low <= high) {

                    i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

                    comparison = arcLengths[i] - targetArcLength;

                    if (comparison < 0) {

                        low = i + 1;

                    } else if (comparison > 0) {

                        high = i - 1;

                    } else {

                        high = i;
                        break;

                        // DONE

                    }

                }

                i = high;

                if (arcLengths[i] === targetArcLength) {

                    return i / (il - 1);

                }

                // we could get finer grain at lengths, or use simple interpolation between two points

                var lengthBefore = arcLengths[i];
                var lengthAfter = arcLengths[i + 1];

                var segmentLength = lengthAfter - lengthBefore;

                // determine where we are between the 'before' and 'after' points

                var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

                // add that fractional amount to t

                var t = (i + segmentFraction) / (il - 1);

                return t;

            },

            // Returns a unit vector tangent at t
            // In case any sub curve does not implement its tangent derivation,
            // 2 points a small delta apart will be used to find its gradient
            // which seems to give a reasonable approximation

            getTangent: function (t) {

                var delta = 0.0001;
                var t1 = t - delta;
                var t2 = t + delta;

                // Capping in case of danger

                if (t1 < 0) t1 = 0;
                if (t2 > 1) t2 = 1;

                var pt1 = this.getPoint(t1);
                var pt2 = this.getPoint(t2);

                var vec = pt2.clone().sub(pt1);
                return vec.normalize();

            },

            getTangentAt: function (u) {

                var t = this.getUtoTmapping(u);
                return this.getTangent(t);

            },

            computeFrenetFrames: function (segments, closed) {

                // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

                var normal = new Vector3();

                var tangents = [];
                var normals = [];
                var binormals = [];

                var vec = new Vector3();
                var mat = new Matrix4();

                var i, u, theta;

                // compute the tangent vectors for each segment on the curve

                for (i = 0; i <= segments; i++) {

                    u = i / segments;

                    tangents[i] = this.getTangentAt(u);
                    tangents[i].normalize();

                }

                // select an initial normal vector perpendicular to the first tangent vector,
                // and in the direction of the minimum tangent xyz component

                normals[0] = new Vector3();
                binormals[0] = new Vector3();
                var min = Number.MAX_VALUE;
                var tx = Math.abs(tangents[0].x);
                var ty = Math.abs(tangents[0].y);
                var tz = Math.abs(tangents[0].z);

                if (tx <= min) {

                    min = tx;
                    normal.set(1, 0, 0);

                }

                if (ty <= min) {

                    min = ty;
                    normal.set(0, 1, 0);

                }

                if (tz <= min) {

                    normal.set(0, 0, 1);

                }

                vec.crossVectors(tangents[0], normal).normalize();

                normals[0].crossVectors(tangents[0], vec);
                binormals[0].crossVectors(tangents[0], normals[0]);


                // compute the slowly-varying normal and binormal vectors for each segment on the curve

                for (i = 1; i <= segments; i++) {

                    normals[i] = normals[i - 1].clone();

                    binormals[i] = binormals[i - 1].clone();

                    vec.crossVectors(tangents[i - 1], tangents[i]);

                    if (vec.length() > Number.EPSILON) {

                        vec.normalize();

                        theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

                        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));

                    }

                    binormals[i].crossVectors(tangents[i], normals[i]);

                }

                // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

                if (closed === true) {

                    theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
                    theta /= segments;

                    if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {

                        theta = -theta;

                    }

                    for (i = 1; i <= segments; i++) {

                        // twist a little...
                        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                        binormals[i].crossVectors(tangents[i], normals[i]);

                    }

                }

                return {
                    tangents: tangents,
                    normals: normals,
                    binormals: binormals
                };

            }

        });

        function LineCurve(v1, v2) {

            Curve.call(this);

            this.v1 = v1;
            this.v2 = v2;

        }

        LineCurve.prototype = Object.create(Curve.prototype);
        LineCurve.prototype.constructor = LineCurve;

        LineCurve.prototype.isLineCurve = true;

        LineCurve.prototype.getPoint = function (t, optionalTarget) {

            var point = optionalTarget || new Vector2();

            if (t === 1) {

                point.copy(this.v2);

            } else {

                point.copy(this.v2).sub(this.v1);
                point.multiplyScalar(t).add(this.v1);

            }

            return point;

        };

        // Line curve is linear, so we can overwrite default getPointAt

        LineCurve.prototype.getPointAt = function (u, optionalTarget) {

            return this.getPoint(u, optionalTarget);

        };

        LineCurve.prototype.getTangent = function (/* t */) {

            var tangent = this.v2.clone().sub(this.v1);

            return tangent.normalize();

        };

        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         *
         **/

        /**************************************************************
         *    Curved Path - a curve path is simply a array of connected
         *  curves, but retains the api of a curve
         **************************************************************/

        function CurvePath() {

            Curve.call(this);

            this.curves = [];

            this.autoClose = false; // Automatically closes the path

        }

        CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {

            constructor: CurvePath,

            add: function (curve) {

                this.curves.push(curve);

            },

            closePath: function () {

                // Add a line curve if start and end of lines are not connected
                var startPoint = this.curves[0].getPoint(0);
                var endPoint = this.curves[this.curves.length - 1].getPoint(1);

                if (!startPoint.equals(endPoint)) {

                    this.curves.push(new LineCurve(endPoint, startPoint));

                }

            },

            // To get accurate point with reference to
            // entire path distance at time t,
            // following has to be done:

            // 1. Length of each sub path have to be known
            // 2. Locate and identify type of curve
            // 3. Get t for the curve
            // 4. Return curve.getPointAt(t')

            getPoint: function (t) {

                var d = t * this.getLength();
                var curveLengths = this.getCurveLengths();
                var i = 0;

                // To think about boundaries points.

                while (i < curveLengths.length) {

                    if (curveLengths[i] >= d) {

                        var diff = curveLengths[i] - d;
                        var curve = this.curves[i];

                        var segmentLength = curve.getLength();
                        var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

                        return curve.getPointAt(u);

                    }

                    i++;

                }

                return null;

                // loop where sum != 0, sum > d , sum+1 <d

            },

            // We cannot use the default THREE.Curve getPoint() with getLength() because in
            // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
            // getPoint() depends on getLength

            getLength: function () {

                var lens = this.getCurveLengths();
                return lens[lens.length - 1];

            },

            // cacheLengths must be recalculated.
            updateArcLengths: function () {

                this.needsUpdate = true;
                this.cacheLengths = null;
                this.getCurveLengths();

            },

            // Compute lengths and cache them
            // We cannot overwrite getLengths() because UtoT mapping uses it.

            getCurveLengths: function () {

                // We use cache values if curves and cache array are same length

                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {

                    return this.cacheLengths;

                }

                // Get length of sub-curve
                // Push sums into cached array

                var lengths = [], sums = 0;

                for (var i = 0, l = this.curves.length; i < l; i++) {

                    sums += this.curves[i].getLength();
                    lengths.push(sums);

                }

                this.cacheLengths = lengths;

                return lengths;

            },

            getSpacedPoints: function (divisions) {

                if (divisions === undefined) divisions = 40;

                var points = [];

                for (var i = 0; i <= divisions; i++) {

                    points.push(this.getPoint(i / divisions));

                }

                if (this.autoClose) {

                    points.push(points[0]);

                }

                return points;

            },

            getPoints: function (divisions) {

                divisions = divisions || 12;

                var points = [], last;

                for (var i = 0, curves = this.curves; i < curves.length; i++) {

                    var curve = curves[i];
                    var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
                        : (curve && curve.isLineCurve) ? 1
                            : (curve && curve.isSplineCurve) ? divisions * curve.points.length
                                : divisions;

                    var pts = curve.getPoints(resolution);

                    for (var j = 0; j < pts.length; j++) {

                        var point = pts[j];

                        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

                        points.push(point);
                        last = point;

                    }

                }

                if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {

                    points.push(points[0]);

                }

                return points;

            }

        });

        function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

            Curve.call(this);

            this.aX = aX;
            this.aY = aY;

            this.xRadius = xRadius;
            this.yRadius = yRadius;

            this.aStartAngle = aStartAngle;
            this.aEndAngle = aEndAngle;

            this.aClockwise = aClockwise;

            this.aRotation = aRotation || 0;

        }

        EllipseCurve.prototype = Object.create(Curve.prototype);
        EllipseCurve.prototype.constructor = EllipseCurve;

        EllipseCurve.prototype.isEllipseCurve = true;

        EllipseCurve.prototype.getPoint = function (t, optionalTarget) {

            var point = optionalTarget || new Vector2();

            var twoPi = Math.PI * 2;
            var deltaAngle = this.aEndAngle - this.aStartAngle;
            var samePoints = Math.abs(deltaAngle) < Number.EPSILON;

            // ensures that deltaAngle is 0 .. 2 PI
            while (deltaAngle < 0) deltaAngle += twoPi;
            while (deltaAngle > twoPi) deltaAngle -= twoPi;

            if (deltaAngle < Number.EPSILON) {

                if (samePoints) {

                    deltaAngle = 0;

                } else {

                    deltaAngle = twoPi;

                }

            }

            if (this.aClockwise === true && !samePoints) {

                if (deltaAngle === twoPi) {

                    deltaAngle = -twoPi;

                } else {

                    deltaAngle = deltaAngle - twoPi;

                }

            }

            var angle = this.aStartAngle + t * deltaAngle;
            var x = this.aX + this.xRadius * Math.cos(angle);
            var y = this.aY + this.yRadius * Math.sin(angle);

            if (this.aRotation !== 0) {

                var cos = Math.cos(this.aRotation);
                var sin = Math.sin(this.aRotation);

                var tx = x - this.aX;
                var ty = y - this.aY;

                // Rotate the point about the center of the ellipse.
                x = tx * cos - ty * sin + this.aX;
                y = tx * sin + ty * cos + this.aY;

            }

            return point.set(x, y);

        };

        function SplineCurve(points /* array of Vector2 */) {

            Curve.call(this);

            this.points = (points === undefined) ? [] : points;

        }

        SplineCurve.prototype = Object.create(Curve.prototype);
        SplineCurve.prototype.constructor = SplineCurve;

        SplineCurve.prototype.isSplineCurve = true;

        SplineCurve.prototype.getPoint = function (t, optionalTarget) {

            var point = optionalTarget || new Vector2();

            var points = this.points;
            var p = (points.length - 1) * t;

            var intPoint = Math.floor(p);
            var weight = p - intPoint;

            var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
            var p1 = points[intPoint];
            var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
            var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];

            point.set(
                CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
                CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
            );

            return point;

        };

        function CubicBezierCurve(v0, v1, v2, v3) {

            Curve.call(this);

            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
            this.v3 = v3;

        }

        CubicBezierCurve.prototype = Object.create(Curve.prototype);
        CubicBezierCurve.prototype.constructor = CubicBezierCurve;

        CubicBezierCurve.prototype.isCubicBezierCurve = true;

        CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {

            var point = optionalTarget || new Vector2();

            var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

            point.set(
                CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
                CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
            );

            return point;

        };

        function QuadraticBezierCurve(v0, v1, v2) {

            Curve.call(this);

            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;

        }

        QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
        QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

        QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

        QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {

            var point = optionalTarget || new Vector2();

            var v0 = this.v0, v1 = this.v1, v2 = this.v2;

            point.set(
                QuadraticBezier(t, v0.x, v1.x, v2.x),
                QuadraticBezier(t, v0.y, v1.y, v2.y)
            );

            return point;

        };

        var PathPrototype = Object.assign(Object.create(CurvePath.prototype), {

            fromPoints: function (vectors) {

                this.moveTo(vectors[0].x, vectors[0].y);

                for (var i = 1, l = vectors.length; i < l; i++) {

                    this.lineTo(vectors[i].x, vectors[i].y);

                }

            },

            moveTo: function (x, y) {

                this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

            },

            lineTo: function (x, y) {

                var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
                this.curves.push(curve);

                this.currentPoint.set(x, y);

            },

            quadraticCurveTo: function (aCPx, aCPy, aX, aY) {

                var curve = new QuadraticBezierCurve(
                    this.currentPoint.clone(),
                    new Vector2(aCPx, aCPy),
                    new Vector2(aX, aY)
                );

                this.curves.push(curve);

                this.currentPoint.set(aX, aY);

            },

            bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

                var curve = new CubicBezierCurve(
                    this.currentPoint.clone(),
                    new Vector2(aCP1x, aCP1y),
                    new Vector2(aCP2x, aCP2y),
                    new Vector2(aX, aY)
                );

                this.curves.push(curve);

                this.currentPoint.set(aX, aY);

            },

            splineThru: function (pts /*Array of Vector*/) {

                var npts = [this.currentPoint.clone()].concat(pts);

                var curve = new SplineCurve(npts);
                this.curves.push(curve);

                this.currentPoint.copy(pts[pts.length - 1]);

            },

            arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

                var x0 = this.currentPoint.x;
                var y0 = this.currentPoint.y;

                this.absarc(aX + x0, aY + y0, aRadius,
                    aStartAngle, aEndAngle, aClockwise);

            },

            absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

                this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);

            },

            ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

                var x0 = this.currentPoint.x;
                var y0 = this.currentPoint.y;

                this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

            },

            absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

                var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

                if (this.curves.length > 0) {

                    // if a previous curve is present, attempt to join
                    var firstPoint = curve.getPoint(0);

                    if (!firstPoint.equals(this.currentPoint)) {

                        this.lineTo(firstPoint.x, firstPoint.y);

                    }

                }

                this.curves.push(curve);

                var lastPoint = curve.getPoint(1);
                this.currentPoint.copy(lastPoint);

            }

        });

        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * Creates free form 2d path using series of points, lines or curves.
         **/

        function Path(points) {

            CurvePath.call(this);
            this.currentPoint = new Vector2();

            if (points) {

                this.fromPoints(points);

            }

        }

        Path.prototype = PathPrototype;
        PathPrototype.constructor = Path;

        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * Defines a 2d shape plane using paths.
         **/

        // STEP 1 Create a path.
        // STEP 2 Turn path into shape.
        // STEP 3 ExtrudeGeometry takes in Shape/Shapes
        // STEP 3a - Extract points from each shape, turn to vertices
        // STEP 3b - Triangulate each shape, add faces.

        function Shape() {

            Path.apply(this, arguments);

            this.holes = [];

        }

        Shape.prototype = Object.assign(Object.create(PathPrototype), {

            constructor: Shape,

            getPointsHoles: function (divisions) {

                var holesPts = [];

                for (var i = 0, l = this.holes.length; i < l; i++) {

                    holesPts[i] = this.holes[i].getPoints(divisions);

                }

                return holesPts;

            },

            // Get points of shape and holes (keypoints based on segments parameter)

            extractAllPoints: function (divisions) {

                return {

                    shape: this.getPoints(divisions),
                    holes: this.getPointsHoles(divisions)

                };

            },

            extractPoints: function (divisions) {

                return this.extractAllPoints(divisions);

            }

        });

        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
         **/

        function ShapePath() {

            this.subPaths = [];
            this.currentPath = null;

        }

        Object.assign(ShapePath.prototype, {

            moveTo: function (x, y) {

                this.currentPath = new Path();
                this.subPaths.push(this.currentPath);
                this.currentPath.moveTo(x, y);

            },

            lineTo: function (x, y) {

                this.currentPath.lineTo(x, y);

            },

            quadraticCurveTo: function (aCPx, aCPy, aX, aY) {

                this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);

            },

            bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

                this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);

            },

            splineThru: function (pts) {

                this.currentPath.splineThru(pts);

            },

            toShapes: function (isCCW, noHoles) {

                function toShapesNoHoles(inSubpaths) {

                    var shapes = [];

                    for (var i = 0, l = inSubpaths.length; i < l; i++) {

                        var tmpPath = inSubpaths[i];

                        var tmpShape = new Shape();
                        tmpShape.curves = tmpPath.curves;

                        shapes.push(tmpShape);

                    }

                    return shapes;

                }

                function isPointInsidePolygon(inPt, inPolygon) {

                    var polyLen = inPolygon.length;

                    // inPt on polygon contour => immediate success    or
                    // toggling of inside/outside at every single! intersection point of an edge
                    //  with the horizontal line through inPt, left of inPt
                    //  not counting lowerY endpoints of edges and whole edges on that line
                    var inside = false;
                    for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {

                        var edgeLowPt = inPolygon[p];
                        var edgeHighPt = inPolygon[q];

                        var edgeDx = edgeHighPt.x - edgeLowPt.x;
                        var edgeDy = edgeHighPt.y - edgeLowPt.y;

                        if (Math.abs(edgeDy) > Number.EPSILON) {

                            // not parallel
                            if (edgeDy < 0) {

                                edgeLowPt = inPolygon[q];
                                edgeDx = -edgeDx;
                                edgeHighPt = inPolygon[p];
                                edgeDy = -edgeDy;

                            }
                            if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y)) continue;

                            if (inPt.y === edgeLowPt.y) {

                                if (inPt.x === edgeLowPt.x) return true;		// inPt is on contour ?
                                // continue;				// no intersection or edgeLowPt => doesn't count !!!

                            } else {

                                var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                                if (perpEdge === 0) return true;		// inPt is on contour ?
                                if (perpEdge < 0) continue;
                                inside = !inside;		// true intersection left of inPt

                            }

                        } else {

                            // parallel or collinear
                            if (inPt.y !== edgeLowPt.y) continue;			// parallel
                            // edge lies on the same horizontal line as inPt
                            if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
                                ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x))) return true;	// inPt: Point on contour !
                            // continue;

                        }

                    }

                    return inside;

                }

                var isClockWise = ShapeUtils.isClockWise;

                var subPaths = this.subPaths;
                if (subPaths.length === 0) return [];

                if (noHoles === true) return toShapesNoHoles(subPaths);


                var solid, tmpPath, tmpShape, shapes = [];

                if (subPaths.length === 1) {

                    tmpPath = subPaths[0];
                    tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves;
                    shapes.push(tmpShape);
                    return shapes;

                }

                var holesFirst = !isClockWise(subPaths[0].getPoints());
                holesFirst = isCCW ? !holesFirst : holesFirst;

                // console.log("Holes first", holesFirst);

                var betterShapeHoles = [];
                var newShapes = [];
                var newShapeHoles = [];
                var mainIdx = 0;
                var tmpPoints;

                newShapes[mainIdx] = undefined;
                newShapeHoles[mainIdx] = [];

                for (var i = 0, l = subPaths.length; i < l; i++) {

                    tmpPath = subPaths[i];
                    tmpPoints = tmpPath.getPoints();
                    solid = isClockWise(tmpPoints);
                    solid = isCCW ? !solid : solid;

                    if (solid) {

                        if ((!holesFirst) && (newShapes[mainIdx])) mainIdx++;

                        newShapes[mainIdx] = {s: new Shape(), p: tmpPoints};
                        newShapes[mainIdx].s.curves = tmpPath.curves;

                        if (holesFirst) mainIdx++;
                        newShapeHoles[mainIdx] = [];

                        //console.log('cw', i);

                    } else {

                        newShapeHoles[mainIdx].push({h: tmpPath, p: tmpPoints[0]});

                        //console.log('ccw', i);

                    }

                }

                // only Holes? -> probably all Shapes with wrong orientation
                if (!newShapes[0]) return toShapesNoHoles(subPaths);


                if (newShapes.length > 1) {

                    var ambiguous = false;
                    var toChange = [];

                    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

                        betterShapeHoles[sIdx] = [];

                    }

                    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

                        var sho = newShapeHoles[sIdx];

                        for (var hIdx = 0; hIdx < sho.length; hIdx++) {

                            var ho = sho[hIdx];
                            var hole_unassigned = true;

                            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {

                                if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {

                                    if (sIdx !== s2Idx) toChange.push({froms: sIdx, tos: s2Idx, hole: hIdx});
                                    if (hole_unassigned) {

                                        hole_unassigned = false;
                                        betterShapeHoles[s2Idx].push(ho);

                                    } else {

                                        ambiguous = true;

                                    }

                                }

                            }
                            if (hole_unassigned) {

                                betterShapeHoles[sIdx].push(ho);

                            }

                        }

                    }
                    // console.log("ambiguous: ", ambiguous);
                    if (toChange.length > 0) {

                        // console.log("to change: ", toChange);
                        if (!ambiguous) newShapeHoles = betterShapeHoles;

                    }

                }

                var tmpHoles;

                for (var i = 0, il = newShapes.length; i < il; i++) {

                    tmpShape = newShapes[i].s;
                    shapes.push(tmpShape);
                    tmpHoles = newShapeHoles[i];

                    for (var j = 0, jl = tmpHoles.length; j < jl; j++) {

                        tmpShape.holes.push(tmpHoles[j].h);

                    }

                }

                //console.log("shape", shapes);

                return shapes;

            }

        });

        /**
         * @author zz85 / http://www.lab4games.net/zz85/blog
         * @author mrdoob / http://mrdoob.com/
         */

        function Font(data) {

            this.data = data;

        }

        Object.assign(Font.prototype, {

            isFont: true,

            generateShapes: function (text, size, divisions) {

                function createPaths(text) {

                    var chars = String(text).split('');
                    var scale = size / data.resolution;
                    var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;

                    var offsetX = 0, offsetY = 0;

                    var paths = [];

                    for (var i = 0; i < chars.length; i++) {

                        var char = chars[i];

                        if (char === '\n') {

                            offsetX = 0;
                            offsetY -= line_height;

                        } else {

                            var ret = createPath(char, scale, offsetX, offsetY);
                            offsetX += ret.offsetX;
                            paths.push(ret.path);

                        }

                    }

                    return paths;

                }

                function createPath(c, scale, offsetX, offsetY) {

                    var glyph = data.glyphs[c] || data.glyphs['?'];

                    if (!glyph) return;

                    var path = new ShapePath();

                    var pts = [];
                    var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

                    if (glyph.o) {

                        var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

                        for (var i = 0, l = outline.length; i < l;) {

                            var action = outline[i++];

                            switch (action) {

                                case 'm': // moveTo

                                    x = outline[i++] * scale + offsetX;
                                    y = outline[i++] * scale + offsetY;

                                    path.moveTo(x, y);

                                    break;

                                case 'l': // lineTo

                                    x = outline[i++] * scale + offsetX;
                                    y = outline[i++] * scale + offsetY;

                                    path.lineTo(x, y);

                                    break;

                                case 'q': // quadraticCurveTo

                                    cpx = outline[i++] * scale + offsetX;
                                    cpy = outline[i++] * scale + offsetY;
                                    cpx1 = outline[i++] * scale + offsetX;
                                    cpy1 = outline[i++] * scale + offsetY;

                                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

                                    laste = pts[pts.length - 1];

                                    if (laste) {

                                        cpx0 = laste.x;
                                        cpy0 = laste.y;

                                        for (var i2 = 1; i2 <= divisions; i2++) {

                                            var t = i2 / divisions;
                                            QuadraticBezier(t, cpx0, cpx1, cpx);
                                            QuadraticBezier(t, cpy0, cpy1, cpy);

                                        }

                                    }

                                    break;

                                case 'b': // bezierCurveTo

                                    cpx = outline[i++] * scale + offsetX;
                                    cpy = outline[i++] * scale + offsetY;
                                    cpx1 = outline[i++] * scale + offsetX;
                                    cpy1 = outline[i++] * scale + offsetY;
                                    cpx2 = outline[i++] * scale + offsetX;
                                    cpy2 = outline[i++] * scale + offsetY;

                                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);

                                    laste = pts[pts.length - 1];

                                    if (laste) {

                                        cpx0 = laste.x;
                                        cpy0 = laste.y;

                                        for (var i2 = 1; i2 <= divisions; i2++) {

                                            var t = i2 / divisions;
                                            CubicBezier(t, cpx0, cpx1, cpx2, cpx);
                                            CubicBezier(t, cpy0, cpy1, cpy2, cpy);

                                        }

                                    }

                                    break;

                            }

                        }

                    }

                    return {offsetX: glyph.ha * scale, path: path};

                }

                //

                if (size === undefined) size = 100;
                if (divisions === undefined) divisions = 4;

                var data = this.data;

                var paths = createPaths(text);
                var shapes = [];

                for (var p = 0, pl = paths.length; p < pl; p++) {

                    Array.prototype.push.apply(shapes, paths[p].toShapes());

                }

                return shapes;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function FontLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

        }

        Object.assign(FontLoader.prototype, {

            load: function (text, onLoad, onProgress, onError) {

                var scope = this;

                var loader = new FileLoader(this.manager);
                //loader.setPath( this.path );
                //loader.load( url, function ( text ) {

                var json;

                try {

                    json = JSON.parse(text);

                } catch (e) {

                    console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                    json = JSON.parse(text.substring(65, text.length - 2));

                }

                var font = scope.parse(json);

                if (onLoad) onLoad(font);

                //}, onProgress, onError );

            },

            parse: function (json) {

                return new Font(json);

            },

            setPath: function (value) {

                this.path = value;
                return this;

            }

        });

        var context;

        var AudioContext = {

            getContext: function () {

                if (context === undefined) {

                    context = new (window.AudioContext || window.webkitAudioContext)();

                }

                return context;

            },

            setContext: function (value) {

                context = value;

            }

        };

        /**
         * @author Reece Aaron Lecrivain / http://reecenotes.com/
         */

        function AudioLoader(manager) {

            this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

        }

        Object.assign(AudioLoader.prototype, {

            load: function (url, onLoad, onProgress, onError) {

                var loader = new FileLoader(this.manager);
                loader.setResponseType('arraybuffer');
                loader.load(url, function (buffer) {

                    var context = AudioContext.getContext();

                    context.decodeAudioData(buffer, function (audioBuffer) {

                        onLoad(audioBuffer);

                    });

                }, onProgress, onError);

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function StereoCamera() {

            this.type = 'StereoCamera';

            this.aspect = 1;

            this.eyeSep = 0.064;

            this.cameraL = new PerspectiveCamera();
            this.cameraL.layers.enable(1);
            this.cameraL.matrixAutoUpdate = false;

            this.cameraR = new PerspectiveCamera();
            this.cameraR.layers.enable(2);
            this.cameraR.matrixAutoUpdate = false;

        }

        Object.assign(StereoCamera.prototype, {

            update: (function () {

                var instance, focus, fov, aspect, near, far, zoom, eyeSep;

                var eyeRight = new Matrix4();
                var eyeLeft = new Matrix4();

                return function update(camera) {

                    var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
                        aspect !== camera.aspect * this.aspect || near !== camera.near ||
                        far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

                    if (needsUpdate) {

                        instance = this;
                        focus = camera.focus;
                        fov = camera.fov;
                        aspect = camera.aspect * this.aspect;
                        near = camera.near;
                        far = camera.far;
                        zoom = camera.zoom;

                        // Off-axis stereoscopic effect based on
                        // http://paulbourke.net/stereographics/stereorender/

                        var projectionMatrix = camera.projectionMatrix.clone();
                        eyeSep = this.eyeSep / 2;
                        var eyeSepOnProjection = eyeSep * near / focus;
                        var ymax = (near * Math.tan(_Math.DEG2RAD * fov * 0.5)) / zoom;
                        var xmin, xmax;

                        // translate xOffset

                        eyeLeft.elements[12] = -eyeSep;
                        eyeRight.elements[12] = eyeSep;

                        // for left eye

                        xmin = -ymax * aspect + eyeSepOnProjection;
                        xmax = ymax * aspect + eyeSepOnProjection;

                        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

                        this.cameraL.projectionMatrix.copy(projectionMatrix);

                        // for right eye

                        xmin = -ymax * aspect - eyeSepOnProjection;
                        xmax = ymax * aspect - eyeSepOnProjection;

                        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

                        this.cameraR.projectionMatrix.copy(projectionMatrix);

                    }

                    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
                    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);

                };

            })()

        });


        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function AudioListener() {

            Object3D.call(this);

            this.type = 'AudioListener';

            this.context = AudioContext.getContext();

            this.gain = this.context.createGain();
            this.gain.connect(this.context.destination);

            this.filter = null;

        }

        AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: AudioListener,

            getInput: function () {

                return this.gain;

            },

            removeFilter: function () {

                if (this.filter !== null) {

                    this.gain.disconnect(this.filter);
                    this.filter.disconnect(this.context.destination);
                    this.gain.connect(this.context.destination);
                    this.filter = null;

                }

            },

            getFilter: function () {

                return this.filter;

            },

            setFilter: function (value) {

                if (this.filter !== null) {

                    this.gain.disconnect(this.filter);
                    this.filter.disconnect(this.context.destination);

                } else {

                    this.gain.disconnect(this.context.destination);

                }

                this.filter = value;
                this.gain.connect(this.filter);
                this.filter.connect(this.context.destination);

            },

            getMasterVolume: function () {

                return this.gain.gain.value;

            },

            setMasterVolume: function (value) {

                this.gain.gain.value = value;

            },

            updateMatrixWorld: (function () {

                var position = new Vector3();
                var quaternion = new Quaternion();
                var scale = new Vector3();

                var orientation = new Vector3();

                return function updateMatrixWorld(force) {

                    Object3D.prototype.updateMatrixWorld.call(this, force);

                    var listener = this.context.listener;
                    var up = this.up;

                    this.matrixWorld.decompose(position, quaternion, scale);

                    orientation.set(0, 0, -1).applyQuaternion(quaternion);

                    if (listener.positionX) {

                        listener.positionX.setValueAtTime(position.x, this.context.currentTime);
                        listener.positionY.setValueAtTime(position.y, this.context.currentTime);
                        listener.positionZ.setValueAtTime(position.z, this.context.currentTime);
                        listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime);
                        listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime);
                        listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime);
                        listener.upX.setValueAtTime(up.x, this.context.currentTime);
                        listener.upY.setValueAtTime(up.y, this.context.currentTime);
                        listener.upZ.setValueAtTime(up.z, this.context.currentTime);

                    } else {

                        listener.setPosition(position.x, position.y, position.z);
                        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);

                    }

                };

            })()

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author Reece Aaron Lecrivain / http://reecenotes.com/
         */

        function Audio(listener) {

            Object3D.call(this);

            this.type = 'Audio';

            this.context = listener.context;

            this.gain = this.context.createGain();
            this.gain.connect(listener.getInput());

            this.autoplay = false;

            this.buffer = null;
            this.loop = false;
            this.startTime = 0;
            this.offset = 0;
            this.playbackRate = 1;
            this.isPlaying = false;
            this.hasPlaybackControl = true;
            this.sourceType = 'empty';

            this.filters = [];

        }

        Audio.prototype = Object.assign(Object.create(Object3D.prototype), {

            constructor: Audio,

            getOutput: function () {

                return this.gain;

            },

            setNodeSource: function (audioNode) {

                this.hasPlaybackControl = false;
                this.sourceType = 'audioNode';
                this.source = audioNode;
                this.connect();

                return this;

            },

            setBuffer: function (audioBuffer) {

                this.buffer = audioBuffer;
                this.sourceType = 'buffer';

                if (this.autoplay) this.play();

                return this;

            },

            play: function () {

                if (this.isPlaying === true) {

                    console.warn('THREE.Audio: Audio is already playing.');
                    return;

                }

                if (this.hasPlaybackControl === false) {

                    console.warn('THREE.Audio: this Audio has no playback control.');
                    return;

                }

                var source = this.context.createBufferSource();

                source.buffer = this.buffer;
                source.loop = this.loop;
                source.onended = this.onEnded.bind(this);
                source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
                this.startTime = this.context.currentTime;
                source.start(this.startTime, this.offset);

                this.isPlaying = true;

                this.source = source;

                return this.connect();

            },

            pause: function () {

                if (this.hasPlaybackControl === false) {

                    console.warn('THREE.Audio: this Audio has no playback control.');
                    return;

                }

                if (this.isPlaying === true) {

                    this.source.stop();
                    this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
                    this.isPlaying = false;

                }

                return this;

            },

            stop: function () {

                if (this.hasPlaybackControl === false) {

                    console.warn('THREE.Audio: this Audio has no playback control.');
                    return;

                }

                this.source.stop();
                this.offset = 0;
                this.isPlaying = false;

                return this;

            },

            connect: function () {

                if (this.filters.length > 0) {

                    this.source.connect(this.filters[0]);

                    for (var i = 1, l = this.filters.length; i < l; i++) {

                        this.filters[i - 1].connect(this.filters[i]);

                    }

                    this.filters[this.filters.length - 1].connect(this.getOutput());

                } else {

                    this.source.connect(this.getOutput());

                }

                return this;

            },

            disconnect: function () {

                if (this.filters.length > 0) {

                    this.source.disconnect(this.filters[0]);

                    for (var i = 1, l = this.filters.length; i < l; i++) {

                        this.filters[i - 1].disconnect(this.filters[i]);

                    }

                    this.filters[this.filters.length - 1].disconnect(this.getOutput());

                } else {

                    this.source.disconnect(this.getOutput());

                }

                return this;

            },

            getFilters: function () {

                return this.filters;

            },

            setFilters: function (value) {

                if (!value) value = [];

                if (this.isPlaying === true) {

                    this.disconnect();
                    this.filters = value;
                    this.connect();

                } else {

                    this.filters = value;

                }

                return this;

            },

            getFilter: function () {

                return this.getFilters()[0];

            },

            setFilter: function (filter) {

                return this.setFilters(filter ? [filter] : []);

            },

            setPlaybackRate: function (value) {

                if (this.hasPlaybackControl === false) {

                    console.warn('THREE.Audio: this Audio has no playback control.');
                    return;

                }

                this.playbackRate = value;

                if (this.isPlaying === true) {

                    this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);

                }

                return this;

            },

            getPlaybackRate: function () {

                return this.playbackRate;

            },

            onEnded: function () {

                this.isPlaying = false;

            },

            getLoop: function () {

                if (this.hasPlaybackControl === false) {

                    console.warn('THREE.Audio: this Audio has no playback control.');
                    return false;

                }

                return this.loop;

            },

            setLoop: function (value) {

                if (this.hasPlaybackControl === false) {

                    console.warn('THREE.Audio: this Audio has no playback control.');
                    return;

                }

                this.loop = value;

                if (this.isPlaying === true) {

                    this.source.loop = this.loop;

                }

                return this;

            },

            getVolume: function () {

                return this.gain.gain.value;

            },

            setVolume: function (value) {

                this.gain.gain.value = value;

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function PositionalAudio(listener) {

            Audio.call(this, listener);

            this.panner = this.context.createPanner();
            this.panner.connect(this.gain);

        }

        PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {

            constructor: PositionalAudio,

            getOutput: function () {

                return this.panner;

            },

            getRefDistance: function () {

                return this.panner.refDistance;

            },

            setRefDistance: function (value) {

                this.panner.refDistance = value;

            },

            getRolloffFactor: function () {

                return this.panner.rolloffFactor;

            },

            setRolloffFactor: function (value) {

                this.panner.rolloffFactor = value;

            },

            getDistanceModel: function () {

                return this.panner.distanceModel;

            },

            setDistanceModel: function (value) {

                this.panner.distanceModel = value;

            },

            getMaxDistance: function () {

                return this.panner.maxDistance;

            },

            setMaxDistance: function (value) {

                this.panner.maxDistance = value;

            },

            updateMatrixWorld: (function () {

                var position = new Vector3();

                return function updateMatrixWorld(force) {

                    Object3D.prototype.updateMatrixWorld.call(this, force);

                    position.setFromMatrixPosition(this.matrixWorld);

                    this.panner.setPosition(position.x, position.y, position.z);

                };

            })()


        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function AudioAnalyser(audio, fftSize) {

            this.analyser = audio.context.createAnalyser();
            this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

            this.data = new Uint8Array(this.analyser.frequencyBinCount);

            audio.getOutput().connect(this.analyser);

        }

        Object.assign(AudioAnalyser.prototype, {

            getFrequencyData: function () {

                this.analyser.getByteFrequencyData(this.data);

                return this.data;

            },

            getAverageFrequency: function () {

                var value = 0, data = this.getFrequencyData();

                for (var i = 0; i < data.length; i++) {

                    value += data[i];

                }

                return value / data.length;

            }

        });

        /**
         *
         * Buffered scene graph property that allows weighted accumulation.
         *
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function PropertyMixer(binding, typeName, valueSize) {

            this.binding = binding;
            this.valueSize = valueSize;

            var bufferType = Float64Array,
                mixFunction;

            switch (typeName) {

                case 'quaternion':
                    mixFunction = this._slerp;
                    break;

                case 'string':
                case 'bool':
                    bufferType = Array;
                    mixFunction = this._select;
                    break;

                default:
                    mixFunction = this._lerp;

            }

            this.buffer = new bufferType(valueSize * 4);
            // layout: [ incoming | accu0 | accu1 | orig ]
            //
            // interpolators can use .buffer as their .result
            // the data then goes to 'incoming'
            //
            // 'accu0' and 'accu1' are used frame-interleaved for
            // the cumulative result and are compared to detect
            // changes
            //
            // 'orig' stores the original state of the property

            this._mixBufferRegion = mixFunction;

            this.cumulativeWeight = 0;

            this.useCount = 0;
            this.referenceCount = 0;

        }

        Object.assign(PropertyMixer.prototype, {

            // accumulate data in the 'incoming' region into 'accu<i>'
            accumulate: function (accuIndex, weight) {

                // note: happily accumulating nothing when weight = 0, the caller knows
                // the weight and shouldn't have made the call in the first place

                var buffer = this.buffer,
                    stride = this.valueSize,
                    offset = accuIndex * stride + stride,

                    currentWeight = this.cumulativeWeight;

                if (currentWeight === 0) {

                    // accuN := incoming * weight

                    for (var i = 0; i !== stride; ++i) {

                        buffer[offset + i] = buffer[i];

                    }

                    currentWeight = weight;

                } else {

                    // accuN := accuN + incoming * weight

                    currentWeight += weight;
                    var mix = weight / currentWeight;
                    this._mixBufferRegion(buffer, offset, 0, mix, stride);

                }

                this.cumulativeWeight = currentWeight;

            },

            // apply the state of 'accu<i>' to the binding when accus differ
            apply: function (accuIndex) {

                var stride = this.valueSize,
                    buffer = this.buffer,
                    offset = accuIndex * stride + stride,

                    weight = this.cumulativeWeight,

                    binding = this.binding;

                this.cumulativeWeight = 0;

                if (weight < 1) {

                    // accuN := accuN + original * ( 1 - cumulativeWeight )

                    var originalValueOffset = stride * 3;

                    this._mixBufferRegion(
                        buffer, offset, originalValueOffset, 1 - weight, stride);

                }

                for (var i = stride, e = stride + stride; i !== e; ++i) {

                    if (buffer[i] !== buffer[i + stride]) {

                        // value has changed -> update scene graph

                        binding.setValue(buffer, offset);
                        break;

                    }

                }

            },

            // remember the state of the bound property and copy it to both accus
            saveOriginalState: function () {

                var binding = this.binding;

                var buffer = this.buffer,
                    stride = this.valueSize,

                    originalValueOffset = stride * 3;

                binding.getValue(buffer, originalValueOffset);

                // accu[0..1] := orig -- initially detect changes against the original
                for (var i = stride, e = originalValueOffset; i !== e; ++i) {

                    buffer[i] = buffer[originalValueOffset + (i % stride)];

                }

                this.cumulativeWeight = 0;

            },

            // apply the state previously taken via 'saveOriginalState' to the binding
            restoreOriginalState: function () {

                var originalValueOffset = this.valueSize * 3;
                this.binding.setValue(this.buffer, originalValueOffset);

            },


            // mix functions

            _select: function (buffer, dstOffset, srcOffset, t, stride) {

                if (t >= 0.5) {

                    for (var i = 0; i !== stride; ++i) {

                        buffer[dstOffset + i] = buffer[srcOffset + i];

                    }

                }

            },

            _slerp: function (buffer, dstOffset, srcOffset, t) {

                Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);

            },

            _lerp: function (buffer, dstOffset, srcOffset, t, stride) {

                var s = 1 - t;

                for (var i = 0; i !== stride; ++i) {

                    var j = dstOffset + i;

                    buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;

                }

            }

        });

        /**
         *
         * A reference to a real property in the scene graph.
         *
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function Composite(targetGroup, path, optionalParsedPath) {

            var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);

            this._targetGroup = targetGroup;
            this._bindings = targetGroup.subscribe_(path, parsedPath);

        }

        Object.assign(Composite.prototype, {

            getValue: function (array, offset) {

                this.bind(); // bind all binding

                var firstValidIndex = this._targetGroup.nCachedObjects_,
                    binding = this._bindings[firstValidIndex];

                // and only call .getValue on the first
                if (binding !== undefined) binding.getValue(array, offset);

            },

            setValue: function (array, offset) {

                var bindings = this._bindings;

                for (var i = this._targetGroup.nCachedObjects_,
                         n = bindings.length; i !== n; ++i) {

                    bindings[i].setValue(array, offset);

                }

            },

            bind: function () {

                var bindings = this._bindings;

                for (var i = this._targetGroup.nCachedObjects_,
                         n = bindings.length; i !== n; ++i) {

                    bindings[i].bind();

                }

            },

            unbind: function () {

                var bindings = this._bindings;

                for (var i = this._targetGroup.nCachedObjects_,
                         n = bindings.length; i !== n; ++i) {

                    bindings[i].unbind();

                }

            }

        });


        function PropertyBinding(rootNode, path, parsedPath) {

            this.path = path;
            this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);

            this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;

            this.rootNode = rootNode;

        }

        Object.assign(PropertyBinding, {

            Composite: Composite,

            create: function (root, path, parsedPath) {

                if (!(root && root.isAnimationObjectGroup)) {

                    return new PropertyBinding(root, path, parsedPath);

                } else {

                    return new PropertyBinding.Composite(root, path, parsedPath);

                }

            },

            /**
             * Replaces spaces with underscores and removes unsupported characters from
             * node names, to ensure compatibility with parseTrackName().
             *
             * @param  {string} name Node name to be sanitized.
             * @return {string}
             */
            sanitizeNodeName: function (name) {

                return name.replace(/\s/g, '_').replace(/[^\w-]/g, '');

            },

            parseTrackName: function () {

                // Parent directories, delimited by '/' or ':'. Currently unused, but must
                // be matched to parse the rest of the track name.
                var directoryRe = /((?:[\w-]+[\/:])*)/;

                // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
                var nodeRe = /([\w-\.]+)?/;

                // Object on target node, and accessor. Name may contain only word
                // characters. Accessor may contain any character except closing bracket.
                var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;

                // Property and accessor. May contain only word characters. Accessor may
                // contain any non-bracket characters.
                var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;

                var trackRe = new RegExp(''
                    + '^'
                    + directoryRe.source
                    + nodeRe.source
                    + objectRe.source
                    + propertyRe.source
                    + '$'
                );

                var supportedObjectNames = ['material', 'materials', 'bones'];

                return function (trackName) {

                    var matches = trackRe.exec(trackName);

                    if (!matches) {

                        throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);

                    }

                    var results = {
                        // directoryName: matches[ 1 ], // (tschw) currently unused
                        nodeName: matches[2],
                        objectName: matches[3],
                        objectIndex: matches[4],
                        propertyName: matches[5], // required
                        propertyIndex: matches[6]
                    };

                    var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

                    if (lastDot !== undefined && lastDot !== -1) {

                        var objectName = results.nodeName.substring(lastDot + 1);

                        // Object names must be checked against a whitelist. Otherwise, there
                        // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                        // 'bar' could be the objectName, or part of a nodeName (which can
                        // include '.' characters).
                        if (supportedObjectNames.indexOf(objectName) !== -1) {

                            results.nodeName = results.nodeName.substring(0, lastDot);
                            results.objectName = objectName;

                        }

                    }

                    if (results.propertyName === null || results.propertyName.length === 0) {

                        throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);

                    }

                    return results;

                };

            }(),

            findNode: function (root, nodeName) {

                if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {

                    return root;

                }

                // search into skeleton bones.
                if (root.skeleton) {

                    var searchSkeleton = function (skeleton) {

                        for (var i = 0; i < skeleton.bones.length; i++) {

                            var bone = skeleton.bones[i];

                            if (bone.name === nodeName) {

                                return bone;

                            }

                        }

                        return null;

                    };

                    var bone = searchSkeleton(root.skeleton);

                    if (bone) {

                        return bone;

                    }

                }

                // search into node subtree.
                if (root.children) {

                    var searchNodeSubtree = function (children) {

                        for (var i = 0; i < children.length; i++) {

                            var childNode = children[i];

                            if (childNode.name === nodeName || childNode.uuid === nodeName) {

                                return childNode;

                            }

                            var result = searchNodeSubtree(childNode.children);

                            if (result) return result;

                        }

                        return null;

                    };

                    var subTreeNode = searchNodeSubtree(root.children);

                    if (subTreeNode) {

                        return subTreeNode;

                    }

                }

                return null;

            }

        });

        Object.assign(PropertyBinding.prototype, { // prototype, continued

            // these are used to "bind" a nonexistent property
            _getValue_unavailable: function () {
            },
            _setValue_unavailable: function () {
            },

            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },

            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },

            GetterByBindingType: [

                function getValue_direct(buffer, offset) {

                    buffer[offset] = this.node[this.propertyName];

                },

                function getValue_array(buffer, offset) {

                    var source = this.resolvedProperty;

                    for (var i = 0, n = source.length; i !== n; ++i) {

                        buffer[offset++] = source[i];

                    }

                },

                function getValue_arrayElement(buffer, offset) {

                    buffer[offset] = this.resolvedProperty[this.propertyIndex];

                },

                function getValue_toArray(buffer, offset) {

                    this.resolvedProperty.toArray(buffer, offset);

                }

            ],

            SetterByBindingTypeAndVersioning: [

                [
                    // Direct

                    function setValue_direct(buffer, offset) {

                        this.targetObject[this.propertyName] = buffer[offset];

                    },

                    function setValue_direct_setNeedsUpdate(buffer, offset) {

                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.needsUpdate = true;

                    },

                    function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {

                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = true;

                    }

                ], [

                    // EntireArray

                    function setValue_array(buffer, offset) {

                        var dest = this.resolvedProperty;

                        for (var i = 0, n = dest.length; i !== n; ++i) {

                            dest[i] = buffer[offset++];

                        }

                    },

                    function setValue_array_setNeedsUpdate(buffer, offset) {

                        var dest = this.resolvedProperty;

                        for (var i = 0, n = dest.length; i !== n; ++i) {

                            dest[i] = buffer[offset++];

                        }

                        this.targetObject.needsUpdate = true;

                    },

                    function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {

                        var dest = this.resolvedProperty;

                        for (var i = 0, n = dest.length; i !== n; ++i) {

                            dest[i] = buffer[offset++];

                        }

                        this.targetObject.matrixWorldNeedsUpdate = true;

                    }

                ], [

                    // ArrayElement

                    function setValue_arrayElement(buffer, offset) {

                        this.resolvedProperty[this.propertyIndex] = buffer[offset];

                    },

                    function setValue_arrayElement_setNeedsUpdate(buffer, offset) {

                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.needsUpdate = true;

                    },

                    function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {

                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = true;

                    }

                ], [

                    // HasToFromArray

                    function setValue_fromArray(buffer, offset) {

                        this.resolvedProperty.fromArray(buffer, offset);

                    },

                    function setValue_fromArray_setNeedsUpdate(buffer, offset) {

                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.needsUpdate = true;

                    },

                    function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {

                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.matrixWorldNeedsUpdate = true;

                    }

                ]

            ],

            getValue: function getValue_unbound(targetArray, offset) {

                this.bind();
                this.getValue(targetArray, offset);

                // Note: This class uses a State pattern on a per-method basis:
                // 'bind' sets 'this.getValue' / 'setValue' and shadows the
                // prototype version of these methods with one that represents
                // the bound state. When the property is not found, the methods
                // become no-ops.

            },

            setValue: function getValue_unbound(sourceArray, offset) {

                this.bind();
                this.setValue(sourceArray, offset);

            },

            // create getter / setter pair for a property in the scene graph
            bind: function () {

                var targetObject = this.node,
                    parsedPath = this.parsedPath,

                    objectName = parsedPath.objectName,
                    propertyName = parsedPath.propertyName,
                    propertyIndex = parsedPath.propertyIndex;

                if (!targetObject) {

                    targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;

                    this.node = targetObject;

                }

                // set fail state so we can just 'return' on error
                this.getValue = this._getValue_unavailable;
                this.setValue = this._setValue_unavailable;

                // ensure there is a value node
                if (!targetObject) {

                    console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
                    return;

                }

                if (objectName) {

                    var objectIndex = parsedPath.objectIndex;

                    // special cases were we need to reach deeper into the hierarchy to get the face materials....
                    switch (objectName) {

                        case 'materials':

                            if (!targetObject.material) {

                                console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                                return;

                            }

                            if (!targetObject.material.materials) {

                                console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                                return;

                            }

                            targetObject = targetObject.material.materials;

                            break;

                        case 'bones':

                            if (!targetObject.skeleton) {

                                console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                                return;

                            }

                            // potential future optimization: skip this if propertyIndex is already an integer
                            // and convert the integer string to a true integer.

                            targetObject = targetObject.skeleton.bones;

                            // support resolving morphTarget names into indices.
                            for (var i = 0; i < targetObject.length; i++) {

                                if (targetObject[i].name === objectIndex) {

                                    objectIndex = i;
                                    break;

                                }

                            }

                            break;

                        default:

                            if (targetObject[objectName] === undefined) {

                                console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                                return;

                            }

                            targetObject = targetObject[objectName];

                    }


                    if (objectIndex !== undefined) {

                        if (targetObject[objectIndex] === undefined) {

                            console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                            return;

                        }

                        targetObject = targetObject[objectIndex];

                    }

                }

                // resolve property
                var nodeProperty = targetObject[propertyName];

                if (nodeProperty === undefined) {

                    var nodeName = parsedPath.nodeName;

                    console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
                        '.' + propertyName + ' but it wasn\'t found.', targetObject);
                    return;

                }

                // determine versioning scheme
                var versioning = this.Versioning.None;

                if (targetObject.needsUpdate !== undefined) { // material

                    versioning = this.Versioning.NeedsUpdate;
                    this.targetObject = targetObject;

                } else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform

                    versioning = this.Versioning.MatrixWorldNeedsUpdate;
                    this.targetObject = targetObject;

                }

                // determine how the property gets bound
                var bindingType = this.BindingType.Direct;

                if (propertyIndex !== undefined) {

                    // access a sub element of the property array (only primitives are supported right now)

                    if (propertyName === "morphTargetInfluences") {

                        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

                        // support resolving morphTarget names into indices.
                        if (!targetObject.geometry) {

                            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                            return;

                        }

                        if (targetObject.geometry.isBufferGeometry) {

                            if (!targetObject.geometry.morphAttributes) {

                                console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                                return;

                            }

                            for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {

                                if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {

                                    propertyIndex = i;
                                    break;

                                }

                            }


                        } else {

                            if (!targetObject.geometry.morphTargets) {

                                console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);
                                return;

                            }

                            for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {

                                if (targetObject.geometry.morphTargets[i].name === propertyIndex) {

                                    propertyIndex = i;
                                    break;

                                }

                            }

                        }

                    }

                    bindingType = this.BindingType.ArrayElement;

                    this.resolvedProperty = nodeProperty;
                    this.propertyIndex = propertyIndex;

                } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {

                    // must use copy for Object3D.Euler/Quaternion

                    bindingType = this.BindingType.HasFromToArray;

                    this.resolvedProperty = nodeProperty;

                } else if (Array.isArray(nodeProperty)) {

                    bindingType = this.BindingType.EntireArray;

                    this.resolvedProperty = nodeProperty;

                } else {

                    this.propertyName = propertyName;

                }

                // select getter / setter
                this.getValue = this.GetterByBindingType[bindingType];
                this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];

            },

            unbind: function () {

                this.node = null;

                // back to the prototype version of getValue / setValue
                // note: avoiding to mutate the shape of 'this' via 'delete'
                this.getValue = this._getValue_unbound;
                this.setValue = this._setValue_unbound;

            }

        });

        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(PropertyBinding.prototype, {

            // initial state of these methods that calls 'bind'
            _getValue_unbound: PropertyBinding.prototype.getValue,
            _setValue_unbound: PropertyBinding.prototype.setValue,

        });

        /**
         *
         * A group of objects that receives a shared animation state.
         *
         * Usage:
         *
         *    -    Add objects you would otherwise pass as 'root' to the
         *        constructor or the .clipAction method of AnimationMixer.
         *
         *    -    Instead pass this object as 'root'.
         *
         *    -    You can also add and remove objects later when the mixer
         *        is running.
         *
         * Note:
         *
         *    Objects of this class appear as one object to the mixer,
         *    so cache control of the individual objects must be done
         *    on the group.
         *
         * Limitation:
         *
         *    -    The animated properties must be compatible among the
         *        all objects in the group.
         *
         *  -    A single property can either be controlled through a
         *    target group or directly, but not both.
         *
         * @author tschw
         */

        function AnimationObjectGroup() {

            this.uuid = _Math.generateUUID();

            // cached objects followed by the active ones
            this._objects = Array.prototype.slice.call(arguments);

            this.nCachedObjects_ = 0;			// threshold
            // note: read by PropertyBinding.Composite

            var indices = {};
            this._indicesByUUID = indices;		// for bookkeeping

            for (var i = 0, n = arguments.length; i !== n; ++i) {

                indices[arguments[i].uuid] = i;

            }

            this._paths = [];					// inside: string
            this._parsedPaths = [];				// inside: { we don't care, here }
            this._bindings = []; 				// inside: Array< PropertyBinding >
            this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

            var scope = this;

            this.stats = {

                objects: {
                    get total() {

                        return scope._objects.length;

                    },
                    get inUse() {

                        return this.total - scope.nCachedObjects_;

                    }
                },
                get bindingsPerObject() {

                    return scope._bindings.length;

                }

            };

        }

        Object.assign(AnimationObjectGroup.prototype, {

            isAnimationObjectGroup: true,

            add: function () {

                var objects = this._objects,
                    nObjects = objects.length,
                    nCachedObjects = this.nCachedObjects_,
                    indicesByUUID = this._indicesByUUID,
                    paths = this._paths,
                    parsedPaths = this._parsedPaths,
                    bindings = this._bindings,
                    nBindings = bindings.length;

                for (var i = 0, n = arguments.length; i !== n; ++i) {

                    var object = arguments[i],
                        uuid = object.uuid,
                        index = indicesByUUID[uuid],
                        knownObject = undefined;

                    if (index === undefined) {

                        // unknown object -> add it to the ACTIVE region

                        index = nObjects++;
                        indicesByUUID[uuid] = index;
                        objects.push(object);

                        // accounting is done, now do the same for all bindings

                        for (var j = 0, m = nBindings; j !== m; ++j) {

                            bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));

                        }

                    } else if (index < nCachedObjects) {

                        knownObject = objects[index];

                        // move existing object to the ACTIVE region

                        var firstActiveIndex = --nCachedObjects,
                            lastCachedObject = objects[firstActiveIndex];

                        indicesByUUID[lastCachedObject.uuid] = index;
                        objects[index] = lastCachedObject;

                        indicesByUUID[uuid] = firstActiveIndex;
                        objects[firstActiveIndex] = object;

                        // accounting is done, now do the same for all bindings

                        for (var j = 0, m = nBindings; j !== m; ++j) {

                            var bindingsForPath = bindings[j],
                                lastCached = bindingsForPath[firstActiveIndex],
                                binding = bindingsForPath[index];

                            bindingsForPath[index] = lastCached;

                            if (binding === undefined) {

                                // since we do not bother to create new bindings
                                // for objects that are cached, the binding may
                                // or may not exist

                                binding = new PropertyBinding(object, paths[j], parsedPaths[j]);

                            }

                            bindingsForPath[firstActiveIndex] = binding;

                        }

                    } else if (objects[index] !== knownObject) {

                        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +
                            'detected. Clean the caches or recreate your infrastructure when reloading scenes.');

                    } // else the object is already where we want it to be

                } // for arguments

                this.nCachedObjects_ = nCachedObjects;

            },

            remove: function () {

                var objects = this._objects,
                    nCachedObjects = this.nCachedObjects_,
                    indicesByUUID = this._indicesByUUID,
                    bindings = this._bindings,
                    nBindings = bindings.length;

                for (var i = 0, n = arguments.length; i !== n; ++i) {

                    var object = arguments[i],
                        uuid = object.uuid,
                        index = indicesByUUID[uuid];

                    if (index !== undefined && index >= nCachedObjects) {

                        // move existing object into the CACHED region

                        var lastCachedIndex = nCachedObjects++,
                            firstActiveObject = objects[lastCachedIndex];

                        indicesByUUID[firstActiveObject.uuid] = index;
                        objects[index] = firstActiveObject;

                        indicesByUUID[uuid] = lastCachedIndex;
                        objects[lastCachedIndex] = object;

                        // accounting is done, now do the same for all bindings

                        for (var j = 0, m = nBindings; j !== m; ++j) {

                            var bindingsForPath = bindings[j],
                                firstActive = bindingsForPath[lastCachedIndex],
                                binding = bindingsForPath[index];

                            bindingsForPath[index] = firstActive;
                            bindingsForPath[lastCachedIndex] = binding;

                        }

                    }

                } // for arguments

                this.nCachedObjects_ = nCachedObjects;

            },

            // remove & forget
            uncache: function () {

                var objects = this._objects,
                    nObjects = objects.length,
                    nCachedObjects = this.nCachedObjects_,
                    indicesByUUID = this._indicesByUUID,
                    bindings = this._bindings,
                    nBindings = bindings.length;

                for (var i = 0, n = arguments.length; i !== n; ++i) {

                    var object = arguments[i],
                        uuid = object.uuid,
                        index = indicesByUUID[uuid];

                    if (index !== undefined) {

                        delete indicesByUUID[uuid];

                        if (index < nCachedObjects) {

                            // object is cached, shrink the CACHED region

                            var firstActiveIndex = --nCachedObjects,
                                lastCachedObject = objects[firstActiveIndex],
                                lastIndex = --nObjects,
                                lastObject = objects[lastIndex];

                            // last cached object takes this object's place
                            indicesByUUID[lastCachedObject.uuid] = index;
                            objects[index] = lastCachedObject;

                            // last object goes to the activated slot and pop
                            indicesByUUID[lastObject.uuid] = firstActiveIndex;
                            objects[firstActiveIndex] = lastObject;
                            objects.pop();

                            // accounting is done, now do the same for all bindings

                            for (var j = 0, m = nBindings; j !== m; ++j) {

                                var bindingsForPath = bindings[j],
                                    lastCached = bindingsForPath[firstActiveIndex],
                                    last = bindingsForPath[lastIndex];

                                bindingsForPath[index] = lastCached;
                                bindingsForPath[firstActiveIndex] = last;
                                bindingsForPath.pop();

                            }

                        } else {

                            // object is active, just swap with the last and pop

                            var lastIndex = --nObjects,
                                lastObject = objects[lastIndex];

                            indicesByUUID[lastObject.uuid] = index;
                            objects[index] = lastObject;
                            objects.pop();

                            // accounting is done, now do the same for all bindings

                            for (var j = 0, m = nBindings; j !== m; ++j) {

                                var bindingsForPath = bindings[j];

                                bindingsForPath[index] = bindingsForPath[lastIndex];
                                bindingsForPath.pop();

                            }

                        } // cached or active

                    } // if object is known

                } // for arguments

                this.nCachedObjects_ = nCachedObjects;

            },

            // Internal interface used by befriended PropertyBinding.Composite:

            subscribe_: function (path, parsedPath) {

                // returns an array of bindings for the given path that is changed
                // according to the contained objects in the group

                var indicesByPath = this._bindingsIndicesByPath,
                    index = indicesByPath[path],
                    bindings = this._bindings;

                if (index !== undefined) return bindings[index];

                var paths = this._paths,
                    parsedPaths = this._parsedPaths,
                    objects = this._objects,
                    nObjects = objects.length,
                    nCachedObjects = this.nCachedObjects_,
                    bindingsForPath = new Array(nObjects);

                index = bindings.length;

                indicesByPath[path] = index;

                paths.push(path);
                parsedPaths.push(parsedPath);
                bindings.push(bindingsForPath);

                for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {

                    var object = objects[i];
                    bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);

                }

                return bindingsForPath;

            },

            unsubscribe_: function (path) {

                // tells the group to forget about a property path and no longer
                // update the array previously obtained with 'subscribe_'

                var indicesByPath = this._bindingsIndicesByPath,
                    index = indicesByPath[path];

                if (index !== undefined) {

                    var paths = this._paths,
                        parsedPaths = this._parsedPaths,
                        bindings = this._bindings,
                        lastBindingsIndex = bindings.length - 1,
                        lastBindings = bindings[lastBindingsIndex],
                        lastBindingsPath = path[lastBindingsIndex];

                    indicesByPath[lastBindingsPath] = index;

                    bindings[index] = lastBindings;
                    bindings.pop();

                    parsedPaths[index] = parsedPaths[lastBindingsIndex];
                    parsedPaths.pop();

                    paths[index] = paths[lastBindingsIndex];
                    paths.pop();

                }

            }

        });

        /**
         *
         * Action provided by AnimationMixer for scheduling clip playback on specific
         * objects.
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         *
         */

        function AnimationAction(mixer, clip, localRoot) {

            this._mixer = mixer;
            this._clip = clip;
            this._localRoot = localRoot || null;

            var tracks = clip.tracks,
                nTracks = tracks.length,
                interpolants = new Array(nTracks);

            var interpolantSettings = {
                endingStart: ZeroCurvatureEnding,
                endingEnd: ZeroCurvatureEnding
            };

            for (var i = 0; i !== nTracks; ++i) {

                var interpolant = tracks[i].createInterpolant(null);
                interpolants[i] = interpolant;
                interpolant.settings = interpolantSettings;

            }

            this._interpolantSettings = interpolantSettings;

            this._interpolants = interpolants;	// bound by the mixer

            // inside: PropertyMixer (managed by the mixer)
            this._propertyBindings = new Array(nTracks);

            this._cacheIndex = null;			// for the memory manager
            this._byClipCacheIndex = null;		// for the memory manager

            this._timeScaleInterpolant = null;
            this._weightInterpolant = null;

            this.loop = LoopRepeat;
            this._loopCount = -1;

            // global mixer time when the action is to be started
            // it's set back to 'null' upon start of the action
            this._startTime = null;

            // scaled local time of the action
            // gets clamped or wrapped to 0..clip.duration according to loop
            this.time = 0;

            this.timeScale = 1;
            this._effectiveTimeScale = 1;

            this.weight = 1;
            this._effectiveWeight = 1;

            this.repetitions = Infinity; 		// no. of repetitions when looping

            this.paused = false;				// true -> zero effective time scale
            this.enabled = true;				// false -> zero effective weight

            this.clampWhenFinished = false;	// keep feeding the last frame?

            this.zeroSlopeAtStart = true;		// for smooth interpolation w/o separate
            this.zeroSlopeAtEnd = true;		// clips for start, loop and end

        }

        Object.assign(AnimationAction.prototype, {

            // State & Scheduling

            play: function () {

                this._mixer._activateAction(this);

                return this;

            },

            stop: function () {

                this._mixer._deactivateAction(this);

                return this.reset();

            },

            reset: function () {

                this.paused = false;
                this.enabled = true;

                this.time = 0;			// restart clip
                this._loopCount = -1;	// forget previous loops
                this._startTime = null;	// forget scheduling

                return this.stopFading().stopWarping();

            },

            isRunning: function () {

                return this.enabled && !this.paused && this.timeScale !== 0 &&
                    this._startTime === null && this._mixer._isActiveAction(this);

            },

            // return true when play has been called
            isScheduled: function () {

                return this._mixer._isActiveAction(this);

            },

            startAt: function (time) {

                this._startTime = time;

                return this;

            },

            setLoop: function (mode, repetitions) {

                this.loop = mode;
                this.repetitions = repetitions;

                return this;

            },

            // Weight

            // set the weight stopping any scheduled fading
            // although .enabled = false yields an effective weight of zero, this
            // method does *not* change .enabled, because it would be confusing
            setEffectiveWeight: function (weight) {

                this.weight = weight;

                // note: same logic as when updated at runtime
                this._effectiveWeight = this.enabled ? weight : 0;

                return this.stopFading();

            },

            // return the weight considering fading and .enabled
            getEffectiveWeight: function () {

                return this._effectiveWeight;

            },

            fadeIn: function (duration) {

                return this._scheduleFading(duration, 0, 1);

            },

            fadeOut: function (duration) {

                return this._scheduleFading(duration, 1, 0);

            },

            crossFadeFrom: function (fadeOutAction, duration, warp) {

                fadeOutAction.fadeOut(duration);
                this.fadeIn(duration);

                if (warp) {

                    var fadeInDuration = this._clip.duration,
                        fadeOutDuration = fadeOutAction._clip.duration,

                        startEndRatio = fadeOutDuration / fadeInDuration,
                        endStartRatio = fadeInDuration / fadeOutDuration;

                    fadeOutAction.warp(1.0, startEndRatio, duration);
                    this.warp(endStartRatio, 1.0, duration);

                }

                return this;

            },

            crossFadeTo: function (fadeInAction, duration, warp) {

                return fadeInAction.crossFadeFrom(this, duration, warp);

            },

            stopFading: function () {

                var weightInterpolant = this._weightInterpolant;

                if (weightInterpolant !== null) {

                    this._weightInterpolant = null;
                    this._mixer._takeBackControlInterpolant(weightInterpolant);

                }

                return this;

            },

            // Time Scale Control

            // set the time scale stopping any scheduled warping
            // although .paused = true yields an effective time scale of zero, this
            // method does *not* change .paused, because it would be confusing
            setEffectiveTimeScale: function (timeScale) {

                this.timeScale = timeScale;
                this._effectiveTimeScale = this.paused ? 0 : timeScale;

                return this.stopWarping();

            },

            // return the time scale considering warping and .paused
            getEffectiveTimeScale: function () {

                return this._effectiveTimeScale;

            },

            setDuration: function (duration) {

                this.timeScale = this._clip.duration / duration;

                return this.stopWarping();

            },

            syncWith: function (action) {

                this.time = action.time;
                this.timeScale = action.timeScale;

                return this.stopWarping();

            },

            halt: function (duration) {

                return this.warp(this._effectiveTimeScale, 0, duration);

            },

            warp: function (startTimeScale, endTimeScale, duration) {

                var mixer = this._mixer, now = mixer.time,
                    interpolant = this._timeScaleInterpolant,

                    timeScale = this.timeScale;

                if (interpolant === null) {

                    interpolant = mixer._lendControlInterpolant();
                    this._timeScaleInterpolant = interpolant;

                }

                var times = interpolant.parameterPositions,
                    values = interpolant.sampleValues;

                times[0] = now;
                times[1] = now + duration;

                values[0] = startTimeScale / timeScale;
                values[1] = endTimeScale / timeScale;

                return this;

            },

            stopWarping: function () {

                var timeScaleInterpolant = this._timeScaleInterpolant;

                if (timeScaleInterpolant !== null) {

                    this._timeScaleInterpolant = null;
                    this._mixer._takeBackControlInterpolant(timeScaleInterpolant);

                }

                return this;

            },

            // Object Accessors

            getMixer: function () {

                return this._mixer;

            },

            getClip: function () {

                return this._clip;

            },

            getRoot: function () {

                return this._localRoot || this._mixer._root;

            },

            // Interna

            _update: function (time, deltaTime, timeDirection, accuIndex) {

                // called by the mixer

                if (!this.enabled) {

                    // call ._updateWeight() to update ._effectiveWeight

                    this._updateWeight(time);
                    return;

                }

                var startTime = this._startTime;

                if (startTime !== null) {

                    // check for scheduled start of action

                    var timeRunning = (time - startTime) * timeDirection;
                    if (timeRunning < 0 || timeDirection === 0) {

                        return; // yet to come / don't decide when delta = 0

                    }

                    // start

                    this._startTime = null; // unschedule
                    deltaTime = timeDirection * timeRunning;

                }

                // apply time scale and advance time

                deltaTime *= this._updateTimeScale(time);
                var clipTime = this._updateTime(deltaTime);

                // note: _updateTime may disable the action resulting in
                // an effective weight of 0

                var weight = this._updateWeight(time);

                if (weight > 0) {

                    var interpolants = this._interpolants;
                    var propertyMixers = this._propertyBindings;

                    for (var j = 0, m = interpolants.length; j !== m; ++j) {

                        interpolants[j].evaluate(clipTime);
                        propertyMixers[j].accumulate(accuIndex, weight);

                    }

                }

            },

            _updateWeight: function (time) {

                var weight = 0;

                if (this.enabled) {

                    weight = this.weight;
                    var interpolant = this._weightInterpolant;

                    if (interpolant !== null) {

                        var interpolantValue = interpolant.evaluate(time)[0];

                        weight *= interpolantValue;

                        if (time > interpolant.parameterPositions[1]) {

                            this.stopFading();

                            if (interpolantValue === 0) {

                                // faded out, disable
                                this.enabled = false;

                            }

                        }

                    }

                }

                this._effectiveWeight = weight;
                return weight;

            },

            _updateTimeScale: function (time) {

                var timeScale = 0;

                if (!this.paused) {

                    timeScale = this.timeScale;

                    var interpolant = this._timeScaleInterpolant;

                    if (interpolant !== null) {

                        var interpolantValue = interpolant.evaluate(time)[0];

                        timeScale *= interpolantValue;

                        if (time > interpolant.parameterPositions[1]) {

                            this.stopWarping();

                            if (timeScale === 0) {

                                // motion has halted, pause
                                this.paused = true;

                            } else {

                                // warp done - apply final time scale
                                this.timeScale = timeScale;

                            }

                        }

                    }

                }

                this._effectiveTimeScale = timeScale;
                return timeScale;

            },

            _updateTime: function (deltaTime) {

                var time = this.time + deltaTime;

                if (deltaTime === 0) return time;

                var duration = this._clip.duration,

                    loop = this.loop,
                    loopCount = this._loopCount;

                if (loop === LoopOnce) {

                    if (loopCount === -1) {

                        // just started

                        this._loopCount = 0;
                        this._setEndings(true, true, false);

                    }

                    handle_stop: {

                        if (time >= duration) {

                            time = duration;

                        } else if (time < 0) {

                            time = 0;

                        } else break handle_stop;

                        if (this.clampWhenFinished) this.paused = true;
                        else this.enabled = false;

                        this._mixer.dispatchEvent({
                            type: 'finished', action: this,
                            direction: deltaTime < 0 ? -1 : 1
                        });

                    }

                } else { // repetitive Repeat or PingPong

                    var pingPong = (loop === LoopPingPong);

                    if (loopCount === -1) {

                        // just started

                        if (deltaTime >= 0) {

                            loopCount = 0;

                            this._setEndings(true, this.repetitions === 0, pingPong);

                        } else {

                            // when looping in reverse direction, the initial
                            // transition through zero counts as a repetition,
                            // so leave loopCount at -1

                            this._setEndings(this.repetitions === 0, true, pingPong);

                        }

                    }

                    if (time >= duration || time < 0) {

                        // wrap around

                        var loopDelta = Math.floor(time / duration); // signed
                        time -= duration * loopDelta;

                        loopCount += Math.abs(loopDelta);

                        var pending = this.repetitions - loopCount;

                        if (pending < 0) {

                            // have to stop (switch state, clamp time, fire event)

                            if (this.clampWhenFinished) this.paused = true;
                            else this.enabled = false;

                            time = deltaTime > 0 ? duration : 0;

                            this._mixer.dispatchEvent({
                                type: 'finished', action: this,
                                direction: deltaTime > 0 ? 1 : -1
                            });

                        } else {

                            // keep running

                            if (pending === 0) {

                                // entering the last round

                                var atStart = deltaTime < 0;
                                this._setEndings(atStart, !atStart, pingPong);

                            } else {

                                this._setEndings(false, false, pingPong);

                            }

                            this._loopCount = loopCount;

                            this._mixer.dispatchEvent({
                                type: 'loop', action: this, loopDelta: loopDelta
                            });

                        }

                    }

                    if (pingPong && (loopCount & 1) === 1) {

                        // invert time for the "pong round"

                        this.time = time;
                        return duration - time;

                    }

                }

                this.time = time;
                return time;

            },

            _setEndings: function (atStart, atEnd, pingPong) {

                var settings = this._interpolantSettings;

                if (pingPong) {

                    settings.endingStart = ZeroSlopeEnding;
                    settings.endingEnd = ZeroSlopeEnding;

                } else {

                    // assuming for LoopOnce atStart == atEnd == true

                    if (atStart) {

                        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

                    } else {

                        settings.endingStart = WrapAroundEnding;

                    }

                    if (atEnd) {

                        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

                    } else {

                        settings.endingEnd = WrapAroundEnding;

                    }

                }

            },

            _scheduleFading: function (duration, weightNow, weightThen) {

                var mixer = this._mixer, now = mixer.time,
                    interpolant = this._weightInterpolant;

                if (interpolant === null) {

                    interpolant = mixer._lendControlInterpolant();
                    this._weightInterpolant = interpolant;

                }

                var times = interpolant.parameterPositions,
                    values = interpolant.sampleValues;

                times[0] = now;
                values[0] = weightNow;
                times[1] = now + duration;
                values[1] = weightThen;

                return this;

            }

        });

        /**
         *
         * Player for AnimationClips.
         *
         *
         * @author Ben Houston / http://clara.io/
         * @author David Sarno / http://lighthaus.us/
         * @author tschw
         */

        function AnimationMixer(root) {

            this._root = root;
            this._initMemoryManager();
            this._accuIndex = 0;

            this.time = 0;

            this.timeScale = 1.0;

        }

        Object.assign(AnimationMixer.prototype, EventDispatcher.prototype, {

            _bindAction: function (action, prototypeAction) {

                var root = action._localRoot || this._root,
                    tracks = action._clip.tracks,
                    nTracks = tracks.length,
                    bindings = action._propertyBindings,
                    interpolants = action._interpolants,
                    rootUuid = root.uuid,
                    bindingsByRoot = this._bindingsByRootAndName,
                    bindingsByName = bindingsByRoot[rootUuid];

                if (bindingsByName === undefined) {

                    bindingsByName = {};
                    bindingsByRoot[rootUuid] = bindingsByName;

                }

                for (var i = 0; i !== nTracks; ++i) {

                    var track = tracks[i],
                        trackName = track.name,
                        binding = bindingsByName[trackName];

                    if (binding !== undefined) {

                        bindings[i] = binding;

                    } else {

                        binding = bindings[i];

                        if (binding !== undefined) {

                            // existing binding, make sure the cache knows

                            if (binding._cacheIndex === null) {

                                ++binding.referenceCount;
                                this._addInactiveBinding(binding, rootUuid, trackName);

                            }

                            continue;

                        }

                        var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;

                        binding = new PropertyMixer(
                            PropertyBinding.create(root, trackName, path),
                            track.ValueTypeName, track.getValueSize());

                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);

                        bindings[i] = binding;

                    }

                    interpolants[i].resultBuffer = binding.buffer;

                }

            },

            _activateAction: function (action) {

                if (!this._isActiveAction(action)) {

                    if (action._cacheIndex === null) {

                        // this action has been forgotten by the cache, but the user
                        // appears to be still using it -> rebind

                        var rootUuid = (action._localRoot || this._root).uuid,
                            clipUuid = action._clip.uuid,
                            actionsForClip = this._actionsByClip[clipUuid];

                        this._bindAction(action,
                            actionsForClip && actionsForClip.knownActions[0]);

                        this._addInactiveAction(action, clipUuid, rootUuid);

                    }

                    var bindings = action._propertyBindings;

                    // increment reference counts / sort out state
                    for (var i = 0, n = bindings.length; i !== n; ++i) {

                        var binding = bindings[i];

                        if (binding.useCount++ === 0) {

                            this._lendBinding(binding);
                            binding.saveOriginalState();

                        }

                    }

                    this._lendAction(action);

                }

            },

            _deactivateAction: function (action) {

                if (this._isActiveAction(action)) {

                    var bindings = action._propertyBindings;

                    // decrement reference counts / sort out state
                    for (var i = 0, n = bindings.length; i !== n; ++i) {

                        var binding = bindings[i];

                        if (--binding.useCount === 0) {

                            binding.restoreOriginalState();
                            this._takeBackBinding(binding);

                        }

                    }

                    this._takeBackAction(action);

                }

            },

            // Memory manager

            _initMemoryManager: function () {

                this._actions = []; // 'nActiveActions' followed by inactive ones
                this._nActiveActions = 0;

                this._actionsByClip = {};
                // inside:
                // {
                // 		knownActions: Array< AnimationAction >	- used as prototypes
                // 		actionByRoot: AnimationAction			- lookup
                // }


                this._bindings = []; // 'nActiveBindings' followed by inactive ones
                this._nActiveBindings = 0;

                this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


                this._controlInterpolants = []; // same game as above
                this._nActiveControlInterpolants = 0;

                var scope = this;

                this.stats = {

                    actions: {
                        get total() {

                            return scope._actions.length;

                        },
                        get inUse() {

                            return scope._nActiveActions;

                        }
                    },
                    bindings: {
                        get total() {

                            return scope._bindings.length;

                        },
                        get inUse() {

                            return scope._nActiveBindings;

                        }
                    },
                    controlInterpolants: {
                        get total() {

                            return scope._controlInterpolants.length;

                        },
                        get inUse() {

                            return scope._nActiveControlInterpolants;

                        }
                    }

                };

            },

            // Memory management for AnimationAction objects

            _isActiveAction: function (action) {

                var index = action._cacheIndex;
                return index !== null && index < this._nActiveActions;

            },

            _addInactiveAction: function (action, clipUuid, rootUuid) {

                var actions = this._actions,
                    actionsByClip = this._actionsByClip,
                    actionsForClip = actionsByClip[clipUuid];

                if (actionsForClip === undefined) {

                    actionsForClip = {

                        knownActions: [action],
                        actionByRoot: {}

                    };

                    action._byClipCacheIndex = 0;

                    actionsByClip[clipUuid] = actionsForClip;

                } else {

                    var knownActions = actionsForClip.knownActions;

                    action._byClipCacheIndex = knownActions.length;
                    knownActions.push(action);

                }

                action._cacheIndex = actions.length;
                actions.push(action);

                actionsForClip.actionByRoot[rootUuid] = action;

            },

            _removeInactiveAction: function (action) {

                var actions = this._actions,
                    lastInactiveAction = actions[actions.length - 1],
                    cacheIndex = action._cacheIndex;

                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();

                action._cacheIndex = null;


                var clipUuid = action._clip.uuid,
                    actionsByClip = this._actionsByClip,
                    actionsForClip = actionsByClip[clipUuid],
                    knownActionsForClip = actionsForClip.knownActions,

                    lastKnownAction =
                        knownActionsForClip[knownActionsForClip.length - 1],

                    byClipCacheIndex = action._byClipCacheIndex;

                lastKnownAction._byClipCacheIndex = byClipCacheIndex;
                knownActionsForClip[byClipCacheIndex] = lastKnownAction;
                knownActionsForClip.pop();

                action._byClipCacheIndex = null;


                var actionByRoot = actionsForClip.actionByRoot,
                    rootUuid = (action._localRoot || this._root).uuid;

                delete actionByRoot[rootUuid];

                if (knownActionsForClip.length === 0) {

                    delete actionsByClip[clipUuid];

                }

                this._removeInactiveBindingsForAction(action);

            },

            _removeInactiveBindingsForAction: function (action) {

                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {

                    var binding = bindings[i];

                    if (--binding.referenceCount === 0) {

                        this._removeInactiveBinding(binding);

                    }

                }

            },

            _lendAction: function (action) {

                // [ active actions |  inactive actions  ]
                // [  active actions >| inactive actions ]
                //                 s        a
                //                  <-swap->
                //                 a        s

                var actions = this._actions,
                    prevIndex = action._cacheIndex,

                    lastActiveIndex = this._nActiveActions++,

                    firstInactiveAction = actions[lastActiveIndex];

                action._cacheIndex = lastActiveIndex;
                actions[lastActiveIndex] = action;

                firstInactiveAction._cacheIndex = prevIndex;
                actions[prevIndex] = firstInactiveAction;

            },

            _takeBackAction: function (action) {

                // [  active actions  | inactive actions ]
                // [ active actions |< inactive actions  ]
                //        a        s
                //         <-swap->
                //        s        a

                var actions = this._actions,
                    prevIndex = action._cacheIndex,

                    firstInactiveIndex = --this._nActiveActions,

                    lastActiveAction = actions[firstInactiveIndex];

                action._cacheIndex = firstInactiveIndex;
                actions[firstInactiveIndex] = action;

                lastActiveAction._cacheIndex = prevIndex;
                actions[prevIndex] = lastActiveAction;

            },

            // Memory management for PropertyMixer objects

            _addInactiveBinding: function (binding, rootUuid, trackName) {

                var bindingsByRoot = this._bindingsByRootAndName,
                    bindingByName = bindingsByRoot[rootUuid],

                    bindings = this._bindings;

                if (bindingByName === undefined) {

                    bindingByName = {};
                    bindingsByRoot[rootUuid] = bindingByName;

                }

                bindingByName[trackName] = binding;

                binding._cacheIndex = bindings.length;
                bindings.push(binding);

            },

            _removeInactiveBinding: function (binding) {

                var bindings = this._bindings,
                    propBinding = binding.binding,
                    rootUuid = propBinding.rootNode.uuid,
                    trackName = propBinding.path,
                    bindingsByRoot = this._bindingsByRootAndName,
                    bindingByName = bindingsByRoot[rootUuid],

                    lastInactiveBinding = bindings[bindings.length - 1],
                    cacheIndex = binding._cacheIndex;

                lastInactiveBinding._cacheIndex = cacheIndex;
                bindings[cacheIndex] = lastInactiveBinding;
                bindings.pop();

                delete bindingByName[trackName];

                remove_empty_map: {

                    for (var _ in bindingByName) break remove_empty_map; // eslint-disable-line no-unused-vars

                    delete bindingsByRoot[rootUuid];

                }

            },

            _lendBinding: function (binding) {

                var bindings = this._bindings,
                    prevIndex = binding._cacheIndex,

                    lastActiveIndex = this._nActiveBindings++,

                    firstInactiveBinding = bindings[lastActiveIndex];

                binding._cacheIndex = lastActiveIndex;
                bindings[lastActiveIndex] = binding;

                firstInactiveBinding._cacheIndex = prevIndex;
                bindings[prevIndex] = firstInactiveBinding;

            },

            _takeBackBinding: function (binding) {

                var bindings = this._bindings,
                    prevIndex = binding._cacheIndex,

                    firstInactiveIndex = --this._nActiveBindings,

                    lastActiveBinding = bindings[firstInactiveIndex];

                binding._cacheIndex = firstInactiveIndex;
                bindings[firstInactiveIndex] = binding;

                lastActiveBinding._cacheIndex = prevIndex;
                bindings[prevIndex] = lastActiveBinding;

            },


            // Memory management of Interpolants for weight and time scale

            _lendControlInterpolant: function () {

                var interpolants = this._controlInterpolants,
                    lastActiveIndex = this._nActiveControlInterpolants++,
                    interpolant = interpolants[lastActiveIndex];

                if (interpolant === undefined) {

                    interpolant = new LinearInterpolant(
                        new Float32Array(2), new Float32Array(2),
                        1, this._controlInterpolantsResultBuffer);

                    interpolant.__cacheIndex = lastActiveIndex;
                    interpolants[lastActiveIndex] = interpolant;

                }

                return interpolant;

            },

            _takeBackControlInterpolant: function (interpolant) {

                var interpolants = this._controlInterpolants,
                    prevIndex = interpolant.__cacheIndex,

                    firstInactiveIndex = --this._nActiveControlInterpolants,

                    lastActiveInterpolant = interpolants[firstInactiveIndex];

                interpolant.__cacheIndex = firstInactiveIndex;
                interpolants[firstInactiveIndex] = interpolant;

                lastActiveInterpolant.__cacheIndex = prevIndex;
                interpolants[prevIndex] = lastActiveInterpolant;

            },

            _controlInterpolantsResultBuffer: new Float32Array(1),

            // return an action for a clip optionally using a custom root target
            // object (this method allocates a lot of dynamic memory in case a
            // previously unknown clip/root combination is specified)
            clipAction: function (clip, optionalRoot) {

                var root = optionalRoot || this._root,
                    rootUuid = root.uuid,

                    clipObject = typeof clip === 'string' ?
                        AnimationClip.findByName(root, clip) : clip,

                    clipUuid = clipObject !== null ? clipObject.uuid : clip,

                    actionsForClip = this._actionsByClip[clipUuid],
                    prototypeAction = null;

                if (actionsForClip !== undefined) {

                    var existingAction =
                        actionsForClip.actionByRoot[rootUuid];

                    if (existingAction !== undefined) {

                        return existingAction;

                    }

                    // we know the clip, so we don't have to parse all
                    // the bindings again but can just copy
                    prototypeAction = actionsForClip.knownActions[0];

                    // also, take the clip from the prototype action
                    if (clipObject === null)
                        clipObject = prototypeAction._clip;

                }

                // clip must be known when specified via string
                if (clipObject === null) return null;

                // allocate all resources required to run it
                var newAction = new AnimationAction(this, clipObject, optionalRoot);

                this._bindAction(newAction, prototypeAction);

                // and make the action known to the memory manager
                this._addInactiveAction(newAction, clipUuid, rootUuid);

                return newAction;

            },

            // get an existing action
            existingAction: function (clip, optionalRoot) {

                var root = optionalRoot || this._root,
                    rootUuid = root.uuid,

                    clipObject = typeof clip === 'string' ?
                        AnimationClip.findByName(root, clip) : clip,

                    clipUuid = clipObject ? clipObject.uuid : clip,

                    actionsForClip = this._actionsByClip[clipUuid];

                if (actionsForClip !== undefined) {

                    return actionsForClip.actionByRoot[rootUuid] || null;

                }

                return null;

            },

            // deactivates all previously scheduled actions
            stopAllAction: function () {

                var actions = this._actions,
                    nActions = this._nActiveActions,
                    bindings = this._bindings,
                    nBindings = this._nActiveBindings;

                this._nActiveActions = 0;
                this._nActiveBindings = 0;

                for (var i = 0; i !== nActions; ++i) {

                    actions[i].reset();

                }

                for (var i = 0; i !== nBindings; ++i) {

                    bindings[i].useCount = 0;

                }

                return this;

            },

            // advance the time and update apply the animation
            update: function (deltaTime) {

                deltaTime *= this.timeScale;

                var actions = this._actions,
                    nActions = this._nActiveActions,

                    time = this.time += deltaTime,
                    timeDirection = Math.sign(deltaTime),

                    accuIndex = this._accuIndex ^= 1;

                // run active actions

                for (var i = 0; i !== nActions; ++i) {

                    var action = actions[i];

                    action._update(time, deltaTime, timeDirection, accuIndex);

                }

                // update scene graph

                var bindings = this._bindings,
                    nBindings = this._nActiveBindings;

                for (var i = 0; i !== nBindings; ++i) {

                    bindings[i].apply(accuIndex);

                }

                return this;

            },

            // return this mixer's root target object
            getRoot: function () {

                return this._root;

            },

            // free all resources specific to a particular clip
            uncacheClip: function (clip) {

                var actions = this._actions,
                    clipUuid = clip.uuid,
                    actionsByClip = this._actionsByClip,
                    actionsForClip = actionsByClip[clipUuid];

                if (actionsForClip !== undefined) {

                    // note: just calling _removeInactiveAction would mess up the
                    // iteration state and also require updating the state we can
                    // just throw away

                    var actionsToRemove = actionsForClip.knownActions;

                    for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {

                        var action = actionsToRemove[i];

                        this._deactivateAction(action);

                        var cacheIndex = action._cacheIndex,
                            lastInactiveAction = actions[actions.length - 1];

                        action._cacheIndex = null;
                        action._byClipCacheIndex = null;

                        lastInactiveAction._cacheIndex = cacheIndex;
                        actions[cacheIndex] = lastInactiveAction;
                        actions.pop();

                        this._removeInactiveBindingsForAction(action);

                    }

                    delete actionsByClip[clipUuid];

                }

            },

            // free all resources specific to a particular root target object
            uncacheRoot: function (root) {

                var rootUuid = root.uuid,
                    actionsByClip = this._actionsByClip;

                for (var clipUuid in actionsByClip) {

                    var actionByRoot = actionsByClip[clipUuid].actionByRoot,
                        action = actionByRoot[rootUuid];

                    if (action !== undefined) {

                        this._deactivateAction(action);
                        this._removeInactiveAction(action);

                    }

                }

                var bindingsByRoot = this._bindingsByRootAndName,
                    bindingByName = bindingsByRoot[rootUuid];

                if (bindingByName !== undefined) {

                    for (var trackName in bindingByName) {

                        var binding = bindingByName[trackName];
                        binding.restoreOriginalState();
                        this._removeInactiveBinding(binding);

                    }

                }

            },

            // remove a targeted clip from the cache
            uncacheAction: function (clip, optionalRoot) {

                var action = this.existingAction(clip, optionalRoot);

                if (action !== null) {

                    this._deactivateAction(action);
                    this._removeInactiveAction(action);

                }

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function Uniform(value) {

            if (typeof value === 'string') {

                console.warn('THREE.Uniform: Type parameter is no longer needed.');
                value = arguments[1];

            }

            this.value = value;

        }

        Uniform.prototype.clone = function () {

            return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());

        };

        /**
         * @author benaadams / https://twitter.com/ben_a_adams
         */

        function InstancedBufferGeometry() {

            BufferGeometry.call(this);

            this.type = 'InstancedBufferGeometry';
            this.maxInstancedCount = undefined;

        }

        InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {

            constructor: InstancedBufferGeometry,

            isInstancedBufferGeometry: true,

            copy: function (source) {

                BufferGeometry.prototype.copy.call(this, source);

                this.maxInstancedCount = source.maxInstancedCount;

                return this;

            },

            clone: function () {

                return new this.constructor().copy(this);

            }

        });

        /**
         * @author benaadams / https://twitter.com/ben_a_adams
         */

        function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {

            this.uuid = _Math.generateUUID();

            this.data = interleavedBuffer;
            this.itemSize = itemSize;
            this.offset = offset;

            this.normalized = normalized === true;

        }

        Object.defineProperties(InterleavedBufferAttribute.prototype, {

            count: {

                get: function () {

                    return this.data.count;

                }

            },

            array: {

                get: function () {

                    return this.data.array;

                }

            }

        });

        Object.assign(InterleavedBufferAttribute.prototype, {

            isInterleavedBufferAttribute: true,

            setX: function (index, x) {

                this.data.array[index * this.data.stride + this.offset] = x;

                return this;

            },

            setY: function (index, y) {

                this.data.array[index * this.data.stride + this.offset + 1] = y;

                return this;

            },

            setZ: function (index, z) {

                this.data.array[index * this.data.stride + this.offset + 2] = z;

                return this;

            },

            setW: function (index, w) {

                this.data.array[index * this.data.stride + this.offset + 3] = w;

                return this;

            },

            getX: function (index) {

                return this.data.array[index * this.data.stride + this.offset];

            },

            getY: function (index) {

                return this.data.array[index * this.data.stride + this.offset + 1];

            },

            getZ: function (index) {

                return this.data.array[index * this.data.stride + this.offset + 2];

            },

            getW: function (index) {

                return this.data.array[index * this.data.stride + this.offset + 3];

            },

            setXY: function (index, x, y) {

                index = index * this.data.stride + this.offset;

                this.data.array[index + 0] = x;
                this.data.array[index + 1] = y;

                return this;

            },

            setXYZ: function (index, x, y, z) {

                index = index * this.data.stride + this.offset;

                this.data.array[index + 0] = x;
                this.data.array[index + 1] = y;
                this.data.array[index + 2] = z;

                return this;

            },

            setXYZW: function (index, x, y, z, w) {

                index = index * this.data.stride + this.offset;

                this.data.array[index + 0] = x;
                this.data.array[index + 1] = y;
                this.data.array[index + 2] = z;
                this.data.array[index + 3] = w;

                return this;

            }

        });

        /**
         * @author benaadams / https://twitter.com/ben_a_adams
         */

        function InterleavedBuffer(array, stride) {

            this.uuid = _Math.generateUUID();

            this.array = array;
            this.stride = stride;
            this.count = array !== undefined ? array.length / stride : 0;

            this.dynamic = false;
            this.updateRange = {offset: 0, count: -1};

            this.onUploadCallback = function () {
            };

            this.version = 0;

        }

        Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {

            set: function (value) {

                if (value === true) this.version++;

            }

        });

        Object.assign(InterleavedBuffer.prototype, {

            isInterleavedBuffer: true,

            setArray: function (array) {

                if (Array.isArray(array)) {

                    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');

                }

                this.count = array !== undefined ? array.length / this.stride : 0;
                this.array = array;

            },

            setDynamic: function (value) {

                this.dynamic = value;

                return this;

            },

            copy: function (source) {

                this.array = new source.array.constructor(source.array);
                this.count = source.count;
                this.stride = source.stride;
                this.dynamic = source.dynamic;

                return this;

            },

            copyAt: function (index1, attribute, index2) {

                index1 *= this.stride;
                index2 *= attribute.stride;

                for (var i = 0, l = this.stride; i < l; i++) {

                    this.array[index1 + i] = attribute.array[index2 + i];

                }

                return this;

            },

            set: function (value, offset) {

                if (offset === undefined) offset = 0;

                this.array.set(value, offset);

                return this;

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            onUpload: function (callback) {

                this.onUploadCallback = callback;

                return this;

            }

        });

        /**
         * @author benaadams / https://twitter.com/ben_a_adams
         */

        function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {

            InterleavedBuffer.call(this, array, stride);

            this.meshPerAttribute = meshPerAttribute || 1;

        }

        InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {

            constructor: InstancedInterleavedBuffer,

            isInstancedInterleavedBuffer: true,

            copy: function (source) {

                InterleavedBuffer.prototype.copy.call(this, source);

                this.meshPerAttribute = source.meshPerAttribute;

                return this;

            }

        });

        /**
         * @author benaadams / https://twitter.com/ben_a_adams
         */

        function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {

            BufferAttribute.call(this, array, itemSize);

            this.meshPerAttribute = meshPerAttribute || 1;

        }

        InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {

            constructor: InstancedBufferAttribute,

            isInstancedBufferAttribute: true,

            copy: function (source) {

                BufferAttribute.prototype.copy.call(this, source);

                this.meshPerAttribute = source.meshPerAttribute;

                return this;

            }

        });

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author bhouston / http://clara.io/
         * @author stephomi / http://stephaneginier.com/
         */

        function Raycaster(origin, direction, near, far) {

            this.ray = new Ray(origin, direction);
            // direction is assumed to be normalized (for accurate distance calculations)

            this.near = near || 0;
            this.far = far || Infinity;

            this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {threshold: 1},
                Sprite: {}
            };

            Object.defineProperties(this.params, {
                PointCloud: {
                    get: function () {

                        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                        return this.Points;

                    }
                }
            });

        }

        function ascSort(a, b) {

            return a.distance - b.distance;

        }

        function intersectObject(object, raycaster, intersects, recursive) {

            if (object.visible === false) return;

            object.raycast(raycaster, intersects);

            if (recursive === true) {

                var children = object.children;

                for (var i = 0, l = children.length; i < l; i++) {

                    intersectObject(children[i], raycaster, intersects, true);

                }

            }

        }

        Object.assign(Raycaster.prototype, {

            linePrecision: 1,

            set: function (origin, direction) {

                // direction is assumed to be normalized (for accurate distance calculations)

                this.ray.set(origin, direction);

            },

            setFromCamera: function (coords, camera) {

                if ((camera && camera.isPerspectiveCamera)) {

                    this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                    this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();

                } else if ((camera && camera.isOrthographicCamera)) {

                    this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
                    this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);

                } else {

                    console.error('THREE.Raycaster: Unsupported camera type.');

                }

            },

            intersectObject: function (object, recursive) {

                var intersects = [];

                intersectObject(object, this, intersects, recursive);

                intersects.sort(ascSort);

                return intersects;

            },

            intersectObjects: function (objects, recursive) {

                var intersects = [];

                if (Array.isArray(objects) === false) {

                    console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                    return intersects;

                }

                for (var i = 0, l = objects.length; i < l; i++) {

                    intersectObject(objects[i], this, intersects, recursive);

                }

                intersects.sort(ascSort);

                return intersects;

            }

        });

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function Clock(autoStart) {

            this.autoStart = (autoStart !== undefined) ? autoStart : true;

            this.startTime = 0;
            this.oldTime = 0;
            this.elapsedTime = 0;

            this.running = false;

        }

        Object.assign(Clock.prototype, {

            start: function () {

                this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

                this.oldTime = this.startTime;
                this.elapsedTime = 0;
                this.running = true;

            },

            stop: function () {

                this.getElapsedTime();
                this.running = false;
                this.autoStart = false;

            },

            getElapsedTime: function () {

                this.getDelta();
                return this.elapsedTime;

            },

            getDelta: function () {

                var diff = 0;

                if (this.autoStart && !this.running) {

                    this.start();
                    return 0;

                }

                if (this.running) {

                    var newTime = (typeof performance === 'undefined' ? Date : performance).now();

                    diff = (newTime - this.oldTime) / 1000;
                    this.oldTime = newTime;

                    this.elapsedTime += diff;

                }

                return diff;

            }

        });

        /**
         * @author bhouston / http://clara.io
         * @author WestLangley / http://github.com/WestLangley
         *
         * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
         *
         * The poles (phi) are at the positive and negative y axis.
         * The equator starts at positive z.
         */

        function Spherical(radius, phi, theta) {

            this.radius = (radius !== undefined) ? radius : 1.0;
            this.phi = (phi !== undefined) ? phi : 0; // up / down towards top and bottom pole
            this.theta = (theta !== undefined) ? theta : 0; // around the equator of the sphere

            return this;

        }

        Object.assign(Spherical.prototype, {

            set: function (radius, phi, theta) {

                this.radius = radius;
                this.phi = phi;
                this.theta = theta;

                return this;

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (other) {

                this.radius = other.radius;
                this.phi = other.phi;
                this.theta = other.theta;

                return this;

            },

            // restrict phi to be betwee EPS and PI-EPS
            makeSafe: function () {

                var EPS = 0.000001;
                this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));

                return this;

            },

            setFromVector3: function (vec3) {

                this.radius = vec3.length();

                if (this.radius === 0) {

                    this.theta = 0;
                    this.phi = 0;

                } else {

                    this.theta = Math.atan2(vec3.x, vec3.z); // equator angle around y-up axis
                    this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1)); // polar angle

                }

                return this;

            }

        });

        /**
         * @author Mugen87 / https://github.com/Mugen87
         *
         * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
         *
         */

        function Cylindrical(radius, theta, y) {

            this.radius = (radius !== undefined) ? radius : 1.0; // distance from the origin to a point in the x-z plane
            this.theta = (theta !== undefined) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
            this.y = (y !== undefined) ? y : 0; // height above the x-z plane

            return this;

        }

        Object.assign(Cylindrical.prototype, {

            set: function (radius, theta, y) {

                this.radius = radius;
                this.theta = theta;
                this.y = y;

                return this;

            },

            clone: function () {

                return new this.constructor().copy(this);

            },

            copy: function (other) {

                this.radius = other.radius;
                this.theta = other.theta;
                this.y = other.y;

                return this;

            },

            setFromVector3: function (vec3) {

                this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
                this.theta = Math.atan2(vec3.x, vec3.z);
                this.y = vec3.y;

                return this;

            }

        });

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        function ImmediateRenderObject(material) {

            Object3D.call(this);

            this.material = material;
            this.render = function (/* renderCallback */) {
            };

        }

        ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
        ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

        ImmediateRenderObject.prototype.isImmediateRenderObject = true;

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author WestLangley / http://github.com/WestLangley
         */

        function VertexNormalsHelper(object, size, hex, linewidth) {

            this.object = object;

            this.size = (size !== undefined) ? size : 1;

            var color = (hex !== undefined) ? hex : 0xff0000;

            var width = (linewidth !== undefined) ? linewidth : 1;

            //

            var nNormals = 0;

            var objGeometry = this.object.geometry;

            if (objGeometry && objGeometry.isGeometry) {

                nNormals = objGeometry.faces.length * 3;

            } else if (objGeometry && objGeometry.isBufferGeometry) {

                nNormals = objGeometry.attributes.normal.count;

            }

            //

            var geometry = new BufferGeometry();

            var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);

            geometry.addAttribute('position', positions);

            LineSegments.call(this, geometry, new LineBasicMaterial({color: color, linewidth: width}));

            //

            this.matrixAutoUpdate = false;

            this.update();

        }

        VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
        VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

        VertexNormalsHelper.prototype.update = (function () {

            var v1 = new Vector3();
            var v2 = new Vector3();
            var normalMatrix = new Matrix3();

            return function update() {

                var keys = ['a', 'b', 'c'];

                this.object.updateMatrixWorld(true);

                normalMatrix.getNormalMatrix(this.object.matrixWorld);

                var matrixWorld = this.object.matrixWorld;

                var position = this.geometry.attributes.position;

                //

                var objGeometry = this.object.geometry;

                if (objGeometry && objGeometry.isGeometry) {

                    var vertices = objGeometry.vertices;

                    var faces = objGeometry.faces;

                    var idx = 0;

                    for (var i = 0, l = faces.length; i < l; i++) {

                        var face = faces[i];

                        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {

                            var vertex = vertices[face[keys[j]]];

                            var normal = face.vertexNormals[j];

                            v1.copy(vertex).applyMatrix4(matrixWorld);

                            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

                            position.setXYZ(idx, v1.x, v1.y, v1.z);

                            idx = idx + 1;

                            position.setXYZ(idx, v2.x, v2.y, v2.z);

                            idx = idx + 1;

                        }

                    }

                } else if (objGeometry && objGeometry.isBufferGeometry) {

                    var objPos = objGeometry.attributes.position;

                    var objNorm = objGeometry.attributes.normal;

                    var idx = 0;

                    // for simplicity, ignore index and drawcalls, and render every normal

                    for (var j = 0, jl = objPos.count; j < jl; j++) {

                        v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);

                        v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));

                        v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

                        position.setXYZ(idx, v1.x, v1.y, v1.z);

                        idx = idx + 1;

                        position.setXYZ(idx, v2.x, v2.y, v2.z);

                        idx = idx + 1;

                    }

                }

                position.needsUpdate = true;

            };

        }());

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         * @author WestLangley / http://github.com/WestLangley
         */

        function SpotLightHelper(light, color) {

            Object3D.call(this);

            this.light = light;
            this.light.updateMatrixWorld();

            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;

            this.color = color;

            var geometry = new BufferGeometry();

            var positions = [
                0, 0, 0, 0, 0, 1,
                0, 0, 0, 1, 0, 1,
                0, 0, 0, -1, 0, 1,
                0, 0, 0, 0, 1, 1,
                0, 0, 0, 0, -1, 1
            ];

            for (var i = 0, j = 1, l = 32; i < l; i++, j++) {

                var p1 = (i / l) * Math.PI * 2;
                var p2 = (j / l) * Math.PI * 2;

                positions.push(
                    Math.cos(p1), Math.sin(p1), 1,
                    Math.cos(p2), Math.sin(p2), 1
                );

            }

            geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));

            var material = new LineBasicMaterial({fog: false});

            this.cone = new LineSegments(geometry, material);
            this.add(this.cone);

            this.update();

        }

        SpotLightHelper.prototype = Object.create(Object3D.prototype);
        SpotLightHelper.prototype.constructor = SpotLightHelper;

        SpotLightHelper.prototype.dispose = function () {

            this.cone.geometry.dispose();
            this.cone.material.dispose();

        };

        SpotLightHelper.prototype.update = function () {

            var vector = new Vector3();
            var vector2 = new Vector3();

            return function update() {

                this.light.updateMatrixWorld();

                var coneLength = this.light.distance ? this.light.distance : 1000;
                var coneWidth = coneLength * Math.tan(this.light.angle);

                this.cone.scale.set(coneWidth, coneWidth, coneLength);

                vector.setFromMatrixPosition(this.light.matrixWorld);
                vector2.setFromMatrixPosition(this.light.target.matrixWorld);

                this.cone.lookAt(vector2.sub(vector));

                if (this.color !== undefined) {

                    this.cone.material.color.set(this.color);

                } else {

                    this.cone.material.color.copy(this.light.color);

                }

            };

        }();

        /**
         * @author Sean Griffin / http://twitter.com/sgrif
         * @author Michael Guerrero / http://realitymeltdown.com
         * @author mrdoob / http://mrdoob.com/
         * @author ikerr / http://verold.com
         * @author Mugen87 / https://github.com/Mugen87
         */

        function getBoneList(object) {

            var boneList = [];

            if (object && object.isBone) {

                boneList.push(object);

            }

            for (var i = 0; i < object.children.length; i++) {

                boneList.push.apply(boneList, getBoneList(object.children[i]));

            }

            return boneList;

        }

        function SkeletonHelper(object) {

            var bones = getBoneList(object);

            var geometry = new BufferGeometry();

            var vertices = [];
            var colors = [];

            var color1 = new Color(0, 0, 1);
            var color2 = new Color(0, 1, 0);

            for (var i = 0; i < bones.length; i++) {

                var bone = bones[i];

                if (bone.parent && bone.parent.isBone) {

                    vertices.push(0, 0, 0);
                    vertices.push(0, 0, 0);
                    colors.push(color1.r, color1.g, color1.b);
                    colors.push(color2.r, color2.g, color2.b);

                }

            }

            geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

            var material = new LineBasicMaterial({
                vertexColors: VertexColors,
                depthTest: false,
                depthWrite: false,
                transparent: true
            });

            LineSegments.call(this, geometry, material);

            this.root = object;
            this.bones = bones;

            this.matrix = object.matrixWorld;
            this.matrixAutoUpdate = false;

        }

        SkeletonHelper.prototype = Object.create(LineSegments.prototype);
        SkeletonHelper.prototype.constructor = SkeletonHelper;

        SkeletonHelper.prototype.updateMatrixWorld = function () {

            var vector = new Vector3();

            var boneMatrix = new Matrix4();
            var matrixWorldInv = new Matrix4();

            return function updateMatrixWorld(force) {

                var bones = this.bones;

                var geometry = this.geometry;
                var position = geometry.getAttribute('position');

                matrixWorldInv.getInverse(this.root.matrixWorld);

                for (var i = 0, j = 0; i < bones.length; i++) {

                    var bone = bones[i];

                    if (bone.parent && bone.parent.isBone) {

                        boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                        vector.setFromMatrixPosition(boneMatrix);
                        position.setXYZ(j, vector.x, vector.y, vector.z);

                        boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                        vector.setFromMatrixPosition(boneMatrix);
                        position.setXYZ(j + 1, vector.x, vector.y, vector.z);

                        j += 2;

                    }

                }

                geometry.getAttribute('position').needsUpdate = true;

                Object3D.prototype.updateMatrixWorld.call(this, force);

            };

        }();

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         */

        function PointLightHelper(light, sphereSize, color) {

            this.light = light;
            this.light.updateMatrixWorld();

            this.color = color;

            var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
            var material = new MeshBasicMaterial({wireframe: true, fog: false});

            Mesh.call(this, geometry, material);

            this.matrix = this.light.matrixWorld;
            this.matrixAutoUpdate = false;

            this.update();


            /*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

        }

        PointLightHelper.prototype = Object.create(Mesh.prototype);
        PointLightHelper.prototype.constructor = PointLightHelper;

        PointLightHelper.prototype.dispose = function () {

            this.geometry.dispose();
            this.material.dispose();

        };

        PointLightHelper.prototype.update = function () {

            if (this.color !== undefined) {

                this.material.color.set(this.color);

            } else {

                this.material.color.copy(this.light.color);

            }

            /*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

        };

        /**
         * @author abelnation / http://github.com/abelnation
         * @author Mugen87 / http://github.com/Mugen87
         * @author WestLangley / http://github.com/WestLangley
         */

        function RectAreaLightHelper(light, color) {

            Object3D.call(this);

            this.light = light;
            this.light.updateMatrixWorld();

            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;

            this.color = color;

            var material = new LineBasicMaterial({fog: false});

            var geometry = new BufferGeometry();

            geometry.addAttribute('position', new BufferAttribute(new Float32Array(5 * 3), 3));

            this.line = new Line(geometry, material);
            this.add(this.line);


            this.update();

        }

        RectAreaLightHelper.prototype = Object.create(Object3D.prototype);
        RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

        RectAreaLightHelper.prototype.dispose = function () {

            this.children[0].geometry.dispose();
            this.children[0].material.dispose();

        };

        RectAreaLightHelper.prototype.update = function () {

            // calculate new dimensions of the helper

            var hx = this.light.width * 0.5;
            var hy = this.light.height * 0.5;

            var position = this.line.geometry.attributes.position;
            var array = position.array;

            // update vertices

            array[0] = hx;
            array[1] = -hy;
            array[2] = 0;
            array[3] = hx;
            array[4] = hy;
            array[5] = 0;
            array[6] = -hx;
            array[7] = hy;
            array[8] = 0;
            array[9] = -hx;
            array[10] = -hy;
            array[11] = 0;
            array[12] = hx;
            array[13] = -hy;
            array[14] = 0;

            position.needsUpdate = true;

            if (this.color !== undefined) {

                this.line.material.color.set(this.color);

            } else {

                this.line.material.color.copy(this.light.color);

            }

        };

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         * @author Mugen87 / https://github.com/Mugen87
         */

        function HemisphereLightHelper(light, size, color) {

            Object3D.call(this);

            this.light = light;
            this.light.updateMatrixWorld();

            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;

            this.color = color;

            var geometry = new OctahedronBufferGeometry(size);
            geometry.rotateY(Math.PI * 0.5);

            this.material = new MeshBasicMaterial({wireframe: true, fog: false});
            if (this.color === undefined) this.material.vertexColors = VertexColors;

            var position = geometry.getAttribute('position');
            var colors = new Float32Array(position.count * 3);

            geometry.addAttribute('color', new BufferAttribute(colors, 3));

            this.add(new Mesh(geometry, this.material));

            this.update();

        }

        HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
        HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

        HemisphereLightHelper.prototype.dispose = function () {

            this.children[0].geometry.dispose();
            this.children[0].material.dispose();

        };

        HemisphereLightHelper.prototype.update = function () {

            var vector = new Vector3();

            var color1 = new Color();
            var color2 = new Color();

            return function update() {

                var mesh = this.children[0];

                if (this.color !== undefined) {

                    this.material.color.set(this.color);

                } else {

                    var colors = mesh.geometry.getAttribute('color');

                    color1.copy(this.light.color);
                    color2.copy(this.light.groundColor);

                    for (var i = 0, l = colors.count; i < l; i++) {

                        var color = (i < (l / 2)) ? color1 : color2;

                        colors.setXYZ(i, color.r, color.g, color.b);

                    }

                    colors.needsUpdate = true;

                }

                mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());

            };

        }();

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function GridHelper(size, divisions, color1, color2) {

            size = size || 10;
            divisions = divisions || 10;
            color1 = new Color(color1 !== undefined ? color1 : 0x444444);
            color2 = new Color(color2 !== undefined ? color2 : 0x888888);

            var center = divisions / 2;
            var step = size / divisions;
            var halfSize = size / 2;

            var vertices = [], colors = [];

            for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {

                vertices.push(-halfSize, 0, k, halfSize, 0, k);
                vertices.push(k, 0, -halfSize, k, 0, halfSize);

                var color = i === center ? color1 : color2;

                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;

            }

            var geometry = new BufferGeometry();
            geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

            var material = new LineBasicMaterial({vertexColors: VertexColors});

            LineSegments.call(this, geometry, material);

        }

        GridHelper.prototype = Object.create(LineSegments.prototype);
        GridHelper.prototype.constructor = GridHelper;

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author Mugen87 / http://github.com/Mugen87
         * @author Hectate / http://www.github.com/Hectate
         */

        function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {

            radius = radius || 10;
            radials = radials || 16;
            circles = circles || 8;
            divisions = divisions || 64;
            color1 = new Color(color1 !== undefined ? color1 : 0x444444);
            color2 = new Color(color2 !== undefined ? color2 : 0x888888);

            var vertices = [];
            var colors = [];

            var x, z;
            var v, i, j, r, color;

            // create the radials

            for (i = 0; i <= radials; i++) {

                v = (i / radials) * (Math.PI * 2);

                x = Math.sin(v) * radius;
                z = Math.cos(v) * radius;

                vertices.push(0, 0, 0);
                vertices.push(x, 0, z);

                color = (i & 1) ? color1 : color2;

                colors.push(color.r, color.g, color.b);
                colors.push(color.r, color.g, color.b);

            }

            // create the circles

            for (i = 0; i <= circles; i++) {

                color = (i & 1) ? color1 : color2;

                r = radius - (radius / circles * i);

                for (j = 0; j < divisions; j++) {

                    // first vertex

                    v = (j / divisions) * (Math.PI * 2);

                    x = Math.sin(v) * r;
                    z = Math.cos(v) * r;

                    vertices.push(x, 0, z);
                    colors.push(color.r, color.g, color.b);

                    // second vertex

                    v = ((j + 1) / divisions) * (Math.PI * 2);

                    x = Math.sin(v) * r;
                    z = Math.cos(v) * r;

                    vertices.push(x, 0, z);
                    colors.push(color.r, color.g, color.b);

                }

            }

            var geometry = new BufferGeometry();
            geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

            var material = new LineBasicMaterial({vertexColors: VertexColors});

            LineSegments.call(this, geometry, material);

        }

        PolarGridHelper.prototype = Object.create(LineSegments.prototype);
        PolarGridHelper.prototype.constructor = PolarGridHelper;

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author WestLangley / http://github.com/WestLangley
         */

        function FaceNormalsHelper(object, size, hex, linewidth) {

            // FaceNormalsHelper only supports THREE.Geometry

            this.object = object;

            this.size = (size !== undefined) ? size : 1;

            var color = (hex !== undefined) ? hex : 0xffff00;

            var width = (linewidth !== undefined) ? linewidth : 1;

            //

            var nNormals = 0;

            var objGeometry = this.object.geometry;

            if (objGeometry && objGeometry.isGeometry) {

                nNormals = objGeometry.faces.length;

            } else {

                console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');

            }

            //

            var geometry = new BufferGeometry();

            var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);

            geometry.addAttribute('position', positions);

            LineSegments.call(this, geometry, new LineBasicMaterial({color: color, linewidth: width}));

            //

            this.matrixAutoUpdate = false;
            this.update();

        }

        FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
        FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

        FaceNormalsHelper.prototype.update = (function () {

            var v1 = new Vector3();
            var v2 = new Vector3();
            var normalMatrix = new Matrix3();

            return function update() {

                this.object.updateMatrixWorld(true);

                normalMatrix.getNormalMatrix(this.object.matrixWorld);

                var matrixWorld = this.object.matrixWorld;

                var position = this.geometry.attributes.position;

                //

                var objGeometry = this.object.geometry;

                var vertices = objGeometry.vertices;

                var faces = objGeometry.faces;

                var idx = 0;

                for (var i = 0, l = faces.length; i < l; i++) {

                    var face = faces[i];

                    var normal = face.normal;

                    v1.copy(vertices[face.a])
                        .add(vertices[face.b])
                        .add(vertices[face.c])
                        .divideScalar(3)
                        .applyMatrix4(matrixWorld);

                    v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

                    position.setXYZ(idx, v1.x, v1.y, v1.z);

                    idx = idx + 1;

                    position.setXYZ(idx, v2.x, v2.y, v2.z);

                    idx = idx + 1;

                }

                position.needsUpdate = true;

            };

        }());

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author mrdoob / http://mrdoob.com/
         * @author WestLangley / http://github.com/WestLangley
         */

        function DirectionalLightHelper(light, size, color) {

            Object3D.call(this);

            this.light = light;
            this.light.updateMatrixWorld();

            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;

            this.color = color;

            if (size === undefined) size = 1;

            var geometry = new BufferGeometry();
            geometry.addAttribute('position', new Float32BufferAttribute([
                -size, size, 0,
                size, size, 0,
                size, -size, 0,
                -size, -size, 0,
                -size, size, 0
            ], 3));

            var material = new LineBasicMaterial({fog: false});

            this.lightPlane = new Line(geometry, material);
            this.add(this.lightPlane);

            geometry = new BufferGeometry();
            geometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

            this.targetLine = new Line(geometry, material);
            this.add(this.targetLine);

            this.update();

        }

        DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
        DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

        DirectionalLightHelper.prototype.dispose = function () {

            this.lightPlane.geometry.dispose();
            this.lightPlane.material.dispose();
            this.targetLine.geometry.dispose();
            this.targetLine.material.dispose();

        };

        DirectionalLightHelper.prototype.update = function () {

            var v1 = new Vector3();
            var v2 = new Vector3();
            var v3 = new Vector3();

            return function update() {

                v1.setFromMatrixPosition(this.light.matrixWorld);
                v2.setFromMatrixPosition(this.light.target.matrixWorld);
                v3.subVectors(v2, v1);

                this.lightPlane.lookAt(v3);

                if (this.color !== undefined) {

                    this.lightPlane.material.color.set(this.color);
                    this.targetLine.material.color.set(this.color);

                } else {

                    this.lightPlane.material.color.copy(this.light.color);
                    this.targetLine.material.color.copy(this.light.color);

                }

                this.targetLine.lookAt(v3);
                this.targetLine.scale.z = v3.length();

            };

        }();

        /**
         * @author alteredq / http://alteredqualia.com/
         * @author Mugen87 / https://github.com/Mugen87
         *
         *    - shows frustum, line of sight and up of the camera
         *    - suitable for fast updates
         *    - based on frustum visualization in lightgl.js shadowmap example
         *        http://evanw.github.com/lightgl.js/tests/shadowmap.html
         */

        function CameraHelper(camera) {

            var geometry = new BufferGeometry();
            var material = new LineBasicMaterial({color: 0xffffff, vertexColors: FaceColors});

            var vertices = [];
            var colors = [];

            var pointMap = {};

            // colors

            var colorFrustum = new Color(0xffaa00);
            var colorCone = new Color(0xff0000);
            var colorUp = new Color(0x00aaff);
            var colorTarget = new Color(0xffffff);
            var colorCross = new Color(0x333333);

            // near

            addLine('n1', 'n2', colorFrustum);
            addLine('n2', 'n4', colorFrustum);
            addLine('n4', 'n3', colorFrustum);
            addLine('n3', 'n1', colorFrustum);

            // far

            addLine('f1', 'f2', colorFrustum);
            addLine('f2', 'f4', colorFrustum);
            addLine('f4', 'f3', colorFrustum);
            addLine('f3', 'f1', colorFrustum);

            // sides

            addLine('n1', 'f1', colorFrustum);
            addLine('n2', 'f2', colorFrustum);
            addLine('n3', 'f3', colorFrustum);
            addLine('n4', 'f4', colorFrustum);

            // cone

            addLine('p', 'n1', colorCone);
            addLine('p', 'n2', colorCone);
            addLine('p', 'n3', colorCone);
            addLine('p', 'n4', colorCone);

            // up

            addLine('u1', 'u2', colorUp);
            addLine('u2', 'u3', colorUp);
            addLine('u3', 'u1', colorUp);

            // target

            addLine('c', 't', colorTarget);
            addLine('p', 'c', colorCross);

            // cross

            addLine('cn1', 'cn2', colorCross);
            addLine('cn3', 'cn4', colorCross);

            addLine('cf1', 'cf2', colorCross);
            addLine('cf3', 'cf4', colorCross);

            function addLine(a, b, color) {

                addPoint(a, color);
                addPoint(b, color);

            }

            function addPoint(id, color) {

                vertices.push(0, 0, 0);
                colors.push(color.r, color.g, color.b);

                if (pointMap[id] === undefined) {

                    pointMap[id] = [];

                }

                pointMap[id].push((vertices.length / 3) - 1);

            }

            geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

            LineSegments.call(this, geometry, material);

            this.camera = camera;
            if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();

            this.matrix = camera.matrixWorld;
            this.matrixAutoUpdate = false;

            this.pointMap = pointMap;

            this.update();

        }

        CameraHelper.prototype = Object.create(LineSegments.prototype);
        CameraHelper.prototype.constructor = CameraHelper;

        CameraHelper.prototype.update = function () {

            var geometry, pointMap;

            var vector = new Vector3();
            var camera = new Camera();

            function setPoint(point, x, y, z) {

                vector.set(x, y, z).unproject(camera);

                var points = pointMap[point];

                if (points !== undefined) {

                    var position = geometry.getAttribute('position');

                    for (var i = 0, l = points.length; i < l; i++) {

                        position.setXYZ(points[i], vector.x, vector.y, vector.z);

                    }

                }

            }

            return function update() {

                geometry = this.geometry;
                pointMap = this.pointMap;

                var w = 1, h = 1;

                // we need just camera projection matrix
                // world matrix must be identity

                camera.projectionMatrix.copy(this.camera.projectionMatrix);

                // center / target

                setPoint('c', 0, 0, -1);
                setPoint('t', 0, 0, 1);

                // near

                setPoint('n1', -w, -h, -1);
                setPoint('n2', w, -h, -1);
                setPoint('n3', -w, h, -1);
                setPoint('n4', w, h, -1);

                // far

                setPoint('f1', -w, -h, 1);
                setPoint('f2', w, -h, 1);
                setPoint('f3', -w, h, 1);
                setPoint('f4', w, h, 1);

                // up

                setPoint('u1', w * 0.7, h * 1.1, -1);
                setPoint('u2', -w * 0.7, h * 1.1, -1);
                setPoint('u3', 0, h * 2, -1);

                // cross

                setPoint('cf1', -w, 0, 1);
                setPoint('cf2', w, 0, 1);
                setPoint('cf3', 0, -h, 1);
                setPoint('cf4', 0, h, 1);

                setPoint('cn1', -w, 0, -1);
                setPoint('cn2', w, 0, -1);
                setPoint('cn3', 0, -h, -1);
                setPoint('cn4', 0, h, -1);

                geometry.getAttribute('position').needsUpdate = true;

            };

        }();

        /**
         * @author mrdoob / http://mrdoob.com/
         * @author Mugen87 / http://github.com/Mugen87
         */

        function BoxHelper(object, color) {

            this.object = object;

            if (color === undefined) color = 0xffff00;

            var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var positions = new Float32Array(8 * 3);

            var geometry = new BufferGeometry();
            geometry.setIndex(new BufferAttribute(indices, 1));
            geometry.addAttribute('position', new BufferAttribute(positions, 3));

            LineSegments.call(this, geometry, new LineBasicMaterial({color: color}));

            this.matrixAutoUpdate = false;

            this.update();

        }

        BoxHelper.prototype = Object.create(LineSegments.prototype);
        BoxHelper.prototype.constructor = BoxHelper;

        BoxHelper.prototype.update = (function () {

            var box = new Box3();

            return function update(object) {

                if (object !== undefined) {

                    console.warn('THREE.BoxHelper: .update() has no longer arguments.');

                }

                if (this.object !== undefined) {

                    box.setFromObject(this.object);

                }

                if (box.isEmpty()) return;

                var min = box.min;
                var max = box.max;

                /*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

                var position = this.geometry.attributes.position;
                var array = position.array;

                array[0] = max.x;
                array[1] = max.y;
                array[2] = max.z;
                array[3] = min.x;
                array[4] = max.y;
                array[5] = max.z;
                array[6] = min.x;
                array[7] = min.y;
                array[8] = max.z;
                array[9] = max.x;
                array[10] = min.y;
                array[11] = max.z;
                array[12] = max.x;
                array[13] = max.y;
                array[14] = min.z;
                array[15] = min.x;
                array[16] = max.y;
                array[17] = min.z;
                array[18] = min.x;
                array[19] = min.y;
                array[20] = min.z;
                array[21] = max.x;
                array[22] = min.y;
                array[23] = min.z;

                position.needsUpdate = true;

                this.geometry.computeBoundingSphere();

            };

        })();

        BoxHelper.prototype.setFromObject = function (object) {

            this.object = object;
            this.update();

            return this;

        };

        /**
         * @author WestLangley / http://github.com/WestLangley
         */

        function Box3Helper(box, hex) {

            this.type = 'Box3Helper';

            this.box = box;

            var color = (hex !== undefined) ? hex : 0xffff00;

            var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);

            var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];

            var geometry = new BufferGeometry();

            geometry.setIndex(new BufferAttribute(indices, 1));

            geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));

            LineSegments.call(this, geometry, new LineBasicMaterial({color: color}));

            this.geometry.computeBoundingSphere();

        }

        Box3Helper.prototype = Object.create(LineSegments.prototype);
        Box3Helper.prototype.constructor = Box3Helper;

        Box3Helper.prototype.updateMatrixWorld = function (force) {

            var box = this.box;

            if (box.isEmpty()) return;

            box.getCenter(this.position);

            box.getSize(this.scale);

            this.scale.multiplyScalar(0.5);

            Object3D.prototype.updateMatrixWorld.call(this, force);

        };

        /**
         * @author WestLangley / http://github.com/WestLangley
         */

        function PlaneHelper(plane, size, hex) {

            this.type = 'PlaneHelper';

            this.plane = plane;

            this.size = (size === undefined) ? 1 : size;

            var color = (hex !== undefined) ? hex : 0xffff00;

            var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];

            var geometry = new BufferGeometry();
            geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
            geometry.computeBoundingSphere();

            Line.call(this, geometry, new LineBasicMaterial({color: color}));

            //

            var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];

            var geometry2 = new BufferGeometry();
            geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));
            geometry2.computeBoundingSphere();

            this.add(new Mesh(geometry2, new MeshBasicMaterial({
                color: color,
                opacity: 0.2,
                transparent: true,
                depthWrite: false
            })));

        }

        PlaneHelper.prototype = Object.create(Line.prototype);
        PlaneHelper.prototype.constructor = PlaneHelper;

        PlaneHelper.prototype.updateMatrixWorld = function (force) {

            var scale = -this.plane.constant;

            if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

            this.scale.set(0.5 * this.size, 0.5 * this.size, scale);

            this.lookAt(this.plane.normal);

            Object3D.prototype.updateMatrixWorld.call(this, force);

        };

        /**
         * @author WestLangley / http://github.com/WestLangley
         * @author zz85 / http://github.com/zz85
         * @author bhouston / http://clara.io
         *
         * Creates an arrow for visualizing directions
         *
         * Parameters:
         *  dir - Vector3
         *  origin - Vector3
         *  length - Number
         *  color - color in hex value
         *  headLength - Number
         *  headWidth - Number
         */

        var lineGeometry;
        var coneGeometry;

        function ArrowHelper(dir, origin, length, color, headLength, headWidth) {

            // dir is assumed to be normalized

            Object3D.call(this);

            if (color === undefined) color = 0xffff00;
            if (length === undefined) length = 1;
            if (headLength === undefined) headLength = 0.2 * length;
            if (headWidth === undefined) headWidth = 0.2 * headLength;

            if (lineGeometry === undefined) {

                lineGeometry = new BufferGeometry();
                lineGeometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

                coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
                coneGeometry.translate(0, -0.5, 0);

            }

            this.position.copy(origin);

            this.line = new Line(lineGeometry, new LineBasicMaterial({color: color}));
            this.line.matrixAutoUpdate = false;
            this.add(this.line);

            this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({color: color}));
            this.cone.matrixAutoUpdate = false;
            this.add(this.cone);

            this.setDirection(dir);
            this.setLength(length, headLength, headWidth);

        }

        ArrowHelper.prototype = Object.create(Object3D.prototype);
        ArrowHelper.prototype.constructor = ArrowHelper;

        ArrowHelper.prototype.setDirection = (function () {

            var axis = new Vector3();
            var radians;

            return function setDirection(dir) {

                // dir is assumed to be normalized

                if (dir.y > 0.99999) {

                    this.quaternion.set(0, 0, 0, 1);

                } else if (dir.y < -0.99999) {

                    this.quaternion.set(1, 0, 0, 0);

                } else {

                    axis.set(dir.z, 0, -dir.x).normalize();

                    radians = Math.acos(dir.y);

                    this.quaternion.setFromAxisAngle(axis, radians);

                }

            };

        }());

        ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {

            if (headLength === undefined) headLength = 0.2 * length;
            if (headWidth === undefined) headWidth = 0.2 * headLength;

            this.line.scale.set(1, Math.max(0, length - headLength), 1);
            this.line.updateMatrix();

            this.cone.scale.set(headWidth, headLength, headWidth);
            this.cone.position.y = length;
            this.cone.updateMatrix();

        };

        ArrowHelper.prototype.setColor = function (color) {

            this.line.material.color.copy(color);
            this.cone.material.color.copy(color);

        };

        /**
         * @author sroucheray / http://sroucheray.org/
         * @author mrdoob / http://mrdoob.com/
         */

        function AxesHelper(size) {

            size = size || 1;

            var vertices = [
                0, 0, 0, size, 0, 0,
                0, 0, 0, 0, size, 0,
                0, 0, 0, 0, 0, size
            ];

            var colors = [
                1, 0, 0, 1, 0.6, 0,
                0, 1, 0, 0.6, 1, 0,
                0, 0, 1, 0, 0.6, 1
            ];

            var geometry = new BufferGeometry();
            geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

            var material = new LineBasicMaterial({vertexColors: VertexColors});

            LineSegments.call(this, geometry, material);

        }

        AxesHelper.prototype = Object.create(LineSegments.prototype);
        AxesHelper.prototype.constructor = AxesHelper;

        /**
         * @author zz85 https://github.com/zz85
         *
         * Centripetal CatmullRom Curve - which is useful for avoiding
         * cusps and self-intersections in non-uniform catmull rom curves.
         * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
         *
         * curve.type accepts centripetal(default), chordal and catmullrom
         * curve.tension is used for catmullrom which defaults to 0.5
         */


        /*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

        function CubicPoly() {

            var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

            /*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
            function init(x0, x1, t0, t1) {

                c0 = x0;
                c1 = t0;
                c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
                c3 = 2 * x0 - 2 * x1 + t0 + t1;

            }

            return {

                initCatmullRom: function (x0, x1, x2, x3, tension) {

                    init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));

                },

                initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {

                    // compute tangents when parameterized in [t1,t2]
                    var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                    var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

                    // rescale tangents for parametrization in [0,1]
                    t1 *= dt1;
                    t2 *= dt1;

                    init(x1, x2, t1, t2);

                },

                calc: function (t) {

                    var t2 = t * t;
                    var t3 = t2 * t;
                    return c0 + c1 * t + c2 * t2 + c3 * t3;

                }

            };

        }

        //

        var tmp = new Vector3();
        var px = new CubicPoly();
        var py = new CubicPoly();
        var pz = new CubicPoly();

        function CatmullRomCurve3(points) {

            Curve.call(this);

            if (points.length < 2) console.warn('THREE.CatmullRomCurve3: Points array needs at least two entries.');

            this.points = points || [];
            this.closed = false;

        }

        CatmullRomCurve3.prototype = Object.create(Curve.prototype);
        CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

        CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

        CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {

            var point = optionalTarget || new Vector3();

            var points = this.points;
            var l = points.length;

            var p = (l - (this.closed ? 0 : 1)) * t;
            var intPoint = Math.floor(p);
            var weight = p - intPoint;

            if (this.closed) {

                intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;

            } else if (weight === 0 && intPoint === l - 1) {

                intPoint = l - 2;
                weight = 1;

            }

            var p0, p1, p2, p3; // 4 points

            if (this.closed || intPoint > 0) {

                p0 = points[(intPoint - 1) % l];

            } else {

                // extrapolate first point
                tmp.subVectors(points[0], points[1]).add(points[0]);
                p0 = tmp;

            }

            p1 = points[intPoint % l];
            p2 = points[(intPoint + 1) % l];

            if (this.closed || intPoint + 2 < l) {

                p3 = points[(intPoint + 2) % l];

            } else {

                // extrapolate last point
                tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                p3 = tmp;

            }

            if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {

                // init Centripetal / Chordal Catmull-Rom
                var pow = this.type === 'chordal' ? 0.5 : 0.25;
                var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
                var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
                var dt2 = Math.pow(p2.distanceToSquared(p3), pow);

                // safety check for repeated points
                if (dt1 < 1e-4) dt1 = 1.0;
                if (dt0 < 1e-4) dt0 = dt1;
                if (dt2 < 1e-4) dt2 = dt1;

                px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);

            } else if (this.type === 'catmullrom') {

                var tension = this.tension !== undefined ? this.tension : 0.5;
                px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
                py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
                pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);

            }

            point.set(
                px.calc(weight),
                py.calc(weight),
                pz.calc(weight)
            );

            return point;

        };

        function CubicBezierCurve3(v0, v1, v2, v3) {

            Curve.call(this);

            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
            this.v3 = v3;

        }

        CubicBezierCurve3.prototype = Object.create(Curve.prototype);
        CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

        CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

        CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {

            var point = optionalTarget || new Vector3();

            var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

            point.set(
                CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
                CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
                CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
            );

            return point;

        };

        function QuadraticBezierCurve3(v0, v1, v2) {

            Curve.call(this);

            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;

        }

        QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
        QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

        QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

        QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {

            var point = optionalTarget || new Vector3();

            var v0 = this.v0, v1 = this.v1, v2 = this.v2;

            point.set(
                QuadraticBezier(t, v0.x, v1.x, v2.x),
                QuadraticBezier(t, v0.y, v1.y, v2.y),
                QuadraticBezier(t, v0.z, v1.z, v2.z)
            );

            return point;

        };

        function LineCurve3(v1, v2) {

            Curve.call(this);

            this.v1 = v1;
            this.v2 = v2;

        }

        LineCurve3.prototype = Object.create(Curve.prototype);
        LineCurve3.prototype.constructor = LineCurve3;

        LineCurve3.prototype.isLineCurve3 = true;

        LineCurve3.prototype.getPoint = function (t, optionalTarget) {

            var point = optionalTarget || new Vector3();

            if (t === 1) {

                point.copy(this.v2);

            } else {

                point.copy(this.v2).sub(this.v1);
                point.multiplyScalar(t).add(this.v1);

            }

            return point;

        };

        // Line curve is linear, so we can overwrite default getPointAt

        LineCurve3.prototype.getPointAt = function (u, optionalTarget) {

            return this.getPoint(u, optionalTarget);

        };

        function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

            EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);

        }

        ArcCurve.prototype = Object.create(EllipseCurve.prototype);
        ArcCurve.prototype.constructor = ArcCurve;

        ArcCurve.prototype.isArcCurve = true;

        /**
         * @author alteredq / http://alteredqualia.com/
         */

        var SceneUtils = {

            createMultiMaterialObject: function (geometry, materials) {

                var group = new Group();

                for (var i = 0, l = materials.length; i < l; i++) {

                    group.add(new Mesh(geometry, materials[i]));

                }

                return group;

            },

            detach: function (child, parent, scene) {

                child.applyMatrix(parent.matrixWorld);
                parent.remove(child);
                scene.add(child);

            },

            attach: function (child, scene, parent) {

                child.applyMatrix(new Matrix4().getInverse(parent.matrixWorld));

                scene.remove(child);
                parent.add(child);

            }

        };

        /**
         * @author mrdoob / http://mrdoob.com/
         */

        function Face4(a, b, c, d, normal, color, materialIndex) {

            console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
            return new Face3(a, b, c, normal, color, materialIndex);

        }

        var LineStrip = 0;

        var LinePieces = 1;

        function MeshFaceMaterial(materials) {

            console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
            return materials;

        }

        function MultiMaterial(materials) {

            if (materials === undefined) materials = [];

            console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
            materials.isMultiMaterial = true;
            materials.materials = materials;
            materials.clone = function () {

                return materials.slice();

            };
            return materials;

        }

        function PointCloud(geometry, material) {

            console.warn('THREE.PointCloud has been renamed to THREE.Points.');
            return new Points(geometry, material);

        }

        function Particle(material) {

            console.warn('THREE.Particle has been renamed to THREE.Sprite.');
            return new Sprite(material);

        }

        function ParticleSystem(geometry, material) {

            console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
            return new Points(geometry, material);

        }

        function PointCloudMaterial(parameters) {

            console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
            return new PointsMaterial(parameters);

        }

        function ParticleBasicMaterial(parameters) {

            console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
            return new PointsMaterial(parameters);

        }

        function ParticleSystemMaterial(parameters) {

            console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
            return new PointsMaterial(parameters);

        }

        function Vertex(x, y, z) {

            console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
            return new Vector3(x, y, z);

        }

        //

        function DynamicBufferAttribute(array, itemSize) {

            console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
            return new BufferAttribute(array, itemSize).setDynamic(true);

        }

        function Int8Attribute(array, itemSize) {

            console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
            return new Int8BufferAttribute(array, itemSize);

        }

        function Uint8Attribute(array, itemSize) {

            console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
            return new Uint8BufferAttribute(array, itemSize);

        }

        function Uint8ClampedAttribute(array, itemSize) {

            console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
            return new Uint8ClampedBufferAttribute(array, itemSize);

        }

        function Int16Attribute(array, itemSize) {

            console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
            return new Int16BufferAttribute(array, itemSize);

        }

        function Uint16Attribute(array, itemSize) {

            console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
            return new Uint16BufferAttribute(array, itemSize);

        }

        function Int32Attribute(array, itemSize) {

            console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
            return new Int32BufferAttribute(array, itemSize);

        }

        function Uint32Attribute(array, itemSize) {

            console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
            return new Uint32BufferAttribute(array, itemSize);

        }

        function Float32Attribute(array, itemSize) {

            console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
            return new Float32BufferAttribute(array, itemSize);

        }

        function Float64Attribute(array, itemSize) {

            console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
            return new Float64BufferAttribute(array, itemSize);

        }

        //

        Curve.create = function (construct, getPoint) {

            console.log('THREE.Curve.create() has been deprecated');

            construct.prototype = Object.create(Curve.prototype);
            construct.prototype.constructor = construct;
            construct.prototype.getPoint = getPoint;

            return construct;

        };

        //

        Object.assign(CurvePath.prototype, {

            createPointsGeometry: function (divisions) {

                console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

                // generate geometry from path points (for Line or Points objects)

                var pts = this.getPoints(divisions);
                return this.createGeometry(pts);

            },

            createSpacedPointsGeometry: function (divisions) {

                console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

                // generate geometry from equidistant sampling along the path

                var pts = this.getSpacedPoints(divisions);
                return this.createGeometry(pts);

            },

            createGeometry: function (points) {

                console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

                var geometry = new Geometry();

                for (var i = 0, l = points.length; i < l; i++) {

                    var point = points[i];
                    geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));

                }

                return geometry;

            }

        });

        //

        function ClosedSplineCurve3(points) {

            console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

            CatmullRomCurve3.call(this, points);
            this.type = 'catmullrom';
            this.closed = true;

        }

        ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

        //

        function SplineCurve3(points) {

            console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

            CatmullRomCurve3.call(this, points);
            this.type = 'catmullrom';

        }

        SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

        //

        function Spline(points) {

            console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');

            CatmullRomCurve3.call(this, points);
            this.type = 'catmullrom';

        }

        Spline.prototype = Object.create(CatmullRomCurve3.prototype);

        Object.assign(Spline.prototype, {

            initFromArray: function (/* a */) {

                console.error('THREE.Spline: .initFromArray() has been removed.');

            },
            getControlPointsArray: function (/* optionalTarget */) {

                console.error('THREE.Spline: .getControlPointsArray() has been removed.');

            },
            reparametrizeByArcLength: function (/* samplingCoef */) {

                console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');

            }

        });

        //

        function AxisHelper(size) {

            console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
            return new AxesHelper(size);

        }

        function BoundingBoxHelper(object, color) {

            console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
            return new BoxHelper(object, color);

        }

        function EdgesHelper(object, hex) {

            console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
            return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({color: hex !== undefined ? hex : 0xffffff}));

        }

        GridHelper.prototype.setColors = function () {

            console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');

        };

        SkeletonHelper.prototype.update = function () {

            console.error('THREE.SkeletonHelper: update() no longer needs to be called.');

        };

        function WireframeHelper(object, hex) {

            console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
            return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({color: hex !== undefined ? hex : 0xffffff}));

        }

        //

        function XHRLoader(manager) {

            console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
            return new FileLoader(manager);

        }

        function BinaryTextureLoader(manager) {

            console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
            return new DataTextureLoader(manager);

        }

        //

        Object.assign(Box2.prototype, {

            center: function (optionalTarget) {

                console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
                return this.getCenter(optionalTarget);

            },
            empty: function () {

                console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
                return this.isEmpty();

            },
            isIntersectionBox: function (box) {

                console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
                return this.intersectsBox(box);

            },
            size: function (optionalTarget) {

                console.warn('THREE.Box2: .size() has been renamed to .getSize().');
                return this.getSize(optionalTarget);

            }
        });

        Object.assign(Box3.prototype, {

            center: function (optionalTarget) {

                console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
                return this.getCenter(optionalTarget);

            },
            empty: function () {

                console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
                return this.isEmpty();

            },
            isIntersectionBox: function (box) {

                console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
                return this.intersectsBox(box);

            },
            isIntersectionSphere: function (sphere) {

                console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
                return this.intersectsSphere(sphere);

            },
            size: function (optionalTarget) {

                console.warn('THREE.Box3: .size() has been renamed to .getSize().');
                return this.getSize(optionalTarget);

            }
        });

        Line3.prototype.center = function (optionalTarget) {

            console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
            return this.getCenter(optionalTarget);

        };

        Object.assign(_Math, {

            random16: function () {

                console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
                return Math.random();

            },

            nearestPowerOfTwo: function (value) {

                console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
                return _Math.floorPowerOfTwo(value);

            },

            nextPowerOfTwo: function (value) {

                console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
                return _Math.ceilPowerOfTwo(value);

            }

        });

        Object.assign(Matrix3.prototype, {

            flattenToArrayOffset: function (array, offset) {

                console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
                return this.toArray(array, offset);

            },
            multiplyVector3: function (vector) {

                console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
                return vector.applyMatrix3(this);

            },
            multiplyVector3Array: function (/* a */) {

                console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');

            },
            applyToBuffer: function (buffer /*, offset, length */) {

                console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
                return this.applyToBufferAttribute(buffer);

            },
            applyToVector3Array: function (/* array, offset, length */) {

                console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');

            }

        });

        Object.assign(Matrix4.prototype, {

            extractPosition: function (m) {

                console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
                return this.copyPosition(m);

            },
            flattenToArrayOffset: function (array, offset) {

                console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
                return this.toArray(array, offset);

            },
            getPosition: function () {

                var v1;

                return function getPosition() {

                    if (v1 === undefined) v1 = new Vector3();
                    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
                    return v1.setFromMatrixColumn(this, 3);

                };

            }(),
            setRotationFromQuaternion: function (q) {

                console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
                return this.makeRotationFromQuaternion(q);

            },
            multiplyToArray: function () {

                console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');

            },
            multiplyVector3: function (vector) {

                console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
                return vector.applyMatrix4(this);

            },
            multiplyVector4: function (vector) {

                console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
                return vector.applyMatrix4(this);

            },
            multiplyVector3Array: function (/* a */) {

                console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');

            },
            rotateAxis: function (v) {

                console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
                v.transformDirection(this);

            },
            crossVector: function (vector) {

                console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
                return vector.applyMatrix4(this);

            },
            translate: function () {

                console.error('THREE.Matrix4: .translate() has been removed.');

            },
            rotateX: function () {

                console.error('THREE.Matrix4: .rotateX() has been removed.');

            },
            rotateY: function () {

                console.error('THREE.Matrix4: .rotateY() has been removed.');

            },
            rotateZ: function () {

                console.error('THREE.Matrix4: .rotateZ() has been removed.');

            },
            rotateByAxis: function () {

                console.error('THREE.Matrix4: .rotateByAxis() has been removed.');

            },
            applyToBuffer: function (buffer /*, offset, length */) {

                console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
                return this.applyToBufferAttribute(buffer);

            },
            applyToVector3Array: function (/* array, offset, length */) {

                console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');

            },
            makeFrustum: function (left, right, bottom, top, near, far) {

                console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
                return this.makePerspective(left, right, top, bottom, near, far);

            }

        });

        Plane.prototype.isIntersectionLine = function (line) {

            console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
            return this.intersectsLine(line);

        };

        Quaternion.prototype.multiplyVector3 = function (vector) {

            console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
            return vector.applyQuaternion(this);

        };

        Object.assign(Ray.prototype, {

            isIntersectionBox: function (box) {

                console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
                return this.intersectsBox(box);

            },
            isIntersectionPlane: function (plane) {

                console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
                return this.intersectsPlane(plane);

            },
            isIntersectionSphere: function (sphere) {

                console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
                return this.intersectsSphere(sphere);

            }

        });

        Object.assign(Shape.prototype, {

            extrude: function (options) {

                console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
                return new ExtrudeGeometry(this, options);

            },
            makeGeometry: function (options) {

                console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
                return new ShapeGeometry(this, options);

            }

        });

        Object.assign(Vector2.prototype, {

            fromAttribute: function (attribute, index, offset) {

                console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
                return this.fromBufferAttribute(attribute, index, offset);

            },
            distanceToManhattan: function (v) {

                console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
                return this.manhattanDistanceTo(v);

            },
            lengthManhattan: function () {

                console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
                return this.manhattanLength();

            }

        });

        Object.assign(Vector3.prototype, {

            setEulerFromRotationMatrix: function () {

                console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');

            },
            setEulerFromQuaternion: function () {

                console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');

            },
            getPositionFromMatrix: function (m) {

                console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
                return this.setFromMatrixPosition(m);

            },
            getScaleFromMatrix: function (m) {

                console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
                return this.setFromMatrixScale(m);

            },
            getColumnFromMatrix: function (index, matrix) {

                console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
                return this.setFromMatrixColumn(matrix, index);

            },
            applyProjection: function (m) {

                console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
                return this.applyMatrix4(m);

            },
            fromAttribute: function (attribute, index, offset) {

                console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
                return this.fromBufferAttribute(attribute, index, offset);

            },
            distanceToManhattan: function (v) {

                console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
                return this.manhattanDistanceTo(v);

            },
            lengthManhattan: function () {

                console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
                return this.manhattanLength();

            }

        });

        Object.assign(Vector4.prototype, {

            fromAttribute: function (attribute, index, offset) {

                console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
                return this.fromBufferAttribute(attribute, index, offset);

            },
            lengthManhattan: function () {

                console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
                return this.manhattanLength();

            }

        });

        //

        Geometry.prototype.computeTangents = function () {

            console.warn('THREE.Geometry: .computeTangents() has been removed.');

        };

        Object.assign(Object3D.prototype, {

            getChildByName: function (name) {

                console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
                return this.getObjectByName(name);

            },
            renderDepth: function () {

                console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');

            },
            translate: function (distance, axis) {

                console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
                return this.translateOnAxis(axis, distance);

            }

        });

        Object.defineProperties(Object3D.prototype, {

            eulerOrder: {
                get: function () {

                    console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                    return this.rotation.order;

                },
                set: function (value) {

                    console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                    this.rotation.order = value;

                }
            },
            useQuaternion: {
                get: function () {

                    console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');

                },
                set: function () {

                    console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');

                }
            }

        });

        Object.defineProperties(LOD.prototype, {

            objects: {
                get: function () {

                    console.warn('THREE.LOD: .objects has been renamed to .levels.');
                    return this.levels;

                }
            }

        });

        Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {

            get: function () {

                console.warn('THREE.Skeleton: useVertexTexture has been removed.');

            },
            set: function () {

                console.warn('THREE.Skeleton: useVertexTexture has been removed.');

            }

        });

        Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {

            get: function () {

                console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
                return this.arcLengthDivisions;

            },
            set: function (value) {

                console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
                this.arcLengthDivisions = value;

            }

        });

        //

        PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {

            console.warn("THREE.PerspectiveCamera.setLens is deprecated. " +
                "Use .setFocalLength and .filmGauge for a photographic setup.");

            if (filmGauge !== undefined) this.filmGauge = filmGauge;
            this.setFocalLength(focalLength);

        };

        //

        Object.defineProperties(Light.prototype, {
            onlyShadow: {
                set: function () {

                    console.warn('THREE.Light: .onlyShadow has been removed.');

                }
            },
            shadowCameraFov: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
                    this.shadow.camera.fov = value;

                }
            },
            shadowCameraLeft: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
                    this.shadow.camera.left = value;

                }
            },
            shadowCameraRight: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
                    this.shadow.camera.right = value;

                }
            },
            shadowCameraTop: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
                    this.shadow.camera.top = value;

                }
            },
            shadowCameraBottom: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
                    this.shadow.camera.bottom = value;

                }
            },
            shadowCameraNear: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
                    this.shadow.camera.near = value;

                }
            },
            shadowCameraFar: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
                    this.shadow.camera.far = value;

                }
            },
            shadowCameraVisible: {
                set: function () {

                    console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');

                }
            },
            shadowBias: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
                    this.shadow.bias = value;

                }
            },
            shadowDarkness: {
                set: function () {

                    console.warn('THREE.Light: .shadowDarkness has been removed.');

                }
            },
            shadowMapWidth: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
                    this.shadow.mapSize.width = value;

                }
            },
            shadowMapHeight: {
                set: function (value) {

                    console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
                    this.shadow.mapSize.height = value;

                }
            }
        });

        //

        Object.defineProperties(BufferAttribute.prototype, {

            length: {
                get: function () {

                    console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
                    return this.array.length;

                }
            }

        });

        Object.assign(BufferGeometry.prototype, {

            addIndex: function (index) {

                console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
                this.setIndex(index);

            },
            addDrawCall: function (start, count, indexOffset) {

                if (indexOffset !== undefined) {

                    console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');

                }
                console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
                this.addGroup(start, count);

            },
            clearDrawCalls: function () {

                console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
                this.clearGroups();

            },
            computeTangents: function () {

                console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');

            },
            computeOffsets: function () {

                console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');

            }

        });

        Object.defineProperties(BufferGeometry.prototype, {

            drawcalls: {
                get: function () {

                    console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
                    return this.groups;

                }
            },
            offsets: {
                get: function () {

                    console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
                    return this.groups;

                }
            }

        });

        //

        Object.defineProperties(Uniform.prototype, {

            dynamic: {
                set: function () {

                    console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');

                }
            },
            onUpdate: {
                value: function () {

                    console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
                    return this;

                }
            }

        });

        //

        Object.defineProperties(Material.prototype, {

            wrapAround: {
                get: function () {

                    console.warn('THREE.Material: .wrapAround has been removed.');

                },
                set: function () {

                    console.warn('THREE.Material: .wrapAround has been removed.');

                }
            },
            wrapRGB: {
                get: function () {

                    console.warn('THREE.Material: .wrapRGB has been removed.');
                    return new Color();

                }
            },

            shading: {
                get: function () {

                    console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');

                },
                set: function (value) {

                    console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                    this.flatShading = (value === FlatShading);

                }
            }

        });

        Object.defineProperties(MeshPhongMaterial.prototype, {

            metal: {
                get: function () {

                    console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
                    return false;

                },
                set: function () {

                    console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');

                }
            }

        });

        Object.defineProperties(ShaderMaterial.prototype, {

            derivatives: {
                get: function () {

                    console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                    return this.extensions.derivatives;

                },
                set: function (value) {

                    console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                    this.extensions.derivatives = value;

                }
            }

        });

        //

        Object.assign(WebGLRenderer.prototype, {

            getCurrentRenderTarget: function () {

                console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
                return this.getRenderTarget();

            },

            getMaxAnisotropy: function () {

                console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
                return this.capabilities.getMaxAnisotropy();

            },

            getPrecision: function () {

                console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
                return this.capabilities.precision;

            },

            resetGLState: function () {

                console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
                return this.state.reset();

            },

            supportsFloatTextures: function () {

                console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
                return this.extensions.get('OES_texture_float');

            },
            supportsHalfFloatTextures: function () {

                console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
                return this.extensions.get('OES_texture_half_float');

            },
            supportsStandardDerivatives: function () {

                console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
                return this.extensions.get('OES_standard_derivatives');

            },
            supportsCompressedTextureS3TC: function () {

                console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
                return this.extensions.get('WEBGL_compressed_texture_s3tc');

            },
            supportsCompressedTexturePVRTC: function () {

                console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
                return this.extensions.get('WEBGL_compressed_texture_pvrtc');

            },
            supportsBlendMinMax: function () {

                console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
                return this.extensions.get('EXT_blend_minmax');

            },
            supportsVertexTextures: function () {

                console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
                return this.capabilities.vertexTextures;

            },
            supportsInstancedArrays: function () {

                console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
                return this.extensions.get('ANGLE_instanced_arrays');

            },
            enableScissorTest: function (boolean) {

                console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
                this.setScissorTest(boolean);

            },
            initMaterial: function () {

                console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');

            },
            addPrePlugin: function () {

                console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');

            },
            addPostPlugin: function () {

                console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');

            },
            updateShadowMap: function () {

                console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');

            }

        });

        Object.defineProperties(WebGLRenderer.prototype, {

            shadowMapEnabled: {
                get: function () {

                    return this.shadowMap.enabled;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
                    this.shadowMap.enabled = value;

                }
            },
            shadowMapType: {
                get: function () {

                    return this.shadowMap.type;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
                    this.shadowMap.type = value;

                }
            },
            shadowMapCullFace: {
                get: function () {

                    return this.shadowMap.cullFace;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
                    this.shadowMap.cullFace = value;

                }
            }
        });

        Object.defineProperties(WebGLShadowMap.prototype, {

            cullFace: {
                get: function () {

                    return this.renderReverseSided ? CullFaceFront : CullFaceBack;

                },
                set: function (cullFace) {

                    var value = (cullFace !== CullFaceBack);
                    console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + ".");
                    this.renderReverseSided = value;

                }
            }

        });

        //

        Object.defineProperties(WebGLRenderTarget.prototype, {

            wrapS: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                    return this.texture.wrapS;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                    this.texture.wrapS = value;

                }
            },
            wrapT: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                    return this.texture.wrapT;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                    this.texture.wrapT = value;

                }
            },
            magFilter: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                    return this.texture.magFilter;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                    this.texture.magFilter = value;

                }
            },
            minFilter: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                    return this.texture.minFilter;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                    this.texture.minFilter = value;

                }
            },
            anisotropy: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                    return this.texture.anisotropy;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                    this.texture.anisotropy = value;

                }
            },
            offset: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                    return this.texture.offset;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                    this.texture.offset = value;

                }
            },
            repeat: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                    return this.texture.repeat;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                    this.texture.repeat = value;

                }
            },
            format: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                    return this.texture.format;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                    this.texture.format = value;

                }
            },
            type: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                    return this.texture.type;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                    this.texture.type = value;

                }
            },
            generateMipmaps: {
                get: function () {

                    console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                    return this.texture.generateMipmaps;

                },
                set: function (value) {

                    console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                    this.texture.generateMipmaps = value;

                }
            }

        });

        //

        Audio.prototype.load = function (file) {

            console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
            var scope = this;
            var audioLoader = new AudioLoader();
            audioLoader.load(file, function (buffer) {

                scope.setBuffer(buffer);

            });
            return this;

        };

        AudioAnalyser.prototype.getData = function () {

            console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
            return this.getFrequencyData();

        };


        //

        var GeometryUtils = {

            merge: function (geometry1, geometry2, materialIndexOffset) {

                console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
                var matrix;

                if (geometry2.isMesh) {

                    geometry2.matrixAutoUpdate && geometry2.updateMatrix();

                    matrix = geometry2.matrix;
                    geometry2 = geometry2.geometry;

                }

                geometry1.merge(geometry2, matrix, materialIndexOffset);

            },

            center: function (geometry) {

                console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
                return geometry.center();

            }

        };

        var ImageUtils = {

            crossOrigin: undefined,

            loadTexture: function (url, mapping, onLoad, onError) {

                console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');

                var loader = new TextureLoader();
                loader.setCrossOrigin(this.crossOrigin);

                var texture = loader.load(url, onLoad, undefined, onError);

                if (mapping) texture.mapping = mapping;

                return texture;

            },

            loadTextureCube: function (urls, mapping, onLoad, onError) {

                console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');

                var loader = new CubeTextureLoader();
                loader.setCrossOrigin(this.crossOrigin);

                var texture = loader.load(urls, onLoad, undefined, onError);

                if (mapping) texture.mapping = mapping;

                return texture;

            },

            loadCompressedTexture: function () {

                console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');

            },

            loadCompressedTextureCube: function () {

                console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');

            }

        };

        //

        function Projector() {

            console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');

            this.projectVector = function (vector, camera) {

                console.warn('THREE.Projector: .projectVector() is now vector.project().');
                vector.project(camera);

            };

            this.unprojectVector = function (vector, camera) {

                console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
                vector.unproject(camera);

            };

            this.pickingRay = function () {

                console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');

            };

        }

        //

        function CanvasRenderer() {

            console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');

            this.domElement = document.createElement('canvas');
            this.clear = function () {
            };
            this.render = function () {
            };
            this.setClearColor = function () {
            };
            this.setSize = function () {
            };

        }

        exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
        exports.WebGLRenderTarget = WebGLRenderTarget;
        exports.WebGLRenderer = WebGLRenderer;
        exports.ShaderLib = ShaderLib;
        exports.UniformsLib = UniformsLib;
        exports.UniformsUtils = UniformsUtils;
        exports.ShaderChunk = ShaderChunk;
        exports.FogExp2 = FogExp2;
        exports.Fog = Fog;
        exports.Scene = Scene;
        exports.LensFlare = LensFlare;
        exports.Sprite = Sprite;
        exports.LOD = LOD;
        exports.SkinnedMesh = SkinnedMesh;
        exports.Skeleton = Skeleton;
        exports.Bone = Bone;
        exports.Mesh = Mesh;
        exports.LineSegments = LineSegments;
        exports.LineLoop = LineLoop;
        exports.Line = Line;
        exports.Points = Points;
        exports.Group = Group;
        exports.VideoTexture = VideoTexture;
        exports.DataTexture = DataTexture;
        exports.CompressedTexture = CompressedTexture;
        exports.CubeTexture = CubeTexture;
        exports.CanvasTexture = CanvasTexture;
        exports.DepthTexture = DepthTexture;
        exports.Texture = Texture;
        exports.CompressedTextureLoader = CompressedTextureLoader;
        exports.DataTextureLoader = DataTextureLoader;
        exports.CubeTextureLoader = CubeTextureLoader;
        exports.TextureLoader = TextureLoader;
        exports.ObjectLoader = ObjectLoader;
        exports.MaterialLoader = MaterialLoader;
        exports.BufferGeometryLoader = BufferGeometryLoader;
        exports.DefaultLoadingManager = DefaultLoadingManager;
        exports.LoadingManager = LoadingManager;
        exports.JSONLoader = JSONLoader;
        exports.ImageLoader = ImageLoader;
        exports.FontLoader = FontLoader;
        exports.FileLoader = FileLoader;
        exports.Loader = Loader;
        exports.Cache = Cache;
        exports.AudioLoader = AudioLoader;
        exports.SpotLightShadow = SpotLightShadow;
        exports.SpotLight = SpotLight;
        exports.PointLight = PointLight;
        exports.RectAreaLight = RectAreaLight;
        exports.HemisphereLight = HemisphereLight;
        exports.DirectionalLightShadow = DirectionalLightShadow;
        exports.DirectionalLight = DirectionalLight;
        exports.AmbientLight = AmbientLight;
        exports.LightShadow = LightShadow;
        exports.Light = Light;
        exports.StereoCamera = StereoCamera;
        exports.PerspectiveCamera = PerspectiveCamera;
        exports.OrthographicCamera = OrthographicCamera;
        exports.ArrayCamera = ArrayCamera;
        exports.Camera = Camera;
        exports.AudioListener = AudioListener;
        exports.PositionalAudio = PositionalAudio;
        exports.AudioContext = AudioContext;
        exports.AudioAnalyser = AudioAnalyser;
        exports.Audio = Audio;
        exports.VectorKeyframeTrack = VectorKeyframeTrack;
        exports.StringKeyframeTrack = StringKeyframeTrack;
        exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
        exports.NumberKeyframeTrack = NumberKeyframeTrack;
        exports.ColorKeyframeTrack = ColorKeyframeTrack;
        exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
        exports.PropertyMixer = PropertyMixer;
        exports.PropertyBinding = PropertyBinding;
        exports.KeyframeTrack = KeyframeTrack;
        exports.AnimationUtils = AnimationUtils;
        exports.AnimationObjectGroup = AnimationObjectGroup;
        exports.AnimationMixer = AnimationMixer;
        exports.AnimationClip = AnimationClip;
        exports.Uniform = Uniform;
        exports.InstancedBufferGeometry = InstancedBufferGeometry;
        exports.BufferGeometry = BufferGeometry;
        exports.Geometry = Geometry;
        exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
        exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
        exports.InterleavedBuffer = InterleavedBuffer;
        exports.InstancedBufferAttribute = InstancedBufferAttribute;
        exports.Face3 = Face3;
        exports.Object3D = Object3D;
        exports.Raycaster = Raycaster;
        exports.Layers = Layers;
        exports.EventDispatcher = EventDispatcher;
        exports.Clock = Clock;
        exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
        exports.LinearInterpolant = LinearInterpolant;
        exports.DiscreteInterpolant = DiscreteInterpolant;
        exports.CubicInterpolant = CubicInterpolant;
        exports.Interpolant = Interpolant;
        exports.Triangle = Triangle;
        exports.Math = _Math;
        exports.Spherical = Spherical;
        exports.Cylindrical = Cylindrical;
        exports.Plane = Plane;
        exports.Frustum = Frustum;
        exports.Sphere = Sphere;
        exports.Ray = Ray;
        exports.Matrix4 = Matrix4;
        exports.Matrix3 = Matrix3;
        exports.Box3 = Box3;
        exports.Box2 = Box2;
        exports.Line3 = Line3;
        exports.Euler = Euler;
        exports.Vector4 = Vector4;
        exports.Vector3 = Vector3;
        exports.Vector2 = Vector2;
        exports.Quaternion = Quaternion;
        exports.Color = Color;
        exports.ImmediateRenderObject = ImmediateRenderObject;
        exports.VertexNormalsHelper = VertexNormalsHelper;
        exports.SpotLightHelper = SpotLightHelper;
        exports.SkeletonHelper = SkeletonHelper;
        exports.PointLightHelper = PointLightHelper;
        exports.RectAreaLightHelper = RectAreaLightHelper;
        exports.HemisphereLightHelper = HemisphereLightHelper;
        exports.GridHelper = GridHelper;
        exports.PolarGridHelper = PolarGridHelper;
        exports.FaceNormalsHelper = FaceNormalsHelper;
        exports.DirectionalLightHelper = DirectionalLightHelper;
        exports.CameraHelper = CameraHelper;
        exports.BoxHelper = BoxHelper;
        exports.Box3Helper = Box3Helper;
        exports.PlaneHelper = PlaneHelper;
        exports.ArrowHelper = ArrowHelper;
        exports.AxesHelper = AxesHelper;
        exports.CatmullRomCurve3 = CatmullRomCurve3;
        exports.CubicBezierCurve3 = CubicBezierCurve3;
        exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
        exports.LineCurve3 = LineCurve3;
        exports.ArcCurve = ArcCurve;
        exports.EllipseCurve = EllipseCurve;
        exports.SplineCurve = SplineCurve;
        exports.CubicBezierCurve = CubicBezierCurve;
        exports.QuadraticBezierCurve = QuadraticBezierCurve;
        exports.LineCurve = LineCurve;
        exports.Shape = Shape;
        exports.Path = Path;
        exports.ShapePath = ShapePath;
        exports.Font = Font;
        exports.CurvePath = CurvePath;
        exports.Curve = Curve;
        exports.ShapeUtils = ShapeUtils;
        exports.SceneUtils = SceneUtils;
        exports.WebGLUtils = WebGLUtils;
        exports.ParametricGeometry = ParametricGeometry;
        exports.ParametricBufferGeometry = ParametricBufferGeometry;
        exports.TetrahedronGeometry = TetrahedronGeometry;
        exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
        exports.OctahedronGeometry = OctahedronGeometry;
        exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
        exports.IcosahedronGeometry = IcosahedronGeometry;
        exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
        exports.PolyhedronGeometry = PolyhedronGeometry;
        exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
        exports.TextGeometry = TextGeometry;
        exports.TextBufferGeometry = TextBufferGeometry;
        exports.SphereGeometry = SphereGeometry;
        exports.SphereBufferGeometry = SphereBufferGeometry;
        exports.RingGeometry = RingGeometry;
        exports.RingBufferGeometry = RingBufferGeometry;
        exports.PlaneGeometry = PlaneGeometry;
        exports.PlaneBufferGeometry = PlaneBufferGeometry;
        exports.ExtrudeGeometry = ExtrudeGeometry;
        exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
        exports.ShapeGeometry = ShapeGeometry;
        exports.ShapeBufferGeometry = ShapeBufferGeometry;
        exports.ConeGeometry = ConeGeometry;
        exports.ConeBufferGeometry = ConeBufferGeometry;
        exports.CylinderGeometry = CylinderGeometry;
        exports.CylinderBufferGeometry = CylinderBufferGeometry;
        exports.CircleGeometry = CircleGeometry;
        exports.CircleBufferGeometry = CircleBufferGeometry;
        exports.BoxGeometry = BoxGeometry;
        exports.BoxBufferGeometry = BoxBufferGeometry;
        exports.ShadowMaterial = ShadowMaterial;
        exports.SpriteMaterial = SpriteMaterial;
        exports.MeshPhongMaterial = MeshPhongMaterial;
        exports.MeshLambertMaterial = MeshLambertMaterial;
        exports.MeshBasicMaterial = MeshBasicMaterial;
        exports.Material = Material;
        exports.Float64BufferAttribute = Float64BufferAttribute;
        exports.Float32BufferAttribute = Float32BufferAttribute;
        exports.Uint32BufferAttribute = Uint32BufferAttribute;
        exports.Int32BufferAttribute = Int32BufferAttribute;
        exports.Uint16BufferAttribute = Uint16BufferAttribute;
        exports.Int16BufferAttribute = Int16BufferAttribute;
        exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
        exports.Uint8BufferAttribute = Uint8BufferAttribute;
        exports.Int8BufferAttribute = Int8BufferAttribute;
        exports.BufferAttribute = BufferAttribute;
        exports.REVISION = REVISION;
        exports.MOUSE = MOUSE;
        exports.CullFaceNone = CullFaceNone;
        exports.CullFaceBack = CullFaceBack;
        exports.CullFaceFront = CullFaceFront;
        exports.CullFaceFrontBack = CullFaceFrontBack;
        exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
        exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
        exports.BasicShadowMap = BasicShadowMap;
        exports.PCFShadowMap = PCFShadowMap;
        exports.PCFSoftShadowMap = PCFSoftShadowMap;
        exports.FrontSide = FrontSide;
        exports.BackSide = BackSide;
        exports.DoubleSide = DoubleSide;
        exports.FlatShading = FlatShading;
        exports.SmoothShading = SmoothShading;
        exports.NoColors = NoColors;
        exports.FaceColors = FaceColors;
        exports.VertexColors = VertexColors;
        exports.NoBlending = NoBlending;
        exports.NormalBlending = NormalBlending;
        exports.AdditiveBlending = AdditiveBlending;
        exports.SubtractiveBlending = SubtractiveBlending;
        exports.MultiplyBlending = MultiplyBlending;
        exports.CustomBlending = CustomBlending;
        exports.AddEquation = AddEquation;
        exports.SubtractEquation = SubtractEquation;
        exports.ReverseSubtractEquation = ReverseSubtractEquation;
        exports.MinEquation = MinEquation;
        exports.MaxEquation = MaxEquation;
        exports.ZeroFactor = ZeroFactor;
        exports.OneFactor = OneFactor;
        exports.SrcColorFactor = SrcColorFactor;
        exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
        exports.SrcAlphaFactor = SrcAlphaFactor;
        exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
        exports.DstAlphaFactor = DstAlphaFactor;
        exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
        exports.DstColorFactor = DstColorFactor;
        exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
        exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
        exports.NeverDepth = NeverDepth;
        exports.AlwaysDepth = AlwaysDepth;
        exports.LessDepth = LessDepth;
        exports.LessEqualDepth = LessEqualDepth;
        exports.EqualDepth = EqualDepth;
        exports.GreaterEqualDepth = GreaterEqualDepth;
        exports.GreaterDepth = GreaterDepth;
        exports.NotEqualDepth = NotEqualDepth;
        exports.MultiplyOperation = MultiplyOperation;
        exports.MixOperation = MixOperation;
        exports.AddOperation = AddOperation;
        exports.NoToneMapping = NoToneMapping;
        exports.LinearToneMapping = LinearToneMapping;
        exports.ReinhardToneMapping = ReinhardToneMapping;
        exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
        exports.CineonToneMapping = CineonToneMapping;
        exports.UVMapping = UVMapping;
        exports.CubeReflectionMapping = CubeReflectionMapping;
        exports.CubeRefractionMapping = CubeRefractionMapping;
        exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
        exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
        exports.SphericalReflectionMapping = SphericalReflectionMapping;
        exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
        exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
        exports.RepeatWrapping = RepeatWrapping;
        exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
        exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
        exports.NearestFilter = NearestFilter;
        exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
        exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
        exports.LinearFilter = LinearFilter;
        exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
        exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
        exports.UnsignedByteType = UnsignedByteType;
        exports.ByteType = ByteType;
        exports.ShortType = ShortType;
        exports.UnsignedShortType = UnsignedShortType;
        exports.IntType = IntType;
        exports.UnsignedIntType = UnsignedIntType;
        exports.FloatType = FloatType;
        exports.HalfFloatType = HalfFloatType;
        exports.UnsignedShort4444Type = UnsignedShort4444Type;
        exports.UnsignedShort5551Type = UnsignedShort5551Type;
        exports.UnsignedShort565Type = UnsignedShort565Type;
        exports.UnsignedInt248Type = UnsignedInt248Type;
        exports.AlphaFormat = AlphaFormat;
        exports.RGBFormat = RGBFormat;
        exports.RGBAFormat = RGBAFormat;
        exports.LuminanceFormat = LuminanceFormat;
        exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
        exports.RGBEFormat = RGBEFormat;
        exports.DepthFormat = DepthFormat;
        exports.DepthStencilFormat = DepthStencilFormat;
        exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
        exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
        exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
        exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
        exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
        exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
        exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
        exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
        exports.RGB_ETC1_Format = RGB_ETC1_Format;
        exports.LoopOnce = LoopOnce;
        exports.LoopRepeat = LoopRepeat;
        exports.LoopPingPong = LoopPingPong;
        exports.InterpolateDiscrete = InterpolateDiscrete;
        exports.InterpolateLinear = InterpolateLinear;
        exports.InterpolateSmooth = InterpolateSmooth;
        exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
        exports.ZeroSlopeEnding = ZeroSlopeEnding;
        exports.WrapAroundEnding = WrapAroundEnding;
        exports.TrianglesDrawMode = TrianglesDrawMode;
        exports.TriangleStripDrawMode = TriangleStripDrawMode;
        exports.TriangleFanDrawMode = TriangleFanDrawMode;
        exports.LinearEncoding = LinearEncoding;
        exports.sRGBEncoding = sRGBEncoding;
        exports.GammaEncoding = GammaEncoding;
        exports.RGBEEncoding = RGBEEncoding;
        exports.LogLuvEncoding = LogLuvEncoding;
        exports.RGBM7Encoding = RGBM7Encoding;
        exports.RGBM16Encoding = RGBM16Encoding;
        exports.RGBDEncoding = RGBDEncoding;
        exports.BasicDepthPacking = BasicDepthPacking;
        exports.RGBADepthPacking = RGBADepthPacking;
        exports.CubeGeometry = BoxGeometry;
        exports.Face4 = Face4;
        exports.LineStrip = LineStrip;
        exports.LinePieces = LinePieces;
        exports.MeshFaceMaterial = MeshFaceMaterial;
        exports.MultiMaterial = MultiMaterial;
        exports.PointCloud = PointCloud;
        exports.Particle = Particle;
        exports.ParticleSystem = ParticleSystem;
        exports.PointCloudMaterial = PointCloudMaterial;
        exports.ParticleBasicMaterial = ParticleBasicMaterial;
        exports.ParticleSystemMaterial = ParticleSystemMaterial;
        exports.Vertex = Vertex;
        exports.DynamicBufferAttribute = DynamicBufferAttribute;
        exports.Int8Attribute = Int8Attribute;
        exports.Uint8Attribute = Uint8Attribute;
        exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
        exports.Int16Attribute = Int16Attribute;
        exports.Uint16Attribute = Uint16Attribute;
        exports.Int32Attribute = Int32Attribute;
        exports.Uint32Attribute = Uint32Attribute;
        exports.Float32Attribute = Float32Attribute;
        exports.Float64Attribute = Float64Attribute;
        exports.ClosedSplineCurve3 = ClosedSplineCurve3;
        exports.SplineCurve3 = SplineCurve3;
        exports.Spline = Spline;
        exports.AxisHelper = AxisHelper;
        exports.BoundingBoxHelper = BoundingBoxHelper;
        exports.EdgesHelper = EdgesHelper;
        exports.WireframeHelper = WireframeHelper;
        exports.XHRLoader = XHRLoader;
        exports.BinaryTextureLoader = BinaryTextureLoader;
        exports.GeometryUtils = GeometryUtils;
        exports.ImageUtils = ImageUtils;
        exports.Projector = Projector;
        exports.CanvasRenderer = CanvasRenderer;

        Object.defineProperty(exports, '__esModule', {value: true});

    })));

});
define("js/lib/tween.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = {
        Linear: function (t, n, e, u) {
            return e * t / u + n
        }, Quad: {
            easeIn: function (t, n, e, u) {
                return e * (t /= u) * t + n
            }, easeOut: function (t, n, e, u) {
                return -e * (t /= u) * (t - 2) + n
            }, easeInOut: function (t, n, e, u) {
                return (t /= u / 2) < 1 ? e / 2 * t * t + n : -e / 2 * (--t * (t - 2) - 1) + n
            }
        }, Cubic: {
            easeIn: function (t, n, e, u) {
                return e * (t /= u) * t * t + n
            }, easeOut: function (t, n, e, u) {
                return e * ((t = t / u - 1) * t * t + 1) + n
            }, easeInOut: function (t, n, e, u) {
                return (t /= u / 2) < 1 ? e / 2 * t * t * t + n : e / 2 * ((t -= 2) * t * t + 2) + n
            }
        }, Quart: {
            easeIn: function (t, n, e, u) {
                return e * (t /= u) * t * t * t + n
            }, easeOut: function (t, n, e, u) {
                return -e * ((t = t / u - 1) * t * t * t - 1) + n
            }, easeInOut: function (t, n, e, u) {
                return (t /= u / 2) < 1 ? e / 2 * t * t * t * t + n : -e / 2 * ((t -= 2) * t * t * t - 2) + n
            }
        }, Quint: {
            easeIn: function (t, n, e, u) {
                return e * (t /= u) * t * t * t * t + n
            }, easeOut: function (t, n, e, u) {
                return e * ((t = t / u - 1) * t * t * t * t + 1) + n
            }, easeInOut: function (t, n, e, u) {
                return (t /= u / 2) < 1 ? e / 2 * t * t * t * t * t + n : e / 2 * ((t -= 2) * t * t * t * t + 2) + n
            }
        }, Sine: {
            easeIn: function (t, n, e, u) {
                return -e * Math.cos(t / u * (Math.PI / 2)) + e + n
            }, easeOut: function (t, n, e, u) {
                return e * Math.sin(t / u * (Math.PI / 2)) + n
            }, easeInOut: function (t, n, e, u) {
                return -e / 2 * (Math.cos(Math.PI * t / u) - 1) + n
            }
        }, Expo: {
            easeIn: function (t, n, e, u) {
                return 0 == t ? n : e * Math.pow(2, 10 * (t / u - 1)) + n
            }, easeOut: function (t, n, e, u) {
                return t == u ? n + e : e * (1 - Math.pow(2, -10 * t / u)) + n
            }, easeInOut: function (t, n, e, u) {
                return 0 == t ? n : t == u ? n + e : (t /= u / 2) < 1 ? e / 2 * Math.pow(2, 10 * (t - 1)) + n : e / 2 * (2 - Math.pow(2, -10 * --t)) + n
            }
        }, Circ: {
            easeIn: function (t, n, e, u) {
                return -e * (Math.sqrt(1 - (t /= u) * t) - 1) + n
            }, easeOut: function (t, n, e, u) {
                return e * Math.sqrt(1 - (t = t / u - 1) * t) + n
            }, easeInOut: function (t, n, e, u) {
                return (t /= u / 2) < 1 ? -e / 2 * (Math.sqrt(1 - t * t) - 1) + n : e / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + n
            }
        }, Elastic: {
            easeIn: function (t, n, e, u, a, r) {
                var o;
                return 0 == t ? n : 1 == (t /= u) ? n + e : (void 0 === r && (r = .3 * u), !a || a < Math.abs(e) ? (o = r / 4, a = e) : o = r / (2 * Math.PI) * Math.asin(e / a), -a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * u - o) * (2 * Math.PI) / r) + n)
            }, easeOut: function (t, n, e, u, a, r) {
                var o;
                return 0 == t ? n : 1 == (t /= u) ? n + e : (void 0 === r && (r = .3 * u), !a || a < Math.abs(e) ? (a = e, o = r / 4) : o = r / (2 * Math.PI) * Math.asin(e / a), a * Math.pow(2, -10 * t) * Math.sin((t * u - o) * (2 * Math.PI) / r) + e + n)
            }, easeInOut: function (t, n, e, u, a, r) {
                var o;
                return 0 == t ? n : 2 == (t /= u / 2) ? n + e : (void 0 === r && (r = u * (.3 * 1.5)), !a || a < Math.abs(e) ? (a = e, o = r / 4) : o = r / (2 * Math.PI) * Math.asin(e / a), t < 1 ? a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * u - o) * (2 * Math.PI) / r) * -.5 + n : a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * u - o) * (2 * Math.PI) / r) * .5 + e + n)
            }
        }, Back: {
            easeIn: function (t, n, e, u, a) {
                return void 0 === a && (a = 1.70158), e * (t /= u) * t * ((a + 1) * t - a) + n
            }, easeOut: function (t, n, e, u, a) {
                return void 0 === a && (a = 1.70158), e * ((t = t / u - 1) * t * ((a + 1) * t + a) + 1) + n
            }, easeInOut: function (t, n, e, u, a) {
                return void 0 === a && (a = 1.70158), (t /= u / 2) < 1 ? e / 2 * (t * t * ((1 + (a *= 1.525)) * t - a)) + n : e / 2 * ((t -= 2) * t * ((1 + (a *= 1.525)) * t + a) + 2) + n
            }
        }, Bounce: {
            easeIn: function (n, e, u, a) {
                return u - t.Bounce.easeOut(a - n, 0, u, a) + e
            }, easeOut: function (t, n, e, u) {
                return (t /= u) < 1 / 2.75 ? e * (7.5625 * t * t) + n : t < 2 / 2.75 ? e * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + n : t < 2.5 / 2.75 ? e * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + n : e * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + n
            }, easeInOut: function (n, e, u, a) {
                return n < a / 2 ? .5 * t.Bounce.easeIn(2 * n, 0, u, a) + e : .5 * t.Bounce.easeOut(2 * n - a, 0, u, a) + .5 * u + e
            }
        }
    };
    exports.default = t;
});
define("js/network/network.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function a(e, a) {
        if (!(e instanceof a)) throw new TypeError("Cannot call a class as a function")
    }

    function s(e, a) {
        var s = a ? e + "(" + a + ")" : e;
        wx.showModal({title: "", content: s, showCancel: !1})
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, a) {
            for (var s = 0; s < a.length; s++) {
                var t = a[s];
                t.enumerable = t.enumerable || !1, t.configurable = !0, "value" in t && (t.writable = !0), Object.defineProperty(e, t.key, t)
            }
        }

        return function (a, s, t) {
            return s && e(a.prototype, s), t && e(a, t), a
        }
    }();
    exports.upLoadVerifyPic = function (e) {
        var a = e.path || "", t = e.succ || function () {
            console.log("upLoadVerifyPic need succ func")
        }, o = e.complete || function () {
            console.log("upLoadVerifyPic need complete func")
        }, i = n.default.sessionId || "";
        if (!a || !i) return console.log("upLoadVerifyPic need session_id" + i + "upLoadVerifyPic need path" + a), o(), void s("", "n0");
        console.log(u.AJAX_URL + "/wxagame/wxagame_filetransfer?action=preview"), wx.uploadFile({
            url: u.AJAX_URL + "/wxagame/wxagame_filetransfer?action=preview",
            filePath: a,
            name: "file",
            formData: {base_req: JSON.stringify({session_id: i, fast: 1})},
            success: function (e) {
                if (console.log("upLoadVerifyPic success", e), 200 == e.statusCode) if (e.data) {
                    var a = JSON.parse(e.data);
                    if (a.base_resp && 0 == a.base_resp.errcode) {
                        var n = a.content;
                        t(n)
                    } else s("", "e" + a.base_resp.errcode)
                } else s("", "no res data"); else s("", "s" + e.statusCode)
            },
            fail: function (e) {
                console.log("upLoadVerifyPic fail", e), s("", "n1")
            },
            complete: function () {
                o()
            }
        })
    }, exports.upLoadVerifySubmit = function (e) {
        var a = n.default.sessionId || "", t = e.complete || function () {
            console.log("upLoadVerifySubmit need complete func")
        }, o = e.succ || function () {
            console.log("upLoadVerifySubmit need succ func")
        }, i = String(e.name), r = String(e.mobile), d = String(e.fileid), f = Number.parseInt(e.is_async) || 0;
        if (!a) return console.log("upLoadVerifySubmit need session_id" + a), s("", "n0"), void t();
        var c = {
            base_req: {session_id: n.default.sessionId, fast: 1},
            name: i,
            phone_number: r,
            photo_id: d,
            is_async: f
        };
        wx.request({
            url: u.AJAX_URL + "/wxagame/wxagame_appeal?action=submit",
            method: "POST",
            data: c,
            success: function (e) {
                200 === e.statusCode ? e.data && e.data.base_resp && 0 === e.data.base_resp.errcode ? o() : s("", "e" + e.data.base_resp.errcode) : s("", "s" + e.statusCode)
            },
            fail: function () {
                s("", "n1")
            },
            complete: function () {
                t()
            }
        })
    };
    var n = e(require("../store/session")), o = e(require("../store/storage")), i = require("../util/encryption"),
        r = require("./../config"), u = (e(require("../lib/mue/eventcenter")), {AJAX_URL: "https://mp.weixin.qq.com"}),
        d = function () {
            function e() {
                a(this, e)
            }

            return t(e, null, [{
                key: "onServerConfigForbid", value: function (e) {
                    this.emmitServerConfigForbid = e
                }
            }, {
                key: "getUserInfo", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    }, a = {base_req: {session_id: n.default.sessionId, fast: 1}};
                    return new Promise(function (s, t) {
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_getuserinfo",
                            method: "POST",
                            data: a,
                            success: function (a) {
                                if (200 === a.statusCode) if (0 === a.data.base_resp.errcode) {
                                    e(a.data);
                                    var n = {
                                        nickname: a.data.nickname,
                                        headimg: a.data.headimg,
                                        open_id: a.data.open_id
                                    };
                                    o.default.saveMyUserInfo(n), s(a.data)
                                } else t(); else t()
                            },
                            fail: function (e) {
                                t()
                            }
                        })
                    })
                }
            }, {
                key: "requestLogin", value: function (e) {
                    e || (e = function () {
                    }), wx.login({
                        success: function (a) {
                            a.code ? (n.default.setLoginState(a.code), e(!0)) : e(!1)
                        }, fail: function (a) {
                            e(!1)
                        }
                    })
                }
            }, {
                key: "requestFriendsScore", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    };
                    if (!n.default.serverConfig || n.default.serverConfig.friends_score_switch) {
                        if (n.default.sessionId) {
                            var a = {base_req: {session_id: n.default.sessionId, fast: 1}};
                            return new Promise(function (s, t) {
                                wx.request({
                                    url: u.AJAX_URL + "/wxagame/wxagame_getfriendsscore",
                                    method: "POST",
                                    data: a,
                                    success: function (a) {
                                        200 === a.statusCode && 0 === a.data.base_resp.errcode ? (e(!0, a.data), s(a.data)) : e && e(!1)
                                    },
                                    fail: function (a) {
                                        e(!1, !1), t()
                                    }
                                })
                            })
                        }
                        e(!1)
                    }
                }
            }, {
                key: "requestSettlement", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {
                        }, t = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                    if (n.default.sessionId) {
                        var o = {score: e, times: a, game_data: JSON.stringify(t)}, r = {
                            base_req: {session_id: n.default.sessionId, fast: 1},
                            action_data: (0, i.encrypt)(o, n.default.sessionId)
                        };
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_settlement",
                            method: "POST",
                            data: r,
                            success: function (e) {
                                if (200 === e.statusCode) if (0 === e.data.base_resp.errcode) {
                                    var a = e.data.cheater_status || 0;
                                    if (1 == (e.data.appeal_status || 0)) s(!0, {banType: 2}, e.data); else switch (a) {
                                        case 1:
                                            s(!0, {banType: 3}, e.data);
                                            break;
                                        case 2:
                                            s(!0, {banType: 1}, e.data);
                                            break;
                                        default:
                                            s(!0, {banType: 0}, e.data)
                                    }
                                } else s(!1, "e" + e.data.base_resp.errcode); else s(!1, "s" + e.statusCode)
                            },
                            fail: function (e) {
                                s(!1, "n1")
                            }
                        })
                    } else s(!1, "n0")
                }
            }, {
                key: "requestCreateGame", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    };
                    if (!n.default.serverConfig || n.default.serverConfig.audience_mode_switch) {
                        n.default.sessionId || this.reGetSessionId("requestCreateGame", e);
                        var a = {base_req: {session_id: n.default.sessionId, fast: 1}};
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_creategame",
                            method: "POST",
                            data: a,
                            success: function (a) {
                                200 === a.statusCode && 0 === a.data.base_resp.errcode ? e(!0, a) : e(!1)
                            },
                            fail: function (a) {
                                e(!1)
                            }
                        })
                    } else e(!1, "")
                }
            }, {
                key: "reGetSessionId", value: function (e, a) {
                    var s = this;
                    o.default.clearSessionId(), this.requestLogin(function (t) {
                        t ? a ? s[e](a) : s[e]() : a && a(!1)
                    })
                }
            }, {
                key: "requestInit", value: function (e) {
                    if (n.default.sessionId) if (n.default.serverConfig) {
                        var a = n.default.serverConfig.version;
                        this.requestServerInit(a, e)
                    } else this.requestServerInit(0, e)
                }
            }, {
                key: "requestServerInit", value: function (e) {
                    var a = {base_req: {session_id: n.default.sessionId, fast: 1}, version: e};
                    wx.request({
                        url: u.AJAX_URL + "/wxagame/wxagame_init",
                        method: "POST",
                        data: a,
                        success: function (e) {
                            200 === e.statusCode && 0 === e.data.base_resp.errcode && (e.data.version > n.default.serverConfig.version || !n.default.serverConfig.version) && (n.default.setServerConfig(e.data), o.default.saveServerConfig(e.data))
                        },
                        fail: function (e) {
                        }
                    })
                }
            }, {
                key: "requestMmpayBonus", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    };
                    if (n.default.sessionId) {
                        var a = {base_req: {session_id: n.default.sessionId, fast: 1}};
                        console.log("---------------request MMPAY"), wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_getuserstatus",
                            method: "POST",
                            data: a,
                            success: function (a) {
                                200 === a.statusCode ? a.data && 0 !== a.data.base_resp.errcode ? e(!1, a) : a.data ? e(!0, a) : e(!1, a) : e(!1, a)
                            },
                            fail: function (a) {
                                e(!1, a)
                            }
                        })
                    } else e(!1)
                }
            }, {
                key: "getGroupScore", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    };
                    if (n.default.sessionId) {
                        var a = {
                            base_req: {
                                session_id: n.default.sessionId,
                                fast: 1,
                                group_info: {share_ticket: n.default.shareTicket}
                            }
                        };
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_getgrouprank",
                            method: "POST",
                            data: a,
                            success: function (a) {
                                200 === a.statusCode && 0 === a.data.base_resp.errcode ? e(!0, a) : e(!1)
                            },
                            fail: function (a) {
                                e(!1)
                            }
                        })
                    } else e(!1)
                }
            }, {
                key: "createPK", value: function (e) {
                    return new Promise(function (a, s) {
                        if (n.default.sessionId) {
                            wx.showLoading();
                            var t = {base_req: {session_id: n.default.sessionId, fast: 1}, score: e};
                            wx.request({
                                url: u.AJAX_URL + "/wxagame/wxagame_createpk",
                                method: "POST",
                                data: t,
                                success: function (e) {
                                    200 === e.statusCode && 0 === e.data.base_resp.errcode ? (n.default.setPkId(e.data.pk_id), a()) : s()
                                },
                                fail: function (e) {
                                    s()
                                },
                                complete: function () {
                                    wx.hideLoading()
                                }
                            })
                        } else s()
                    })
                }
            }, {
                key: "getBattleData", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    }, a = arguments[1];
                    if (n.default.sessionId && a) {
                        var s = {base_req: {session_id: n.default.sessionId, fast: 1}, pk_id: a};
                        n.default.shareTicket && (s.base_req.group_info = {share_ticket: n.default.shareTicket}), wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_getpkinfo",
                            method: "POST",
                            data: s,
                            success: function (a) {
                                200 === a.statusCode && 0 === a.data.base_resp.errcode ? e(!0, a) : e(!1)
                            },
                            fail: function (a) {
                                e(!1)
                            }
                        })
                    } else e(!1)
                }
            }, {
                key: "updatepkinfo", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    }, a = arguments[1], s = arguments[2];
                    if (n.default.sessionId && a) {
                        var t = {base_req: {session_id: n.default.sessionId, fast: 1}, pk_id: a, score: s};
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_updatepkinfo",
                            method: "POST",
                            data: t,
                            success: function (a) {
                                200 === a.statusCode && 0 === a.data.base_resp.errcode ? e(!0, a) : e(!1)
                            },
                            fail: function (a) {
                                e(!1)
                            }
                        })
                    } else e(!1)
                }
            }, {
                key: "quitGame", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    };
                    if (n.default.gameId || n.default.sessionId) {
                        var a = {base_req: {session_id: n.default.sessionId, fast: 1}, game_id: n.default.gameId};
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_quitgame",
                            method: "POST",
                            data: a,
                            success: function (a) {
                                200 === a.statusCode && 0 === a.data.base_resp.errcode ? e(!0, a) : e(!1)
                            },
                            fail: function (a) {
                                e(!1)
                            }
                        })
                    } else e(!1)
                }
            }, {
                key: "syncop", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    };
                    if (n.default.gameId || n.default.sessionId) {
                        var a = {base_req: {session_id: n.default.sessionId, fast: 1}, game_id: n.default.gameId};
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_syncop",
                            method: "POST",
                            data: a,
                            success: function (a) {
                                200 === a.statusCode && 0 === a.data.base_resp.errcode ? e(!0, a) : e(!1)
                            },
                            fail: function (a) {
                                e(!1)
                            }
                        })
                    } else callback(!1)
                }
            }, {
                key: "sendReport", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                        a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (n.default.sessionId) {
                        var s = {base_req: {session_id: n.default.sessionId, fast: 1, client_info: a}, report_list: e};
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_bottlereport",
                            method: "POST",
                            data: s,
                            success: function (e) {
                            },
                            fail: function () {
                            }
                        })
                    }
                }
            }, {
                key: "sendEggReport", value: function (e) {
                    if (n.default.sessionId) {
                        var a = {base_req: {session_id: n.default.sessionId, fast: 1}, egg_info_list: e};
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_eggreport",
                            method: "POST",
                            data: a,
                            success: function (e) {
                                console.log("Network sendEggReport success", e)
                            },
                            fail: function () {
                                console.log("Network sendEggReport fail")
                            }
                        })
                    }
                }
            }, {
                key: "badReport", value: function (e, a) {
                    var s = wx.getSystemInfoSync(), t = n.default.sessionId || "",
                        e = "nickName:" + o.default.getMyUserInfo().nickname + ",model:" + s.model + ",SDKVersion:" + s.SDKVersion + ",version:" + s.version + ",subVersion:" + r.SUBVERSION + ",sessionId:" + t + ",errmsg:" + e + ",stack:" + a;
                    this.requestBadjs(130, e)
                }
            }, {
                key: "logReport", value: function (e) {
                    var a = wx.getSystemInfoSync(),
                        s = (n.default.sessionId, "nickName:" + o.default.getMyUserInfo().nickname + ",model:" + a.model + ",SDKVersion:" + a.SDKVersion + ",version:" + a.version + ",subVersion:" + r.SUBVERSION + ",logMsg:" + e);
                    this.requestBadjs(150, s)
                }
            }, {
                key: "requestBadjs", value: function (e, a) {
                    wx.request({
                        url: "https://badjs.weixinbridge.com/badjs",
                        data: {id: e, level: 4, msg: a + "$"},
                        success: function (e) {
                        },
                        fail: function (e) {
                        }
                    })
                }
            }, {
                key: "sendServerError", value: function (e) {
                    if (n.default.sessionId) {
                        var a = {base_req: {session_id: n.default.sessionId, fast: 1}, id: 3, key: e};
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_jsreport",
                            method: "POST",
                            data: a,
                            success: function (e) {
                            },
                            fail: function () {
                            }
                        })
                    }
                }
            }, {
                key: "createRouterId", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    };
                    if (n.default.sessionId) {
                        var a = {base_req: {session_id: n.default.sessionId, fast: 1}};
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_allocrouteid",
                            method: "POST",
                            data: a,
                            success: function (a) {
                                200 === a.statusCode ? a.data && a.data.base_resp && 0 === a.data.base_resp.errcode ? (e(!0, a.data.route_id), console.log("Network createRouterId: ", a.data.route_id)) : e(!1, "e" + a.data.base_resp.errcode) : e(!1, "s" + a.statusCode)
                            },
                            fail: function (a) {
                                e(!1, "n1")
                            }
                        })
                    } else e(!1, "n0")
                }
            }, {
                key: "getWeeklyPlayBack", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                    }, a = arguments[1];
                    if (n.default.sessionId && a) {
                        var s = {
                            base_req: {session_id: n.default.sessionId, fast: 1},
                            action: "weekly_rank",
                            playback_id: a
                        };
                        wx.request({
                            url: u.AJAX_URL + "/wxagame/wxagame_playback",
                            method: "POST",
                            data: s,
                            success: function (a) {
                                200 === a.statusCode ? a.data && 0 !== a.data.base_resp.errcode ? e(!1, a) : a.data && a.data.game_data ? e(!0, JSON.parse(a.data.game_data)) : e(!1, a) : e(!1, a)
                            },
                            fail: function (a) {
                                e(!1, a)
                            }
                        })
                    } else e(!1)
                }
            }]), e
        }();
    exports.default = d;
});
define("js/network/relayMoniter.js", function (require, module, exports) {
    "use strict";

    function t(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var e = function () {
        function t(t, e) {
            for (var i = 0; i < e.length; i++) {
                var o = e[i];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o)
            }
        }

        return function (e, i, o) {
            return i && t(e.prototype, i), o && t(e, o), e
        }
    }(), i = function () {
        function i(e) {
            t(this, i), this.optionReport = e.report || function () {
            }, this.duration = e.duration || 7e3, this.logMessage = "", this.logMaxLength = e.logMaxLength || 5e3, this.timeout = null, this.haveReport = 0
        }

        return e(i, [{
            key: "start", value: function () {
                var t = this;
                this.timeout || this.haveReport || (this.timeout = setTimeout(function () {
                    t.report()
                }, this.duration))
            }
        }, {
            key: "pulse", value: function () {
                var t = this;
                this.timeout && (this.rpClearTimeout(), this.timeout = setTimeout(function () {
                    t.report()
                }, this.duration))
            }
        }, {
            key: "stop", value: function () {
                this.rpClearTimeout()
            }
        }, {
            key: "rpClearTimeout", value: function () {
                this.timeout && (clearTimeout(this.timeout), this.timeout = null)
            }
        }, {
            key: "report", value: function () {
                this.haveReport = 1, this.optionReport(this.logMessage), this.logMessage = ""
            }
        }, {
            key: "log", value: function () {
                for (var t = arguments.length, e = Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                var o = e.join(";;;");
                if (o) {
                    this.logMessage += o;
                    var n = this.logMessage.length;
                    if (n > this.logMaxLength) {
                        var r = n - this.logMaxLength;
                        this.logMessage = this.logMessage.slice(r, n)
                    }
                }
            }
        }]), i
    }();
    exports.default = i;
});
define("js/network/reporter.js", function (require, module, exports) {
    "use strict";

    function t(t) {
        return t && t.__esModule ? t : {default: t}
    }

    function e(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var r = e[i];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
                }
            }

            return function (e, i, r) {
                return i && t(e.prototype, i), r && t(e, r), e
            }
        }(), r = t(require("./network")), s = require("../config"), a = t(require("../lib/mue/eventcenter")),
        o = function () {
            function t() {
                e(this, t), this.timeOut = null, this.reportList = [], this.pkState = {
                    isGroup: 0,
                    score: 0
                }, this.singleState = 0, this.observeState = {
                    startTime: 0,
                    success: 0
                }, this.playerState = {startTime: 0, maxAudience: 0}, this.gameStartTime = 0;
                try {
                    var i = wx.getSystemInfoSync();
                    this.clientInfo = {platform: i.platform, brand: i.brand, model: i.model, system: i.system}
                } catch (t) {
                    console.log(t)
                }
                this.relayGameStartTime = 0, this.bindEvent()
            }

            return i(t, [{
                key: "bindEvent", value: function () {
                    var t = this;
                    a.default.on(s.EVENT.CREATE_RELAY_ROOM_FAIL, function (e, i) {
                        t.reportCreateRelayRoom(i)
                    }), a.default.on(s.EVENT.RP_JOIN_RELAY_ROOM_AGAIN, function (e, i) {
                        t.reportPlayGameAgain({result: i.res})
                    }), a.default.on(s.EVENT.RP_JOIN_RELAY_ROOM, function (e, i) {
                        t.reportJoinRelayRoom(i)
                    }), a.default.on(s.EVENT.RP_RELAY_START, function (e, i) {
                        t.relayGameStartTime = t.getTime(), t.reportRelayStart(i), t.sendReport()
                    }), a.default.on(s.EVENT.RP_RELAY_GAME_END, function (e, i) {
                        var r = 0;
                        t.relayGameStartTime && (r = t.getTime() - t.relayGameStartTime), i.duration = r, t.reportRelayEnd(i)
                    })
                }
            }, {
                key: "getTime", value: function () {
                    var t = Date.now();
                    return t = Math.floor(t / 1e3)
                }
            }, {
                key: "enterReport", value: function (t) {
                    if (this.gameStartTime = this.getTime(), t) {
                        var e = {ts: this.getTime(), type: 0, scene: t};
                        this.reportList.push(e)
                    }
                }
            }, {
                key: "quitReport", value: function () {
                    if (this.gameStartTime) {
                        var t = {ts: this.getTime(), type: 1, duration: this.getTime() - this.gameStartTime};
                        this.reportList.push(t)
                    }
                }
            }, {
                key: "playGameReport", value: function (t, e, i) {
                    if (this.singleState) {
                        var r = {
                            ts: this.getTime(),
                            type: 2,
                            score: t,
                            best_score: e,
                            break_record: t > e ? 1 : 0,
                            duration: this.getTime() - this.singleState,
                            times: i
                        };
                        this.reportList.push(r), this.singleState = 0
                    }
                }
            }, {
                key: "addEggBlockReport", value: function () {
                    for (var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], a = [], o = 13; o < 33; ++o) t[o] && a.push({
                        id: o,
                        count: t[o],
                        type: 0
                    }), e[o] && a.push({id: o, count: t[o], type: 1}), i[o] && a.push({
                        id: o,
                        count: t[o],
                        type: 2
                    }), s[o] && a.push({id: o, count: t[o], type: 3});
                    r.default.sendEggReport(a)
                }
            }, {
                key: "playGameReportStart", value: function () {
                    this.singleState = this.getTime()
                }
            }, {
                key: "shareAudienceReport", value: function (t) {
                    var e = {ts: this.getTime(), type: 3, is_group: t};
                    this.reportList.push(e)
                }
            }, {
                key: "playAudienceReport", value: function () {
                    if (this.playerState.startTime) {
                        var t = {
                            ts: this.getTime(),
                            type: 4,
                            duration: this.getTime() - this.playerState.startTime,
                            max_audience: this.playerState.maxAudience
                        };
                        this.reportList.push(t), this.playerState.startTime = 0, this.playerState.maxAudience = 0
                    }
                }
            }, {
                key: "playAudienceReportStart", value: function () {
                    this.playerState.startTime = this.getTime()
                }
            }, {
                key: "playAudienceReportMaxPeople", value: function (t) {
                    this.playerState.maxAudience < t && (this.playerState.maxAudience = t)
                }
            }, {
                key: "joinAudienceReport", value: function () {
                    var t = 0 == this.observeState.startTime ? 0 : this.getTime() - this.observeState.startTime, e = {
                        ts: this.getTime(),
                        type: 5,
                        duration: t,
                        join_audience_success: this.observeState.success
                    };
                    this.reportList.push(e), this.observeState.startTime = 0, this.observeState.success = 0
                }
            }, {
                key: "joinAudienceReportStart", value: function () {
                    this.observeState.startTime = this.getTime(), this.observeState.success = 1
                }
            }, {
                key: "shareGroupReport", value: function (t) {
                    var e = {ts: this.getTime(), type: 6, is_group: t};
                    this.reportList.push(e)
                }
            }, {
                key: "sharePKReport", value: function (t) {
                    var e = {ts: this.getTime(), type: 7, is_group: t};
                    this.reportList.push(e)
                }
            }, {
                key: "joinPKReport", value: function (t) {
                    var e = {ts: this.getTime(), type: 8, is_group: t};
                    this.reportList.push(e)
                }
            }, {
                key: "playPKReport", value: function (t) {
                    var e = 0;
                    t == this.pkState.score && (e = 1), t > this.pkState.score && (e = 3);
                    var i = {ts: this.getTime(), type: 9, is_group: this.pkState.isGroup, result: e};
                    this.reportList.push(i)
                }
            }, {
                key: "playPKReportStart", value: function (t) {
                    this.pkState.isGroup = t
                }
            }, {
                key: "playPKScore", value: function (t) {
                    this.pkState.score = t
                }
            }, {
                key: "resetPKReport", value: function () {
                    this.pkState.isGroup = 0, this.pkState.score = 0
                }
            }, {
                key: "gameBeginReport", value: function () {
                    var t = {ts: this.getTime(), type: 10};
                    this.reportList.push(t)
                }
            }, {
                key: "reportGotoRelayMode", value: function () {
                    var t = {ts: this.getTime(), type: 11};
                    this.reportList.push(t)
                }
            }, {
                key: "reportCreateRelayRoom", value: function () {
                    var t = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).result,
                        e = void 0 === t ? 0 : t, i = {ts: this.getTime(), type: 12, result: e};
                    this.reportList.push(i)
                }
            }, {
                key: "reportJoinRelayRoom", value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = t.scene,
                        i = void 0 === e ? 1 : e, r = t.result, s = void 0 === r ? 0 : r,
                        a = {ts: this.getTime(), type: 13, scene: i, result: s};
                    this.reportList.push(a)
                }
            }, {
                key: "reportRelayStart", value: function () {
                    var t = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).result,
                        e = void 0 === t ? 0 : t, i = {ts: this.getTime(), type: 14, result: e};
                    this.reportList.push(i)
                }
            }, {
                key: "reportRelayEnd", value: function (t) {
                    var e = t.jielong_score, i = t.player_num, r = t.max_audience, s = t.difficulty, a = t.duration,
                        o = {
                            ts: this.getTime(),
                            type: 15,
                            player_num: i,
                            max_audience: r,
                            difficulty: s,
                            jielong_score: e,
                            duration: a
                        };
                    this.reportList.push(o)
                }
            }, {
                key: "reportPlayGameAgain", value: function (t) {
                    var e = t.result, i = {ts: this.getTime(), type: 16, result: e};
                    this.reportList.push(i)
                }
            }, {
                key: "sendReport", value: function () {
                    this.reportList.length && (r.default.sendReport(this.reportList, this.clientInfo), this.reportList = [])
                }
            }, {
                key: "clearTimer", value: function () {
                    this.timeOut && clearInterval(this.timeOut)
                }
            }, {
                key: "setTimer", value: function (t) {
                    this.timeOut = setInterval(this.sendReport.bind(this), t)
                }
            }]), t
        }();
    exports.default = o;
});
define("js/network/socket.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var a = function () {
        function e(e, t) {
            for (var a = 0; a < t.length; a++) {
                var n = t[a];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (t, a, n) {
            return a && e(t.prototype, a), n && e(t, n), t
        }
    }(), n = e(require("../store/session")), o = e(require("./network")), s = function () {
        function e(a) {
            var n = this;
            t(this, e), this.alive = !1, this.noErr = !1, this.game = a, this.handlers = {}, this.handleSocketErr = "", this.heartBeat = [], wx.onSocketOpen(function (e) {
                n.alive = !0, "relay" == n.game.mode ? n.game.gameCtrl.onSocketOpen() : n.joinGame()
            }), wx.onSocketClose(function (e) {
                "player" != n.game.mode || n.noErr || (o.default.quitGame(), n.game.gameCtrl.onSocketCloseErr()), "observe" != n.game.mode || n.noErr || n.game.gameCtrl.onSocketCloseErr(), "relay" != n.game.mode || n.noErr || n.game.gameCtrl.onSocketCloseErr(), n.alive = !1, console.log("Socket close", e, "", n.noErr)
            }), wx.onSocketError(function (e) {
            }), wx.onSocketMessage(function (e) {
                n.cleanHeartBeat(), n.heartBeat.push(setTimeout(n.sendHeartBeat.bind(n), 5e3));
                var t;
                try {
                    t = JSON.parse(e.data)
                } catch (e) {
                    return n.game.handleWxOnError({
                        message: "socket receive wrong msg JSON.parse(res.data) error",
                        stack: ""
                    }), void wx.closeSocket()
                }
                t.cmd, 106 === t.cmd && n.handleACK(t), 101 === t.cmd && n.handleJoinGame(t), t.cmd, 108 === t.cmd && n.handlePeopleCome(t), 102 === t.cmd && n.receiveCommand(t), 109 == t.cmd && n.close(), 107 == t.cmd && n.handlePlayerOut(), 401 != t.cmd && 402 != t.cmd || n.handleRelayCMD(t)
            })
        }

        return a(e, [{
            key: "cleanHeartBeat", value: function () {
                if (this.heartBeat.length) for (; this.heartBeat.length;) {
                    var e = this.heartBeat.pop();
                    clearTimeout(e)
                }
            }
        }, {
            key: "connectSocket", value: function () {
                var e = this;
                console.log("connectSocket"), wx.connectSocket({
                    url: "wss://wxagame.weixin.qq.com",
                    success: function () {
                        console.log("wx.connectSocket success")
                    },
                    fail: function (t) {
                        e.alive = !1
                    }
                })
            }
        }, {
            key: "sendCommand", value: function (e, t) {
                var a = n.default.gameId, o = n.default.gameTicket;
                if (a && o && e) if ("string" == typeof a) {
                    var s = {cmd: 102, i: a, n: e, k: o, o: [JSON.stringify(t)]};
                    wx.sendSocketMessage({data: JSON.stringify(s)})
                } else console.warn("Socket send cmd need gameId")
            }
        }, {
            key: "sendNullCommand", value: function () {
                var e = n.default.gameId, t = n.default.gameTicket;
                if (e && t) if ("string" == typeof e) {
                    var a = {cmd: 102, i: e, k: t, o: []};
                    wx.sendSocketMessage({data: JSON.stringify(a)})
                } else console.warn("Socket send cmd need gameId")
            }
        }, {
            key: "getCommand", value: function (e) {
            }
        }, {
            key: "sendRelayCmd", value: function (e) {
                var t = this;
                if (this.game.gameModel.relayInfo.router_id && n.default.sessionId && e) {
                    var a = JSON.stringify(e), o = {
                        cmd: 401,
                        router_id: this.game.gameModel.relayInfo.router_id,
                        session_id: n.default.sessionId,
                        fast: 1,
                        data: a
                    };
                    wx.sendSocketMessage({
                        data: JSON.stringify(o), fail: function (e) {
                            e && e.errMsg && e.errMsg.match(/WebSocket is not connected$/) && (t.alive = !1)
                        }
                    })
                }
            }
        }, {
            key: "onRelayCmdCome", value: function (e) {
                this.handleRelayCMD = e
            }
        }, {
            key: "onPeopleCome", value: function (e) {
                this.peopleCome = e
            }
        }, {
            key: "onReciveCommand", value: function (e) {
                this.observerMessage = e
            }
        }, {
            key: "onJoinSuccess", value: function (e) {
                this.joinSuccess = e
            }
        }, {
            key: "onPlayerOut", value: function (e) {
                this.playerOutHandler = e
            }
        }, {
            key: "receiveCommand", value: function (e) {
                "function" == typeof this.observerMessage && e.o && e.o[0] && e.o[0].o && this.observerMessage(e.n, JSON.parse(e.o[0].o))
            }
        }, {
            key: "handlePeopleCome", value: function (e) {
                "function" == typeof this.peopleCome && this.peopleCome(e)
            }
        }, {
            key: "receiveACK", value: function () {
            }
        }, {
            key: "joinGame", value: function () {
                var e = n.default.gameId;
                if (n.default.sessionId && e) {
                    var t = {cmd: 101, game_id: e, fast: 1, session_id: n.default.sessionId};
                    wx.sendSocketMessage({data: JSON.stringify(t)})
                }
            }
        }, {
            key: "handleACK", value: function (e) {
                this.handlers.ack && this.handlers.ack.forEach(function (t) {
                    t(e)
                })
            }
        }, {
            key: "handleJoinGame", value: function (e) {
                if ("observe" == this.game.mode) switch (e.ret) {
                    case 0:
                    case 2:
                        this.joinSuccess(!0);
                        break;
                    default:
                        this.joinSuccess(!1)
                } else 0 != e.ret ? this.joinSuccess(!1) : this.joinSuccess(!0)
            }
        }, {
            key: "sendHeartBeat", value: function () {
                if ("player" == this.game.mode) this.sendNullCommand(); else {
                    var e = {cmd: 104};
                    wx.sendSocketMessage({data: JSON.stringify(e)})
                }
            }
        }, {
            key: "quitObserve", value: function () {
                if (this.alive) {
                    var e = {cmd: 109, fast: 1, game_id: n.default.gameId, session_id: n.default.sessionId};
                    wx.sendSocketMessage({data: JSON.stringify(e)})
                }
            }
        }, {
            key: "close", value: function () {
                var e = this;
                this.alive && (this.cleanHeartBeat(), this.noErr = !0, console.log("emmit close"), wx.closeSocket(), n.default.clearShareTicket(), n.default.clearGameId(), setTimeout(function () {
                    e.reset()
                }, 1e3))
            }
        }, {
            key: "onSocketErr", value: function (e) {
                this.handleSocketErr = e
            }
        }, {
            key: "reset", value: function () {
                this.noErr = !1
            }
        }, {
            key: "handlePlayerOut", value: function () {
                "function" == typeof this.playerOutHandler && this.playerOutHandler()
            }
        }]), e
    }();
    exports.default = s;
});
define("js/pages/battle/battleGamePage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (t, i, n) {
            return i && e(t.prototype, i), n && e(t, n), t
        }
    }(), i = function () {
        function i(t) {
            e(this, i), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.UI = this.game.UI, this.viewer = this.game.viewer, this.name = "game"
        }

        return t(i, [{
            key: "show", value: function () {
                this.UI.showScore(), this.UI.scoreText.obj.position.y = 21, this.UI.scoreText.obj.position.x = -13, this.UI.scoreText.changeStyle({textAlign: "left"})
            }
        }, {
            key: "hide", value: function () {
                this.UI.hideScore()
            }
        }]), i
    }();
    exports.default = i;
});
define("js/pages/battle/battlePkPage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var i = t[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, n, i) {
            return n && e(t.prototype, n), i && e(t, i), t
        }
    }(), n = function () {
        function n(t) {
            e(this, n), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.name = "battlePage"
        }

        return t(n, [{
            key: "show", value: function (e) {
                this.full2D.showPkPage(e)
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D()
            }
        }]), n
    }();
    exports.default = n;
});
define("js/pages/full2D.js", function (require, module, exports) {
    "use strict";

    function t(t) {
        return t && t.__esModule ? t : {default: t}
    }

    function e(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var o = e[i];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o)
                }
            }

            return function (e, i, o) {
                return i && t(e.prototype, i), o && t(e, o), e
            }
        }(), o = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(require("../lib/three")), a = require("../config"), s = t(require("../text")), n = require("../lib/animation"),
        r = (t(require("../store/storage")), t(require("../scroll/scrollHandler")), t(require("../report")), require("./pages2d/base")),
        h = require("./pages2d/start"), l = require("./pages2d/beginner"), y = require("./pages2d/lookers"),
        p = require("./pages2d/pk"), c = require("./pages2d/rank"), u = require("./pages2d/gg"),
        d = require("./pages2d/gghigh"), g = require("./pages2d/verify"), v = require("./pages2d/relay"),
        m = require("./pages2d/record"), T = t(require("../lib/mue/eventcenter")), f = t(require("./headimgAnimation")),
        _ = window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio,
        k = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth,
        R = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth, w = R * _,
        x = ["btn", "list1", "list2", "bg"], A = a.FRUSTUMSIZE, b = (wx.loadFont("res/num.ttf"), function () {
            function t(i) {
                var h = this;
                e(this, t), this.texture = {}, this.material = {}, this.geometry = {}, this.obj = {}, this.canvas = {}, this.context = {}, this._touchInfo = {
                    trackingID: -1,
                    maxDy: 0,
                    maxDx: 0
                }, this.options = Object.assign({}, {}, i), this.imgid = {
                    btn: 0,
                    bg: 0,
                    list1: 0,
                    list2: 0
                }, this.options.onGroupShare = i.onGroupShare, this.options.friendRankReturn = i.friendRankReturn, this.options.groupPlayGame = i.groupPlayGame, this.options.onClickRank = i.onClickRank, this.options.onClickReplay = i.onClickReplay, this.options.onClickShare = i.onClickShare, this.options.onClickPureShare = i.onClickPureShare, this.options.onClickStart = i.onClickStart, this.options.onShowFriendRank = i.onShowFriendRank, this.options.onBattlePlay = i.onBattlePlay, this.options.onLookersStart = i.onLookersStart, this.options.newRelay = i.newRelay, this.options.outRelay1 = i.outRelay1, this.options.outRelay2 = i.outRelay2, this.options.startRelay = i.startRelay, this.options.shareRelay = i.shareRelay, this.options.replayRelay = i.replayRelay, this.options.skipRelayBeginner = i.skipRelayBeginner, this.options.getRelayQr = i.getRelayQr, this.options.quitRecord = i.quitRecord, this.options.goRecord = i.goRecord, T.default.on(a.EVENT.RELAYSTART, function (t, e) {
                    h.hide2D(), h.relayHeadImg || (h.relayHeadImg = new f.default), h.relayText || (h.relayText = new o.Object3D, h.turnText = new s.default("", {
                        fillStyle: 4209243,
                        chinese: !0,
                        textAlign: "left"
                    }), h.relayText.add(h.turnText.obj), h.outText = new s.default("", {
                        fillStyle: 4209243,
                        chinese: !0,
                        textAlign: "left"
                    }), h.relayText.add(h.outText.obj), h.relayText.scale.set(1.5, 1.5, 1.5), h.relayText.position.x = -13.8, h.relayText.position.y = 11.5), h.options.camera.add(h.relayText), h.outText.obj.visible = !1, h.turnText.obj.visible = !1, h.relayHeadImg.set(e.playerlist), h.options.camera.add(h.relayHeadImg.obj), h.relayHeadImg.obj.position.x = -8.8, h.relayHeadImg.obj.position.y = 20, e.my_seat_no == e.now_player_seat_no && (h.turnText.obj.visible = !0, h.outText.obj.visible = !1)
                }), T.default.on(a.EVENT.SYNCSCENE, function (t, e) {
                    h.hide2D(), h.relayHeadImg || (h.relayHeadImg = new f.default), h.relayText || (h.relayText = new o.Object3D, h.turnText = new s.default("", {
                        fillStyle: 4209243,
                        chinese: !0,
                        textAlign: "left"
                    }), h.relayText.add(h.turnText.obj), h.outText = new s.default("", {
                        fillStyle: 4209243,
                        chinese: !0,
                        textAlign: "left"
                    }), h.relayText.add(h.outText.obj), h.relayText.scale.set(1.5, 1.5, 1.5), h.relayText.position.x = -13.8, h.relayText.position.y = 11.5), h.options.camera.add(h.relayText);
                    var i = e.serverData.playerlist;
                    i = i.slice(e.serverData.now_player_index, i.length).concat(i.slice(0, e.serverData.now_player_index)), console.log("1", i, e.serverData.now_player_index), i = i.filter(function (t) {
                        return 0 === t.rank
                    }), console.log("2", i), h.options.camera.add(h.relayHeadImg.obj), h.relayHeadImg.obj.position.x = -8.8, h.relayHeadImg.obj.position.y = 20, e.serverData.my_seat_no == e.serverData.now_player_seat_no ? (h.turnText.obj.visible = !0, h.outText.obj.visible = !1, h.relayHeadImg.set(i, {timeout: !0})) : (h.turnText.obj.visible = !1, h.outText.obj.visible = !1, h.relayHeadImg.set(i))
                }), T.default.on(a.EVENT.ORDERRUNGAME, function (t, e) {
                    console.log("order run game next-------------------------------", e.now_player_seat_no, e.my_seat_no), h.relayHeadImg || (h.relayHeadImg = new f.default), h.relayHeadImg.next(e), console.log("", e.my_seat_no, e.now_player_seat_no), e.my_seat_no == e.now_player_seat_no ? (h.turnText.obj.visible = !0, h.outText.obj.visible = !1) : (h.turnText.obj.visible = !1, h.outText.obj.visible = !1)
                }), T.default.on(a.EVENT.PLAYERDIED, function (t, e) {
                    if (h.canvasType == r.CANVASTYPE.relay) {
                        h.outText.obj.visible = !0, h.turnText.obj.visible = !1;
                        var i = e.playerlist.filter(function (t) {
                            return 0 === t.rank
                        });
                        console.log("playerlist.length ? ", i.length), e.my_seat_no == e.now_player_seat_no && i.length > 2 && (console.log("", e.my_seat_no, e.now_player_seat_no), h.showRelayGG({
                            all_player: e.player_count,
                            my_rank: e.player_rank
                        }))
                    }
                }), T.default.on(a.EVENT.RECEIVEMINICODE, function (t, e) {
                    h.showRelayQr(e)
                }), T.default.on(a.EVENT.ENDGAME, function (t, e) {
                    h.relayHeadImg && h.options.camera.remove(h.relayHeadImg.obj), h.relayText && h.options.camera.remove(h.relayText);
                    var i = 0, o = e.my_seat_no, a = e.playerlist.find(function (t) {
                        return t.seat_no === o
                    });
                    a && a.rank >= 0 && (i = a.rank + 1), console.log("rank:", e), n.TweenAnimation.killAll(), h.showRelayRank({
                        players: e.playerlist,
                        my_seat_no: e.my_seat_no,
                        my_rank: i,
                        total_score: e.score
                    })
                }), T.default.on(a.EVENT.RELAYMODEDESTROY, function (t, e) {
                    h.relayHeadImg && h.relayHeadImg.obj && (h.outText.obj.visible = h.turnText.obj.visible = !1, h.options.camera.remove(h.relayText), h.options.camera.remove(h.relayHeadImg.obj))
                })
            }

            return i(t, [{
                key: "showFriendRankList", value: function (t) {
                    this.opt = t || {}, (0, c.drawFriendRankList)({self: this})
                }
            }, {
                key: "showGroupRankList", value: function (t, e) {
                    (0, c.drawGroupRankList)(this, t, e)
                }
            }, {
                key: "showGameOverPage", value: function (t) {
                    t = t || {}, this.opt = t, (0, u.routeGameOver)(this)
                }
            }, {
                key: "showStartPage", value: function (t) {
                    r.DEBUG || (this.opt = t || {}, (0, h.drawStartPage)(this))
                }
            }, {
                key: "showPkPage", value: function (t) {
                    this.opt = t, (0, p.drawPkPage)({self: this})
                }
            }, {
                key: "showLookersPage", value: function (t) {
                    this.opt = t, (0, y.drawLookersPage)({self: this})
                }
            }, {
                key: "showRecordPage", value: function (t) {
                    this.opt = t, (0, m.drawRecordPage)({self: this})
                }
            }, {
                key: "showBeginnerPage", value: function () {
                    (0, l.drawBeginnerPage)({self: this})
                }
            }, {
                key: "showRelayRoom", value: function (t, e) {
                    this.relayOpt = t, (this.canvasType != r.CANVASTYPE.relayQr || e) && (this.opt = t, (0, v.drawRelayRoomPage)(this))
                }
            }, {
                key: "showRelayGG", value: function (t) {
                    this.opt = t, (0, v.drawRelayGG)(this)
                }
            }, {
                key: "showRelaying", value: function (t) {
                    this.opt = t, (0, v.drawRelaying)(this)
                }
            }, {
                key: "showRelayLookers", value: function (t) {
                    this.opt = t, (0, v.drawRelayLookers)(this)
                }
            }, {
                key: "showRelayRank", value: function (t) {
                    this.opt = t, (0, v.drawRelayRank)(this)
                }
            }, {
                key: "showRelayBeginner", value: function (t) {
                    this.opt = t, (0, v.drawRelayBeginner)(this)
                }
            }, {
                key: "showRelayQr", value: function (t) {
                    this.opt = t, (0, v.drawRelayQr)(this)
                }
            }, {
                key: "hide2D", value: function () {
                    (0, r.hide)(this)
                }
            }, {
                key: "hide2DGradually", value: function () {
                    if (!r.DEBUG) for (var t = this, e = 0; e < x.length; e++) this.obj[x[e]] && n.customAnimation.to(this.material[x[e]], 1, {
                        opacity: 0,
                        onComplete: function (e) {
                            return function () {
                                t.material[x[e]].opacity = 1, t.obj[x[e]].visible = !1, t.showState = !1, t.options.camera.remove(t.obj[x[e]])
                            }
                        }(e)
                    })
                }
            }, {
                key: "_findDelta", value: function (t) {
                    var e = this._touchInfo, i = t.touches[0] || t.changedTouches[0];
                    return i ? {x: i.pageX - e.x, y: i.pageY - e.y} : null
                }
            }, {
                key: "doTouchStartEvent", value: function (t) {
                    if (this.showState) {
                        var e = t.changedTouches[0].pageX, i = t.changedTouches[0].pageY;
                        if (this.startX = e, this.startY = i, this.canvasType == r.CANVASTYPE.friendRank || this.canvasType == r.CANVASTYPE.groupRank || this.canvasType == r.CANVASTYPE.pk || this.canvasType == r.CANVASTYPE.relayRank) {
                            var o = this._touchInfo, a = this.scrollHandler;
                            if (!a) return;
                            o.trackingID = "touch", o.x = t.touches[0].pageX, o.y = t.touches[0].pageY, o.maxDx = 0, o.maxDy = 0, o.historyX = [0], o.historyY = [0], o.historyTime = [+new Date], o.listener = a, a.onTouchStart && a.onTouchStart()
                        } else this.canvasType == r.CANVASTYPE.gameOver ? (e = this._cxp(e), i = this._cyp(i), (!this.noplay_time || this.noplay_time < 0) && e > 117 && e < 297 && i > 540 && i < 660 && this._drawGameOverBtnClick()) : this.canvasType == r.CANVASTYPE.start && (e = this._cxp(e), i = this._cyp(i), e > 100 && e < 320 && i > 557 && i < 617 && this._drawStartClick())
                    }
                }
            }, {
                key: "doTouchMoveEvent", value: function (t) {
                    if (this.showState && (this.canvasType == r.CANVASTYPE.friendRank || this.canvasType == r.CANVASTYPE.groupRank || this.canvasType == r.CANVASTYPE.pk || this.canvasType == r.CANVASTYPE.relayRank)) {
                        var e = this._touchInfo;
                        if (-1 == e.trackingID) return;
                        t.preventDefault();
                        var i = this._findDelta(t);
                        if (!i) return;
                        e.maxDy = Math.max(e.maxDy, Math.abs(i.y)), e.maxDx = Math.max(e.maxDx, Math.abs(i.x));
                        var o = +new Date;
                        for (e.historyX.push(i.x), e.historyY.push(i.y), e.historyTime.push(o); e.historyTime.length > 10;) e.historyTime.shift(), e.historyX.shift(), e.historyY.shift();
                        e.listener && e.listener.onTouchMove && e.listener.onTouchMove(i.x, i.y, o)
                    }
                }
            }, {
                key: "doTouchEndEvent", value: function (t) {
                    if (this.showState) {
                        var e = t.changedTouches[0].pageX, i = t.changedTouches[0].pageY, o = i, s = !0;
                        if (this.canvasType != r.CANVASTYPE.friendRank && this.canvasType != r.CANVASTYPE.groupRank && this.canvasType != r.CANVASTYPE.pk && this.canvasType != r.CANVASTYPE.gameOver && this.canvasType != r.CANVASTYPE.relayRank || !(Math.abs(e - this.startX) > 5 || Math.abs(i - this.startY) > 5) || (s = !1), e = this._cxp(e), i = this._cyp(i), s) {
                            if (this.canvasType == r.CANVASTYPE.groupRank) {
                                if (e > 134 && e < 283 && i > 640 && i < 727) return (0, r.hide)(this), void(!!this.options.groupPlayGame && this.options.groupPlayGame());
                                if (e > 349 && e < 379 && i > 140 && i < 590) {
                                    v = Math.round((this._cyp(o - this.lastScrollY) - 171) / 60);
                                    this.sotedRankList[v].playback_id && !!this.options.goRecord && this.options.goRecord({
                                        user_data: this.sotedRankList[v],
                                        scene: "group"
                                    })
                                }
                            }
                            if (this.canvasType == r.CANVASTYPE.friendRank) {
                                if (e > 120 && e < 300 && i > 640 && i < 720) return void(!!this.options.onGroupShare && this.options.onGroupShare());
                                if (e > 330 && e < 408 && i > 100 && i < 140) return void(this.lastCanvasType == r.CANVASTYPE.gameOver ? !!this.options.friendRankReturn && this.options.friendRankReturn("") : this.lastCanvasType == r.CANVASTYPE.start && !!this.options.friendRankReturn && this.options.friendRankReturn(""));
                                if (e > 349 && e < 379 && i > 140 && i < 590) {
                                    v = Math.round((this._cyp(o - this.lastScrollY) - 171) / 60);
                                    this.sotedRankList[v].playback_id && !!this.options.goRecord && this.options.goRecord({
                                        user_data: this.sotedRankList[v],
                                        scene: "friends"
                                    })
                                }
                            }
                            if (this.canvasType == r.CANVASTYPE.gameOver) return void("beginner" != this.opt.type && "tired" != this.opt.type && !this.opt.banType && e > 25 && e < 385 && i > 290 && i < 500 ? !!this.options.onClickRank && this.options.onClickRank() : !this.opt.banType && e > 150 && e < 260 && i > 199 && i < 260 ? !!this.options.onClickShare && this.options.onClickShare() : (!this.noplay_time || this.noplay_time < 0) && e > 117 && e < 297 && i > 540 && i < 660 ? !!this.options.onClickReplay && this.options.onClickReplay() : 1 == this.opt.banType && e > 150 && e < 260 && i > 430 && i < 500 ? (0, g.routeVerify)(this) : e < 100 && i < 70 && T.default.emit(a.EVENT.GOSTARTPAGE, {}));
                            if (this.canvasType == r.CANVASTYPE.gameOverHighest && (e > 340 && e < 407 && i > 76 && i < 138 ? (this.canvasType = r.CANVASTYPE.gameOver, (0, u.routeGameOver)(this, !0)) : e > 111 && e < 380 && i > 540 && i < 660 ? !!this.options.onClickReplay && this.options.onClickReplay() : this.changlleList.length > 0 && e > 170 && e < 230 && i > 330 && i < 390 ? !!this.options.onClickPureShare && this.options.onClickPureShare(this.opt.type) : (0 == this.changlleList.length || "rank" == this.opt.type) && e > 170 && e < 230 && i > 390 && i < 440 ? !!this.options.onClickPureShare && this.options.onClickPureShare(this.opt.type) : this.changlleList.length > 5 && e > 55 && e < 115 && i > 437 && i < 497 ? (0, d.reDrawChangeAva)(this, -1) : this.changlleList.length > 5 && e > 297 && e < 357 && i > 437 && i < 497 && (0, d.reDrawChangeAva)(this, 1)), this.canvasType == r.CANVASTYPE.start) return void(e > 93 && e < 321 && i > 557 && i < 617 ? !!this.options.onClickStart && this.options.onClickStart() : !this.opt.hideRank && e > 217 && e < 313 && i > 660 && i < 680 ? !!this.options.onShowFriendRank && this.options.onShowFriendRank() : !this.opt.hideRank && e > 79 && e < 197 && i > 660 && i < 680 ? !!this.options.newRelay && this.options.newRelay() : 1 == this.opt.banType && e > 128 && e < 286 && i > 369 && i < 433 ? (0, g.routeVerify)(this) : this._drawStartClickRevert());
                            if (this.canvasType == r.CANVASTYPE.pk) {
                                if (e > 110 && e < 310 && i > 650 && i < 730) return void(!!this.options.onBattlePlay && this.options.onBattlePlay(""));
                                if (this.opt.organizerInfo.left_time > 0 && 0 == this.opt.organizerInfo.is_self && e > 140 && e < 280 && i > 325 && i < 405) return void(!!this.options.onBattlePlay && this.options.onBattlePlay("pk"))
                            }
                            if (this.canvasType == r.CANVASTYPE.lookers) return void(e > 130 && e < 280 && i > 650 && i < 720 && !!this.options.onLookersStart && this.options.onLookersStart());
                            if (this.canvasType == r.CANVASTYPE.verify && (e > 130 && e < 280 && i > 607 && i < 640 ? this.opt.verify_step >= 4 ? (this.opt.banType = 2, this.lastCanvasType == r.CANVASTYPE.gameOver ? (0, u.routeGameOver)(this, !0) : (0, h.drawStartPage)(this)) : (0, g.routeVerify)(this) : e > 130 && e < 280 && i > 670 && i < 720 ? (this.opt.verify_step = 0, this.lastCanvasType == r.CANVASTYPE.gameOver ? (0, u.routeGameOver)(this, !0) : (0, h.drawStartPage)(this)) : 3 == this.opt.verify_step && e > 130 && e < 370 && i > 240 && i < 300 ? (0, g.clickVerifyForm)(this, "name") : 3 == this.opt.verify_step && e > 130 && e < 370 && i > 300 && i < 360 && (0, g.clickVerifyForm)(this, "mobile")), this.canvasType == r.CANVASTYPE.relay) if (0 == this.opt.game_status && this.opt.my_seat_no == this.opt.room_owner_seat && this.opt.players.length > 1 && e > 160 && e < 260 && i > 627 && i < 677) console.log(""), this.opt.game_level = this.opt.game_level || 0, !!this.options.startRelay && this.options.startRelay(this.opt.game_level); else if (0 == this.opt.game_status && this.opt.my_seat_no == this.opt.room_owner_seat && e > 160 && e < 260 && i > 555 && i < 595) {
                                console.log("");
                                var n = this;
                                wx.showActionSheet({
                                    itemList: ["", "", ""], success: function (t) {
                                        console.log(t.tapIndex), n.opt.game_level = t.tapIndex, n.showRelayRoom(n.opt), T.default.emit(a.EVENT.CHANGEGAMELEVEL, t.tapIndex)
                                    }, fail: function (t) {
                                        console.log(t.errMsg)
                                    }
                                })
                            } else 0 == this.opt.game_status && e < 100 && i < 70 ? (console.log("home"), this.relayHeadImg && this.relayHeadImg.obj && this.options.camera.remove(this.relayHeadImg.obj), this.relayText && this.options.camera.remove(this.relayText), !!this.options.outRelay1 && this.options.outRelay1()) : 0 == this.opt.game_status && this.opt.my_seat_no == this.opt.room_owner_seat && e > 160 && e < 260 && i > 99 && i < 140 ? (console.log(""), !!this.options.shareRelay && this.options.shareRelay()) : 0 == this.opt.game_status && this.opt.my_seat_no != this.opt.room_owner_seat && e > 160 && e < 260 && i > 598 && i < 618 ? (console.log(""), !!this.options.shareRelay && this.options.shareRelay()) : (1 == this.opt.game_status || 2 == this.opt.game_status) && e < 100 && i < 70 ? (console.log("home"), this.relayHeadImg && this.relayHeadImg.obj && this.options.camera.remove(this.relayHeadImg.obj), this.relayText && this.options.camera.remove(this.relayText), !!this.options.outRelay2 && this.options.outRelay2()) : 1 == this.opt.game_status && e > 160 && e < 260 && i > 568 && i < 608 ? (console.log(""), !!this.options.watchRelay && this.options.watchRelay()) : 0 == this.opt.game_status && this.opt.my_seat_no == this.opt.room_owner_seat && e > 160 && e < 260 && i > 161 && i < 201 ? (console.log(""), T.default.emit(a.EVENT.GETRELAYQR), !!this.options.getRelayQr && this.options.getRelayQr(), this.showRelayQr({})) : 2 == this.opt.game_status && e > 160 && e < 260 && i > 568 && i < 608 && (console.log(""), !!this.options.newRelay && this.options.newRelay());
                            this.canvasType == r.CANVASTYPE.relayRank && (e < 100 && i < 70 ? (console.log("/ relay rank"), !!this.options.outRelay1 && this.options.outRelay1()) : 0 != this.opt.my_seat_no && e > 30 && e < 380 && i > 561 && i < 651 && (console.log(""), T.default.emit(a.EVENT.REPLAYAGAIN, {}))), this.canvasType == r.CANVASTYPE.relayGG && (e > 30 && e < 384 && i > 460 && i < 550 ? (console.log(""), this.hide2D()) : e < 100 && i < 70 && (this.relayHeadImg && this.relayHeadImg.obj && this.options.camera.remove(this.relayHeadImg.obj), this.relayText && this.options.camera.remove(this.relayText), console.log(""), !!this.options.outRelay1 && this.options.outRelay1())), this.canvasType == r.CANVASTYPE.relayBeginner && e > 310 && e < 397 && i > 530 && i < 560 && (console.log(""), !!this.options.skipRelayBeginner && this.options.skipRelayBeginner()), this.canvasType == r.CANVASTYPE.relayQr && e < 100 && i < 70 && this.showRelayRoom(this.relayOpt, !0), this.canvasType == r.CANVASTYPE.record && e < 100 && i < 70 && !!this.options.quitRecord && this.options.quitRecord()
                        }
                        this.canvasType == r.CANVASTYPE.gameOver && (!this.noplay_time || this.noplay_time < 0) && this._drawGameOverBtnClickRevert();
                        var l = this._touchInfo;
                        if (-1 != l.trackingID) {
                            t.preventDefault();
                            var y = this._findDelta(t);
                            if (y) {
                                var p = l.listener;
                                l.trackingID = -1, l.listener = null;
                                var c = {x: 0, y: 0};
                                if (l.historyTime.length > 2) for (var v = l.historyTime.length - 1, m = l.historyTime[v], f = l.historyX[v], _ = l.historyY[v]; v > 0;) {
                                    v--;
                                    var k = m - l.historyTime[v];
                                    if (k > 30 && k < 50) {
                                        c.x = (f - l.historyX[v]) / (k / 1e3), c.y = (_ - l.historyY[v]) / (k / 1e3);
                                        break
                                    }
                                }
                                l.historyTime = [], l.historyX = [], l.historyY = [], p && p.onTouchEnd && p.onTouchEnd(y.x, y.y, c)
                            }
                        }
                    }
                }
            }, {
                key: "updatePosition", value: function (t) {
                    var e;
                    t > 0 && (t = 0);
                    var i = 10 * (0, r.cwh)(60) / w * A, o = 10 * (0, r.cwh)(60);
                    this.canvasType != r.CANVASTYPE.friendRank && this.canvasType != r.CANVASTYPE.groupRank || (e = -(this._cy(143) + o / 2 - w / 2) / w * A), this.canvasType == r.CANVASTYPE.pk && (e = -(this._cy(437) + o / 2 - w / 2) / w * A), this.canvasType == r.CANVASTYPE.relayRank && (e = -(this._cy(404) + o / 2 - w / 2) / w * A, 1 != this.opt.my_rank && (e = -(this._cy(318) + o / 2 - w / 2) / w * A));
                    var a = Math.floor((e - A * t / R) / i);
                    if (this.lastN != a && this.lastN - a < 0) a % 2 == 0 ? this._drawList(10 * (a + 1), "list2") : this._drawList(10 * (a + 1), "list1"); else if (this.lastN != a && this.lastN - a > 0) {
                        var s = a;
                        -1 == s && (s = 1), a % 2 == 0 ? this._drawList(10 * a, "list1") : this._drawList(10 * s, "list2")
                    }
                    a % 2 == 0 ? (this.obj.list1.position.y = e - A * t / R - a * i, this.obj.list2.position.y = e - A * t / R - (a + 1) * i) : (this.obj.list2.position.y = e - A * t / R - a * i, this.obj.list1.position.y = e - A * t / R - (a + 1) * i), this.lastN = a, this.lastScrollY = t
                }
            }, {
                key: "_drawList", value: function (t, e) {
                    this.canvasType != r.CANVASTYPE.pk ? this.canvasType == r.CANVASTYPE.friendRank || this.canvasType == r.CANVASTYPE.groupRank ? (0, c.drawRankList)(this, t, e) : this.canvasType == r.CANVASTYPE.relay && (0, v.drawRelayList)(this, t, e) : (0, p.drawPkList)(this, t, e)
                }
            }, {
                key: "_drawGameOverBtnClick", value: function () {
                    this.context.btn.clearRect(this._cx(91), this._cy(527), (0, r.cwh)(232), (0, r.cwh)(134)), this._drawImageCenter("res/replay.png", this._cx(207), this._cy(607), (0, r.cwh)(190), (0, r.cwh)(75), "btn", null, this.imgid.btn)
                }
            }, {
                key: "_drawGameOverBtnClickRevert", value: function () {
                    this.context.btn.clearRect(this._cx(91), this._cy(527), (0, r.cwh)(232), (0, r.cwh)(134)), this._drawImageCenter("res/replay.png", this._cx(207), this._cy(607), (0, r.cwh)(212), (0, r.cwh)(84), "btn", null, this.imgid.btn)
                }
            }, {
                key: "_drawStartClick", value: function () {
                    this.context.btn.clearRect(this._cx(91), this._cy(530), (0, r.cwh)(232), (0, r.cwh)(104)), this._drawImageCenter("res/play.png", this._cx(207), this._cy(587), (0, r.cwh)(190), (0, r.cwh)(75), "btn", null, this.imgid.btn)
                }
            }, {
                key: "_drawStartClickRevert", value: function () {
                    this.context.btn.clearRect(this._cx(91), this._cy(530), (0, r.cwh)(232), (0, r.cwh)(104)), this._drawImageCenter("res/play.png", this._cx(207), this._cy(587), (0, r.cwh)(212), (0, r.cwh)(84), "btn", null, this.imgid.btn)
                }
            }, {
                key: "_cx", value: function (t) {
                    var e = t * k / 414;
                    return R / k < 736 / 414 && (e = t * R / 736 + (k - 414 * R / 736) / 2), e * _
                }
            }, {
                key: "_cy", value: function (t) {
                    return (R / k > 736 / 414 ? t * k / 414 + (R - 736 * k / 414) / 2 : t * R / 736) * _
                }
            }, {
                key: "_cxp", value: function (t) {
                    return t / k * 414
                }
            }, {
                key: "_cyp", value: function (t) {
                    return R / k > 736 / 414 ? (t - (R - 736 * k / 414) / 2) / k * 414 : t / R * 736
                }
            }, {
                key: "_drawImageCenter", value: function (t, e, i, o, a, s, n, h, l) {
                    "/0" != t && "/96" != t && "/64" != t && t || (t = "res/ava.png");
                    var y = new Image, p = this;
                    y.onload = function () {
                        p.imgid[s] == h && (p.context[s].drawImage(y, e - o / 2, i - a / 2, o, a), !!n && n(), l || (0, r.updatePlane)({
                            self: p,
                            type: s
                        }))
                    }, y.onerror = function () {
                        !!n && n()
                    }, y.src = t
                }
            }]), t
        }());
    exports.default = b;
});
define("js/pages/group/groupPage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var i = t[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, n, i) {
            return n && e(t.prototype, n), i && e(t, i), t
        }
    }(), n = function () {
        function n(t) {
            e(this, n), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.name = "groupRankList"
        }

        return t(n, [{
            key: "show", value: function (e, t) {
                this.full2D.showGroupRankList(e, t)
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D()
            }
        }]), n
    }();
    exports.default = n;
});
define("js/pages/headimgAnimation.js", function (require, module, exports) {
    "use strict";

    function i(i, t) {
        if (!(i instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function i(i, t) {
            for (var o = 0; o < t.length; o++) {
                var e = t[o];
                e.enumerable = e.enumerable || !1, e.configurable = !0, "value" in e && (e.writable = !0), Object.defineProperty(i, e.key, e)
            }
        }

        return function (t, o, e) {
            return o && i(t.prototype, o), e && i(t, e), t
        }
    }(), o = function (i) {
        if (i && i.__esModule) return i;
        var t = {};
        if (null != i) for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);
        return t.default = i, t
    }(require("../lib/three")), e = require("../lib/animation"), s = require("../config"), n = function (i) {
        return i && i.__esModule ? i : {default: i}
    }(require("../lib/mue/eventcenter")), r = function () {
        function e(t, s) {
            i(this, e);
            var n = new o.Shape;
            n = this.roundedRect(n, -1.5, -1.5, 3, 3, .25);
            new o.Shape;
            var r = new o.ShapeGeometry(n);
            this.reMapUv(r), this.avatorFrame = new o.Mesh(r, new o.MeshBasicMaterial({
                transparent: !0,
                map: t,
                opacity: 1
            })), this.outer = new o.Mesh(r, new o.MeshBasicMaterial({
                transparent: !0,
                color: 16777215,
                opacity: 1
            })), this.outer.scale.set(1.05, 1.05, 1.05), this.outer.position.z = -.1, this.obj = new o.Object3D, this.obj.add(this.avatorFrame), this.obj.add(this.outer), this.id = s, this.waitingList = []
        }

        return t(e, [{
            key: "roundedRect", value: function (i, t, o, e, s, n) {
                return i.moveTo(t, o + n), i.lineTo(t, o + s - n), i.quadraticCurveTo(t, o + s, t + n, o + s), i.lineTo(t + e - n, o + s), i.quadraticCurveTo(t + e, o + s, t + e, o + s - n), i.lineTo(t + e, o + n), i.quadraticCurveTo(t + e, o, t + e - n, o), i.lineTo(t + n, o), i.quadraticCurveTo(t, o, t, o + n), i
            }
        }, {
            key: "reMapUv", value: function (i) {
                i.computeBoundingBox();
                var t = i.boundingBox.max, e = i.boundingBox.min, s = new o.Vector2(0 - e.x, 0 - e.y),
                    n = new o.Vector2(t.x - e.x, t.y - e.y), r = i.faces;
                i.faceVertexUvs[0] = [];
                for (var a = 0; a < r.length; a++) {
                    var l = i.vertices[r[a].a], c = i.vertices[r[a].b], h = i.vertices[r[a].c];
                    i.faceVertexUvs[0].push([new o.Vector2((l.x + s.x) / n.x, (l.y + s.y) / n.y), new o.Vector2((c.x + s.x) / n.x, (c.y + s.y) / n.y), new o.Vector2((h.x + s.x) / n.x, (h.y + s.y) / n.y)])
                }
                i.uvsNeedUpdate = !0
            }
        }]), e
    }(), a = function () {
        function a() {
            i(this, a), this.obj = new o.Object3D, this.list = [], this.secondList = [];
            var t = new o.PlaneBufferGeometry(26, .76, 30);
            this.progress = new o.Object3D;
            var e = s.loader.load("res/progress2.png"), n = new o.CircleGeometry(.38, 15, 0, Math.PI);
            this.roundCircle = new o.Mesh(n, new o.MeshBasicMaterial({map: e})), this.roundCircleBack = new o.Mesh(n, new o.MeshBasicMaterial({
                transparent: !0,
                opacity: .08,
                color: 0
            })), this.secondRoundCircleBack = this.roundCircleBack.clone(), this.secondRoundCircle = this.roundCircle.clone(), this.backgroundBar = new o.Mesh(t, new o.MeshBasicMaterial({
                transparent: !0,
                opacity: .08,
                color: 0
            })), this.progressBar = new o.Object3D, this.progressBar.add(new o.Mesh(t, new o.MeshBasicMaterial({
                map: e,
                transparent: !0
            }))), this.progressShadow = new o.Mesh(new o.PlaneGeometry(26, .38), new o.MeshBasicMaterial({
                transparent: !0,
                color: 16777215,
                opacity: .08
            })), this.progressShadow.position.set(0, .19, .1), this.progressBar.add(this.progressShadow), this.progress.add(this.roundCircleBack), this.secondRoundCircleBack.position.z = this.roundCircleBack.position.z = this.backgroundBar.position.z = -.1, this.progress.add(this.secondRoundCircleBack), this.progress.add(this.backgroundBar), this.progress.add(this.progressBar), this.roundCircle.rotation.z = this.roundCircleBack.rotation.z = -Math.PI / 2, this.roundCircle.position.x = this.roundCircleBack.position.x = 13, this.secondRoundCircle = this.roundCircle.clone(), this.secondRoundCircle.rotation.z = this.secondRoundCircleBack.rotation.z = Math.PI / 2, this.secondRoundCircle.position.x = this.secondRoundCircleBack.position.x = -13, this.progress.add(this.roundCircle), this.progress.add(this.secondRoundCircle), this.progress.position.set(8.2, 3.25, 0), this.obj.add(this.progress), this.turnAudio = wx.createInnerAudioContext(), this.turnAudio.src = "res/turn.mp3"
        }

        return t(a, [{
            key: "set", value: function (i, t) {
                var o = this;
                this.destroy(), this.list = [];
                for (var a = 0, l = i.length; a < l; ++a) {
                    "/0" != i[a].headimg && "/96" != i[a].headimg && "/64" != i[a].headimg && i[a].headimg || (i[a].headimg = "res/ava.png");
                    var c = s.loader.load(i[a].headimg), h = new r(c, i[a].seat_no);
                    this.obj.add(h.obj), h.obj.position.x = 4 * (a - 5 >= 1 ? a - 5 : a), 0 == a && (h.obj.scale.set(2.2, 2.2, 2.2), h.obj.position.set(-1.8, -1.8, 0)), a >= 6 && (h.obj.position.y = -3.5), this.list.push(h);
                    var u = new r(c, i[a].seat_no);
                    u.obj.visible = !1, this.obj.add(u.obj), this.secondList.push(u)
                }
                this.progressBar.scale.x = 1, this.progressBar.position.x = 0, this.roundCircle.position.x = 13, this.roundCircle.visible = !0, this.secondRoundCircle.visible = !0;
                var d = 5;
                t && t.timeout && (d = 1), e.customAnimation.to(this.progressBar.scale, d, {
                    x: .01,
                    name: "progress",
                    onComplete: function () {
                        o.progressBlinkTimer = setInterval(function () {
                            o.roundCircle.visible = !o.roundCircle.visible, o.secondRoundCircle.visible = !o.secondRoundCircle.visible
                        }, 800), t && t.noEmit || n.default.emitSync(s.EVENT.PROGRESSOVER)
                    }
                }), e.customAnimation.to(this.progressBar.position, d, {
                    x: -13,
                    name: "progress"
                }), e.customAnimation.to(this.roundCircle.position, d, {x: -13, name: "progress"})
            }
        }, {
            key: "next", value: function (i, t) {
                var o = this;
                if (console.log("next111111"), this.progressBlinkTimer && (clearInterval(this.progressBlinkTimer), this.progressBlinkTimer = null), this.animating) return console.log("waitingList!!!!!!!!"), void this.waitingList.push(i);
                console.log("next22222222"), e.TweenAnimation.kill("progress"), this.roundCircle.visible = !0, this.secondRoundCircle.visible = !0, this.animating = !0;
                var r = this.list.shift(), a = this.secondList.shift();
                if (i && i.now_player_seat_no == r.id) return console.warn("data next "), this.list.unshift(r), this.secondList.unshift(a), void(this.animating = !1);
                if (this.list[0]) {
                    i && i.my_seat_no == i.now_player_seat_no && this.turnAudio.play(), i && this.currentDie(r.id, i.playerlist) && (r.died = !0);
                    var l = .3;
                    t && t.noAnimation && (l = .01), this.list[0].avatorFrame.material.opacity = .3, this.list[0].outer.material.opacity = .3, e.customAnimation.to(this.list[0].avatorFrame.material, l, {opacity: 1}), e.customAnimation.to(this.list[0].outer.material, l, {opacity: 1}), e.customAnimation.to(this.list[0].obj.scale, l, {
                        x: 2.2,
                        y: 2.2,
                        z: 2.2
                    }), e.customAnimation.to(this.list[0].obj.position, l, {
                        x: -1.8,
                        y: -1.8
                    }), this.progressBar.scale.x = 1, this.progressBar.position.x = 0, this.roundCircle.position.x = 13, e.customAnimation.to(this.progressBar.scale, 5, {
                        x: .01,
                        name: "progress",
                        onComplete: function () {
                            console.log("fuck progress over"), o.progressBlinkTimer = setInterval(function () {
                                o.roundCircle.visible = !o.roundCircle.visible, o.secondRoundCircle.visible = !o.secondRoundCircle.visible
                            }, 800), i && n.default.emitSync(s.EVENT.PROGRESSOVER)
                        }
                    }), e.customAnimation.to(this.progressBar.position, 5, {
                        x: -13,
                        name: "progress"
                    }), e.customAnimation.to(this.roundCircle.position, 5, {x: -13, name: "progress"});
                    for (var c = 1, h = this.list.length; c < h; ++c) if (5 == c) {
                        var u = this.list[5];
                        u.obj.position.z = -1;
                        var d = this.secondList[5];
                        e.customAnimation.to(u.outer.material, l, {opacity: 0}), e.customAnimation.to(u.avatorFrame.material, l, {opacity: 0}), e.customAnimation.to(u.obj.position, l, {x: 0}), d.obj.visible = !0, d.outer.material.opacity = 0, d.avatorFrame.material.opacity = 0, d.obj.position.x = 24, d.obj.position.y = 0, e.customAnimation.to(d.obj.position, l, {
                            x: d.obj.position.x - 4,
                            onEnded: function () {
                                u.obj.position.x = d.obj.position.x, u.obj.position.y = d.obj.position.y, u.outer.material.opacity = 1, u.avatorFrame.material.opacity = 1, d.obj.visible = !1
                            }
                        }), e.customAnimation.to(d.avatorFrame.material, l, {opacity: 1}), e.customAnimation.to(d.outer.material, l, {opacity: 1})
                    } else this.list[c].obj.position.z = 0, e.customAnimation.to(this.list[c].obj.position, l, {x: 4 * (c - 5 >= 1 ? c - 5 : c)});
                    e.customAnimation.to(r.obj.position, l, {
                        x: -8, onEnded: function () {
                            if (o.animating = !1, o.waitingList.length > 0) {
                                console.log("onComplete next");
                                var i = o.waitingList.shift();
                                o.next(i, {noAnimation: !0})
                            }
                        }
                    }), e.customAnimation.to(r.avatorFrame.material, l, {opacity: 0}), e.customAnimation.to(r.outer.material, l, {opacity: 0}), r.died ? (this.obj.remove(r.obj), this.obj.remove(a.obj)) : (a.obj.position.x = 4 * (this.list.length - 5 >= 1 ? this.list.length - 5 : this.list.length) + 4, console.log("secondFirstItem obj", a.obj.position.x, this.list.length), a.obj.position.y = this.list.length + 1 > 6 ? -3.5 : 0, a.avatorFrame.material.opacity = 0, a.outer.material.opacity = 0, a.obj.visible = !0, e.customAnimation.to(a.obj.position, l, {
                        x: a.obj.position.x - 4,
                        onEnded: function () {
                            r.obj.scale.set(1, 1, 1), r.obj.position.x = a.obj.position.x, r.obj.position.y = a.obj.position.y, console.log("final", r.obj.position.x, r.obj.position.y), r.avatorFrame.material.opacity = 1, r.outer.material.opacity = 1, a.obj.visible = !1
                        }
                    }), e.customAnimation.to(a.avatorFrame.material, l, {opacity: 1}), e.customAnimation.to(a.outer.material, l, {opacity: 1}), this.list.push(r), this.secondList.push(a))
                } else this.animating = !1
            }
        }, {
            key: "currentJumperDie", value: function () {
                this.list[0].died = !0
            }
        }, {
            key: "currentDie", value: function (i, t) {
                console.log("id", i, t);
                for (var o = 0, e = t.length; o < e; ++o) if (t[o].seat_no == i && 0 != t[o].rank) return !0
            }
        }, {
            key: "destroy", value: function () {
                this.progressBlinkTimer && (clearInterval(this.progressBlinkTimer), this.progressBlinkTimer = null);
                for (var i = 0, t = this.list.length; i < t; ++i) this.list[i] && this.list[i].obj && this.list[i].obj.material && this.list[i].obj.material.map && this.list[i].obj.material.map.dispose(), this.obj.remove(this.list[i].obj);
                for (var i = 0, t = this.secondList.length; i < t; ++i) this.secondList[i] && this.secondList[i].obj && this.secondList[i].obj.material && this.secondList[i].obj.material.map && this.secondList[i].obj.material.map.dispose(), this.obj.remove(this.secondList[i].obj);
                this.list = [], this.secondList = [], this.waitingList = [], this.animating = !1
            }
        }]), a
    }();
    exports.default = a;
});
define("js/pages/lookers.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
            function e(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var n = t[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                }
            }

            return function (t, i, n) {
                return i && e(t.prototype, i), n && e(t, n), t
            }
        }(), n = function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
            return t.default = e, t
        }(require("../lib/three")), a = require("../config"),
        r = (e(require("../store/storage")), e(require("../scroll/scrollHandler")), window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio),
        s = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth,
        o = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth, h = o * r, c = s * r,
        l = a.FRUSTUMSIZE, u = c / h * l, d = ["bg"], f = function () {
            function e(i) {
                t(this, e), this.texture = {}, this.material = {}, this.geometry = {}, this.obj = {}, this.canvas = {}, this.context = {}, this._touchInfo = {
                    trackingID: -1,
                    maxDy: 0,
                    maxDx: 0
                }, this.cwidth = c, this.cheight = 50, this.options = Object.assign({}, {}, i), this._createPlane()
            }

            return i(e, [{
                key: "showLookers", value: function (e) {
                    this.showState = !0, e = e || {}, this._drawLookers(e)
                }
            }, {
                key: "showLookersShare", value: function (e) {
                    this.showState = !0, e = e || {}
                }
            }, {
                key: "hideLookers", value: function () {
                    this.showState = !1;
                    for (var e = 0; e < d.length; e++) this.obj[d[e]].visible = !1, this.options.camera.remove(this.obj[d[e]])
                }
            }, {
                key: "_drawLookers", value: function (e) {
                    var t = this, i = this.context.bg;
                    i.fillStyle = "pink", i.strokeStyle = "red", i.lineWidth = 2 * r, i.clearRect(0, 0, this._cx(414), this._cx(this.cheight));
                    var n = this.cheight;
                    if (e.avaImg) {
                        for (var a = c - e.avatar.length * this._cx(32), s = this, o = 0; o < e.avatar.length; o++) !function () {
                            var i = o * t._cx(36) + a;
                            t._drawImageCenter(e.avatar[o], i, n / 2, s._cx(25), s._cx(25), "bg", function () {
                                s._drawImageCenter("res/2d/ava_square.png", i, n / 2, s._cx(26), s._cx(26), "bg")
                            })
                        }();
                        i.fillStyle = "rgba(0,0,0,0.56)", i.font = this._cf(14), i.textAlign = "right", i.textBaseline = "middle", i.fillText("" + e.num + "", a - this._cx(20), this._cx(16))
                    }
                    e.icon && this._drawImageCenter("res/observShare.png", this._cx(35), n / 2, this._cx(14), this._cx(16), "bg"), e.wording && (i.fillStyle = "rgba(0,0,0,0.56)", i.font = this._cf(14), i.textAlign = "left", i.textBaseline = "middle", i.fillText("", this._cx(55), this._cx(16))), this._updatePlane("bg")
                }
            }, {
                key: "_createPlane", value: function () {
                    for (var e = 0; e < d.length; e++) this.canvas[d[e]] = document.createElement("canvas"), this.context[d[e]] = this.canvas[d[e]].getContext("2d"), this.canvas[d[e]].width = c, this.canvas[d[e]].height = this.cheight * r, this.texture[d[e]] = new n.Texture(this.canvas[d[e]]), this.material[d[e]] = new n.MeshBasicMaterial({
                        map: this.texture[d[e]],
                        transparent: !0
                    }), this.geometry[d[e]] = new n.PlaneGeometry(u, this.cheight / o * l), this.obj[d[e]] = new n.Mesh(this.geometry[d[e]], this.material[d[e]]), this.material[d[e]].map.minFilter = n.LinearFilter, this.obj[d[e]].position.y = -(.5 - this.cheight / 2 / o) * l, this.obj[d[e]].position.x = 0, this.obj[d[e]].position.z = 9 - .001 * e
                }
            }, {
                key: "_updatePlane", value: function (e) {
                    this.showState && (this.texture[e].needsUpdate = !0, this.obj[e].visible = !0, this.options.camera.add(this.obj[e]))
                }
            }, {
                key: "_drawImageCenter", value: function (e, t, i, n, a, r, s) {
                    "/0" != e && "/96" != e && "/64" != e && e || (e = "res/ava.png");
                    var o = new Image, h = this, c = this.context[r];
                    o.onload = function () {
                        c.drawImage(o, t - n / 2, i - a / 2, n, a), !!s && s(), h._updatePlane(r)
                    }, o.onerror = function () {
                        !!s && s()
                    }, o.src = e
                }
            }, {
                key: "_cx", value: function (e) {
                    return e * s / 414 * r
                }
            }, {
                key: "_cf", value: function (e) {
                    return e * r * s / 414 + "px Helvetica"
                }
            }]), e
        }();
    exports.default = f;
});
define("js/pages/observe/observeGg.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (t, i, n) {
            return i && e(t.prototype, i), n && e(t, n), t
        }
    }(), i = function () {
        function i(t) {
            e(this, i), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.UI = this.game.UI, this.name = "viewerGG"
        }

        return t(i, [{
            key: "show", value: function (e) {
                var t = this.model.observeInfo;
                this.full2D.showLookersPage({
                    type: "gg",
                    score: e,
                    headimg: t.headimg,
                    nickname: t.nickName
                }), this.UI.hideScore()
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D()
            }
        }]), i
    }();
    exports.default = i;
});
define("js/pages/observe/observeOut.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (t, i, n) {
            return i && e(t.prototype, i), n && e(t, n), t
        }
    }(), i = function () {
        function i(t) {
            e(this, i), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.UI = this.game.UI, this.name = "viewerOut"
        }

        return t(i, [{
            key: "show", value: function () {
                var e = this.model.observeInfo;
                this.full2D.showLookersPage({
                    type: "out",
                    headimg: e.headimg,
                    nickname: e.nickName
                }), this.UI.hideScore()
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D()
            }
        }]), i
    }();
    exports.default = i;
});
define("js/pages/observe/observeWaiting.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var o = t[i];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
            }
        }

        return function (t, i, o) {
            return i && e(t.prototype, i), o && e(t, o), t
        }
    }(), i = function () {
        function i(t) {
            e(this, i), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.UI = this.game.UI, this.name = "viewerWaiting"
        }

        return t(i, [{
            key: "show", value: function () {
                var e = this.model.observeInfo;
                this.full2D.showLookersPage({
                    type: "in",
                    headimg: e.headimg,
                    nickname: e.nickName
                }), this.UI.scoreText.obj.position.x = 0, this.UI.scoreText.obj.position.y = 11, this.UI.scoreText.changeStyle({textAlign: "center"}), this.UI.showScore()
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D(), this.UI.hideScore(), this.UI.scoreText.obj.position.y = 21, this.UI.scoreText.obj.position.x = -13, this.UI.scoreText.changeStyle({textAlign: "left"})
            }
        }]), i
    }();
    exports.default = i;
});
define("js/pages/pages2d/base.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        (e = Object.assign({}, {
            self: {},
            type: "bg"
        }, e)).self.showState && (e.self.canvasType == y.gameOver && "bg" != e.type && "btn" != e.type && "sample" != e.type || e.self.canvasType == y.start && "bg" != e.type && "btn" != e.type && "sample" != e.type || e.self.canvasType == y.record && "bg" != e.type || (e.self.texture[e.type].needsUpdate = !0, e.self.obj[e.type].visible = !0, e.self.options.camera.add(e.self.obj[e.type])))
    }

    function t(e, t, n) {
        if (e && t) {
            var r = e.distanceToPoint(t);
            r < 0 && !n && e.negate(), n && r > 0 && e.negate()
        }
    }

    function n(e, t) {
        if (!h) {
            e.showState = !1;
            for (var n = 0; n < m.length; n++) !e.obj[m[n]] || t && t.indexOf(m[n]) >= 0 || (e.obj[m[n]].visible = !1, e.options.camera.remove(e.obj[m[n]]));
            t || (e.lastopt = void 0)
        }
    }

    function r(e) {
        var t = e * u / 414;
        return g / u < 736 / 414 && (t = e * g / 736), t * d
    }

    function o(e) {
        var t = e * u / 414;
        return g / u < 736 / 414 && (t = e * g / 736 + (u - 414 * g / 736) / 2), t * d
    }

    function a(e) {
        return (g / u > 736 / 414 ? e * u / 414 + (g - 736 * u / 414) / 2 : e * g / 736) * d
    }

    function s(e, t) {
        var n = e * d * u / 414;
        return g / u < 736 / 414 && (n = e * d * g / 736), t && I ? n + "px " + I : n + "px Helvetica"
    }

    function i(t) {
        "/0" != (t = Object.assign({}, {
            self: {},
            src: "",
            pos: [0, 0, 100, 100],
            type: "bg",
            cb: null,
            imgid: 0,
            noupdate: !1,
            round: !1
        }, t)).src && "/96" != t.src && "/64" != t.src && t.src || (t.src = "res/ava.png");
        var n = new Image, s = t.self.context[t.type];
        n.onload = function () {
            if (t.self.imgid[t.type] == t.imgid) {
                if (t.round) {
                    s.save();
                    var i = void 0;
                    i = "list1" == t.type || "list2" == t.type ? r(t.pos[1]) - r(t.pos[3]) / 2 : a(t.pos[1]) - r(t.pos[3]) / 2, p(o(t.pos[0]) - r(t.pos[2]) / 2, i, r(t.pos[2]), r(t.pos[3]), 2, s), s.clip(), s.drawImage(n, o(t.pos[0]) - r(t.pos[2]) / 2, i, r(t.pos[2]), r(t.pos[3])), s.closePath(), s.restore()
                } else "list1" == t.type || "list2" == t.type ? s.drawImage(n, o(t.pos[0]) - r(t.pos[2]) / 2, r(t.pos[1]) - r(t.pos[3]) / 2, r(t.pos[2]), r(t.pos[3])) : s.drawImage(n, o(t.pos[0]) - r(t.pos[2]) / 2, a(t.pos[1]) - r(t.pos[3]) / 2, r(t.pos[2]), r(t.pos[3]));
                !!t.cb && t.cb(), t.noupdate || e({self: t.self, type: t.type})
            }
        }, n.onerror = function () {
            !!t.cb && t.cb()
        }, n.src = t.src
    }

    function p(e, t, n, r, o, a) {
        a.beginPath(), a.moveTo(e, t + o - 1), a.lineTo(e, t + r - o), a.quadraticCurveTo(e, t + r, e + o, t + r), a.lineTo(e + n - o, t + r), a.quadraticCurveTo(e + n, t + r, e + n, t + r - o), a.lineTo(e + n, t + o), a.quadraticCurveTo(e + n, t, e + n - o, t), a.lineTo(e + o, t), a.quadraticCurveTo(e, t, e, t + o), a.stroke(), a.closePath()
    }

    function l(e, t) {
        return (e = e || "").replace(/[^\x00-\xff]/g, "**").length > t && (e = l(e = e.substring(0, e.length - 1), t)), e
    }

    Object.defineProperty(exports, "__esModule", {value: !0}), exports.ListLineHeight = exports.DEBUG = exports.frustumSizeWidth = exports.frustumSizeHeight = exports.CANVASTYPE = exports.WIDTH = exports.HEIGHT = exports.realDpr = exports.Dpr = void 0, exports.createPlane = function (e, t) {
        if (n(e, t), e.showState = !0, !e.canvas.bg) {
            h && (m = ["sample", "btn", "list1", "list2", "bg"]);
            for (var o = 0; o < m.length; o++) e.canvas[m[o]] = document.createElement("canvas"), e.context[m[o]] = e.canvas[m[o]].getContext("2d"), e.canvas[m[o]].width = x, "list1" == m[o] || "list2" == m[o] ? e.canvas[m[o]].height = 10 * r(k) : e.canvas[m[o]].height = w, e.texture[m[o]] = new c.Texture(e.canvas[m[o]]), e.material[m[o]] = new c.MeshBasicMaterial({
                map: e.texture[m[o]],
                transparent: !0
            }), "list1" == m[o] || "list2" == m[o] ? e.geometry[m[o]] = new c.PlaneBufferGeometry(b, 10 * r(k) / w * v) : e.geometry[m[o]] = new c.PlaneBufferGeometry(b, v), e.obj[m[o]] = new c.Mesh(e.geometry[m[o]], e.material[m[o]]), e.material[m[o]].map.minFilter = c.LinearFilter, e.obj[m[o]].position.y = 0, e.obj[m[o]].position.x = 0, e.obj[m[o]].position.z = 9 - .001 * o;
            h && T && (e.context.sample.globalAlpha = .4, setTimeout(function () {
                i({self: e, src: "res/sample.png", pos: [207, 368, 414, 736], type: "sample", imgid: e.imgid.sample})
            }, 2e3))
        }
    }, exports.updatePlane = e, exports.updateClip = function (e) {
        var n = e.self;
        n.p0 || (n.p0 = new c.Vector3(0, 0, 9), n.p1 = new c.Vector3(-b * (.5 - o(30) / x), (.5 - a(143) / w) * v, 9), n.p2 = new c.Vector3(b * (.5 - o(30) / x), v * (.5 - a(143) / w), 9), n.p3 = new c.Vector3(b * (.5 - o(30) / x), -v * (.5 - a(144) / w), 9), n.p4 = new c.Vector3(-b * (.5 - o(30) / x), -v * (.5 - a(144) / w), 9)), n.p5 || (n.p5 = new c.Vector3(-b * (.5 - o(30) / x), (.5 - a(205) / w) * v, 9), n.p6 = new c.Vector3(b * (.5 - o(30) / x), v * (.5 - a(205) / w), 9), n.p7 = new c.Vector3(b * (.5 - o(30) / x), -v * (.5 - a(104) / w), 9), n.p8 = new c.Vector3(-b * (.5 - o(30) / x), -v * (.5 - a(104) / w), 9)), n.p9 || (n.p9 = new c.Vector3(-b * (.5 - o(30) / x), -v * (.5 - a(332) / w), 9), n.p10 = new c.Vector3(b * (.5 - o(30) / x), -v * (.5 - a(332) / w), 9), n.p11 = new c.Vector3(b * (.5 - o(30) / x), -v * (.5 - a(175) / w), 9), n.p12 = new c.Vector3(-b * (.5 - o(30) / x), -v * (.5 - a(175) / w), 9)), n.p13 || (n.p13 = new c.Vector3(-b * (.5 - o(30) / x), (.5 - a(318) / w) * v, 9), n.p14 = new c.Vector3(b * (.5 - o(30) / x), v * (.5 - a(318) / w), 9), n.p15 = new c.Vector3(b * (.5 - o(30) / x), -v * (.5 - a(176) / w), 9), n.p16 = new c.Vector3(-b * (.5 - o(30) / x), -v * (.5 - a(176) / w), 9));
        var r = n.p0.clone(), s = n.p1.clone(), i = n.p2.clone(), p = n.p3.clone(), l = n.p4.clone();
        n.canvasType == y.pk && (s = n.p5.clone(), i = n.p6.clone(), p = n.p7.clone(), l = n.p8.clone()), n.canvasType == y.relayRank && (s = n.p9.clone(), i = n.p10.clone(), p = n.p11.clone(), l = n.p12.clone(), 1 != n.opt.my_rank && (s = n.p13.clone(), i = n.p14.clone(), p = n.p15.clone(), l = n.p16.clone())), n.options.camera.updateMatrixWorld();
        var f = n.options.camera.matrixWorld;
        r.applyMatrix4(f), s.applyMatrix4(f), i.applyMatrix4(f), p.applyMatrix4(f), l.applyMatrix4(f);
        var d = new c.Triangle(i, s), u = d.plane();
        n.canvasType == y.relayRank && 1 == n.opt.my_rank ? t(u, r.clone(), !0) : t(u, r.clone());
        var g = (d = new c.Triangle(p, i)).plane();
        t(g, r.clone());
        var m = (d = new c.Triangle(l, p)).plane();
        t(m, r.clone());
        var h = (d = new c.Triangle(s, l)).plane();
        t(h, r.clone()), n.material.list1.clippingPlanes = [u, g, m, h], n.material.list1.needsUpdate = !0, n.material.list2.clippingPlanes = [u, g, m, h], n.material.list2.needsUpdate = !0
    }, exports.hide = n, exports.cwh = r, exports.cx = o, exports.cy = a, exports.rerank = function (e) {
        for (var t, n, r = 0, o = e.length; r < o; r++) for (t = 0; t < o; t++) e[r].week_best_score > e[t].week_best_score && (n = e[t], e[t] = e[r], e[r] = n);
        return e
    }, exports.drawImageCenter = i, exports.drawHomeImg = function (t, n) {
        var r = new Image;
        r.onload = function () {
            1624 == w && 750 == x ? t.drawImage(r, 10 * d, 44 * d, 104, 64) : t.drawImage(r, 10 * d, 10 * d, 104, 64), e({
                self: n,
                type: "bg"
            })
        }, r.src = "res/2d/home.png"
    }, exports.drawReturnImg = function (t, n) {
        var r = new Image;
        r.onload = function () {
            1624 == w && 750 == x ? t.drawImage(r, 10 * d, 45 * d, 86, 64) : t.drawImage(r, 10 * d, 10 * d, 86, 64), e({
                self: n,
                type: "bg"
            })
        }, r.src = "res/2d/return.png"
    }, exports.roundedRect = p, exports.drawText = function (e) {
        var t = (e = Object.assign({}, {
            self: {},
            t: "",
            size: 17,
            pos: [0, 0],
            type: "bg",
            special: !1,
            align: "center",
            color: "#fff",
            bold: !1,
            italic: !1
        }, e)).self.context[e.type], n = s(e.size, e.special);
        e.bold && (n = "bold " + n), e.italic && (n = "italic " + n), t.font = n, t.textBaseline = "middle", t.textAlign = e.align, t.fillStyle = e.color, "list1" == e.type || "list2" == e.type ? t.fillText(e.t, o(e.pos[0]), r(e.pos[1])) : t.fillText(e.t, o(e.pos[0]), a(e.pos[1]))
    }, exports.routeCanvas = function (e, t) {
        e.last2CanvasType = e.lastCanvasType, e.lastCanvasType = e.canvasType, e.canvasType = y[t]
    }, exports.cname = function (e, t) {
        return t = t || 16, (e = e || "").replace(/[^\x00-\xff]/g, "**").length > t + 2 && (e = l(e, t) + "..."), e
    }, exports.findSelfIndex = function (e, t, n) {
        return e.nickname === this.myUserInfo.nickname && e.week_best_score === this.myUserInfo.week_best_score
    }, exports.relayRerank = function (e) {
        for (var t, n, r = 0, o = e.length; r < o; r++) for (t = 0; t < o; t++) e[r].rank < e[t].rank && (n = e[t], e[t] = e[r], e[r] = n);
        return e
    };
    var c = function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e) for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            return t.default = e, t
        }(require("../../lib/three")), f = require("../../config"),
        d = exports.Dpr = window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio,
        u = (exports.realDpr = window.devicePixelRatio, window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth),
        g = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth, w = exports.HEIGHT = g * d,
        x = exports.WIDTH = u * d, m = ["btn", "list1", "list2", "bg"], y = exports.CANVASTYPE = {
            friendRank: 0,
            groupRank: 1,
            gameOver: 2,
            start: 3,
            pk: 4,
            lookers: 5,
            gameOverNew: 6,
            gameOverHighest: 7,
            beginner: 8,
            verify: 9,
            relay: 10,
            relayGG: 11,
            relayRank: 12,
            relayLookers: 13,
            record: 14,
            relayBeginner: 15,
            relayQr: 16
        }, v = exports.frustumSizeHeight = f.FRUSTUMSIZE, b = exports.frustumSizeWidth = x / w * v, h = exports.DEBUG = !1,
        T = !1, k = exports.ListLineHeight = 60, I = wx.loadFont("res/num.ttf");
});
define("js/pages/pages2d/beginner.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0}), exports.drawBeginnerPage = function (r) {
        var t = (r = Object.assign({}, {self: {}}, r)).self;
        (0, e.routeCanvas)(t, "beginner"), (0, e.createPlane)(t);
        var a = t.context.bg;
        a.clearRect(0, 0, e.WIDTH, e.HEIGHT), a.fillStyle = "rgba(255,255,255,0.3)", a.fillRect((0, e.cx)(103), (0, e.cy)(134), (0, e.cwh)(206), (0, e.cwh)(115)), (0, e.drawText)({
            t: "",
            self: t,
            size: 17,
            pos: [207, 172],
            color: "black"
        }), (0, e.drawText)({
            t: "",
            self: t,
            size: 17,
            pos: [149, 213],
            color: "black",
            align: "left"
        }), (0, e.drawText)({
            t: "",
            self: t,
            size: 17,
            pos: [265, 213],
            color: "black",
            align: "right"
        }), (0, e.drawImageCenter)({
            self: t,
            src: "res/i.png",
            pos: [198, 211, 13.2, 35.6],
            type: "bg",
            imgid: t.imgid.bg
        }), (0, e.updatePlane)({self: t, type: "bg"})
    };
    var e = require("./base");
});
define("js/pages/pages2d/bl.js", function (require, module, exports) {
    "use strict";

    function r(r, n, o, g, f, s) {
        if (!(isNaN(s) || s < 1)) {
            s |= 0;
            var x, b, i, l, u, v, c, h, d, p, m, w, B, D, I, N, _, j, k, y, A, C, G, M, O, P = r,
                R = (x = P.getImageData(n, o, g, f)).data, q = s + s + 1, z = g - 1, E = f - 1, F = s + 1,
                H = F * (F + 1) / 2, J = new t, K = J;
            for (l = 1; l < q; l++) if (K = K.next = new t, l == F) var L = K;
            K.next = J;
            var Q = null, S = null;
            h = c = 0;
            var T = a[s], U = e[s];
            for (i = 0; i < f; i++) {
                for (_ = j = k = y = d = p = m = w = 0, B = F * (A = R[c]), D = F * (C = R[c + 1]), I = F * (G = R[c + 2]), N = F * (M = R[c + 3]), d += H * A, p += H * C, m += H * G, w += H * M, K = J, l = 0; l < F; l++) K.r = A, K.g = C, K.b = G, K.a = M, K = K.next;
                for (l = 1; l < F; l++) u = c + ((z < l ? z : l) << 2), d += (K.r = A = R[u]) * (O = F - l), p += (K.g = C = R[u + 1]) * O, m += (K.b = G = R[u + 2]) * O, w += (K.a = M = R[u + 3]) * O, _ += A, j += C, k += G, y += M, K = K.next;
                for (Q = J, S = L, b = 0; b < g; b++) R[c + 3] = M = w * T >> U, 0 != M ? (M = 255 / M, R[c] = (d * T >> U) * M, R[c + 1] = (p * T >> U) * M, R[c + 2] = (m * T >> U) * M) : R[c] = R[c + 1] = R[c + 2] = 0, d -= B, p -= D, m -= I, w -= N, B -= Q.r, D -= Q.g, I -= Q.b, N -= Q.a, u = h + ((u = b + s + 1) < z ? u : z) << 2, d += _ += Q.r = R[u], p += j += Q.g = R[u + 1], m += k += Q.b = R[u + 2], w += y += Q.a = R[u + 3], Q = Q.next, B += A = S.r, D += C = S.g, I += G = S.b, N += M = S.a, _ -= A, j -= C, k -= G, y -= M, S = S.next, c += 4;
                h += g
            }
            for (b = 0; b < g; b++) {
                for (j = k = y = _ = p = m = w = d = 0, B = F * (A = R[c = b << 2]), D = F * (C = R[c + 1]), I = F * (G = R[c + 2]), N = F * (M = R[c + 3]), d += H * A, p += H * C, m += H * G, w += H * M, K = J, l = 0; l < F; l++) K.r = A, K.g = C, K.b = G, K.a = M, K = K.next;
                for (v = g, l = 1; l <= s; l++) c = v + b << 2, d += (K.r = A = R[c]) * (O = F - l), p += (K.g = C = R[c + 1]) * O, m += (K.b = G = R[c + 2]) * O, w += (K.a = M = R[c + 3]) * O, _ += A, j += C, k += G, y += M, K = K.next, l < E && (v += g);
                for (c = b, Q = J, S = L, i = 0; i < f; i++) R[(u = c << 2) + 3] = M = w * T >> U, M > 0 ? (M = 255 / M, R[u] = (d * T >> U) * M, R[u + 1] = (p * T >> U) * M, R[u + 2] = (m * T >> U) * M) : R[u] = R[u + 1] = R[u + 2] = 0, d -= B, p -= D, m -= I, w -= N, B -= Q.r, D -= Q.g, I -= Q.b, N -= Q.a, u = b + ((u = i + F) < E ? u : E) * g << 2, d += _ += Q.r = R[u], p += j += Q.g = R[u + 1], m += k += Q.b = R[u + 2], w += y += Q.a = R[u + 3], Q = Q.next, B += A = S.r, D += C = S.g, I += G = S.b, N += M = S.a, _ -= A, j -= C, k -= G, y -= M, S = S.next, c += g
            }
            P.putImageData(x, n, o), console.log("end ?")
        }
    }

    function t() {
        this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null
    }

    Object.defineProperty(exports, "__esModule", {value: !0}), exports.stackBlurCanvasRGBA = r;
    var a = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259],
        e = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
});
define("js/pages/pages2d/gg.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        e.imgid.bg++;
        var s = e.opt;
        s.score = s.score || 0, s.highest_score = s.highest_score || 0, s.banType = s.banType || 0;
        var r = e.context.bg;
        r.clearRect(0, 0, t.WIDTH, t.HEIGHT), r.fillStyle = "rgba(0,0,0, 0.8)", r.fillRect(0, 0, t.WIDTH, t.HEIGHT), (0, t.drawHomeImg)(r, e);
        var a = 0;
        s.banType ? a = 69 : ((0, t.drawImageCenter)({
            self: e,
            src: "res/btn.png",
            pos: [207, 214, 86, 32],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, t.drawText)({self: e, size: 13, t: "", pos: [207, 214]})), (0, t.drawText)({
            self: e,
            size: 14,
            t: "",
            pos: [207, 84 + a]
        }), (0, t.drawText)({
            self: e,
            size: 88,
            special: !0,
            t: s.score,
            pos: [212, 150 + a]
        }), r.fillStyle = "rgba(255,255,255,0.2)", r.fillRect((0, t.cx)(162), (0, t.cy)(78 + a), (0, t.cwh)(9), (0, t.cwh)(3)), r.fillRect((0, t.cx)(162), (0, t.cy)(84 + a), (0, t.cwh)(9), (0, t.cwh)(3)), r.fillRect((0, t.cx)(241), (0, t.cy)(78 + a), (0, t.cwh)(9), (0, t.cwh)(3)), r.fillRect((0, t.cx)(241), (0, t.cy)(84 + a), (0, t.cwh)(9), (0, t.cwh)(3));
        var i = !1;
        if ((s.game_cnt > 5 || s.score > 5) && s.score < s.highest_score && 1 != e.myidx && !e._has_show_tired && +new Date / 1e3 - s.start_time > 1800 && (i = !0, e._has_show_tired = !0), i) r.lineWidth = 4 * t.Dpr, r.strokeStyle = "#fff", r.fillStyle = "#fff", (0, t.roundedRect)((0, t.cx)(31), (0, t.cy)(298), (0, t.cwh)(354), (0, t.cwh)(210), 1 * t.Dpr, r), r.fill(), (0, t.drawText)({
            self: e,
            t: "",
            pos: [80, 370],
            size: 17,
            color: "black",
            align: "left"
        }), (0, t.drawText)({
            self: e,
            t: "",
            pos: [80, 410],
            size: 17,
            color: "black",
            align: "left"
        }), (0, t.drawImageCenter)({
            self: e,
            src: "res/tired.png",
            pos: [297, 397, 179, 185],
            type: "bg",
            imgid: e.imgid.bg
        }), e.opt.type = "tired"; else if (s.banType) (0, t.drawText)({
            self: e,
            t: "",
            pos: [207, 373],
            size: 17
        }), (0, t.drawText)({
            self: e,
            t: "",
            pos: [207, 399],
            size: 17
        }), r.beginPath(), r.lineWidth = .5 * t.Dpr, r.strokeStyle = "rgba(255,255,255,0.1)", r.moveTo((0, t.cx)(0), (0, t.cy)(296)), r.lineTo((0, t.cx)(414), (0, t.cy)(296)), r.moveTo((0, t.cx)(0), (0, t.cy)(526)), r.lineTo((0, t.cx)(414), (0, t.cy)(526)), r.stroke(), r.closePath(), 1 == s.banType && ((0, t.drawImageCenter)({
            self: e,
            src: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJNNcIVa8Pr2VajbZ52iaZX9Vlib0QAKEJGDIV8F9iaFeqXoawUbQkDP8zc6fbm95nKLgw/0?wx_fmt=png",
            pos: [207, 459, 138, 44],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, t.drawText)({self: e, t: "", pos: [207, 459], size: 17})); else {
            r.lineWidth = .5 * t.Dpr, r.fillStyle = "rgba(0,0,0,0.3)", r.strokeStyle = "rgba(255,255,255,0.3)", (0, t.roundedRect)((0, t.cx)(30), (0, t.cy)(297), (0, t.cwh)(354), (0, t.cwh)(192), 4 * t.Dpr, r), r.fill(), r.fillStyle = "rgba(255,255,255,0.06)", r.fillRect((0, t.cx)(150), (0, t.cy)(336), (0, t.cwh)(115), (0, t.cwh)(153)), r.beginPath(), r.lineWidth = .5 * t.Dpr, r.strokeStyle = "rgba(255,255,255,0.4)", r.moveTo((0, t.cx)(30), (0, t.cy)(336)), r.lineTo((0, t.cx)(384), (0, t.cy)(336)), r.stroke(), r.closePath(), (0, t.drawText)({
                self: e,
                t: "  ",
                color: "rgba(255,255,255,0.6)",
                align: "left",
                size: 12,
                pos: [46, 316]
            }), (0, t.drawText)({
                self: e,
                t: "",
                align: "left",
                size: 12,
                pos: [291, 316]
            }), (0, t.drawImageCenter)({
                self: e,
                src: "res/r_arr.png",
                pos: [371, 315, 6.6, 10],
                type: "bg",
                imgid: e.imgid.bg
            });
            var o = e.myidx - 2, c = 0;
            1 == e.sotedRankList.length && (c = 1);
            for (var l = 0; l < 3; l++) if (1 == e.myidx && 0 == l && o++, e.myidx != e.sotedRankList.length || 2 != l) {
                var n = "";
                n = e.myidx == o + 1 + l ? "#41bf8c" : "#888", e.sotedRankList[o + l] && function () {
                    (0, t.drawText)({
                        self: e,
                        color: n,
                        italic: !0,
                        bold: !0,
                        size: 16,
                        t: o + 1 + l,
                        pos: [90 + 118 * (l + c), 356]
                    }), (0, t.drawText)({
                        self: e,
                        color: "#888",
                        t: (0, t.cname)(e.sotedRankList[o + l].nickname, 14),
                        pos: [90 + 118 * (l + c), 435],
                        size: 14
                    }), (0, t.drawText)({
                        self: e,
                        size: 22,
                        special: !0,
                        t: e.sotedRankList[o + l].week_best_score || 0,
                        pos: [90 + 118 * (l + c), 463]
                    });
                    var s = 90 + 118 * (l + c);
                    (0, t.drawImageCenter)({
                        self: e,
                        round: !0,
                        src: e.sotedRankList[o + l].headimg,
                        pos: [s, 393, 42, 42],
                        type: "bg",
                        cb: function () {
                            (0, t.drawImageCenter)({
                                self: e,
                                src: "res/ava_rank.png",
                                pos: [s, 393, 58, 58],
                                type: "bg",
                                imgid: e.imgid.bg
                            })
                        },
                        imgid: e.imgid.bg,
                        noupdate: !0
                    })
                }()
            }
        }
        var g = e.context.btn;
        g.clearRect(0, 0, t.WIDTH, t.HEIGHT), i ? (0, t.drawImageCenter)({
            self: e,
            src: "res/noplay.png",
            pos: [207, 607, 212, 84],
            type: "btn",
            cb: function () {
                e.noplay_time = 5, (0, t.drawText)({
                    self: e,
                    type: "btn",
                    color: "#00C777",
                    size: 22,
                    t: e.noplay_time,
                    pos: [140, 607]
                }), (0, t.updatePlane)({self: e, type: "btn"}), e.timer = setInterval(function () {
                    e.noplay_time--, e.noplay_time <= 0 ? (clearInterval(e.timer), g.clearRect(0, 0, t.WIDTH, t.HEIGHT), (0, t.drawImageCenter)({
                        self: e,
                        src: "res/replay.png",
                        pos: [207, 607, 212, 84],
                        type: "btn",
                        imgid: e.imgid.btn
                    })) : (g.fillStyle = "white", g.fillRect((0, t.cx)(125), (0, t.cy)(590), (0, t.cwh)(30), (0, t.cwh)(30)), (0, t.drawText)({
                        self: e,
                        color: "#00C777",
                        size: 22,
                        t: e.noplay_time,
                        pos: [140, 607],
                        type: "btn"
                    }), (0, t.updatePlane)({self: e, type: "btn"}))
                }, 1e3)
            },
            imgid: e.imgid.btn
        }) : ((g = e.context.btn).clearRect((0, t.cx)(91), (0, t.cy)(547), (0, t.cwh)(232), (0, t.cwh)(94)), (0, t.drawImageCenter)({
            self: e,
            src: "res/replay.png",
            pos: [207, 607, 212, 84],
            type: "btn",
            imgid: e.imgid.btn
        })), (0, t.drawText)({
            self: e,
            t: "" + Math.max(s.highest_score, s.score),
            size: 14,
            pos: [207, 703]
        }), (0, t.updatePlane)({self: e, type: "bg"})
    }

    Object.defineProperty(exports, "__esModule", {value: !0}), exports.routeGameOver = function (a, i) {
        (0, t.createPlane)(a);
        var o = a.opt;
        a.myUserInfo = s.default.getMyUserInfo() || {
            headimg: "",
            nickname: "",
            week_best_score: 0,
            score_info: [{score: 0}]
        }, a.myUserInfo.last_week_best_score = o.week_best_score, a.myUserInfo.week_best_score = Math.max(o.week_best_score, o.score) || 0;
        var c = s.default.getFriendsScore() || [];
        c.push(a.myUserInfo);
        var l = (0, t.rerank)(c);
        if (a.sotedRankList = l, a.myidx = l.findIndex(t.findSelfIndex.bind(a)) + 1, o.score >= o.highest_score || o.score >= a.myUserInfo.last_week_best_score) {
            (s.default.getMyUserInfo() || {
                headimg: "",
                nickname: "",
                week_best_score: 0,
                score_info: [{score: 0}]
            }).week_best_score = o.score;
            var n = s.default.getFriendsScore() || [];
            a.changlleList = [];
            for (var g = 0; g < n.length; g++) n[g].week_best_score < o.score && n[g].week_best_score > a.myUserInfo.last_week_best_score && a.changlleList.push(n[g])
        }
        a.opt.banType || i ? ((0, t.routeCanvas)(a, "gameOver"), e(a)) : o.score > o.highest_score ? ((0, t.routeCanvas)(a, "gameOverHighest"), a.opt.type = "history", (0, r.drawGameOverHighest)(a, "history")) : l.length > 1 && o.score >= l[0].week_best_score ? ((0, t.routeCanvas)(a, "gameOverHighest"), a.opt.type = "rank", (0, r.drawGameOverHighest)(a, "rank")) : o.score > a.myUserInfo.last_week_best_score ? ((0, t.routeCanvas)(a, "gameOverHighest"), a.opt.type = "week", (0, r.drawGameOverHighest)(a, "week")) : ((0, t.routeCanvas)(a, "gameOver"), e(a))
    }, exports.drawGameOver = e;
    var t = require("./base"), s = function (e) {
        return e && e.__esModule ? e : {default: e}
    }(require("../../store/storage")), r = require("./gghigh");
});
define("js/pages/pages2d/gghigh.js", function (require, module, exports) {
    "use strict";

    function e(e, r) {
        if (e.imgid.btn++, !(e.changlleListStart + 5 * r < 0 || e.changlleListStart + 5 * r >= e.changlleList.length)) {
            e.changlleListStart = e.changlleListStart + 5 * r;
            var s = e.changlleList.slice(e.changlleListStart, e.changlleListStart + 5), i = s.length, c = 32,
                l = 207 - (32 * i + 10 * (i - 1)) / 2;
            e.context.btn.clearRect((0, t.cx)(30), (0, t.cy)(448), (0, t.cwh)(354), (0, t.cwh)(55));
            for (var g = 0; g < i; g++) !function () {
                var r = l + 16 + 42 * g;
                (0, t.drawImageCenter)({
                    self: e,
                    round: !0,
                    src: s[g].headimg,
                    pos: [r, 469, c, c],
                    type: "btn",
                    cb: function () {
                        (0, t.drawImageCenter)({
                            self: e,
                            src: "res/ava_rank.png",
                            pos: [r, 469, 46, 46],
                            type: "btn",
                            imgid: e.imgid.btn
                        })
                    },
                    imgid: e.imgid.btn,
                    noupdate: !0
                })
            }();
            e.changlleList.length > 5 && e.changlleListStart + 5 < e.changlleList.length && (0, t.drawImageCenter)({
                self: e,
                src: "res/r_arr1.png",
                pos: [339, 469, 6, 8],
                type: "btn",
                imgid: e.imgid.btn
            }), e.changlleList.length > 5 && 0 != e.changlleListStart && (0, t.drawImageCenter)({
                self: e,
                src: "res/l_arr.png",
                pos: [69, 469, 6, 8],
                type: "btn",
                imgid: e.imgid.btn
            })
        }
    }

    Object.defineProperty(exports, "__esModule", {value: !0}), exports.drawGameOverHighest = function (r, s) {
        var i = r.opt;
        r.imgid.bg++, i.score = i.score || 0;
        var c = r.context.bg;
        c.clearRect(0, 0, t.WIDTH, t.HEIGHT), c.fillStyle = "rgba(0,0,0, 0.8)", c.fillRect(0, 0, t.WIDTH, t.HEIGHT);
        var l = r.context.btn;
        if (l.clearRect(0, 0, t.WIDTH, t.HEIGHT), (0, t.drawText)({
                self: r,
                size: 14,
                t: "" + Math.max(i.highest_score, i.score),
                pos: [207, 703]
            }), "history" == s || "week" == s) {
            0 == r.changlleList.length ? (c.lineWidth = 2 * t.Dpr, c.strokeStyle = "rgba(255,255,255,0.06)", c.fillStyle = "rgba(0,0,0,0.6)", (0, t.roundedRect)((0, t.cx)(30), (0, t.cy)(104), (0, t.cwh)(354), (0, t.cwh)(371), 4 * t.Dpr, c), c.fill(), (0, t.drawImageCenter)({
                self: r,
                src: "res/pure_share.png",
                pos: [207, 440, 18, 24],
                type: "bg",
                imgid: r.imgid.bg
            })) : (c.lineWidth = 2 * t.Dpr, c.strokeStyle = "rgba(255,255,255,0.06)", c.fillStyle = "rgba(0,0,0,0.6)", (0, t.roundedRect)((0, t.cx)(30), (0, t.cy)(104), (0, t.cwh)(354), (0, t.cwh)(401), 4 * t.Dpr, c), c.fill(), c.lineWidth = .5 * t.Dpr, c.strokeStyle = "rgba(255,255,255,0.2)", c.beginPath(), c.moveTo((0, t.cx)(127), (0, t.cy)(406)), c.lineTo((0, t.cx)(287), (0, t.cy)(406)), c.stroke(), c.closePath(), (0, t.drawText)({
                self: r,
                size: 14,
                t: "" + r.changlleList.length + "",
                pos: [207, 429]
            }), r.changlleListStart = 0, e(r, 0), (0, t.drawImageCenter)({
                self: r,
                src: "res/pure_share.png",
                pos: [207, 368, 18, 24],
                type: "bg",
                imgid: r.imgid.bg
            }));
            var g = "", a = "";
            "history" == s && (r.opt.highest_score < 100 && r.opt.score >= 100 && (g = "", a = "#509FC9"), r.opt.highest_score < 500 && r.opt.score >= 500 && (g = "", a = "#E67600"), r.opt.highest_score < 1e3 && r.opt.score >= 1e3 && (g = "", a = "#009D5E"), r.opt.highest_score < 2e3 && r.opt.score >= 2e3 && (g = "", a = "#7A0096"), r.opt.highest_score < 3e3 && r.opt.score >= 3e3 && (g = "", a = "#555555"), r.opt.highest_score < 5e3 && r.opt.score >= 5e3 && (g = "", a = "#AC8742")), g ? (c.fillStyle = a, c.strokeStyle = a, c.lineWidth = 1 * t.Dpr, (0, t.roundedRect)((0, t.cx)(167), (0, t.cy)(154), (0, t.cwh)(80), (0, t.cwh)(26), 2 * t.Dpr, c), c.fill(), (0, t.drawText)({
                self: r,
                bold: !0,
                size: 14,
                t: g,
                pos: [207, 167]
            })) : (0, t.drawImageCenter)({
                self: r,
                src: "res/new.png",
                pos: [207, 167, 58, 26],
                type: "bg",
                imgid: r.imgid.bg
            }), (0, t.drawText)({
                self: r,
                size: 14,
                t: "history" == s ? "" : "",
                pos: [207, 224]
            }), (0, t.drawText)({self: r, size: 86, special: !0, color: "#00c777", pos: [207, 292.5], t: i.score})
        }
        "rank" == s && ((0, t.drawImageCenter)({
            self: r,
            src: "res/new.png",
            pos: [207, 167, 58, 26],
            type: "bg",
            imgid: r.imgid.bg
        }), c.lineWidth = 2 * t.Dpr, c.strokeStyle = "rgba(255,255,255,0.06)", c.fillStyle = "rgba(0,0,0,0.6)", (0, t.roundedRect)((0, t.cx)(30), (0, t.cy)(104), (0, t.cwh)(354), (0, t.cwh)(371), 4 * t.Dpr, c), c.fill(), (0, t.drawImageCenter)({
            self: r,
            src: r.myUserInfo.headimg,
            pos: [207, 291, 56, 56],
            type: "bg",
            cb: function () {
                (0, t.drawImageCenter)({
                    self: r,
                    src: "res/gold.png",
                    pos: [207, 253, 40, 40],
                    type: "bg",
                    imgid: r.imgid.bg
                })
            },
            imgid: r.imgid.bg
        }), (0, t.drawText)({self: r, size: 14, t: "", pos: [207, 224]}), (0, t.drawText)({
            self: r,
            size: 40,
            special: !0,
            t: i.score,
            pos: [207, 349],
            color: "#00c777"
        }), (0, t.drawImageCenter)({
            self: r,
            src: "res/pure_share.png",
            pos: [207, 415, 18, 24],
            type: "bg",
            imgid: r.imgid.bg
        })), c.fillStyle = "rgba(255,255,255,0.2)", c.fillRect((0, t.cx)(155), (0, t.cy)(218.5), (0, t.cwh)(9), (0, t.cwh)(3)), c.fillRect((0, t.cx)(155), (0, t.cy)(224.5), (0, t.cwh)(9), (0, t.cwh)(3)), c.fillRect((0, t.cx)(248), (0, t.cy)(218.5), (0, t.cwh)(9), (0, t.cwh)(3)), c.fillRect((0, t.cx)(248), (0, t.cy)(224.5), (0, t.cwh)(9), (0, t.cwh)(3)), (0, t.drawImageCenter)({
            self: r,
            src: "res/close.png",
            pos: [375, 112, 43, 43],
            type: "bg",
            imgid: r.imgid.bg
        }), (l = r.context.btn).clearRect((0, t.cx)(91), (0, t.cy)(490), (0, t.cwh)(232), (0, t.cwh)(94)), (0, t.drawImageCenter)({
            self: r,
            src: "res/replay.png",
            pos: [207, 607, 212, 84],
            type: "btn",
            imgid: r.imgid.btn
        }), (0, t.drawImageCenter)({
            self: r,
            src: "res/flower.png",
            pos: [207, 290, 260, 141],
            type: "bg",
            imgid: r.imgid.bg
        }), (0, t.updatePlane)({self: r, type: "bg"})
    }, exports.reDrawChangeAva = e;
    var t = require("./base");
});
define("js/pages/pages2d/lookers.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0}), exports.drawLookersPage = function (t) {
        var i = t.self;
        (0, e.routeCanvas)(i, "lookers"), (0, e.createPlane)(i);
        var r = i.context.bg;
        r.clearRect(0, 0, e.WIDTH, e.HEIGHT);
        var g = i.opt, s = g.score || 0, a = g.nickname || "";
        "in" == g.type ? ((0, e.drawImageCenter)({
            self: i,
            src: g.headimg,
            pos: [207, 91, 50, 50],
            type: "bg",
            cb: function () {
                (0, e.drawImageCenter)({
                    self: i,
                    src: "res/2d/ava_square.png",
                    pos: [207, 91, 53, 53],
                    type: "bg",
                    imgid: i.imgid.bg
                })
            },
            imgid: i.imgid.bg,
            noupdate: !0,
            round: !0
        }), (0, e.drawText)({
            self: i,
            t: a + " ",
            size: 17,
            pos: [207, 144],
            type: "bg",
            color: "black"
        })) : "gg" == g.type ? (r.fillStyle = "rgba(0,0,0, 0.4)", r.fillRect(0, 0, e.WIDTH, e.HEIGHT), (0, e.drawImageCenter)({
            self: i,
            src: g.headimg,
            pos: [207, 91, 50, 50],
            type: "bg",
            cb: function () {
                (0, e.drawImageCenter)({
                    self: i,
                    src: "res/2d/ava_square.png",
                    pos: [207, 91, 53, 53],
                    type: "bg",
                    imgid: i.imgid.bg
                })
            },
            imgid: i.imgid.bg,
            noupdate: !0,
            round: !0
        }), (0, e.drawText)({
            self: i,
            t: a + " ",
            size: 17,
            pos: [207, 144],
            type: "bg"
        }), (0, e.drawText)({self: i, t: "", size: 14, pos: [207, 207], type: "bg"}), (0, e.drawText)({
            self: i,
            t: s,
            size: 80,
            pos: [212, 267],
            type: "bg",
            special: !0
        }), r.strokeStyle = "white", r.lineWidth = .5 * e.Dpr, r.strokeStyle = "rgba(255,255,255,0.5)", r.beginPath(), r.moveTo((0, e.cx)(157), (0, e.cy)(176)), r.lineTo((0, e.cx)(257), (0, e.cy)(176)), r.closePath(), r.stroke(), r.fillStyle = "rgba(255,255,255,0.2)", r.fillRect((0, e.cx)(156), (0, e.cy)(203), (0, e.cwh)(9), (0, e.cwh)(3)), r.fillRect((0, e.cx)(156), (0, e.cy)(209), (0, e.cwh)(9), (0, e.cwh)(3)), r.fillRect((0, e.cx)(243), (0, e.cy)(203), (0, e.cwh)(9), (0, e.cwh)(3)), r.fillRect((0, e.cx)(243), (0, e.cy)(209), (0, e.cwh)(9), (0, e.cwh)(3))) : "out" == g.type ? (r.fillStyle = "rgba(0,0,0, 0.4)", r.fillRect(0, 0, e.WIDTH, e.HEIGHT), (0, e.drawImageCenter)({
            self: i,
            src: g.headimg,
            pos: [207, 221, 50, 50],
            type: "bg",
            cb: function () {
                (0, e.drawImageCenter)({
                    self: i,
                    src: "res/2d/ava_square.png",
                    pos: [207, 221, 53, 53],
                    type: "bg",
                    imgid: i.imgid.bg
                })
            },
            imgid: i.imgid.bg,
            noupdate: !0,
            round: !0
        }), (0, e.drawText)({
            self: i,
            t: a + " ",
            size: 17,
            pos: [207, 278],
            type: "bg"
        })) : "record" == g.type && (0, e.drawImageCenter)({
            self: i,
            src: g.headimg,
            pos: [71, 91, 42, 42],
            type: "bg",
            cb: function () {
                (0, e.drawImageCenter)({
                    self: i,
                    src: "res/2d/ava_square.png",
                    pos: [71, 91, 43, 43],
                    type: "bg",
                    imgid: i.imgid.bg
                })
            },
            imgid: i.imgid.bg,
            noupdate: !0,
            round: !0
        }), "record" != g.type ? (0, e.drawImageCenter)({
            self: i,
            src: "res/btn_iplay.png",
            pos: [207, 663, 131, 54],
            type: "bg",
            imgid: i.imgid.bg
        }) : (0, e.drawImageCenter)({
            self: i,
            src: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJBEN0IEbib1Cef1vsVKvSKGJkU5R4HlfLFrnficcs7hc7VlYRRu523WotJ9QselXVaHQ/0?wx_fmt=png",
            pos: [207, 665, 131, 64],
            type: "bg",
            imgid: i.imgid.bg
        }), (0, e.updatePlane)({self: i, type: "bg"})
    };
    var e = require("./base");
});
define("js/pages/pages2d/pk.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e) {
        var t = e.self;
        e.list;
        t.sotedRankList = e.list;
        var i = t.sotedRankList.length * (0, r.cwh)(r.ListLineHeight) / r.Dpr, s = (0, r.cwh)(194) / r.Dpr;
        t.scrollHandler = new l.default({
            innerOffsetHeight: i,
            outterOffsetHeight: s,
            updatePosition: t.updatePosition.bind(t)
        }), o(t, 0, "list1")
    }

    function o(e, t, o) {
        "list1" == o ? e.imgid.list1++ : "list2" == o && e.imgid.list2++;
        var i = e.sotedRankList.slice(t, t + 10), s = e.context[o];
        if (s.clearRect(0, 0, r.WIDTH, 10 * (0, r.cwh)(r.ListLineHeight)), s.fillStyle = "white", s.textBaseline = "middle", s.fillRect(0, 0, r.WIDTH, 10 * (0, r.cwh)(r.ListLineHeight)), 0 == t || 0 != i.length) {
            if (!(t < 0)) {
                for (var l = i.length, a = 0; a < l; a++) !function () {
                    var s = (a + .5) * r.ListLineHeight, l = a + 1 + t, c = "";
                    c = 1 == l ? "rgb(250,126,0)" : 2 == l ? "rgb(254,193,30)" : 3 == l ? "rgb(251,212,19)" : "#aaa", (0, r.drawText)({
                        self: e,
                        bold: !0,
                        italic: !0,
                        size: 17,
                        t: l,
                        pos: [58.5, s],
                        type: o,
                        color: c
                    });
                    i[a].grade;
                    (0, r.drawImageCenter)({
                        self: e,
                        src: i[a].headimg,
                        pos: [107, s, 34, 34],
                        type: o,
                        cb: function () {
                            (0, r.drawImageCenter)({
                                self: e,
                                src: "res/2d/ava_square.png",
                                pos: [107, s, 37, 37],
                                type: o,
                                imgid: e.imgid[o]
                            })
                        },
                        round: !0,
                        imgid: e.imgid[o],
                        noupdate: !0
                    }), (0, r.drawText)({
                        self: e,
                        align: "left",
                        color: "#000",
                        size: 17,
                        bold: !0,
                        t: (0, r.cname)(i[a].nickname, 14),
                        pos: [144, s - 10],
                        type: o
                    }), i[a].score_info[0].score > e.opt.organizerInfo.score_info[0].score ? (0, r.drawText)({
                        self: e,
                        color: "#FC4814",
                        size: 12,
                        t: "",
                        pos: [144, s + 12],
                        type: o,
                        align: "left"
                    }) : (0, r.drawText)({
                        self: e,
                        color: "#888",
                        size: 12,
                        t: "",
                        pos: [144, s + 12],
                        type: o,
                        align: "left"
                    }), (0, r.drawText)({
                        self: e,
                        color: "#888",
                        size: 22,
                        special: !0,
                        t: i[a].score_info[0].score || 0,
                        pos: [364, s],
                        type: o,
                        align: "right"
                    })
                }();
                0 == l && (0, r.drawText)({
                    self: e,
                    color: "#ccc",
                    size: 14,
                    t: "",
                    pos: [207, 100],
                    type: o
                }), (0, r.updatePlane)({self: e, type: o})
            }
        } else (0, r.updatePlane)({self: e, type: o})
    }

    function i(e, t, o) {
        return 1 === e.is_self
    }

    Object.defineProperty(exports, "__esModule", {value: !0}), exports.drawPkPage = function (e) {
        var o = e.self;
        (0, r.routeCanvas)(o, "pk"), (0, r.createPlane)(o), (0, r.updateClip)({self: o}), o.myidx = o.opt.pkListInfo.findIndex(i) + 1, o.myUserInfo = o.opt.pkListInfo[o.myidx - 1] || s.default.getMyUserInfo() || {
            headimg: "",
            nickname: "",
            week_best_score: 0,
            score_info: [{score: 0}]
        }, t({self: o, list: o.opt.pkListInfo});
        var l = o.context.bg;
        if (l.clearRect(0, 0, r.WIDTH, r.HEIGHT), l.fillStyle = "rgba(0,0,0, 0.8)", l.fillRect(0, 0, (r.WIDTH - (0, r.cwh)(354)) / 2, r.HEIGHT), l.fillRect((0, r.cx)(384), 0, (r.WIDTH - (0, r.cwh)(354)) / 2, r.HEIGHT), l.fillRect((0, r.cx)(30), 0, (0, r.cwh)(354), (0, r.cy)(110)), l.fillRect((0, r.cx)(30), (0, r.cy)(632), (0, r.cwh)(354), (0, r.cy)(144)), l.fillStyle = "rgb(250,250,250)", l.fillRect((0, r.cx)(31), (0, r.cy)(103), (0, r.cwh)(354), (0, r.cwh)(335)), l.lineWidth = 2 * r.Dpr, l.strokeStyle = "#fff", (0, r.roundedRect)((0, r.cx)(30), (0, r.cy)(102), (0, r.cwh)(354), (0, r.cwh)(530), 1 * r.Dpr, l), void 0 == o.opt.gg_score) (0, r.drawImageCenter)({
            self: o,
            src: o.opt.organizerInfo.headimg,
            pos: [207, 158, 50, 50],
            type: "bg",
            imgid: o.imgid.bg
        }), (0, r.drawText)({
            self: o,
            t: o.opt.organizerInfo.nickname,
            color: "rgba(0,0,0,0.8)",
            size: 14,
            pos: [207, 195]
        }), (0, r.drawText)({
            self: o,
            t: "",
            color: "rgba(0,0,0,0.8)",
            size: 14,
            pos: [207, 242]
        }), l.lineWidth = .5 * r.Dpr, l.strokeStyle = "rgba(0,0,0,0.06)", l.beginPath(), l.moveTo((0, r.cx)(160), (0, r.cy)(217)), l.lineTo((0, r.cx)(254), (0, r.cy)(217)), l.closePath(), l.stroke(), l.fillStyle = "rgba(0,0,0,0.2)", l.fillRect((0, r.cx)(162), (0, r.cy)(239), (0, r.cwh)(9), (0, r.cwh)(3)), l.fillRect((0, r.cx)(162), (0, r.cy)(244), (0, r.cwh)(9), (0, r.cwh)(3)), l.fillRect((0, r.cx)(241), (0, r.cy)(239), (0, r.cwh)(9), (0, r.cwh)(3)), l.fillRect((0, r.cx)(241), (0, r.cy)(244), (0, r.cwh)(9), (0, r.cwh)(3)), (0, r.drawText)({
            self: o,
            t: o.opt.organizerInfo.score_info[0].score,
            color: "#000",
            size: 66,
            pos: [207, 298],
            special: !0
        }); else {
            var a = void 0, c = void 0, n = void 0, g = void 0;
            o.opt.gg_score > o.opt.organizerInfo.score_info[0].score ? (a = "res/suc.png", c = "", n = "rgba(0,0,0,1)", g = "rgba(0,0,0,0.3)", (0, r.drawImageCenter)({
                self: o,
                src: "res/flower_small.png",
                pos: [207, 175, 140, 53],
                type: "bg",
                imgis: o.imgid.bg
            })) : (a = "res/fail.png", c = "", n = "rgba(0,0,0,0.3)", g = "rgba(0,0,0,1)"), (0, r.drawImageCenter)({
                self: o,
                src: a,
                pos: [207, 135, 20, 15],
                type: "bg",
                imgid: o.imgid.bg
            }), (0, r.drawText)({
                self: o,
                color: "#000",
                bold: !0,
                size: 30,
                t: c,
                pos: [207, 178]
            }), (0, r.drawImageCenter)({
                self: o,
                src: o.myUserInfo.headimg,
                pos: [158, 289, 26, 26],
                type: "bg",
                imgid: o.imgid.bg
            }), (0, r.drawImageCenter)({
                self: o,
                src: o.opt.organizerInfo.headimg,
                pos: [260, 289, 26, 26],
                type: "bg",
                imgid: o.imgid.bg
            }), (0, r.drawText)({
                self: o,
                color: "rgba(0,0,0,0.8)",
                size: 11,
                t: (0, r.cname)(o.myUserInfo.nickname),
                pos: [158, 318]
            }), (0, r.drawText)({
                self: o,
                color: "rgba(0,0,0,0.8)",
                size: 11,
                t: (0, r.cname)(o.opt.organizerInfo.nickname),
                pos: [260, 318]
            }), o.opt.gg_score > 999 ? (0, r.drawText)({
                self: o,
                color: n,
                size: 44,
                special: !0,
                t: o.opt.gg_score,
                align: "right",
                pos: [190, 253]
            }) : (0, r.drawText)({
                self: o,
                color: n,
                size: 44,
                special: !0,
                t: o.opt.gg_score,
                align: "center",
                pos: [158, 253]
            }), l.fillStyle = "rgba(0,0,0,0.3)", l.fillRect((0, r.cx)(202), (0, r.cy)(242), (0, r.cwh)(10), (0, r.cwh)(4)), o.opt.organizerInfo.score_info[0].score > 999 ? (0, r.drawText)({
                self: o,
                color: g,
                size: 44,
                special: !0,
                t: o.opt.organizerInfo.score_info[0].score,
                align: "left",
                pos: [231, 253]
            }) : (0, r.drawText)({
                self: o,
                color: g,
                size: 44,
                special: !0,
                t: o.opt.organizerInfo.score_info[0].score,
                pos: [260, 253]
            })
        }
        l.strokeStyle = "rgba(0,0,0,0.06)", l.lineWidth = 1, l.beginPath(), l.moveTo((0, r.cx)(30), (0, r.cy)(437)), l.lineTo((0, r.cx)(384), (0, r.cy)(437)), l.stroke(), l.closePath();
        var f = "";
        if (o.opt.organizerInfo.left_time > 0 && 0 == o.opt.organizerInfo.is_self) o.myidx > 0 && (f = ""), (0, r.drawImageCenter)({
            self: o,
            src: "res/btn_bg_g.png",
            pos: [207, 368, 130, 63],
            type: "bg",
            cb: function () {
                (0, r.drawText)({self: o, size: 14, t: f, pos: [207, 368]}), (0, r.updatePlane)({self: o, type: "bg"})
            },
            imgid: o.imgid.bg
        }), (0, r.drawText)({
            self: o,
            size: 12,
            align: "right",
            color: "#000",
            t: "",
            pos: [223, 403.5]
        }), d = (p = +new Date) + 1e3 * o.opt.organizerInfo.left_time, w = (w = (p = new Date(d)).getHours()) < 10 ? "0" + w : w, m = (m = p.getMinutes()) < 10 ? "0" + m : m, (0, r.drawText)({
            self: o,
            size: 12,
            align: "left",
            color: "#fc4814",
            t: w + ":" + m,
            pos: [225, 403.5]
        }); else if (0 == o.opt.organizerInfo.left_time && 0 == o.opt.organizerInfo.is_self) (0, r.drawImageCenter)({
            self: o,
            src: "res/btn_bg_h.png",
            pos: [207, 368, 130, 63],
            type: "bg",
            cb: function () {
                (0, r.drawText)({
                    self: o,
                    size: 14,
                    color: "rgba(0,0,0,0.3)",
                    t: "",
                    pos: [207, 368]
                }), (0, r.updatePlane)({self: o, type: "bg"})
            },
            imgid: o.imgid.bg
        }), (0, r.drawText)({
            self: o,
            size: 14,
            color: "#888",
            t: "",
            pos: [207, 403.5]
        }); else if (o.opt.organizerInfo.left_time > 0 && 1 == o.opt.organizerInfo.is_self) {
            (0, r.drawText)({
                self: o,
                size: 14,
                align: "right",
                color: "#888",
                t: "",
                pos: [223, 369]
            }), l.textAlign = "left", l.fillStyle = "#2c9f67";
            var p = +new Date, d = p + 1e3 * o.opt.organizerInfo.left_time, w = (p = new Date(d)).getHours();
            w = w < 10 ? "0" + w : w;
            var m = p.getMinutes();
            m = m < 10 ? "0" + m : m, (0, r.drawText)({
                self: o,
                size: 14,
                align: "left",
                color: "#2c9f67",
                t: w + ":" + m,
                pos: [225, 369]
            })
        }
        (0, r.drawText)({self: o, size: 17, t: "", pos: [199, 688]}), (0, r.drawImageCenter)({
            self: o,
            src: "res/r_arr.png",
            pos: [280, 688, 6.5, 12.5],
            type: "bg",
            imgid: o.imgid.bg
        }), (0, r.updatePlane)({self: o, type: "bg"})
    }, exports.drawPkList = o;
    var r = require("./base"), s = e(require("../../store/storage")), l = e(require("../../scroll/scrollHandler"));
});
define("js/pages/pages2d/rank.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e) {
        var t = e.self;
        t.imgid.btn++;
        var i = t.context.btn;
        i.clearRect(0, 0, s.WIDTH, s.HEIGHT), i.fillStyle = "rgba(0,0,0, 0.8)", i.fillRect(0, 0, (s.WIDTH - (0, s.cwh)(354)) / 2, s.HEIGHT), i.fillRect((0, s.cx)(384), 0, (s.WIDTH - (0, s.cwh)(354)) / 2, s.HEIGHT), i.fillRect((0, s.cx)(30), 0, (0, s.cwh)(354), (0, s.cy)(110)), i.fillRect((0, s.cx)(30), (0, s.cy)(592), (0, s.cwh)(354), (0, s.cy)(144)), i.fillStyle = "rgba(0,0,0,0.9)", i.fillRect((0, s.cx)(30), (0, s.cy)(110), (0, s.cwh)(354), (0, s.cwh)(33)), i.strokeStyle = "rgba(255,255,255,0.2)", i.lineWidth = 1 * s.Dpr, i.beginPath(), i.moveTo((0, s.cx)(30), (0, s.cy)(143)), i.lineTo((0, s.cx)(384), (0, s.cy)(143)), i.stroke(), i.closePath(), (0, s.drawText)({
            self: t,
            bold: !0,
            size: 12,
            align: "left",
            t: "",
            pos: [54, 126.5],
            type: "btn"
        }), i.lineWidth = 1 * s.Dpr, i.strokeStyle = "rgba(255,255,255,0.2)", (0, s.roundedRect)((0, s.cx)(30), (0, s.cy)(110), (0, s.cwh)(354), (0, s.cwh)(482), 1 * s.Dpr, i), (0, s.updatePlane)({
            self: t,
            type: "btn"
        }), t.canvasType == s.CANVASTYPE.groupRank && ((0, s.drawText)({
            self: t,
            size: 17,
            t: "",
            pos: [207, 680],
            type: "btn"
        }), (0, s.drawImageCenter)({
            self: t,
            src: "res/r_arr.png",
            pos: [244, 680, 6.6, 10],
            type: "btn",
            imgid: t.imgid.btn
        })), t.canvasType == s.CANVASTYPE.friendRank && ((0, s.drawText)({
            self: t,
            size: 17,
            t: "",
            pos: [177, 674],
            align: "left",
            type: "btn"
        }), (0, s.drawImageCenter)({
            self: t,
            src: "res/r_arr.png",
            pos: [270, 674, 6.6, 10],
            type: "btn",
            imgid: t.imgid.btn
        }), (0, s.drawImageCenter)({
            self: t,
            src: "res/rank.png",
            pos: [154, 674, 22, 22],
            type: "btn",
            imgid: t.imgid.btn
        }), (0, s.drawImageCenter)({
            self: t,
            src: "res/close.png",
            pos: [375, 114, 48, 48],
            type: "btn",
            imgid: t.imgid.btn
        }))
    }

    function i(e) {
        var t = e.self, i = e.list, n = [];
        t.myUserInfo = t.myUserInfo || {
            headimg: "",
            nickname: "",
            week_best_score: 0,
            score_info: [{score: 0}]
        }, (i = i || []).push(t.myUserInfo), n = (0, s.rerank)(i), t.sotedRankList = n;
        var l, c = t.sotedRankList.length * (0, s.cwh)(s.ListLineHeight) / s.Dpr;
        t.myidx = n.findIndex(s.findSelfIndex.bind(t)) + 1, l = (0, s.cwh)(445) / s.Dpr, t.scrollHandler = new a.default({
            innerOffsetHeight: c,
            outterOffsetHeight: l,
            updatePosition: t.updatePosition.bind(t)
        }), r(t, 0, "list1"), r(t, 10, "list2")
    }

    function r(e, t, i) {
        "list1" == i ? e.imgid.list1++ : "list2" == i && e.imgid.list2++;
        var r = e.sotedRankList.slice(t, t + 10), n = e.context[i];
        if (n.clearRect(0, 0, s.WIDTH, 10 * (0, s.cwh)(s.ListLineHeight)), n.fillStyle = "rgba(0,0,0,0.9)", n.fillRect(0, 0, s.WIDTH, 10 * (0, s.cwh)(s.ListLineHeight)), 0 == t || 0 != r.length) {
            if (!(t < 0)) {
                for (var a = r.length, l = 0; l < a; l++) {
                    var c, o;
                    !function () {
                        l % 2 == 1 && (n.fillStyle = "rgba(255,255,255, 0.03)", n.fillRect(0, l * (0, s.cwh)(s.ListLineHeight), (0, s.cwh)(414), (0, s.cwh)(s.ListLineHeight)));
                        var a = (l + .5) * s.ListLineHeight;
                        n.textAlign = "center", o = "", o = 1 == (c = l + 1 + t) ? "rgb(250,126,0)" : 2 == c ? "rgb(254,193,30)" : 3 == c ? "rgb(251,212,19)" : "#aaa", (0, s.drawText)({
                            self: e,
                            color: o,
                            size: 17,
                            italic: !0,
                            bold: !0,
                            t: c,
                            pos: [58.5, a],
                            type: i
                        });
                        r[l].grade;
                        n.beginPath(), n.strokeStyle = "rgba(255,255,255, 0.1)", n.fillStyle = "rgba(255,255,255, 0.1)", (0, s.roundedRect)((0, s.cx)(90), (0, s.cwh)(a - 17), (0, s.cwh)(34), (0, s.cwh)(34), 4 * s.Dpr, n), n.fill(), n.closePath(), (0, s.drawImageCenter)({
                            round: !0,
                            self: e,
                            src: r[l].headimg,
                            pos: [107, a, 34, 34],
                            type: i,
                            cb: function () {
                                (0, s.drawImageCenter)({
                                    self: e,
                                    src: "res/ava_rank.png",
                                    pos: [107, a, 47, 47],
                                    type: i,
                                    imgid: e.imgid[i]
                                })
                            },
                            imgid: e.imgid[i],
                            noupdate: !0
                        }), (0, s.drawText)({
                            self: e,
                            align: "left",
                            size: 17,
                            t: (0, s.cname)(r[l].nickname, 16),
                            pos: [144, a],
                            type: i
                        }), (0, s.drawText)({
                            self: e,
                            align: "right",
                            size: 22,
                            special: !0,
                            t: r[l].week_best_score || 0,
                            pos: [339, a + 2],
                            type: i
                        }), r[l].playback_id && (0, s.drawImageCenter)({
                            round: !0,
                            self: e,
                            src: "res/2d/record.png",
                            pos: [359, a, 18, 18],
                            type: i,
                            imgid: e.imgid[i]
                        })
                    }()
                }
                (0, s.updatePlane)({self: e, type: i})
            }
        } else (0, s.updatePlane)({self: e, type: i})
    }

    Object.defineProperty(exports, "__esModule", {value: !0}), exports.drawFriendRankList = function (e) {
        var r = e.self, a = r.last2CanvasType;
        (0, s.routeCanvas)(r, "friendRank"), r.lastCanvasType == s.CANVASTYPE.record && (r.lastCanvasType = a), r.myUserInfo = n.default.getMyUserInfo() || {}, r.myUserInfo.week_best_score = r.opt.week_best_score || 0, (0, s.createPlane)(r), (0, s.updateClip)({self: r}), t({self: r}), i({
            self: r,
            list: n.default.getFriendsScore()
        })
    }, exports.drawGroupRankList = function (e, r, n) {
        (0, s.routeCanvas)(e, "groupRank"), e.myUserInfo = n || {
            headimg: "",
            nickname: "",
            week_best_score: 0,
            grade: 1
        }, (0, s.createPlane)(e), (0, s.updateClip)({self: e}), t({self: e}), i({self: e, list: r})
    }, exports.drawRankList = r;
    var s = require("./base"), n = e(require("../../store/storage")), a = e(require("../../scroll/scrollHandler"));
});
define("js/pages/pages2d/record.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0}), exports.drawRecordPage = function (r) {
        var a = r.self;
        a.imgid.bg++, (0, e.routeCanvas)(a, "record"), (0, e.createPlane)(a);
        var t = a.context.bg;
        t.clearRect(0, 0, e.WIDTH, e.HEIGHT);
        var d = a.opt;
        (0, e.drawImageCenter)({
            self: a, src: d.headimg, pos: [207, 100, 52, 52], type: "bg", cb: function () {
                (0, e.drawImageCenter)({
                    self: a,
                    src: "res/2d/ava_square.png",
                    pos: [207, 100, 53, 53],
                    type: "bg",
                    imgid: a.imgid.bg
                })
            }, imgid: a.imgid.bg, noupdate: !0, round: !0
        }), (0, e.drawReturnImg)(t, a), (0, e.updatePlane)({self: a, type: "bg"})
    };
    var e = require("./base");
});
define("js/pages/pages2d/relay.js", function (require, module, exports) {
    "use strict";

    function e(e, t, o) {
        if (!t) return !1;
        if ((t = JSON.parse(t)).my_seat_no != t.room_owner_seat && e.my_seat_no == e.room_owner_seat) return !1;
        var n = void 0, s = void 0, i = void 0;
        if (e.players.length == t.players.length) for (var c = 0; c < e.players.length; c++) e.players[c].headimg == t.players[c].headimg && e.players[c].name == t.players[c].name || (n = !0); else n = !0;
        return n && r(o), e.game_level != t.game_level && (s = !0, a(o)), e.players.length > 1 && 1 == t.players.length ? (i = !0, l(o)) : t.players.length > 1 && 1 == e.players.length && (i = !0, l(o)), !!(n || s || i) || void 0 == n && void 0 == s && void 0 == i
    }

    function t(e) {
        var t = "data:image/jpeg;base64," + e.opt.room_wxa_code, a = e.context.bg;
        (0, u.drawImageCenter)({
            self: e,
            src: "res/qr.png",
            pos: [207, 368, 390, 390],
            type: "bg",
            imgid: e.imgid.bg,
            cb: function () {
                var r = new Image;
                r.onload = function () {
                    a.save(), a.beginPath(), a.arc((0, u.cx)(207), (0, u.cy)(368), (0, u.cwh)(150), 0, 2 * Math.PI), a.clip(), a.drawImage(r, (0, u.cx)(67), (0, u.cy)(228), (0, u.cwh)(280), (0, u.cwh)(280)), a.closePath(), a.restore(), (0, u.updatePlane)({
                        self: e,
                        type: "bg"
                    })
                }, e.opt.room_wxa_code && (r.src = t)
            }
        })
    }

    function a(e) {
        e.context.btn.clearRect((0, u.cx)(100), (0, u.cy)(555), (0, u.cwh)(200), (0, u.cwh)(40)), (0, u.drawText)({
            self: e,
            t: "  :   " + e.opt.game_level_s,
            size: 17,
            pos: [138, 575],
            align: "left",
            type: "btn"
        }), (0, u.drawImageCenter)({
            self: e,
            src: "res/r_arr.png",
            pos: [273, 575, 6.5, 12.5],
            type: "btn",
            imgid: e.imgid.btn
        }), (0, u.updatePlane)({self: e, type: "btn"})
    }

    function r(e) {
        var t = e.context.btn;
        t.clearRect((0, u.cx)(20), (0, u.cy)(270), (0, u.cwh)(370), (0, u.cwh)(210));
        for (var a = e.opt.players, r = 0; r < 10; r++) !function (r) {
            var l = 59 + r % 5 * 74, o = 314 + 103 * Math.floor(r / 5);
            a[r] ? ((0, u.drawImageCenter)({
                self: e,
                src: a[r].headimg,
                pos: [l, o, 51, 51],
                type: "btn",
                imgid: e.imgid.btn,
                round: !0,
                noupdate: !0,
                cb: function () {
                    (0, u.drawImageCenter)({
                        self: e,
                        src: "res/2d/ava_square.png",
                        pos: [l, o, 53, 53],
                        type: "btn",
                        imgid: e.imgid.btn,
                        cb: function () {
                            console.log(a[r].seat_no, e.opt.room_owner_seat), a[r].seat_no == e.opt.room_owner_seat && (0, u.drawImageCenter)({
                                self: e,
                                src: "res/2d/owner.png",
                                pos: [l, o - 27, 40, 18],
                                imgid: e.imgid.btn,
                                type: "btn",
                                cb: function () {
                                    (0, u.updatePlane)({self: e, type: "btn"})
                                }
                            })
                        }
                    })
                }
            }), (0, u.drawText)({
                self: e,
                t: (0, u.cname)(a[r].name, 6),
                size: 14,
                pos: [l, o + 45],
                type: "btn"
            })) : (t.lineWidth = 1 * u.Dpr, t.strokeStyle = "rgba(0,0,0,0.06)", t.fillStyle = "rgba(0,0,0,0.06)", (0, u.roundedRect)((0, u.cx)(l - 27), (0, u.cy)(o - 27), (0, u.cwh)(53), (0, u.cwh)(53), 4 * u.Dpr, t), t.fill())
        }(r)
    }

    function l(e) {
        e.context.btn.clearRect((0, u.cx)(100), (0, u.cy)(620), (0, u.cwh)(220), (0, u.cwh)(80)), e.opt.players.length > 1 && (0, u.drawImageCenter)({
            self: e,
            src: "res/play.png",
            pos: [207, 657, 208, 78],
            type: "btn",
            imgid: e.imgid.btn
        })
    }

    function o(e) {
        var t = e.context.bg;
        t.clearRect(0, 0, u.WIDTH, u.HEIGHT);
        var a = t.createLinearGradient(0, 0, 0, u.HEIGHT);
        a.addColorStop(0, "#D6F1F1"), a.addColorStop(1, "#D3EDE6"), t.fillStyle = a, t.fillRect(0, 0, u.WIDTH, u.HEIGHT), t.fillStyle = "rgba(0,0,0, 0.3)", t.fillRect(0, 0, u.WIDTH, u.HEIGHT), (0, u.drawImageCenter)({
            self: e,
            src: "res/2d/555.png",
            pos: [207, 214, 37.4, 27],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, u.drawText)({
            self: e,
            size: 24,
            t: "",
            pos: [207, 286]
        }), (0, u.drawHomeImg)(t, e), (0, u.drawImageCenter)({
            self: e,
            src: "res/lookers_btn.png",
            pos: [207, 588, 162, 78],
            type: "bg",
            imgid: e.imgid.bg,
            cb: function () {
                (0, u.drawText)({self: e, t: "", size: 18, pos: [207, 588], color: "#000"})
            }
        }), (0, u.updatePlane)({self: e, type: "bg"})
    }

    function n(e, t, a) {
        if (!t) return !1;
        if (t.my_seat_no != t.room_owner_seat && e.my_seat_no == e.room_owner_seat) return !1;
        t = JSON.parse(t);
        var r = void 0, l = void 0;
        if (e.players.length == t.players.length) for (var o = 0; o < e.players.length; o++) e.players[o].headimg == t.players[o].headimg && e.players[o].name == t.players[o].name || (r = !0); else r = !0;
        return r && s(a), (t.players.length < 10 && e.players.length >= 10 || t.game_level != e.game_level) && (l = !0, i(a)), !(!r && !l)
    }

    function s(e) {
        console.log("diff player");
        var t = e.context.btn, a = e.opt.players;
        t.clearRect((0, u.cx)(20), (0, u.cy)(260), (0, u.cwh)(370), (0, u.cwh)(210));
        for (var r = 0; r < 10; r++) !function (t) {
            var r = 59 + t % 5 * 74, l = 299 + 103 * Math.floor(t / 5);
            a[t] && ((0, u.drawImageCenter)({
                self: e,
                src: a[t].headimg,
                pos: [r, l, 52, 52],
                type: "btn",
                imgid: e.imgid.btn,
                round: !0,
                noupdate: !0,
                cb: function () {
                    (0, u.drawImageCenter)({
                        self: e,
                        src: "res/2d/ava_square.png",
                        pos: [r, l, 54, 54],
                        imgid: e.imgid.btn,
                        type: "btn",
                        cb: function () {
                            a[t].seat_no == e.opt.room_owner_seat && (0, u.drawImageCenter)({
                                self: e,
                                src: "res/2d/owner.png",
                                pos: [r, l - 27, 40, 18],
                                imgid: e.imgid.btn,
                                type: "btn",
                                cb: function () {
                                    (0, u.updatePlane)({self: e, type: "btn"})
                                }
                            })
                        }
                    })
                }
            }), (0, u.drawText)({self: e, t: (0, u.cname)(a[t].name, 6), size: 14, pos: [r, l + 45], type: "btn"}))
        }(r)
    }

    function i(e) {
        e.context.btn.clearRect((0, u.cx)(120), (0, u.cy)(111), (0, u.cwh)(170), (0, u.cwh)(90)), 10 == e.opt.players.length ? (0, u.drawText)({
            self: e,
            size: 24,
            t: "",
            pos: [207, 131.5],
            type: "btn"
        }) : (0, u.drawText)({
            self: e,
            size: 24,
            t: "",
            pos: [207, 131.5],
            type: "btn"
        }), (0, u.drawText)({
            self: e,
            size: 17,
            t: " : " + e.opt.game_level_s,
            pos: [207, 167],
            color: "#FCBA4B",
            type: "btn"
        }), (0, u.updatePlane)({self: e, type: "btn"})
    }

    function c(e) {
        var t = e.context.bg;
        t.clearRect(0, 0, u.WIDTH, u.HEIGHT);
        var a = t.createLinearGradient(0, 0, 0, u.HEIGHT);
        a.addColorStop(0, "#D6F1F1"), a.addColorStop(1, "#D3EDE6"), t.fillStyle = a, t.fillRect(0, 0, u.WIDTH, u.HEIGHT), t.fillStyle = "rgba(0,0,0, 0.3)", t.fillRect(0, 0, u.WIDTH, u.HEIGHT);
        e.opt.players, e.opt;
        (0, u.drawHomeImg)(t, e);
        for (var r = 0; r < 10; r++) {
            var l = 59 + r % 5 * 74, o = 299 + 103 * Math.floor(r / 5);
            t.lineWidth = 1 * u.Dpr, t.strokeStyle = "rgba(0,0,0,0.06)", t.fillStyle = "rgba(0,0,0,0.06)", (0, u.roundedRect)((0, u.cx)(l - 27), (0, u.cy)(o - 27), (0, u.cwh)(54), (0, u.cwh)(54), 4 * u.Dpr, t), t.fill()
        }
        s(e), i(e), (0, u.drawText)({
            self: e,
            size: 14,
            t: "",
            pos: [207, 214]
        }), (0, u.drawText)({self: e, t: "+  ", size: 17, pos: [207, 608]}), (0, u.drawImageCenter)({
            self: e,
            src: "res/btn_invite_fri.png",
            pos: [207, 608, 152, 37],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, u.updatePlane)({self: e, type: "bg"})
    }

    function p(e) {
        e.imgid.bg++;
        var t = e.context.bg;
        t.clearRect(0, 0, u.WIDTH, u.HEIGHT);
        var a = t.createLinearGradient(0, 0, 0, u.HEIGHT);
        a.addColorStop(0, "#D6F1F1"), a.addColorStop(1, "#D3EDE6"), t.fillStyle = a, t.fillRect(0, 0, u.WIDTH, u.HEIGHT), t.fillStyle = "rgba(0,0,0, 0.3)", t.fillRect(0, 0, u.WIDTH, u.HEIGHT);
        var r = e.opt.players, l = e.opt;
        (0, u.drawHomeImg)(t, e);
        var o = [];
        r.length < 6 ? g(e, o = r, 299) : (o = r.slice(0, Math.ceil(r.length / 2)), g(e, o, 299), o = r.slice(Math.ceil(r.length / 2), r.length), g(e, o, 402)), (0, u.drawText)({
            self: e,
            size: 24,
            t: "",
            pos: [207, 141]
        }), (0, u.drawText)({
            self: e,
            size: 17,
            t: " : " + l.game_level_s,
            pos: [207, 167],
            color: "#FCBA4B"
        }), (0, u.drawImageCenter)({
            self: e,
            src: "res/lookers_btn.png",
            pos: [207, 588, 152, 78],
            type: "bg",
            imgid: e.imgid.bg,
            cb: function () {
                (0, u.drawText)({self: e, t: "", size: 22, pos: [207, 588], color: "#000"})
            }
        }), (0, u.updatePlane)({self: e, type: "bg"})
    }

    function g(e, t, a) {
        for (var r = t.length, l = 54, o = 207 - (r * l + 20 * (r - 1)) / 2, n = (e.context.bg, 0); n < r; n++) !function () {
            var r = o + 27 + 74 * n;
            (0, u.drawImageCenter)({
                self: e,
                round: !0,
                src: t[n].headimg,
                pos: [r, a, l, l],
                type: "bg",
                cb: function () {
                    (0, u.drawImageCenter)({
                        self: e,
                        src: "res/2d/ava_square.png",
                        pos: [r, a, 56, 56],
                        type: "bg",
                        imgid: e.imgid.bg
                    })
                },
                imgid: e.imgid.bg,
                noupdate: !0
            }), (0, u.drawText)({self: e, t: (0, u.cname)(t[n].name, 6), size: 14, pos: [r, a + 45]})
        }()
    }

    function d(e) {
        e.context.btn.clearRect(0, 0, u.WIDTH, u.HEIGHT), (0, u.updatePlane)({self: e, type: "btn"});
        var t = e.context.bg;
        t.clearRect(0, 0, u.WIDTH, u.HEIGHT);
        var o = t.createLinearGradient(0, 0, 0, u.HEIGHT);
        o.addColorStop(0, "#D6F1F1"), o.addColorStop(1, "#D3EDE6"), t.fillStyle = o, t.fillRect(0, 0, u.WIDTH, u.HEIGHT), t.fillStyle = "rgba(0,0,0, 0.5)", t.fillRect(0, 0, u.WIDTH, (0, u.cy)(247)), t.fillStyle = "rgba(0,0,0, 0.3)", t.fillRect(0, (0, u.cy)(247), u.WIDTH, (0, u.cy)(489)), r(e), (0, u.drawText)({
            self: e,
            t: "",
            size: 17,
            pos: [198, 181],
            color: "rgba(255,255,255,0.7)"
        }), (0, u.drawImageCenter)({
            self: e,
            src: "res/r_arr.png",
            pos: [273, 181, 6.5, 12.5],
            type: "btn",
            imgid: e.imgid.btn
        }), a(e), (0, u.drawText)({self: e, t: "+  ", size: 17, pos: [207, 119]}), (0, u.drawImageCenter)({
            self: e,
            src: "res/btn_invite_fri.png",
            pos: [207, 119, 152, 37],
            type: "bg",
            imgid: e.imgid.bg
        }), l(e), (0, u.drawHomeImg)(t, e), (0, u.updatePlane)({self: e, type: "bg"})
    }

    function f(e, t, a, r, l, o) {
        o.beginPath(), o.moveTo(e, t + l - 1), o.lineTo(e, t + r - l), o.quadraticCurveTo(e, t + r, e + l, t + r), o.lineTo(e + a - l, t + r), o.quadraticCurveTo(e + a, t + r, e + a, t + r - l), o.lineTo(e + a, t), o.lineTo(e, t), o.stroke(), o.closePath()
    }

    function y(e) {
        (0, u.routeCanvas)(e, "relayRank"), (0, u.createPlane)(e), (0, u.updateClip)({self: e});
        var t = e.context.bg;
        (0, u.drawHomeImg)(t, e), t.fillStyle = "rgba(255,255,255,0.04)", t.fillRect((0, u.cx)(30), (0, u.cy)(177), (0, u.cwh)(354), (0, u.cwh)(227)), t.fillStyle = "rgba(0,0,0,0.3)", t.lineWidth = .5 * u.Dpr, t.strokeStyle = "rgba(0,0,0,0.2)", f((0, u.cx)(30), (0, u.cy)(561), (0, u.cwh)(354), (0, u.cwh)(90), 2 * u.Dpr, t), t.fill();
        var a = e.opt.players || [];
        console.log(" players: ", a), (0, u.drawText)({
            self: e,
            t: a.length + "" + e.opt.total_score,
            size: 17,
            pos: [207, 145]
        }), (0, u.drawImageCenter)({
            self: e,
            src: a[0].headimg,
            pos: [207, 247, 48, 48],
            type: "bg",
            imgid: e.imgid.bg,
            cb: function () {
                (0, u.drawImageCenter)({
                    self: e,
                    src: "res/2d/ava_square.png",
                    pos: [207, 247, 50, 50],
                    imgid: e.imgid.bg
                })
            }
        }), (0, u.drawText)({
            self: e,
            t: "" + e.opt.my_rank + "",
            size: 30,
            pos: [207, 316],
            color: "#E3B857"
        }), (0, u.drawText)({
            self: e,
            t: "" + a.length + "",
            size: 15,
            pos: [207, 356],
            color: "#888"
        }), (0, u.drawText)({self: e, t: "", size: 22, pos: [207, 606]}), (0, u.updatePlane)({
            self: e,
            type: "bg"
        }), b(e, a)
    }

    function m(e) {
        (0, u.routeCanvas)(e, "relayRank"), (0, u.updateClip)({self: e});
        var t = e.context.bg;
        (0, u.drawHomeImg)(t, e), t.fillStyle = "rgba(255,255,255,0.04)", t.fillRect((0, u.cx)(30), (0, u.cy)(177), (0, u.cwh)(354), (0, u.cwh)(141)), t.fill();
        var a = e.opt.players, r = !1;
        0 == e.opt.my_seat_no && (r = !0), r ? (0, u.drawText)({
            self: e,
            t: "",
            size: 30,
            pos: [207, 243]
        }) : (t.fillStyle = "rgba(0,0,0,0.3)", t.strokeStyle = "rgba(0,0,0,0.2)", t.lineWidth = .5 * u.Dpr, f((0, u.cx)(30), (0, u.cy)(560), (0, u.cwh)(354), (0, u.cwh)(90), 2 * u.Dpr, t), t.fill(), (0, u.drawText)({
            self: e,
            t: "" + e.opt.my_rank + "",
            size: 30,
            pos: [207, 237],
            color: "#E3B857"
        }), (0, u.drawText)({self: e, t: "" + a.length + "", size: 17, pos: [207, 275]}), (0, u.drawText)({
            self: e,
            t: "",
            size: 22,
            pos: [207, 606]
        })), (0, u.drawText)({
            self: e,
            t: a.length + "" + e.opt.total_score,
            size: 17,
            pos: [207, 145]
        }), (0, u.updatePlane)({self: e, type: "bg"}), b(e, a)
    }

    function b(e, t) {
        console.log("renderRelayRankList :: ");
        e.sotedRankList = t;
        var a = e.sotedRankList.length * (0, u.cwh)(u.ListLineHeight) / u.Dpr, r = (0, u.cwh)(157) / u.Dpr;
        1 != e.opt.my_rank && (r = (0, u.cwh)(242) / u.Dpr), e.scrollHandler = new T.default({
            innerOffsetHeight: a,
            outterOffsetHeight: r,
            updatePosition: e.updatePosition.bind(e)
        }), w(e, 0, "list1")
    }

    function w(e, t, a) {
        "list1" == a ? e.imgid.list1++ : "list2" == a && e.imgid.list2++;
        var r = e.sotedRankList.slice(t, t + 10), l = e.context[a];
        if (l.clearRect(0, 0, u.WIDTH, 10 * (0, u.cwh)(u.ListLineHeight)), l.textBaseline = "middle", 0 == t || 0 != r.length) {
            if (!(t < 0)) {
                for (var o = r.length, n = 0; n < o; n++) !function () {
                    console.log(n);
                    var l = (n + .5) * u.ListLineHeight, o = n + 1 + t, s = "";
                    s = 1 == o ? "#ffd800" : "#888", (0, u.drawText)({
                        self: e,
                        bold: !0,
                        italic: !0,
                        size: 17,
                        t: o,
                        pos: [58.5, l],
                        type: a,
                        color: s
                    }), (0, u.drawImageCenter)({
                        self: e,
                        src: r[n].headimg,
                        pos: [107, l, 36, 36],
                        type: a,
                        cb: function () {
                            (0, u.drawImageCenter)({
                                self: e,
                                src: "res/2d/ava_square.png",
                                pos: [107, l, 37, 37],
                                type: a,
                                imgid: e.imgid[a]
                            })
                        },
                        round: !0,
                        imgid: e.imgid[a],
                        noupdate: !0
                    }), (0, u.drawText)({
                        self: e,
                        align: "left",
                        size: 17,
                        bold: !0,
                        t: (0, u.cname)(r[n].name, 14),
                        pos: [144, l],
                        type: a
                    })
                }();
                (0, u.updatePlane)({self: e, type: a})
            }
        } else (0, u.updatePlane)({self: e, type: a})
    }

    Object.defineProperty(exports, "__esModule", {value: !0}), exports.drawRelayRoomPage = function (t) {
        var a = t.opt;
        if ((0, u.createPlane)(t, ["bg", "btn"]), (0, u.routeCanvas)(t, "relay"), 1 == a.game_level ? a.game_level_s = "" : 2 == a.game_level ? a.game_level_s = "" : a.game_level_s = "", 2 == a.game_status) (0, u.createPlane)(t), o(t); else if (1 == a.game_status) (0, u.createPlane)(t), p(t); else if (0 == a.game_status) if (a.my_seat_no == a.room_owner_seat) {
            if (e(t.opt, t.lastopt, t)) return void(t.lastopt = JSON.stringify(t.opt));
            t.lastopt = JSON.stringify(t.opt), d(t)
        } else {
            if (n(t.opt, t.lastopt, t)) return void(t.lastopt = JSON.stringify(t.opt));
            t.context.btn.clearRect(0, 0, u.WIDTH, u.HEIGHT), t.lastopt = JSON.stringify(t.opt), c(t)
        }
    }, exports.drawRelayLookers = function (e) {
        e.opt;
        (0, u.createPlane)(e), (0, u.routeCanvas)(e, "relayLookers"), e.context.btn.clearRect(0, 0, u.WIDTH, u.HEIGHT), (0, u.drawImageCenter)({
            self: e,
            src: "res/relay_return.png",
            pos: [207, 678, 140, 54],
            imgid: e.imgid.bg,
            type: "bg",
            cb: function () {
                (0, u.drawText)({
                    self: e,
                    t: "",
                    size: 17,
                    pos: [207, 678],
                    color: "#555"
                }), (0, u.updatePlane)({self: e, type: "bg"})
            }
        })
    }, exports.drawRelayQr = function (e) {
        e.opt;
        (0, u.createPlane)(e), (0, u.routeCanvas)(e, "relayQr");
        var a = e.context.bg;
        a.clearRect(0, 0, u.WIDTH, u.HEIGHT);
        var r = a.createLinearGradient(0, 0, 0, u.HEIGHT);
        r.addColorStop(0, "#D6F1F1"), r.addColorStop(1, "#D3EDE6"), a.fillStyle = r, a.fillRect(0, 0, u.WIDTH, u.HEIGHT), a.fillStyle = "rgba(0,0,0, 0.3)", a.fillRect(0, 0, u.WIDTH, u.HEIGHT), (0, u.drawText)({
            self: e,
            t: "",
            size: 17,
            pos: [207, 180]
        }), t(e), (0, u.drawReturnImg)(a, e), (0, u.updatePlane)({self: e, type: "bg"})
    }, exports.drawRelaying = function (e) {
        var t = e.opt;
        (0, u.createPlane)(e), (0, u.routeCanvas)(e, "relay"), e.context.btn.clearRect(0, 0, u.WIDTH, u.HEIGHT), (0, u.drawText)({
            self: e,
            t: t.text,
            size: 26,
            pos: [34, 220],
            align: "left",
            type: "btn",
            color: "#403A5B"
        }), (0, u.updatePlane)({self: e, type: "btn"})
    }, exports.drawRelayGG = function (e) {
        if (e.canvasType == u.CANVASTYPE.relay || u.DEBUG) {
            (0, u.createPlane)(e);
            var t = e.context.bg;
            t.clearRect(0, 0, u.WIDTH, u.HEIGHT), (0, u.routeCanvas)(e, "relayGG");
            var a = e.opt;
            (0, u.drawHomeImg)(t, e), (0, u.drawImageCenter)({
                self: e,
                src: "res/bl2.png",
                pos: [207, 342.5, 354, 417],
                imgid: e.imgid.bg,
                type: "bg",
                round: !0,
                cb: function () {
                    (0, u.drawImageCenter)({
                        self: e,
                        src: "res/2d/555.png",
                        pos: [207, 214, 37.4, 27],
                        type: "bg",
                        imgid: e.imgid.bg
                    }), (0, u.drawText)({self: e, t: "", size: 36, pos: [207, 298]}), (0, u.drawText)({
                        self: e,
                        t: "" + a.my_rank + "",
                        size: 30,
                        pos: [207, 358],
                        color: "#E3B857"
                    }), (0, u.drawText)({
                        self: e,
                        t: "" + a.all_player + "",
                        size: 17,
                        pos: [207, 398],
                        color: "#888"
                    }), t.lineWidth = 2 * u.Dpr, t.strokeStyle = "rgba(255,255,255,0.06)", t.fillStyle = "rgba(0,0,0,0.3)", f((0, u.cx)(30), (0, u.cy)(460), (0, u.cwh)(354), (0, u.cwh)(91), 4 * u.Dpr, t), t.fill(), (0, u.drawText)({
                        self: e,
                        t: "",
                        size: 22,
                        pos: [207, 506]
                    })
                }
            }), (0, u.updatePlane)({self: e, type: "bg"})
        }
    }, exports.drawRelayRank = function (e) {
        if (e.opt.players = (0, u.relayRerank)(e.opt.players), (0, u.createPlane)(e), e.context.bg.clearRect(0, 0, u.WIDTH, u.HEIGHT), 1 == e.opt.my_rank) (0, u.drawImageCenter)({
            round: !0,
            self: e,
            src: "res/bl2.png",
            pos: [207, 382.5, 354, 537],
            type: "bg",
            imgid: e.imgid.bg,
            cb: function () {
                y(e)
            }
        }); else {
            var t = !1, a = 0;
            0 == e.opt.my_seat_no && (t = !0), a = t ? 446 : 537, (0, u.drawImageCenter)({
                round: !0,
                self: e,
                src: "res/bl2.png",
                pos: [207, 114 + a / 2, 354, a],
                type: "bg",
                imgid: e.imgid.bg,
                cb: function () {
                    m(e)
                }
            })
        }
    }, exports.drawRelayList = w, exports.drawRelayBeginner = function (e) {
        (0, u.routeCanvas)(e, "relayBeginner"), (0, u.createPlane)(e);
        var t = e.context.bg;
        t.clearRect(0, 0, u.WIDTH, u.HEIGHT), t.beginPath(), t.fillStyle = "rgba(132,111,126,0.8)", t.fillRect(0, (0, u.cy)(547), u.WIDTH, (0, u.cwh)(189)), t.fill(), t.closePath(), (0, u.drawImageCenter)({
            self: e,
            src: "res/2d/skip.png",
            pos: [357, 547, 80, 48],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, u.drawText)({self: e, t: "", size: 17, pos: [207, 599]}), (0, u.drawText)({
            self: e,
            t: "",
            size: 14,
            pos: [207, 631]
        }), (0, u.drawText)({
            self: e,
            t: "",
            size: 14,
            pos: [207, 653]
        }), (0, u.drawText)({self: e, t: "", size: 14, pos: [207, 675]}), (0, u.updatePlane)({
            self: e,
            type: "bg"
        })
    };
    var u = require("./base"), T = function (e) {
        return e && e.__esModule ? e : {default: e}
    }(require("../../scroll/scrollHandler"));
});
define("js/pages/pages2d/start.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0}), exports.drawStartPage = function (t) {
        t.imgid.btn++, t.imgid.bg++, (0, e.routeCanvas)(t, "start"), (0, e.createPlane)(t);
        var r = t.context.bg;
        r.clearRect(0, 0, e.WIDTH, e.HEIGHT), r.fillStyle = "rgba(0,0,0, 0.3)", r.fillRect(0, 0, e.WIDTH, e.HEIGHT), (0, e.drawImageCenter)({
            self: t,
            src: "res/title.png",
            pos: [204, 168, 207, 52],
            type: "bg",
            imgid: t.imgid.bg
        }), t.context.btn.clearRect(0, 0, e.WIDTH, e.HEIGHT), (0, e.drawImageCenter)({
            self: t,
            src: "res/play.png",
            pos: [207, 587, 212, 84],
            type: "btn",
            imgid: t.imgid.btn
        }), t.opt.hideRank || ((0, e.drawText)({
            t: "",
            self: t,
            size: 17,
            pos: [89, 670],
            align: "left"
        }), (0, e.drawImageCenter)({
            self: t,
            src: "res/r_arr.png",
            pos: [173, 670, 6.6, 10],
            type: "bg",
            imgid: t.imgid.bg
        }), (0, e.drawText)({t: "|", self: t, size: 17, pos: [207, 670]}), (0, e.drawText)({
            t: "",
            self: t,
            size: 17,
            pos: [238, 670],
            align: "left"
        }), (0, e.drawImageCenter)({
            self: t,
            src: "res/r_arr.png",
            pos: [303, 670, 6.6, 10],
            type: "bg",
            imgid: t.imgid.bg
        })), 1 == t.opt.banType && (r.lineWidth = 1, r.strokeStyle = "rgba(0,0,0,0.7)", r.fillStyle = "rgba(0,0,0,0.7)", (0, e.roundedRect)((0, e.cx)(30), (0, e.cy)(258), (0, e.cwh)(354), (0, e.cwh)(196), 4, r), r.fill(), (0, e.drawText)({
            t: "",
            self: t,
            size: 17,
            pos: [207, 310]
        }), (0, e.drawText)({t: "", self: t, size: 17, pos: [207, 336]}), (0, e.drawImageCenter)({
            self: t,
            src: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJNNcIVa8Pr2VajbZ52iaZX9Vlib0QAKEJGDIV8F9iaFeqXoawUbQkDP8zc6fbm95nKLgw/0?wx_fmt=png",
            pos: [207, 401, 138, 44],
            type: "bg",
            imgid: t.imgid.bg
        }), (0, e.drawText)({t: "", self: t, size: 15, pos: [207, 401]})), (0, e.updatePlane)({self: t, type: "bg"})
    };
    var e = require("./base");
});
define("js/pages/pages2d/verify.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        e.imgid.bg++;
        var t = e.context.bg;
        t.clearRect(0, 0, r.WIDTH, r.HEIGHT), t.fillStyle = "#555", t.fillRect(0, 0, r.WIDTH, r.HEIGHT), (0, r.drawText)({
            self: e,
            t: "",
            size: 30,
            pos: [207, 153]
        }), (0, r.drawText)({
            self: e,
            t: "",
            size: 16,
            pos: [207, 496],
            color: "rgba(255,255,255,0.4)"
        }), (0, r.drawText)({
            self: e,
            t: "",
            size: 16,
            pos: [207, 518],
            color: "rgba(255,255,255,0.4)"
        }), (0, r.drawText)({
            self: e,
            t: "",
            size: 20,
            pos: [207, 450],
            color: "white"
        }), (0, r.drawImageCenter)({
            self: e,
            src: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJNNcIVa8Pr2VeiaWDZj6rCViaLsuSCWtnyo1mvNqBR05HxPZ5oXTzl0ODXjWiakTvq6yw/0?wx_fmt=png",
            pos: [207, 329, 139, 139],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, r.drawImageCenter)({
            self: e,
            src: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJNNcIVa8Pr2VajbZ52iaZX9Vlib0QAKEJGDIV8F9iaFeqXoawUbQkDP8zc6fbm95nKLgw/0?wx_fmt=png",
            pos: [207, 621, 138, 44],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, r.drawText)({self: e, t: "", size: 15, pos: [207, 621]}), (0, r.drawText)({
            self: e,
            t: "",
            size: 17,
            pos: [197, 690]
        }), (0, r.drawImageCenter)({
            self: e,
            src: "res/r_arr.png",
            pos: [247, 690, 6.5, 12.5],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, r.updatePlane)({self: e, type: "bg"})
    }

    function t(e) {
        wx.chooseImage({
            count: 1,
            sizeType: ["original", "compressed"],
            sourceType: ["album", "camera"],
            success: function (t) {
                e.opt.path = t.tempFilePaths[0], i(e)
            },
            fail: function (t) {
                e.opt.verify_step = 0
            }
        })
    }

    function i(e) {
        var t = e.context.bg;
        t.clearRect(0, 0, r.WIDTH, r.HEIGHT), t.fillStyle = "#555", t.fillRect(0, 0, r.WIDTH, r.HEIGHT), (0, r.drawText)({
            self: e,
            t: "",
            size: 30,
            pos: [207, 117]
        }), (0, r.drawText)({self: e, t: "", size: 14, pos: [207, 158]}), (0, r.drawImageCenter)({
            self: e,
            src: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJNNcIVa8Pr2VajbZ52iaZX9Vlib0QAKEJGDIV8F9iaFeqXoawUbQkDP8zc6fbm95nKLgw/0?wx_fmt=png",
            pos: [207, 621, 138, 44],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, r.drawText)({self: e, t: "", size: 15, pos: [207, 621]}), (0, r.drawText)({
            self: e,
            t: "",
            size: 17,
            pos: [197, 690]
        }), (0, r.drawImageCenter)({
            self: e,
            src: "res/r_arr.png",
            pos: [247, 690, 6.5, 12.5],
            type: "bg",
            imgid: e.imgid.bg
        });
        var i = new Image;
        i.onload = function () {
            console.log(i.width, i.height);
            var t = 240, o = 320;
            i.width / i.height > .75 ? o = i.height / i.width * t : t = i.width / i.height * o, console.log(t, o), (0, r.drawImageCenter)({
                self: e,
                src: e.opt.path,
                pos: [207, 388, t, o],
                type: "bg",
                imgid: e.imgid.bg
            })
        }, i.src = e.opt.path, (0, r.updatePlane)({self: e, type: "bg"})
    }

    function o(e) {
        e.opt.loading || (e.opt.loading = !0, wx.showLoading({title: "..."}), (0, p.upLoadVerifyPic)({
            path: e.opt.path,
            succ: function (t) {
                e.opt.fileid = t, e.opt.verify_step++, a(e)
            },
            complete: function () {
                e.opt.loading = !1, wx.hideLoading()
            }
        }))
    }

    function a(e) {
        var t = e.context.bg;
        t.clearRect(0, 0, r.WIDTH, r.HEIGHT), t.fillStyle = "#555", t.fillRect(0, 0, r.WIDTH, r.HEIGHT), t.fillStyle = "#888", t.fillRect(0, (0, r.cy)(206), (0, r.cwh)(414), (0, r.cwh)(215)), (0, r.drawText)({
            self: e,
            t: "",
            size: 20,
            pos: [207, 117]
        }), t.beginPath(), t.lineWidth = .5 * r.Dpr, t.strokeStyle = "rgba(255,255,255,0.4)", t.moveTo((0, r.cx)(30), (0, r.cy)(299)), t.lineTo((0, r.cx)(384), (0, r.cy)(299)), t.stroke(), t.moveTo((0, r.cx)(30), (0, r.cy)(364)), t.lineTo((0, r.cx)(384), (0, r.cy)(364)), t.stroke(), t.closePath(), (0, r.drawText)({
            self: e,
            t: "",
            align: "left",
            size: 17,
            pos: [30, 277],
            color: "rgba(255,255,255,1)"
        }), (0, r.drawText)({
            self: e,
            t: "",
            align: "left",
            size: 17,
            pos: [30, 342],
            color: "rgba(255,255,255,1)"
        }), (0, r.drawText)({
            self: e,
            t: "",
            align: "left",
            size: 17,
            pos: [138, 277],
            color: "rgba(255,255,255,0.3)"
        }), (0, r.drawText)({
            self: e,
            t: "",
            align: "left",
            size: 17,
            pos: [138, 342],
            color: "rgba(255,255,255,0.3)"
        }), (0, r.drawImageCenter)({
            self: e,
            src: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJNNcIVa8Pr2VajbZ52iaZX9Vlib0QAKEJGDIV8F9iaFeqXoawUbQkDP8zc6fbm95nKLgw/0?wx_fmt=png",
            pos: [207, 621, 138, 44],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, r.drawText)({self: e, t: "", size: 15, pos: [207, 621]}), (0, r.drawText)({
            self: e,
            t: "",
            size: 17,
            pos: [197, 690]
        }), (0, r.drawImageCenter)({
            self: e,
            src: "res/r_arr.png",
            pos: [247, 690, 6.5, 12.5],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, r.updatePlane)({self: e, type: "bg"})
    }

    function l(e) {
        e.opt.mobile && e.opt.name ? e.opt.loading || (e.opt.loading = !0, (0, p.upLoadVerifySubmit)({
            name: e.opt.name,
            mobile: e.opt.mobile,
            fileid: e.opt.fileid,
            is_async: e.lastCanvasType == r.CANVASTYPE.start ? 1 : 0,
            succ: function () {
                s(e), e.opt.verify_step++
            },
            complete: function () {
                e.opt.loading = !1
            }
        })) : wx.showToast({title: "", icon: "none"})
    }

    function s(e) {
        var t = e.context.bg;
        t.clearRect(0, 0, r.WIDTH, r.HEIGHT), t.fillStyle = "#555", t.fillRect(0, 0, r.WIDTH, r.HEIGHT), (0, r.drawText)({
            self: e,
            t: "",
            size: 30,
            pos: [207, 237]
        }), (0, r.drawText)({
            self: e,
            t: "",
            size: 14,
            pos: [207, 278],
            color: "rgba(255,255,255,0.4)"
        }), (0, r.drawText)({
            self: e,
            t: "",
            size: 14,
            pos: [207, 298],
            color: "rgba(255,255,255,0.4)"
        }), (0, r.drawImageCenter)({
            self: e,
            src: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJNNcIVa8Pr2VajbZ52iaZX9Vlib0QAKEJGDIV8F9iaFeqXoawUbQkDP8zc6fbm95nKLgw/0?wx_fmt=png",
            pos: [207, 621, 138, 44],
            type: "bg",
            imgid: e.imgid.bg
        }), (0, r.drawText)({self: e, t: "", size: 15, pos: [207, 621]}), (0, r.updatePlane)({self: e, type: "bg"})
    }

    Object.defineProperty(exports, "__esModule", {value: !0}), exports.routeVerify = function (i) {
        i.opt.verify_step = i.opt.verify_step || 0;
        var a = i.opt.verify_step;
        0 == a ? ((0, r.createPlane)(i), (0, r.routeCanvas)(i, "verify"), e(i), i.opt.verify_step++) : 1 == a ? (t(i), i.opt.verify_step++) : 2 == a ? o(i) : 3 == a && l(i)
    }, exports.clickVerifyForm = function (e, t) {
        console.log(e.opt.showkey), e.opt.showkey || (e.opt.showkey = !0, wx.showKeyboard({
            defaultValue: e.opt[t] || "",
            maxLength: 20,
            multiple: !1,
            confirmType: "done",
            complete: function () {
            }
        }), wx.onKeyboardComplete(function (i) {
            e.opt.showkey = !1, e.opt[t] = i.value;
            var o = e.context.bg;
            o.fillStyle = "#888", "name" == t ? (o.fillRect((0, r.cx)(135), (0, r.cy)(262), (0, r.cwh)(250), (0, r.cwh)(30)), (0, r.drawText)({
                self: e,
                t: (0, r.cname)(e.opt.name || "", 20),
                align: "left",
                size: 17,
                pos: [138, 277],
                color: e.opt.name ? "#fff" : "rgba(255,255,255,0.3)"
            })) : (o.fillRect((0, r.cx)(135), (0, r.cy)(327), (0, r.cwh)(250), (0, r.cwh)(30)), (0, r.drawText)({
                self: e,
                t: (0, r.cname)(e.opt.mobile || "", 20),
                align: "left",
                size: 17,
                pos: [138, 342],
                color: e.opt.mobile ? "#fff" : "rgba(255,255,255,0.3)"
            })), (0, r.updatePlane)({self: e, type: "bg"}), wx.offKeyboardComplete()
        }))
    };
    var r = require("./base"), p = require("../../network/network");
});
define("js/pages/player/playerGamePage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (t, i, n) {
            return i && e(t.prototype, i), n && e(t, n), t
        }
    }(), i = function () {
        function i(t) {
            e(this, i), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.UI = this.game.UI, this.viewer = this.game.viewer, this.name = "game"
        }

        return t(i, [{
            key: "show", value: function () {
                this.UI.showScore(), this.UI.scoreText.obj.position.y = 21, this.UI.scoreText.obj.position.x = -13, this.UI.scoreText.changeStyle({textAlign: "left"}), this.viewer.open()
            }
        }, {
            key: "hide", value: function () {
                this.viewer.close(), this.UI.hideScore()
            }
        }]), i
    }();
    exports.default = i;
});
define("js/pages/relay/fakeRoomPage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var a = t[n];
                a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a)
            }
        }

        return function (t, n, a) {
            return n && e(t.prototype, n), a && e(t, a), t
        }
    }(), n = function () {
        function n(t) {
            e(this, n), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.name = "loading"
        }

        return t(n, [{
            key: "show", value: function (e) {
                this.full2D.showRelayRoom({
                    players: [],
                    imgdata: "",
                    game_status: 0,
                    my_seat_no: e ? 1 : 0,
                    room_owner_seat: 1
                })
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D()
            }
        }]), n
    }();
    exports.default = n;
});
define("js/pages/relay/gamePage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var o = t[i];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
            }
        }

        return function (t, i, o) {
            return i && e(t.prototype, i), o && e(t, o), t
        }
    }(), i = function () {
        function i(t) {
            e(this, i), this.game = t, this.name = "game", this.full2D = this.game.full2D, this.UI = this.game.UI
        }

        return t(i, [{
            key: "show", value: function () {
                this.UI.scoreText.obj.position.x = -13.8, this.UI.scoreText.obj.position.y = 26, this.UI.scoreText.obj.scale.set(.8, .8, .8), this.UI.scoreText.changeStyle({textAlign: "left"}), this.UI.showScore()
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D(), this.UI.hideScore(), this.UI.scoreText.obj.position.y = 21, this.UI.scoreText.obj.position.x = -13, this.UI.scoreText.obj.scale.set(1, 1, 1), this.UI.scoreText.changeStyle({textAlign: "left"})
            }
        }, {
            key: "hideScore", value: function () {
                this.UI.hideScore(), this.UI.scoreText.obj.position.y = 21, this.UI.scoreText.obj.position.x = -13, this.UI.scoreText.changeStyle({textAlign: "left"})
            }
        }]), i
    }();
    exports.default = i;
});
define("js/pages/relay/room.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var o = 0; o < t.length; o++) {
                var a = t[o];
                a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a)
            }
        }

        return function (t, o, a) {
            return o && e(t.prototype, o), a && e(t, a), t
        }
    }(), o = function () {
        function o(t) {
            e(this, o), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.name = "relayRoom"
        }

        return t(o, [{
            key: "show", value: function (e) {
                var t = {
                    players: e.playerlist,
                    imgdata: e.room_wxa_code || "",
                    game_status: e.game_status || 0,
                    my_seat_no: e.my_seat_no,
                    room_owner_seat: e.room_owner_seat,
                    game_level: e.game_level || 0
                };
                console.log(""), this.full2D.showRelayRoom(t)
            }
        }, {
            key: "hide", value: function () {
                ((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).hide2D || !1) && this.full2D.hide2D()
            }
        }]), o
    }();
    exports.default = o;
});
define("js/pages/shareCard.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var i = t[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }

            return function (t, n, i) {
                return n && e(t.prototype, n), i && e(t, i), t
            }
        }(), n = function (e) {
            return e && e.__esModule ? e : {default: e}
        }(require("../store/storage")), i = window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio,
        a = (window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth, window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth, wx.loadFont("res/num.ttf")),
        r = function () {
            function i(t) {
                e(this, i), this.texture = {}, this.material = {}
            }

            return t(i, [{
                key: "getShareCard", value: function (e, t) {
                    e = e || {};
                    this.canvas || (this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.canvas.width = 693, this.canvas.height = 558);
                    var i = this.context;
                    if ("shareBattle" == e.type) {
                        i.fillStyle = "white", i.fillRect(0, 0, 693, 558);
                        r = this;
                        this._drawImageCanvas1("res/changlle_share.png", 0, 0, 693, 558, "share", function () {
                            i.fillStyle = "rgba(0,0,0,0.8)", i.font = "180px " + a, i.textBaseline = "middle", i.textAlign = "center", i.fillText(e.score || 0, 356.5, 334.8), !!t && t(r.canvas)
                        })
                    }
                    if ("history" == e.type) {
                        i.fillStyle = "white", i.fillRect(0, 0, 693, 558);
                        r = this;
                        this._drawImageCanvas1("res/high_score.png", 0, 0, 693, 558, "share", function () {
                            i.fillStyle = "#00c777", i.font = "180px " + a, i.textBaseline = "middle", i.textAlign = "center", i.fillText(e.score || 0, 356.5, .68 * 558), !!t && t(r.canvas)
                        })
                    }
                    if ("week" == e.type) {
                        i.fillStyle = "white", i.fillRect(0, 0, 693, 558);
                        r = this;
                        this._drawImageCanvas1("res/high_score_week.png", 0, 0, 693, 558, "share", function () {
                            i.fillStyle = "#00c777", i.font = "180px " + a, i.textBaseline = "middle", i.textAlign = "center", i.fillText(e.score || 0, 356.5, .68 * 558), !!t && t(r.canvas)
                        })
                    }
                    if ("rank" == e.type) {
                        i.fillStyle = "white", i.fillRect(0, 0, 693, 558);
                        var r = this, l = n.default.getMyUserInfo();
                        r._drawImageCanvas1(l.headimg, 305.5, 279, 102, 102, "share", function () {
                            r._drawImageCanvas1("res/high_rank.png", 0, 0, 693, 558, "share", function () {
                                i.fillStyle = "#00c777", i.font = "60px " + a, i.textBaseline = "middle", i.textAlign = "center", i.fillText(e.score || 5678, 356.5, .8 * 558), !!t && t(r.canvas)
                            })
                        })
                    }
                }
            }, {
                key: "_smallReat", value: function () {
                    for (var e = this.context, t = ["red", "blue", "green", "yellow", "skyblue"], n = 0; n < t.length; n++) {
                        e.fillStyle = t[n];
                        for (var i = 0; i < 5; i++) e.fillRect(553 * Math.random(), 691 * Math.random(), 15, 15)
                    }
                }
            }, {
                key: "_drawImageCanvas", value: function (e, t, n, i, a, r, l) {
                    var o = new Image, s = this;
                    o.onload = function () {
                        s.context.drawImage(o, t - i / 2, n - a / 2, i, a), !!l && l(s.canvas)
                    }, o.onerror = function () {
                        !!l && l(s.canvas)
                    }, o.src = e
                }
            }, {
                key: "_drawImageCanvas1", value: function (e, t, n, i, a, r, l) {
                    "/0" != e && "/96" != e && "/64" != e && e || (e = "res/ava.png");
                    var o = new Image, s = this;
                    o.onload = function () {
                        s.context.drawImage(o, t, n, i, a), !!l && l(s.canvas)
                    }, o.onerror = function () {
                        !!l && l(s.canvas)
                    }, o.src = e
                }
            }]), i
        }();
    exports.default = r;
});
define("js/pages/single/relayGuide.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var i = t[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, n, i) {
            return n && e(t.prototype, n), i && e(t, i), t
        }
    }(), n = function (e) {
        return e && e.__esModule ? e : {default: e}
    }(require("../../lib/mue/eventcenter")), i = require("../../config"), r = function () {
        function r(t) {
            e(this, r), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.name = "startPage"
        }

        return t(r, [{
            key: "show", value: function (e) {
                this.full2D.showRelayBeginner()
            }
        }, {
            key: "hide", value: function () {
                n.default.emitSync(i.EVENT.SKIP_RELAY_GUIDE), this.full2D.hide2D()
            }
        }]), r
    }();
    exports.default = r;
});
define("js/pages/single/singleFriendRankPage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var i = t[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, n, i) {
            return n && e(t.prototype, n), i && e(t, i), t
        }
    }(), n = function () {
        function n(t) {
            e(this, n), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.name = "friendRankList"
        }

        return t(n, [{
            key: "show", value: function () {
                this.full2D.showFriendRankList({week_best_score: this.model.weekBestScore})
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D()
            }
        }]), n
    }();
    exports.default = n;
});
define("js/pages/single/singleGameOverPage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (t, i, n) {
            return i && e(t.prototype, i), n && e(t, n), t
        }
    }(), i = function () {
        function i(t) {
            e(this, i), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.name = "singleSettlementPgae"
        }

        return t(i, [{
            key: "show", value: function (e) {
                var t = 0;
                e && (t = e.banType || 0);
                var i = this.model.currentScore, n = this.model.getHighestScore(), r = this.model.startTime,
                    s = this.model.weekBestScore, a = this.game.historyTimes.getTimes();
                this.full2D || this.game.handleWxOnError({
                    message: "can not find full 2D gameOverPage",
                    stack: ""
                }), this.full2D && this.full2D.showGameOverPage({
                    score: i,
                    highest_score: n,
                    start_time: r,
                    week_best_score: s,
                    game_cnt: a,
                    banType: t
                })
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D()
            }
        }]), i
    }();
    exports.default = i;
});
define("js/pages/single/singleGamePage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var o = t[i];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
            }
        }

        return function (t, i, o) {
            return i && e(t.prototype, i), o && e(t, o), t
        }
    }(), i = function () {
        function i(t) {
            e(this, i), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.UI = this.game.UI, this.viewer = this.game.viewer, this.name = "game"
        }

        return t(i, [{
            key: "show", value: function () {
                var e = this.model.is_from_wn, t = this.model.firstBlood;
                e || this.game.guider || (t ? this.viewer.lookers.showLookers({
                    avaImg: !1,
                    icon: !0,
                    wording: !0
                }) : this.viewer.open()), this.UI.showScore(), this.UI.scoreText.obj.position.y = 21, this.UI.scoreText.obj.position.x = -13, this.UI.scoreText.changeStyle({textAlign: "left"})
            }
        }, {
            key: "hide", value: function () {
                this.viewer.close(), this.UI.hideScore()
            }
        }, {
            key: "hideLookersShare", value: function () {
                this.model.firstBlood && (this.model.setFirstBlood(!1), this.viewer.open())
            }
        }]), i
    }();
    exports.default = i;
});
define("js/pages/single/singleStartPage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var i = t[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
            }
        }

        return function (t, n, i) {
            return n && e(t.prototype, n), i && e(t, i), t
        }
    }(), n = function () {
        function n(t) {
            e(this, n), this.game = t, this.model = this.game.gameModel, this.full2D = this.game.full2D, this.name = "startPage"
        }

        return t(n, [{
            key: "show", value: function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                e.hideRank = this.model.firstBlood, this.full2D && this.full2D.showStartPage(e), this.model.firstBlood = !1
            }
        }, {
            key: "hide", value: function () {
                this.full2D.hide2D()
            }
        }]), n
    }();
    exports.default = n;
});
define("js/pages/singleSettlementPage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }

        return function (t, n, r) {
            return n && e(t.prototype, n), r && e(t, r), t
        }
    }(), n = function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
        return t.default = e, t
    }(require("../lib/three")), r = function () {
        function r(t) {
            e(this, r);
            var o = new n.MeshBasicMaterial({color: 32960}), i = new n.Mesh(new n.PlaneGeometry(5, 5), o),
                a = i.clone(), u = i.clone();
            a.position.set(0, -20, -1), i.position.set(-10, -20, -1), u.position.set(10, -20, -1), this.ui = [a, i, u], this.camera = t
        }

        return t(r, [{
            key: "show", value: function () {
                var e = this;
                this.ui.forEach(function (t) {
                    e.camera.add(t)
                })
            }
        }, {
            key: "hide", value: function () {
                var e = this;
                this.ui.forEach(function (t) {
                    e.camera.remove(t)
                })
            }
        }]), r
    }();
    exports.default = r;
});
define("js/random.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0});
    var r = void 0, e = function () {
        return r = (9301 * r + 49297) % 233280, Math.floor(r / 233280 * 100) / 100
    };
    exports.setRandomSeed = function (e) {
        r = e
    }, exports.random = function () {
        if (0 === arguments.length) return e();
        if (1 === arguments.length) {
            var r = arguments[0];
            return Math.floor(e() * r)
        }
        var t = arguments[0], o = arguments[1];
        return Math.floor(e() * (o - t)) + t
    };
});
define("js/rankSystem.js", function (require, module, exports) {
    "use strict";

    function t(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function e(t, e, i, a, o, r) {
        return t.moveTo(e, i + r), t.lineTo(e, i + o - r), t.quadraticCurveTo(e, i + o, e + r, i + o), t.lineTo(e + a - r, i + o), t.quadraticCurveTo(e + a, i + o, e + a, i + o - r), t.lineTo(e + a, i + r), t.quadraticCurveTo(e + a, i, e + a - r, i), t.lineTo(e + r, i), t.quadraticCurveTo(e, i, e, i + r), t
    }

    function i(t) {
        t.computeBoundingBox();
        var e = t.boundingBox.max, i = t.boundingBox.min, a = new o.Vector2(0 - i.x, 0 - i.y),
            r = new o.Vector2(e.x - i.x, e.y - i.y), s = t.faces;
        t.faceVertexUvs[0] = [];
        for (var n = 0; n < s.length; n++) {
            var h = t.vertices[s[n].a], u = t.vertices[s[n].b], c = t.vertices[s[n].c];
            t.faceVertexUvs[0].push([new o.Vector2((h.x + a.x) / r.x, (h.y + a.y) / r.y), new o.Vector2((u.x + a.x) / r.x, (u.y + a.y) / r.y), new o.Vector2((c.x + a.x) / r.x, (c.y + a.y) / r.y)])
        }
        t.uvsNeedUpdate = !0
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var a = function () {
        function t(t, e) {
            for (var i = 0; i < e.length; i++) {
                var a = e[i];
                a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a)
            }
        }

        return function (e, i, a) {
            return i && t(e.prototype, i), a && t(e, a), e
        }
    }(), o = function (t) {
        if (t && t.__esModule) return t;
        var e = {};
        if (null != t) for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        return e.default = t, e
    }(require("./lib/three")), r = (require("./config"), function (t) {
        return t && t.__esModule ? t : {default: t}
    }(require("./text"))), s = require("./lib/animation"), n = 1.3, h = n / 20 * 21, u = function () {
        function u(a) {
            t(this, u), this.game = a, this.seed = 0, this.startDist = 0, this.hitPoint = {
                uuid: "",
                ready: !1,
                texture: null
            }, this.loader = new o.TextureLoader, this.text = new r.default("", {
                fillStyle: 2434341,
                chinese: !0,
                textAlign: "center"
            });
            var s = new o.Shape;
            s = e(s, -h, -h, 2 * h, 2 * h, .5);
            var c = new o.Shape;
            c = e(c, -n, -n, 2 * n, 2 * n, .5);
            var l = new o.ShapeGeometry(c);
            i(l), this.avatorFrame = new o.Mesh(l, new o.MeshBasicMaterial({
                transparent: !0,
                opacity: 1
            })), this.avatorOuter = new o.Mesh(new o.ShapeGeometry(s), new o.MeshBasicMaterial({
                color: 16777215,
                transparent: !0,
                opacity: 1
            })), this.text.obj.scale.set(.8, .8, .8), this.text.obj.position.set(0, 2.2, .1), this.avatorFrame.position.set(0, 0, .1), this.avatorFrame.material.opacity = 0, this.avatorOuter.position.set(0, 0, 0), this.avatorOuter.material.opacity = 0, this.text.material.opacity = 0, this.obj = new o.Object3D, this.text.obj.visible = !1, this.obj.add(this.avatorOuter), this.obj.add(this.avatorFrame), this.obj.add(this.text.obj), this.obj.rotateY(-Math.PI / 4), this.obj.rotateX(-Math.PI / 16 * 3), this.game.scene.add(this.obj), this.obj.visible = !1
        }

        return a(u, [{
            key: "update", value: function () {
                this.game.gameModel.friendsScore && this.game.gameModel.friendsScore.length && (this.seed++, this.hitPoint.uuid == this.game.currentBlock.obj.uuid && this.hitPoint.ready && this.hitPoint.texture && (this.startDist < 2 && (this.startDist++, this.text.obj.visible = !0), this.playAnimate(), this.seed = 0), this.seed >= 5 && this.checkScore())
            }
        }, {
            key: "checkScore", value: function () {
                var t = this.game.UI.score, e = this.game.gameModel.friendsScore;
                try {
                    for (var i = 0; i < e.length; i++) if (e[i].week_best_score == t) {
                        this.hitPoint.uuid = this.game.nextBlock.obj.uuid, this.hitPoint.ready = !1, this.animateAvator(e[i]);
                        break
                    }
                } catch (t) {
                    console.log("RankSystem checkScore err:", t)
                }
            }
        }, {
            key: "animateAvator", value: function (t) {
                var e = this;
                this.loader.load(t.headimg, function (t) {
                    e.hitPoint.uuid == e.game.nextBlock.obj.uuid && (e.hitPoint.ready = !0, t.minFilter = o.LinearFilter, e.hitPoint.texture = t)
                })
            }
        }, {
            key: "playAnimate", value: function () {
                var t = this;
                this.game.bottle.changeScorePos(3);
                var e = this.game.bottle.obj.position.clone(), i = e.x, a = e.z;
                this.obj.position.set(i, 10, a), this.avatorFrame.material.map = this.hitPoint.texture, this.obj.visible = !0, s.customAnimation.to(this.obj.position, .4, {y: 13}), s.customAnimation.to(this.text.material, .4, {opacity: 1}), s.customAnimation.to(this.avatorOuter.material, .4, {opacity: 1}), s.customAnimation.to(this.avatorFrame.material, .4, {opacity: 1}), s.customAnimation.to(this.text.material, .4, {
                    opacity: 0,
                    delay: .6,
                    onComplete: function () {
                        t.resetAvator(), t.game.bottle.changeScorePos(0)
                    }
                }), s.customAnimation.to(this.avatorOuter.material, .4, {
                    opacity: 0,
                    delay: .6
                }), s.customAnimation.to(this.avatorFrame.material, .4, {
                    opacity: 0,
                    delay: .6
                }), this.hitPoint.uuid = "", this.hitPoint.ready = !1, this.hitPoint.texture = null
            }
        }, {
            key: "resetAvator", value: function () {
                this.obj.visible = !1, this.text.obj.visible = !1, this.avatorFrame.material.opacity = 0, this.avatorFrame.material.map && this.avatorFrame.material.map.dispose(), this.avatorFrame.material.map = "", this.avatorOuter.material.opacity = 0, this.text.material.opacity = 0
            }
        }, {
            key: "reset", value: function () {
                this.seed = 0, this.seed = 0, this.startDist = 0, this.startDist = 0, this.hitPoint = {
                    uuid: "",
                    ready: !1,
                    texture: null
                }, this.obj.visible = !1
            }
        }]), u
    }();
    exports.default = u;
});
define("js/report.js", function (require, module, exports) {
    "use strict";

    function e(e, n) {
        if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var n = function () {
        function e(e, n) {
            for (var a = 0; a < n.length; a++) {
                var r = n[a];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }

        return function (n, a, r) {
            return a && e(n.prototype, a), r && e(n, r), n
        }
    }(), a = function () {
        function a(n) {
            e(this, a)
        }

        return n(a, null, [{
            key: "frameReport", value: function (e, n) {
                var a = 0;
                switch (e) {
                    case"iPhone5":
                        a = 1;
                        break;
                    case"iPhone5s":
                        a = 2;
                        break;
                    case"iPhone6":
                        a = 3;
                        break;
                    case"iPhone6s":
                        a = 4;
                        break;
                    case"iPhone6Plus":
                        a = 5;
                        break;
                    case"iPhone6sPlus":
                        a = 6;
                        break;
                    case"iPhone7":
                        a = 7;
                        break;
                    case"iPhone7s":
                        a = 8;
                        break;
                    case"iPhone7Plus":
                        a = 9;
                        break;
                    case"iPhone7sPlus":
                        a = 10;
                        break;
                    case"iPhone8":
                        a = 11;
                        break;
                    case"iPhone8Plus":
                        a = 12;
                        break;
                    case"iPhoneX":
                        a = 13
                }
                (new Image).src = "https://mp.weixin.qq.com/mp/jsmonitor?idkey=58121_" + 3 * a + "_" + n + ";58121_" + (3 * a + 1) + "_1&t=" + Math.random()
            }
        }]), a
    }();
    exports.default = a;
});
define("js/scroll/friction.js", function (require, module, exports) {
    "use strict";

    function t(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var e = function () {
        function t(t, e) {
            for (var i = 0; i < e.length; i++) {
                var r = e[i];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
            }
        }

        return function (e, i, r) {
            return i && t(e.prototype, i), r && t(e, r), e
        }
    }(), i = function () {
        function i(e) {
            t(this, i), this._drag = e, this._dragLog = Math.log(e), this._x = 0, this._v = 0, this._startTime = 0
        }

        return e(i, [{
            key: "set", value: function (t, e) {
                this._x = t, this._v = e, this._startTime = (new Date).getTime()
            }
        }, {
            key: "x", value: function (t) {
                void 0 === t && (t = ((new Date).getTime() - this._startTime) / 1e3);
                var e;
                return e = t === this._dt && this._powDragDt ? this._powDragDt : this._powDragDt = Math.pow(this._drag, t), this._dt = t, this._x + this._v * e / this._dragLog - this._v / this._dragLog
            }
        }, {
            key: "dx", value: function (t) {
                void 0 === t && (t = ((new Date).getTime() - this._startTime) / 1e3);
                var e;
                return e = t === this._dt && this._powDragDt ? this._powDragDt : this._powDragDt = Math.pow(this._drag, t), this._dt = t, this._v * e
            }
        }, {
            key: "done", value: function () {
                return Math.abs(this.dx()) < 3
            }
        }]), i
    }();
    exports.default = i;
});
define("js/scroll/scroll.js", function (require, module, exports) {
    "use strict";

    function t(t) {
        return t && t.__esModule ? t : {default: t}
    }

    function i(t, i) {
        if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var s = function () {
        function t(t, i) {
            for (var s = 0; s < i.length; s++) {
                var n = i[s];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }

        return function (i, s, n) {
            return s && t(i.prototype, s), n && t(i, n), i
        }
    }(), n = t(require("./friction")), e = t(require("./spring")), r = function () {
        function t(s) {
            i(this, t), this._extent = s, this._friction = new n.default(.01), this._spring = new e.default(1, 90, 20), this._startTime = 0, this._springing = !1, this._springOffset = 0
        }

        return s(t, [{
            key: "set", value: function (t, i) {
                this._friction.set(t, i), t > 0 && i >= 0 ? (this._springOffset = 0, this._springing = !0, this._spring.snap(t), this._spring.setEnd(0)) : t < -this._extent && i <= 0 ? (this._springOffset = 0, this._springing = !0, this._spring.snap(t), this._spring.setEnd(-this._extent)) : this._springing = !1, this._startTime = (new Date).getTime()
            }
        }, {
            key: "x", value: function (t) {
                if (!this._startTime) return 0;
                if (t || (t = ((new Date).getTime() - this._startTime) / 1e3), this._springing) return this._spring.x() + this._springOffset;
                var i = this._friction.x(t), s = this.dx(t);
                return i < -this._extent && s <= 0 && (this._springing = !0, this._spring.setEnd(0, s), i < -this._extent ? this._springOffset = -this._extent : this._springOffset = 0, i = this._spring.x() + this._springOffset), i
            }
        }, {
            key: "dx", value: function (t) {
                var i = 0;
                return i = this._lastTime === t ? this._lastDx : this._springing ? this._spring.dx(t) : this._friction.dx(t), this._lastTime = t, this._lastDx = i, i
            }
        }, {
            key: "done", value: function () {
                return this._springing ? this._spring.done() : this._friction.done()
            }
        }]), t
    }();
    exports.default = r;
});
define("js/scroll/scrollHandler.js", function (require, module, exports) {
    "use strict";

    function t(t, i) {
        if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
        function t(t, i) {
            for (var n = 0; n < i.length; n++) {
                var e = i[n];
                e.enumerable = e.enumerable || !1, e.configurable = !0, "value" in e && (e.writable = !0), Object.defineProperty(t, e.key, e)
            }
        }

        return function (i, n, e) {
            return n && t(i.prototype, n), e && t(i, e), i
        }
    }(), n = function (t) {
        return t && t.__esModule ? t : {default: t}
    }(require("./scroll")), e = function () {
        function e(i) {
            t(this, e), i = i || {}, this._options = i, this._itemSize = i.itemSize || 0, this._innerOffsetHeight = i.innerOffsetHeight || 0, this._outterOffsetHeight = i.outterOffsetHeight || 0, this._extent = this._innerOffsetHeight - this._outterOffsetHeight, this._position = 0, this._scroll = new n.default(this._extent), this.updatePosition()
        }

        return i(e, [{
            key: "onTouchStart", value: function () {
                this._startPosition = this._position, this._lastChangePos = this._startPosition, this._startPosition > 0 ? this._startPosition /= .5 : this._startPosition < -this._extent && (this._startPosition = (this._startPosition + this._extent) / .5 - this._extent), this._animation && (this._animation.cancel(), this._scrolling = !1), this.updatePosition()
            }
        }, {
            key: "onTouchMove", value: function (t, i) {
                var n = this._startPosition;
                (n += i) > 0 ? n *= .5 : n < -this._extent && (n = .5 * (n + this._extent) - this._extent), this._position = n, this.updatePosition()
            }
        }, {
            key: "onTouchEnd", value: function (t, i, n) {
                var e = this;
                this._scroll.set(this._position, n.y), this._scrolling = !0, this._lastChangePos = this._position, this._animation = this.animation(this._scroll, function () {
                    var t = (Date.now() - e._scroll._startTime) / 1e3, i = e._scroll.x(t);
                    e._position = i, e.updatePosition()
                }, function () {
                    e._scrolling = !1
                })
            }
        }, {
            key: "scrollTo", value: function (t) {
                this._animation && (this._animation.cancel(), this._scrolling = !1), "number" == typeof t && (this._position = -t), this._position < -this._extent ? this._position = -this._extent : this._position > 0 && (this._position = 0), this.updatePosition()
            }
        }, {
            key: "updatePosition", value: function () {
                this._options.updatePosition(this._position)
            }
        }, {
            key: "animation", value: function (t, i, n) {
                function e(i, n, o, s) {
                    if (!i || !i.cancelled) {
                        o(n);
                        var a = t.done();
                        a || i.cancelled || (i.id = requestAnimationFrame(e.bind(null, i, n, o, s))), a && s && s(n)
                    }
                }

                var o = {id: 0, cancelled: !1};
                return e(o, t, i, n), {
                    cancel: function (t) {
                        t && t.id && cancelAnimationFrame(t.id), t && (t.cancelled = !0)
                    }.bind(null, o), model: t
                }
            }
        }]), e
    }();
    exports.default = e;
});
define("js/scroll/spring.js", function (require, module, exports) {
    "use strict";

    function t(t, i) {
        if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
        function t(t, i) {
            for (var o = 0; o < i.length; o++) {
                var e = i[o];
                e.enumerable = e.enumerable || !1, e.configurable = !0, "value" in e && (e.writable = !0), Object.defineProperty(t, e.key, e)
            }
        }

        return function (i, o, e) {
            return o && t(i.prototype, o), e && t(i, e), i
        }
    }(), o = function () {
        function o(i, e, n) {
            t(this, o), this._m = i, this._k = e, this._c = n, this._solution = null, this._endPosition = 0, this._startTime = 0
        }

        return i(o, [{
            key: "_solve", value: function (t, i) {
                var o = this._c, e = this._m, n = this._k, s = o * o - 4 * e * n;
                if (0 == s) {
                    var r = t, a = i / ((_ = -o / (2 * e)) * t);
                    return {
                        x: function (t) {
                            return (r + a * t) * Math.pow(Math.E, _ * t)
                        }, dx: function (t) {
                            var i = Math.pow(Math.E, _ * t);
                            return _ * (r + a * t) * i + a * i
                        }
                    }
                }
                if (s > 0) {
                    var h = (-o - Math.sqrt(s)) / (2 * e), u = (-o + Math.sqrt(s)) / (2 * e),
                        r = t - (a = (i - h * t) / (u - h));
                    return {
                        x: function (t) {
                            var i, o;
                            return t === this._t && (i = this._powER1T, o = this._powER2T), this._t = t, i || (i = this._powER1T = Math.pow(Math.E, h * t)), o || (o = this._powER2T = Math.pow(Math.E, u * t)), r * i + a * o
                        }, dx: function (t) {
                            var i, o;
                            return t === this._t && (i = this._powER1T, o = this._powER2T), this._t = t, i || (i = this._powER1T = Math.pow(Math.E, h * t)), o || (o = this._powER2T = Math.pow(Math.E, u * t)), r * h * i + a * u * o
                        }
                    }
                }
                var l = Math.sqrt(4 * e * n - o * o) / (2 * e), _ = -o / 2 * e, r = t, a = (i - _ * t) / l;
                return {
                    x: function (t) {
                        return Math.pow(Math.E, _ * t) * (r * Math.cos(l * t) + a * Math.sin(l * t))
                    }, dx: function (t) {
                        var i = Math.pow(Math.E, _ * t), o = Math.cos(l * t), e = Math.sin(l * t);
                        return i * (a * l * o - r * l * e) + _ * i * (a * e + r * o)
                    }
                }
            }
        }, {
            key: "x", value: function (t) {
                return void 0 == t && (t = ((new Date).getTime() - this._startTime) / 1e3), this._solution ? this._endPosition + this._solution.x(t) : 0
            }
        }, {
            key: "dx", value: function (t) {
                return void 0 == t && (t = ((new Date).getTime() - this._startTime) / 1e3), this._solution ? this._solution.dx(t) : 0
            }
        }, {
            key: "setEnd", value: function (t, i, o) {
                if (o || (o = (new Date).getTime()), t != this._endPosition || !this.almostZero(i, .4)) {
                    i = i || 0;
                    var e = this._endPosition;
                    this._solution && (this.almostZero(i, .4) && (i = this._solution.dx((o - this._startTime) / 1e3)), e = this._solution.x((o - this._startTime) / 1e3), this.almostZero(i, .4) && (i = 0), this.almostZero(e, .4) && (e = 0), e += this._endPosition), this._solution && this.almostZero(e - t, .4) && this.almostZero(i, .4) || (this._endPosition = t, this._solution = this._solve(e - this._endPosition, i), this._startTime = o)
                }
            }
        }, {
            key: "snap", value: function (t) {
                this._startTime = (new Date).getTime(), this._endPosition = t, this._solution = {
                    x: function () {
                        return 0
                    }, dx: function () {
                        return 0
                    }
                }
            }
        }, {
            key: "done", value: function (t) {
                return t || (t = (new Date).getTime()), this.almostEqual(this.x(), this._endPosition, .4) && this.almostZero(this.dx(), .4)
            }
        }, {
            key: "almostEqual", value: function (t, i, o) {
                return t > i - o && t < i + o
            }
        }, {
            key: "almostZero", value: function (t, i) {
                return this.almostEqual(t, 0, i)
            }
        }]), o
    }();
    exports.default = o;
});
define("js/shareApp.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    Object.defineProperty(exports, "__esModule", {value: !0}), exports.shareGroupRank = function () {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
        };
        wx.getNetworkType({
            success: function (t) {
                "none" !== t.networkType ? wx.updateShareMenu({
                    withShareTicket: !0, success: function () {
                        wx.shareAppMessage({
                            title: "",
                            query: "mode=groupShare",
                            imageUrl: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNQ0ia79enzYJBrAavqMRykpovYxSA9RRTwIjde6a68ZCczLMBBd8eSoOyTRyp2Codc5IObdeqZVFyw/0?wx_fmt=png",
                            success: function (t) {
                                e(!0, 1)
                            },
                            fail: function (t) {
                                e(!1)
                            }
                        })
                    }
                }) : (e(!1), wx.showModal({title: "", content: "", showCancel: !1}))
            }
        })
    }, exports.shareBattle = function (e, t) {
        var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {
        };
        n.getShareCard({score: t, type: "shareBattle"}, function (t) {
            var n = "";
            try {
                n = t.toTempFilePathSync()
            } catch (e) {
                console.log("shareBattle: ", e)
            }
            e && wx.updateShareMenu({
                withShareTicket: !0, success: function () {
                    wx.shareAppMessage({
                        title: "",
                        query: "mode=battle&pkId=" + e,
                        imageUrl: n,
                        success: function (t) {
                            a(!0, 1), console.log("mode=battle&pkId=" + e)
                        },
                        fail: function () {
                            a(!1)
                        }
                    })
                }, fail: function (e) {
                    a(!1)
                }
            })
        })
    }, exports.shareObserve = function () {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
        }, n = a.default.getMyUserInfo();
        n || (n = {
            nickname: "",
            headimg: ""
        }), console.log("query: ", "gameId=" + t.default.gameId + "&mode=observe&nickName=" + n.nickname + "&headimg=" + n.headimg), wx.updateShareMenu({
            withShareTicket: !0,
            success: function () {
                wx.shareAppMessage({
                    title: "",
                    query: "gameId=" + t.default.gameId + "&mode=observe&nickName=" + n.nickname + "&headimg=" + n.headimg,
                    imageUrl: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNQ0ia79enzYJBiaBtXsYrvBsYBdBdDtKE7y638J84JKPckcOtFMp4QunIWFGc7pibQLm13s9fKZ9ic9ew/0?wx_fmt=png",
                    success: function (t) {
                        e(!0, 1)
                    },
                    fail: function (t) {
                        e(!1)
                    }
                })
            },
            fail: function () {
                e(!1)
            }
        })
    }, exports.pureShare = function (e, t) {
        n.getShareCard({type: e, score: t}, function (t) {
            var a = "";
            try {
                a = t.toTempFilePathSync()
            } catch (e) {
                console.log("pureShare: ", e)
            }
            var n = "";
            n = "rank" == e ? "" : "", wx.shareAppMessage({
                title: n,
                imageUrl: a,
                success: function (e) {
                },
                fail: function (e) {
                }
            })
        })
    }, exports.ShareRelayCard = function (e) {
        var t = e.room_id, a = e.router_id, n = e.version, i = e.cb;
        if (t && a && n) {
            var r = "room_id=" + t + "&mode=relay&router_id=" + encodeURIComponent(a) + "&version=" + n;
            console.log(r), wx.updateShareMenu({
                withShareTicket: !0, success: function () {
                    wx.shareAppMessage({
                        title: "",
                        query: r,
                        imageUrl: "http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJN1hYNSmzE0JHB0FicpvibX9tgX8mb3MxbrtpgVxR9ZJaez7Uys56ckP57EU9ib1365Ng/0?wx_fmt=png",
                        success: function (e) {
                            var t = "";
                            e.shareTickets && (t = e.shareTickets[0]), wx.getShareInfo({
                                shareTicket: t,
                                success: function (e) {
                                    i(r, e.rawData)
                                }
                            })
                        },
                        fail: function (e) {
                        }
                    })
                }, fail: function () {
                    i(!1)
                }
            })
        } else console.log("shareRelay", t, a, n)
    };
    var t = e(require("./store/session")), a = e(require("./store/storage")),
        n = new (e(require("./pages/shareCard")).default)({});
});
define("js/skin.js", function (require, module, exports) {
    "use strict";
});
define("js/stageManager.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }

        return function (t, n, r) {
            return n && e(t.prototype, n), r && e(t, r), t
        }
    }(), n = function () {
        function n() {
            e(this, n), this._stages = {}, this._current = null
        }

        return t(n, [{
            key: "navigatorTo", value: function (e, t) {
                this._current && this._pages[e] ? (this._current.destroyStage(), this._current = this._pages[e], this._current.initStage(t)) : console.warn("StageManager navigator fail")
            }
        }, {
            key: "register", value: function (e, t) {
                "function" == typeof t.destroyStage && "function" == typeof t.initStage ? this._stages[e] = t : consoel.warn("StageManager ")
            }
        }]), n
    }();
    exports.default = n;
});
define("js/store/historyTimes.js", function (require, module, exports) {
    "use strict";

    function e(e) {
        return e && e.__esModule ? e : {default: e}
    }

    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var s = t[i];
                s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, s.key, s)
            }
        }

        return function (t, i, s) {
            return i && e(t.prototype, i), s && e(t, s), t
        }
    }(), s = e(require("./storage")), u = e(require("../network/network")), n = function () {
        function e(i) {
            t(this, e), this.times = s.default.getHistoryTimes(), this.times || (this.times = {
                accurate: 0,
                bonus: 0
            }), this.game = i, this.limitScore = 5
        }

        return i(e, [{
            key: "verifyScore", value: function (e) {
                e >= this.times.accurate ? (this.times.accurate = e, this.times.bonus >= this.limitScore ? this.upLoadHistoryTimes() : s.default.saveHistoryTimes(this.times)) : this.upLoadHistoryTimes()
            }
        }, {
            key: "addOne", value: function () {
                this.times.bonus++
            }
        }, {
            key: "checkUp", value: function () {
                this.times.bonus >= this.limitScore ? this.upLoadHistoryTimes() : s.default.saveHistoryTimes(this.times)
            }
        }, {
            key: "upLoadHistoryTimes", value: function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    i = this.times.accurate + this.times.bonus;
                u.default.requestSettlement(e, i, this.afterUpload.bind(this), t)
            }
        }, {
            key: "afterUpload", value: function (e) {
                e && (this.times.accurate += this.times.bonus, this.times.bonus = 0), s.default.saveHistoryTimes(this.times)
            }
        }, {
            key: "getTimes", value: function () {
                return this.times.accurate + this.times.bonus
            }
        }]), e
    }();
    exports.default = n;
});
define("js/store/session.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (t, i, n) {
            return i && e(t.prototype, i), n && e(t, n), t
        }
    }(), i = function () {
        function i() {
            e(this, i)
        }

        return t(i, null, [{
            key: "init", value: function () {
                this.sessionId = "", this.gameId = "", this.gameTicket = "", this.serverConfig = "", this.shareTicket = "", this.pkId = "", this.serverConfig = ""
            }
        }, {
            key: "setLoginState", value: function (e) {
                this.sessionId = e
            }
        }, {
            key: "setGameId", value: function (e) {
                this.gameId = e
            }
        }, {
            key: "setGameTicket", value: function (e) {
                this.gameTicket = e
            }
        }, {
            key: "setServerConfig", value: function (e) {
                this.serverConfig = e
            }
        }, {
            key: "setShareTicket", value: function (e) {
                this.shareTicket = e
            }
        }, {
            key: "setPkId", value: function (e) {
                this.pkId = e
            }
        }, {
            key: "clearPkId", value: function () {
                this.pkId = ""
            }
        }, {
            key: "clearGameId", value: function () {
                this.gameId = ""
            }
        }, {
            key: "clearShareTicket", value: function () {
                this.ShareTicket = ""
            }
        }, {
            key: "clearGameTicket", value: function () {
                this.gameTicket = ""
            }
        }, {
            key: "setServerConfig", value: function (e) {
                this.serverConfig = e
            }
        }]), i
    }();
    exports.default = i;
});
define("js/store/storage.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var n = 0; n < t.length; n++) {
                var a = t[n];
                a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a)
            }
        }

        return function (t, n, a) {
            return n && e(t.prototype, n), a && e(t, a), t
        }
    }(), n = require("./../config"), a = function () {
        function a() {
            e(this, a), this.mmpayStatus = null
        }

        return t(a, null, [{
            key: "getFriendsScore", value: function () {
                try {
                    var e = wx.getStorageSync("friends_score") || [];
                    return e = e && e.ts ? e.ts < Date.now() ? [] : e.data : []
                } catch (e) {
                    return []
                }
            }
        }, {
            key: "saveFriendsScore", value: function (e) {
                wx.setStorage({
                    key: "friends_score", data: e, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "saveMyUserInfo", value: function (e) {
                wx.setStorage({
                    key: "my_user_info", data: e, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "saveHeighestScore", value: function (e) {
                wx.setStorage({
                    key: "my_heighest_score", data: e, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "getHeighestScore", value: function () {
                try {
                    return wx.getStorageSync("my_heighest_score") || !1
                } catch (e) {
                    return !1
                }
            }
        }, {
            key: "getMyUserInfo", value: function () {
                try {
                    return wx.getStorageSync("my_user_info") || !1
                } catch (e) {
                    return null
                }
            }
        }, {
            key: "saveSessionId", value: function (e) {
                wx.setStorage({
                    key: "session_id", data: e, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "getSessionId", value: function (e) {
                try {
                    return wx.getStorageSync("session_id") || ""
                } catch (e) {
                    return ""
                }
            }
        }, {
            key: "clearSessionId", value: function () {
                wx.removeStorage({
                    key: "session_id", success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "saveServerConfig", value: function (e) {
                wx.setStorage({
                    key: "server_config", data: e, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "getServerConfig", value: function () {
                try {
                    return wx.getStorageSync("server_config") || 0
                } catch (e) {
                    return 0
                }
            }
        }, {
            key: "getFirstBlood", value: function () {
                try {
                    return wx.getStorageSync("first_blood") || 0
                } catch (e) {
                    return 0
                }
            }
        }, {
            key: "saveFirstBlood", value: function () {
                wx.setStorage({
                    key: "first_blood", data: 1, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "getHistoryTimes", value: function () {
                try {
                    return wx.getStorageSync("history_Times2") || !1
                } catch (e) {
                    return !1
                }
            }
        }, {
            key: "saveHistoryTimes", value: function (e) {
                wx.setStorage({
                    key: "history_Times2", data: e, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "saveActionData", value: function (e) {
                wx.setStorage({
                    key: "action_data0", data: e, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "getActionData", value: function () {
                try {
                    return wx.getStorageSync("action_data0") || !1
                } catch (e) {
                    return !1
                }
            }
        }, {
            key: "saveWeekBestScore", value: function (e) {
                wx.setStorage({
                    key: "weeek_best_score0", data: e, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "getWeekBestScore", value: function () {
                try {
                    var e = wx.getStorageSync("weeek_best_score0") || 0;
                    return e && e.ts && (e = e.ts < Date.now() ? 0 : e.data), e
                } catch (e) {
                    return 0
                }
            }
        }, {
            key: "setRelayNewBie", value: function () {
                wx.setStorage({
                    key: "relay_newbie", data: 1, success: function (e) {
                    }, fail: function (e) {
                    }
                })
            }
        }, {
            key: "getRelayNewBie", value: function () {
                try {
                    return wx.getStorageSync("relay_newbie") || 0
                } catch (e) {
                    return 0
                }
            }
        }, {
            key: "getWangZheBaseStatus", value: function () {
                return n.USEWANGZHEBASE
            }
        }, {
            key: "getMmpayBaseStatus", value: function () {
                return n.USEMMPAYBASE
            }
        }, {
            key: "getMmpayBonusStatus", value: function () {
                var e = {status: 0, expire_time: !1}, t = void 0;
                if (this.mmpayStatus) t = this.mmpayStatus; else try {
                    t = wx.getStorageSync("mmpayStatus")
                } catch (n) {
                    t = e
                }
                if (1 == t.status) {
                    var n = Math.round(new Date / 1e3);
                    return t.expire_time + t.svr_time < n ? e : t
                }
                return 0 == t.status ? t : e
            }
        }, {
            key: "setMmpayBonusStatus", value: function (e, t) {
                this.mmpayStatus = Object.assign(e, {svr_time: t}), wx.setStorage({
                    key: "mmpayStatus",
                    data: this.mmpayStatus
                })
            }
        }]), a
    }();
    exports.default = a;
});
define("js/tailSystem.js", function (require, module, exports) {
    "use strict";

    function t(t, i) {
        if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
        function t(t, i) {
            for (var e = 0; e < i.length; e++) {
                var o = i[e];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o)
            }
        }

        return function (i, e, o) {
            return e && t(i.prototype, e), o && t(i, o), i
        }
    }(), e = function (t) {
        if (t && t.__esModule) return t;
        var i = {};
        if (null != t) for (var e in t) Object.prototype.hasOwnProperty.call(t, e) && (i[e] = t[e]);
        return i.default = t, i
    }(require("./lib/three.js")), o = {duration: 100, height: 2, width: .5, distance: .5}, s = function () {
        function s(i, e) {
            t(this, s), this.scene = i, this.bottle = e, this.tailsRemainPool = [], this.tailsUsingPool = [], this.lastDotPosition = this.bottle.obj.position.clone(), this.nowPosition = this.bottle.obj.position.clone(), this.distance = o.distance, this.init()
        }

        return i(s, [{
            key: "init", value: function () {
                var t = o.width, i = o.height;
                this.geometry = new e.PlaneBufferGeometry(t, i), this.material = new e.MeshBasicMaterial({
                    color: 16777215,
                    side: e.DoubleSide,
                    transparent: !0,
                    opacity: .3
                });
                for (var s = 0; s < 20; s++) {
                    var a = new n(this.geometry, this.material);
                    this.scene.add(a.mesh), this.tailsRemainPool.push(a)
                }
            }
        }, {
            key: "update", value: function (t) {
                if (this.updateActiveCell(t), "prepare" == this.bottle.status && (this.nowPosition = this.bottle.obj.position.clone(), this.lastDotPosition = this.bottle.obj.position.clone()), "jump" == this.bottle.status) {
                    var i = void 0;
                    if (this.nowPosition = this.bottle.obj.position.clone(), (i = this.nowPosition.clone().distanceTo(this.lastDotPosition.clone())) < 5) {
                        if (i >= this.distance) for (var e = i / this.distance, s = Math.floor(e), n = this.lastDotPosition.clone(), a = this.nowPosition.clone(), l = t / o.duration, h = 1; h <= s; h++) {
                            a = this.lastDotPosition.clone().lerp(this.nowPosition.clone(), h / e);
                            var r = 1 + l * (h / e - 1);
                            r = r <= 0 ? 0 : r, this.layEgg(n.clone(), a.clone(), r), n = a.clone(), h == s && (this.lastDotPosition = a.clone())
                        }
                    } else this.lastDotPosition = this.nowPosition.clone()
                }
            }
        }, {
            key: "updateActiveCell", value: function (t) {
                for (var i = this.tailsUsingPool, e = 1 / o.duration, s = (o.duration, 0); s < i.length; s++) {
                    i[s].tickTime += t;
                    var n = i[s].mesh.scale.y - e * t;
                    if (n > 0) {
                        if (i[s].mesh.scale.y = n > 0 ? n : 0, i[s].tickTime >= o.duration) {
                            i[s].reset();
                            var a = i.shift();
                            this.tailsRemainPool.push(a), s--
                        }
                    } else {
                        i[s].reset();
                        var l = i.shift();
                        this.tailsRemainPool.push(l), s--
                    }
                }
            }
        }, {
            key: "correctPosition", value: function () {
                this.lastDotPosition = this.bottle.obj.position.clone()
            }
        }, {
            key: "layEgg", value: function (t, i) {
                var e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = this.getMesh();
                this.tailsUsingPool.push(o), o.mesh.position.set(i.x, i.y, i.z), o.mesh.scale.y = e, o.mesh.lookAt(t), o.mesh.rotateY(Math.PI / 2), o.mesh.visible = !0
            }
        }, {
            key: "getMesh", value: function () {
                var t = this.tailsRemainPool.shift();
                return t || (t = new n(this.geometry, this.material), this.scene.add(t.mesh)), t
            }
        }, {
            key: "allReset", value: function () {
                this.tailsRemainPool.forEach(function (t) {
                    t.reset()
                })
            }
        }]), s
    }();
    exports.default = s;
    var n = function () {
        function o(i, s) {
            t(this, o), this.tickTime = 0, this.mesh = new e.Mesh(i, s), this.mesh.visible = !1, this.mesh.name = "tail"
        }

        return i(o, [{
            key: "reset", value: function () {
                this.tickTime = 0, this.mesh.scale.set(1, 1, 1), this.mesh.visible = !1
            }
        }]), o
    }();
});
define("js/text.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
        function e(e, t) {
            for (var i = 0; i < t.length; i++) {
                var s = t[i];
                s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, s.key, s)
            }
        }

        return function (t, i, s) {
            return i && e(t.prototype, i), s && e(t, s), t
        }
    }(), i = function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
        return t.default = e, t
    }(require("./lib/three")), s = (require("./config"), function (e) {
        return e && e.__esModule ? e : {default: e}
    }(require("./font"))), r = function () {
        function r(t, o) {
            if (e(this, r), this.material = new i.MeshBasicMaterial({
                    color: o.fillStyle || 16777215,
                    transparent: !0
                }), o.opacity && (this.material.opacity = o.opacity), this.options = o || {}, this.obj = new i.Object3D, this.obj.name = "text", o.chinese) {
                var n = new i.Mesh(new i.TextBufferGeometry(t, {font: s.default, size: 1, height: .1}), this.material);
                this.obj.add(n), "center" == o.textAlign && (n.position.x = 1.1 * t.length / -2)
            } else {
                this.scores = [], this.plus = new i.Mesh(new i.TextBufferGeometry("+", {
                    font: s.default,
                    size: 3,
                    height: .1
                }), this.material), this.sub = new i.Mesh(new i.TextBufferGeometry("-", {
                    font: s.default,
                    size: 3,
                    height: .1
                }), this.material);
                for (var a = this.options.sumScore ? 5 : 2, h = 0; h < 10; ++h) {
                    for (var u = [], l = new i.TextBufferGeometry(h, {
                        font: s.default,
                        size: 3,
                        height: .1
                    }), f = 0; f < a; ++f) {
                        var c = new i.Mesh(l, this.material);
                        c.using = !1, u.push(c)
                    }
                    this.scores.push(u)
                }
                this.setScore(t)
            }
        }

        return t(r, [{
            key: "setScore", value: function (e) {
                this.sub.visible = !1, this.plus.visible = !1;
                var t = !1;
                e < 0 && (t = !0, e = Math.abs(e));
                var i = 2.5 * (e = e.toString()).length, s = this.options.sumScore ? 5 : 2,
                    r = "center" == this.options.textAlign ? -i / 2 : 0;
                this.options.plusScore && (r = -(i + 2.5) / 2, t ? (this.sub.position.x = r, this.obj.add(this.sub), this.sub.visible = !0) : (this.plus.position.x = r, this.obj.add(this.plus), this.plus.visible = !0), r += 2.5);
                for (var o = 0, n = this.scores.length; o < n; ++o) for (h = 0; h < s; ++h) this.scores[o][h].using && (this.obj.remove(this.scores[o][h]), this.scores[o][h].using = !1);
                for (var o = 0, n = e.length; o < n; ++o) {
                    for (var a = this.scores[e[o]], h = 0; h < s; ++h) if (!a[h].using) {
                        a[h].position.x = r, a[h].using = !0, this.obj.add(a[h]);
                        break
                    }
                    r += 2.5
                }
            }
        }, {
            key: "changeStyle", value: function (e) {
                Object.assign(this.options, e), this.obj.updateMatrix()
            }
        }]), r
    }();
    exports.default = r;
});
define("js/ui.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
            function e(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var o = t[i];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                }
            }

            return function (t, i, o) {
                return i && e(t.prototype, i), o && e(t, o), t
            }
        }(), i = (function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
            t.default = e
        }(require("./lib/three")), require("./config")), o = (require("./lib/animation"), function (e) {
            return e && e.__esModule ? e : {default: e}
        }(require("./text"))), n = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth,
        r = (window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth, function () {
            function n(t, i, r, s) {
                e(this, n);
                this.game = s, this.full2D = r, this.scene = t, this.camera = i, this.score = 0, this.double = 1, this.scoreText = new o.default("0", {
                    fillStyle: 2434341,
                    sumScore: !0,
                    opacity: .8
                }), this.scoreText.obj.position.set(-13, 21, -10), this.scoreText.obj.updateMatrix(), this.scoreText.obj.matrixAutoUpdate = !1, this.camera.add(this.scoreText.obj)
            }

            return t(n, [{
                key: "reset", value: function () {
                    this.scoreText.setScore(0), this.score = 0, this.double = 1
                }
            }, {
                key: "update", value: function () {
                }
            }, {
                key: "hideScore", value: function () {
                    this.scoreText.obj.visible = !1
                }
            }, {
                key: "showScore", value: function () {
                    this.scoreText.obj.visible = !0
                }
            }, {
                key: "addScore", value: function (e, t, i, o) {
                    if (o) return this.score += e, void this.setScore(this.score);
                    t ? 1 === this.double ? this.double = 2 : this.double += 2 : this.double = 1, i && this.double <= 2 && (this.double *= 2), this.double = Math.min(32, this.double), e *= this.double, this.score += e, this.setScore(this.score)
                }
            }, {
                key: "setScore", value: function (e) {
                    this.scoreText.setScore(e), i.BLOCK.minRadiusScale -= .005, i.BLOCK.minRadiusScale = Math.max(.25, i.BLOCK.minRadiusScale), i.BLOCK.maxRadiusScale -= .005, i.BLOCK.maxRadiusScale = Math.max(i.BLOCK.maxRadiusScale, .6), i.BLOCK.maxDistance += .03, i.BLOCK.maxDistance = Math.min(22, i.BLOCK.maxDistance)
                }
            }]), n
        }());
    exports.default = r;
});
define("js/ui/audioManager.js", function (require, module, exports) {
    "use strict";

    function e(e, o) {
        if (!(e instanceof o)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var o = function () {
        function e(e, o) {
            for (var t = 0; t < o.length; t++) {
                var n = o[t];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (o, t, n) {
            return t && e(o.prototype, t), n && e(o, n), o
        }
    }(), t = require("../config"), n = function () {
        function n(o) {
            var i = this;
            e(this, n), this.game = o, this.musicPool = ["success", "combo1", "combo2", "combo3", "combo4", "combo5", "combo6", "combo7", "combo8", "scale_intro", "scale_loop", "restart", "fall", "fall_2", "pop", "icon", "sing", "store", "pay", "luban", "relax"], this.musicPool.forEach(function (e, o) {
                setTimeout(function (e) {
                    this[e] = wx.createInnerAudioContext(), this[e].src = t.AUDIO[e]
                }.bind(i, e), 2 * o)
            }), setTimeout(function () {
                i.scale_loop.loop = !0, i.icon.onEnded(function () {
                    i.icon.destroy()
                }), i.store.onPlay(function () {
                    i.store.before && i.store.before()
                }), i.store.onEnded(function () {
                    i.store.after && i.store.after(), i.timer = setTimeout(function () {
                        i.canTimer && (i.store.seek(0), i.store.play())
                    }, 3e3)
                }), i.pay.onPlay(function () {
                    i.pay.before && i.pay.before()
                }), i.pay.onEnded(function () {
                    i.pay.after && i.pay.after(), i.timer = setTimeout(function () {
                        i.canTimer && (i.pay.seek(0), i.pay.play())
                    }, 3e3)
                }), i.sing.onEnded(function () {
                    i.timer = setTimeout(function () {
                        i.canTimer && (i.sing.seek(0), i.sing.play())
                    }, 3e3)
                }), i.luban.onEnded(function () {
                    i.timer = setTimeout(function () {
                        i.canTimer && (i.luban.seek(0), i.luban.play())
                    }, 3e3)
                }), i.scale_intro.onEnded(function () {
                    "prepare" == i.game.bottle.status && i.scale_loop.play()
                })
            }, 200)
        }

        return o(n, [{
            key: "resetAudio", value: function () {
                var e = this;
                this.musicPool.forEach(function (o) {
                    e[o].stop()
                })
            }
        }, {
            key: "register", value: function (e, o, t) {
                console.log("ley", e), this[e].before = o, this[e].after = t
            }
        }, {
            key: "setTimerFlag", value: function (e) {
                this.canTimer = e
            }
        }, {
            key: "clearTimer", value: function () {
                this.timer && (clearTimeout(this.timer), this.timer = null)
            }
        }, {
            key: "replay", value: function (e) {
                var o = this[e];
                o ? (o.stop(), o.play()) : console.warn("there is no music", e)
            }
        }]), n
    }();
    exports.default = n;
});
define("js/util/common.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0}), exports.checkUpdate = void 0;
    var e = require("./../config"), o = void 0;
    "function" == typeof wx.getUpdateManager && (o = wx.getUpdateManager());
    exports.checkUpdate = function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        arguments[1];
        return new Promise(function (a, n) {
            function d() {
                t == e.VERSION ? a() : n()
            }

            if (0 == t && n(), o) try {
                console.log("can use updateManager"), o.onCheckForUpdate(function (e) {
                    console.log("onCheckForUpdate"), e.hasUpdate ? (console.log("hasUpdate"), wx.showLoading({
                        mask: !0,
                        title: ""
                    })) : (console.log("dontHasUpdate"), n())
                }), o.onUpdateReady(function () {
                    console.log("updateReady"), wx.hideLoading(), o.applyUpdate()
                }), o.onUpdateFailed(function () {
                    console.log("updateFail"), wx.hideLoading(), n()
                })
            } catch (e) {
                d()
            } else d()
        })
    };
});
define("js/util/encryption.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0}), exports.encrypt = function (t, r) {
        var r = r.slice(0, 16), n = e.default.enc.Utf8.parse(r), a = e.default.enc.Utf8.parse(r), u = t;
        u = JSON.stringify(u);
        var d = e.default.AES.encrypt(u, n, {iv: a, mode: e.default.mode.CBC, padding: e.default.pad.Pkcs7});
        return d = d.toString()
    }, exports.encryptSeed = function (t, r) {
        var n = e.default.enc.Utf8.parse(r + "_" + t), a = e.default.SHA256(n).toString();
        return a = a.substr(0, 12), a = parseInt(a, 16), a += 46704096e5
    };
    var e = function (e) {
        return e && e.__esModule ? e : {default: e}
    }(require("../lib/aes"));
});
define("js/util/util.js", function (require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: !0});
    var e = exports.Util = {}, i = wx.getFileSystemManager();
    window.fileManager = i;
    var l = function (e) {
        i.saveFile({
            tempFilePath: e.tempFilePath,
            filePath: wx.env.USER_DATA_PATH + "/" + e.filePath,
            success: function () {
                e.success && e.success()
            },
            fail: function () {
                e.fail && e.fail()
            }
        })
    };
    e.saveFile = function (e) {
        var o = e.filePath.split("/");
        o.length >= 2 && i.access({
            path: wx.env.USER_DATA_PATH + "/" + o[0], success: function () {
                console.log("success, access dir"), l(e)
            }, fail: function () {
                i.mkdir({
                    dirPath: wx.env.USER_DATA_PATH + "/" + o[0], success: function () {
                        console.log("mrk dir ok"), l(e)
                    }, fail: function () {
                        console.log("fail mrk dir"), e.fail && e.fail()
                    }
                })
            }
        })
    }, e.deleteFiles = function (e) {
        for (var l = 0, o = e.length; l < o; ++l) i.unlinkSync(wx.env.USER_DATA_PATH + "/" + e[l])
    }, e.removeDirsNotInList = function (e) {
        console.log("remove list", e), e && i.readdir({
            dirPath: wx.env.USER_DATA_PATH, success: function (l) {
                for (var o = l.files, n = 0, s = o.length; n < s; ++n) e.indexOf(o[n]) < 0 && (console.log("remove dirs", o[n]), wx.removeStorage({
                    key: "skin_" + o[n],
                    success: function () {
                    }
                }), i.rmdir({
                    filePath: wx.env.USER_DATA_PATH + "/" + o[n], success: function () {
                        console.log("remove dir ok")
                    }
                }))
            }, fail: function (e) {
                console.log("faile", e)
            }
        })
    }, e.downloadSaveFile = function (i) {
        wx.downloadFile({
            url: i.url, header: i.header || "", success: function (l) {
                console.log("download okkkkkk"), e.saveFile({
                    filePath: i.filePath,
                    tempFilePath: l.tempFilePath,
                    success: i.success,
                    fail: i.fail
                })
            }, fail: function (e) {
                console.log("fail download", e), i.fail && i.fail()
            }
        })
    };
});
define("js/viewer.js", function (require, module, exports) {
    "use strict";

    function e(e, i) {
        if (!(e instanceof i)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var i = function () {
        function e(e, i) {
            for (var t = 0; t < i.length; t++) {
                var n = i[t];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
            }
        }

        return function (i, t, n) {
            return t && e(i.prototype, t), n && e(i, n), i
        }
    }(), t = (function (e) {
        if (e && e.__esModule) return e;
        var i = {};
        if (null != e) for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (i[t] = e[t]);
        i.default = e
    }(require("./lib/three")), function (e) {
        return e && e.__esModule ? e : {default: e}
    }(require("./pages/lookers"))), n = function () {
        function n(i) {
            e(this, n), this.num = 0, this.list = [], this.imgPlanes = [], this.camera = i, this.lookers = new t.default({camera: i}), this.isOpen = !1
        }

        return i(n, [{
            key: "peopleCome", value: function (e) {
                this.list.findIndex(function (i) {
                    return !!i && i.audience_openid == e.audience_openid
                }) > -1 || (this.list.push(e), this.num++, this.isOpen && this.showAvatar())
            }
        }, {
            key: "peopleOut", value: function (e) {
                var i = this.list.findIndex(function (i) {
                    return !!i && i.audience_openid == e.audience_openid
                });
                i < 0 || (this.num = this.num - 1 < 0 ? 0 : this.num - 1, this.list.splice(i, 1), this.isOpen && this.showAvatar())
            }
        }, {
            key: "showAvatar", value: function () {
                if (this.num > 0) {
                    for (var e = [], i = 1; i < 4; i++) this.list.length - i >= 0 && e.unshift(this.list[this.list.length - i].audience_headimg);
                    this.lookers.showLookers({avaImg: !0, icon: !0, wording: !1, num: this.num, avatar: e})
                } else this.lookers.showLookers({avaImg: !1, icon: !0, wording: !1})
            }
        }, {
            key: "open", value: function () {
                this.isOpen = !0, this.showAvatar()
            }
        }, {
            key: "close", value: function () {
                this.isOpen = !1, this.hideAll()
            }
        }, {
            key: "reset", value: function () {
                this.num = 0, this.list = [], this.lookers.hideLookers()
            }
        }, {
            key: "hideAll", value: function () {
                this.lookers.hideLookers()
            }
        }]), n
    }();
    exports.default = n;
});
define("js/wave.js", function (require, module, exports) {
    "use strict";

    function e(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    Object.defineProperty(exports, "__esModule", {value: !0});
    var t = function () {
            function e(e, t) {
                for (var r = 0; r < t.length; r++) {
                    var n = t[r];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                }
            }

            return function (t, r, n) {
                return r && e(t.prototype, r), n && e(t, n), t
            }
        }(), r = function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
            return t.default = e, t
        }(require("./lib/three")), n = require("./config"),
        i = new r.RingBufferGeometry(n.WAVE.innerRadius, n.WAVE.outerRadius, n.WAVE.thetaSeg), o = function () {
            function o() {
                e(this, o);
                var t = new r.MeshBasicMaterial({color: n.COLORS.pureWhite, transparent: !0});
                this.obj = new r.Mesh(i, t), this.obj.rotation.x = -Math.PI / 2, this.obj.name = "wave"
            }

            return t(o, [{
                key: "reset", value: function () {
                    this.obj.scale.set(1, 1, 1), this.obj.material.opacity = 1, this.obj.visible = !1
                }
            }]), o
        }();
    exports.default = o;
});
define("js/weapp-adapter.js", function (require, module, exports) {
    "use strict";
    var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e
    } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    !function (e) {
        function t(o) {
            if (n[o]) return n[o].exports;
            var r = n[o] = {exports: {}, id: o, loaded: !1};
            return e[o].call(r.exports, r, r.exports, t), r.loaded = !0, r.exports
        }

        var n = {};
        t.m = e, t.c = n, t.p = "", t(0)
    }([function (e, t, n) {
        var o = function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e) for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            return t.default = e, t
        }(n(1)), r = GameGlobal;
        GameGlobal.__isAdapterInjected || (GameGlobal.__isAdapterInjected = !0, function () {
            o.addEventListener = o.canvas.addEventListener = function (e, t) {
                o.document.addEventListener(e, t)
            }, o.removeEventListener = o.canvas.removeEventListener = function (e, t) {
                o.document.removeEventListener(e, t)
            };
            var e = wx.getSystemInfoSync().platform;
            if ("undefined" == typeof __devtoolssubcontext && "devtools" === e) {
                for (var t in o) {
                    var n = Object.getOwnPropertyDescriptor(r, t);
                    n && !0 !== n.configurable || Object.defineProperty(window, t, {value: o[t]})
                }
                for (var i in o.document) {
                    var a = Object.getOwnPropertyDescriptor(r.document, i);
                    a && !0 !== a.configurable || Object.defineProperty(r.document, i, {value: o.document[i]})
                }
                window.parent = window
            } else {
                for (var u in o) r[u] = o[u];
                r.window = o, window = r, window.top = window.parent = window
            }
        }())
    }, function (e, t, n) {
        function o(e) {
            return e && e.__esModule ? e : {default: e}
        }

        Object.defineProperty(t, "__esModule", {value: !0}), t.cancelAnimationFrame = t.requestAnimationFrame = t.clearInterval = t.clearTimeout = t.setInterval = t.setTimeout = t.canvas = t.location = t.localStorage = t.HTMLElement = t.FileReader = t.Audio = t.Image = t.WebSocket = t.XMLHttpRequest = t.navigator = t.document = void 0;
        var r = n(2);
        Object.keys(r).forEach(function (e) {
            "default" !== e && "__esModule" !== e && Object.defineProperty(t, e, {
                enumerable: !0, get: function () {
                    return r[e]
                }
            })
        });
        var i = n(3);
        Object.keys(i).forEach(function (e) {
            "default" !== e && "__esModule" !== e && Object.defineProperty(t, e, {
                enumerable: !0, get: function () {
                    return i[e]
                }
            })
        });
        var a = o(n(9)), u = o(n(10)), c = o(n(17)), l = o(n(18)), s = o(n(19)), f = o(n(11)), d = o(n(12)),
            p = o(n(20)), h = o(n(4)), y = o(n(21)), v = o(n(22));
        t.document = u.default, t.navigator = c.default, t.XMLHttpRequest = l.default, t.WebSocket = s.default, t.Image = f.default, t.Audio = d.default, t.FileReader = p.default, t.HTMLElement = h.default, t.localStorage = y.default, t.location = v.default;
        var b = new a.default;
        t.canvas = b, t.setTimeout = setTimeout, t.setInterval = setInterval, t.clearTimeout = clearTimeout, t.clearInterval = clearInterval, t.requestAnimationFrame = requestAnimationFrame, t.cancelAnimationFrame = cancelAnimationFrame
    }, function (e, t) {
        Object.defineProperty(t, "__esModule", {value: !0});
        var n = wx.getSystemInfoSync(), o = n.screenWidth, r = n.screenHeight, i = n.devicePixelRatio,
            a = t.innerWidth = o, u = t.innerHeight = r;
        t.devicePixelRatio = i;
        t.screen = {availWidth: a, availHeight: u}, t.performance = {
            now: function () {
                return Date.now() / 1e3
            }
        }, t.ontouchstart = null, t.ontouchmove = null, t.ontouchend = null
    }, function (t, n, o) {
        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, n) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !n || "object" !== (void 0 === n ? "undefined" : e(n)) && "function" != typeof n ? t : n
        }

        function a(t, n) {
            if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === n ? "undefined" : e(n)));
            t.prototype = Object.create(n && n.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n)
        }

        Object.defineProperty(n, "__esModule", {value: !0}), n.HTMLCanvasElement = n.HTMLImageElement = void 0;
        var u = function (e) {
            return e && e.__esModule ? e : {default: e}
        }(o(4));
        n.HTMLImageElement = function (e) {
            function t() {
                return r(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, "img"))
            }

            return a(t, u.default), t
        }(), n.HTMLCanvasElement = function (e) {
            function t() {
                return r(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, "canvas"))
            }

            return a(t, u.default), t
        }()
    }, function (t, n, o) {
        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, n) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !n || "object" !== (void 0 === n ? "undefined" : e(n)) && "function" != typeof n ? t : n
        }

        function a(t, n) {
            if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === n ? "undefined" : e(n)));
            t.prototype = Object.create(n && n.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n)
        }

        Object.defineProperty(n, "__esModule", {value: !0});
        var u = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var o = t[n];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                }
            }

            return function (t, n, o) {
                return n && e(t.prototype, n), o && e(t, o), t
            }
        }(), c = function (e) {
            return e && e.__esModule ? e : {default: e}
        }(o(5)), l = o(8), s = o(2), f = function (e) {
            function t() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                r(this, t);
                var n = i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this));
                return n.className = "", n.childern = [], n.style = {
                    width: s.innerWidth + "px",
                    height: s.innerHeight + "px"
                }, n.insertBefore = l.noop, n.innerHTML = "", n.tagName = e.toUpperCase(), n
            }

            return a(t, c.default), u(t, [{
                key: "setAttribute", value: function (e, t) {
                    this[e] = t
                }
            }, {
                key: "getAttribute", value: function (e) {
                    return this[e]
                }
            }, {
                key: "getBoundingClientRect", value: function () {
                    return {top: 0, left: 0, width: s.innerWidth, height: s.innerHeight}
                }
            }, {
                key: "focus", value: function () {
                }
            }, {
                key: "clientWidth", get: function () {
                    var e = parseInt(this.style.fontSize, 10) * this.innerHTML.length;
                    return Number.isNaN(e) ? 0 : e
                }
            }, {
                key: "clientHeight", get: function () {
                    var e = parseInt(this.style.fontSize, 10);
                    return Number.isNaN(e) ? 0 : e
                }
            }]), t
        }();
        n.default = f
    }, function (t, n, o) {
        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, n) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !n || "object" !== (void 0 === n ? "undefined" : e(n)) && "function" != typeof n ? t : n
        }

        function a(t, n) {
            if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === n ? "undefined" : e(n)));
            t.prototype = Object.create(n && n.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n)
        }

        Object.defineProperty(n, "__esModule", {value: !0});
        var u = function (e) {
            return e && e.__esModule ? e : {default: e}
        }(o(6)), c = function (e) {
            function t() {
                r(this, t);
                var e = i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this));
                return e.className = "", e.children = [], e
            }

            return a(t, u.default), t
        }();
        n.default = c
    }, function (t, n, o) {
        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, n) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !n || "object" !== (void 0 === n ? "undefined" : e(n)) && "function" != typeof n ? t : n
        }

        function a(t, n) {
            if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === n ? "undefined" : e(n)));
            t.prototype = Object.create(n && n.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n)
        }

        Object.defineProperty(n, "__esModule", {value: !0});
        var u = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var o = t[n];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                }
            }

            return function (t, n, o) {
                return n && e(t.prototype, n), o && e(t, o), t
            }
        }(), c = function (e) {
            return e && e.__esModule ? e : {default: e}
        }(o(7)), l = function (e) {
            function t() {
                r(this, t);
                var e = i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this));
                return e.childNodes = [], e
            }

            return a(t, c.default), u(t, [{
                key: "appendChild", value: function (e) {
                    if (!(e instanceof t)) throw new TypeError("Failed to executed 'appendChild' on 'Node': parameter 1 is not of type 'Node'.");
                    this.childNodes.push(e)
                }
            }, {
                key: "cloneNode", value: function () {
                    var e = Object.create(this);
                    return Object.assign(e, this), e
                }
            }, {
                key: "removeChild", value: function (e) {
                    var t = this.childNodes.findIndex(function (t) {
                        return t === e
                    });
                    return t > -1 ? this.childNodes.splice(t, 1) : null
                }
            }]), t
        }();
        n.default = l
    }, function (e, t) {
        function n(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        Object.defineProperty(t, "__esModule", {value: !0});
        var o = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var o = t[n];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                }
            }

            return function (t, n, o) {
                return n && e(t.prototype, n), o && e(t, o), t
            }
        }(), r = new WeakMap, i = function () {
            function e() {
                n(this, e), r.set(this, {})
            }

            return o(e, [{
                key: "addEventListener", value: function (e, t) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o = r.get(this);
                    o || (o = {}, r.set(this, o)), o[e] || (o[e] = []), o[e].push(t), n.capture && console.warn("EventTarget.addEventListener: options.capture is not implemented."), n.once && console.warn("EventTarget.addEventListener: options.once is not implemented."), n.passive && console.warn("EventTarget.addEventListener: options.passive is not implemented.")
                }
            }, {
                key: "removeEventListener", value: function (e, t) {
                    var n = r.get(this)[e];
                    if (n && n.length > 0) for (var o = n.length; o--; o > 0) if (n[o] === t) {
                        n.splice(o, 1);
                        break
                    }
                }
            }, {
                key: "dispatchEvent", value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        t = r.get(this)[e.type];
                    if (t) for (var n = 0; n < t.length; n++) t[n](e)
                }
            }]), e
        }();
        t.default = i
    }, function (e, t) {
        Object.defineProperty(t, "__esModule", {value: !0}), t.noop = function () {
        }
    }, function (e, t, n) {
        function o(e) {
            return e && e.__esModule ? e : {default: e}
        }

        Object.defineProperty(t, "__esModule", {value: !0}), t.default = function () {
            var e = wx.createCanvas();
            e.type = "canvas", e.__proto__.__proto__ = new r.default("canvas");
            e.getContext;
            return e.getBoundingClientRect = function () {
                return {top: 0, left: 0, width: window.innerWidth, height: window.innerHeight}
            }, e
        };
        n(3);
        var r = o(n(4));
        o(n(10))
    }, function (e, t, n) {
        function o(e) {
            return e && e.__esModule ? e : {default: e}
        }

        Object.defineProperty(t, "__esModule", {value: !0});
        var r = function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e) for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            return t.default = e, t
        }(n(1)), i = o(n(4)), a = o(n(11)), u = o(n(12)), c = o(n(9));
        n(15);
        var l = {}, s = {
            readyState: "complete",
            visibilityState: "visible",
            documentElement: r,
            hidden: !1,
            style: {},
            location: r.location,
            ontouchstart: null,
            ontouchmove: null,
            ontouchend: null,
            head: new i.default("head"),
            body: new i.default("body"),
            createElement: function (e) {
                return "canvas" === e ? new c.default : "audio" === e ? new u.default : "img" === e ? new a.default : new i.default(e)
            },
            getElementById: function (e) {
                return e === r.canvas.id ? r.canvas : null
            },
            getElementsByTagName: function (e) {
                return "head" === e ? [s.head] : "body" === e ? [s.body] : "canvas" === e ? [r.canvas] : []
            },
            querySelector: function (e) {
                return "head" === e ? s.head : "body" === e ? s.body : "canvas" === e ? r.canvas : e === "#" + r.canvas.id ? r.canvas : null
            },
            querySelectorAll: function (e) {
                return "head" === e ? [s.head] : "body" === e ? [s.body] : "canvas" === e ? [r.canvas] : []
            },
            addEventListener: function (e, t) {
                l[e] || (l[e] = []), l[e].push(t)
            },
            removeEventListener: function (e, t) {
                var n = l[e];
                if (n && n.length > 0) for (var o = n.length; o--; o > 0) if (n[o] === t) {
                    n.splice(o, 1);
                    break
                }
            },
            dispatchEvent: function (e) {
                var t = l[e.type];
                if (t) for (var n = 0; n < t.length; n++) t[n](e)
            }
        };
        t.default = s
    }, function (e, t) {
        Object.defineProperty(t, "__esModule", {value: !0}), t.default = function () {
            return wx.createImage()
        }
    }, function (t, n, o) {
        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, n) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !n || "object" !== (void 0 === n ? "undefined" : e(n)) && "function" != typeof n ? t : n
        }

        function a(t, n) {
            if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === n ? "undefined" : e(n)));
            t.prototype = Object.create(n && n.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n)
        }

        Object.defineProperty(n, "__esModule", {value: !0});
        var u = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var o = t[n];
                        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                    }
                }

                return function (t, n, o) {
                    return n && e(t.prototype, n), o && e(t, o), t
                }
            }(), c = function (e) {
                return e && e.__esModule ? e : {default: e}
            }(o(13)), l = 0, s = 1, f = 2, d = 3, p = 4, h = new WeakMap, y = new WeakMap,
            v = (new WeakMap, new WeakMap, function (e) {
                function t(e) {
                    r(this, t);
                    var n = i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this));
                    n.HAVE_NOTHING = l, n.HAVE_METADATA = s, n.HAVE_CURRENT_DATA = f, n.HAVE_FUTURE_DATA = d, n.HAVE_ENOUGH_DATA = p, n.readyState = l, y.set(n, "");
                    var o = wx.createInnerAudioContext();
                    return h.set(n, o), o.onCanplay(function () {
                        n.dispatchEvent({type: "load"}), n.dispatchEvent({type: "loadend"}), n.dispatchEvent({type: "canplay"}), n.dispatchEvent({type: "canplaythrough"}), n.dispatchEvent({type: "loadedmetadata"}), n.readyState = f
                    }), o.onPlay(function () {
                        n.dispatchEvent({type: "play"})
                    }), o.onPause(function () {
                        n.dispatchEvent({type: "pause"})
                    }), o.onEnded(function () {
                        n.dispatchEvent({type: "ended"}), n.readyState = p
                    }), o.onError(function () {
                        n.dispatchEvent({type: "error"})
                    }), e && (h.get(n).src = e), n
                }

                return a(t, c.default), u(t, [{
                    key: "load", value: function () {
                        console.warn("HTMLAudioElement.load() is not implemented.")
                    }
                }, {
                    key: "play", value: function () {
                        h.get(this).play()
                    }
                }, {
                    key: "pause", value: function () {
                        h.get(this).pause()
                    }
                }, {
                    key: "canPlayType", value: function () {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return "string" != typeof e ? "" : e.indexOf("audio/mpeg") > -1 || e.indexOf("audio/mp4") ? "probably" : ""
                    }
                }, {
                    key: "cloneNode", value: function () {
                        var e = new t;
                        return e.loop = h.get(this).loop, e.autoplay = h.get(this).loop, e.src = this.src, e
                    }
                }, {
                    key: "currentTime", get: function () {
                        return h.get(this).currentTime
                    }, set: function (e) {
                        h.get(this).seek(e)
                    }
                }, {
                    key: "src", get: function () {
                        return y.get(this)
                    }, set: function (e) {
                        y.set(this, e), h.get(this).src = e
                    }
                }, {
                    key: "loop", get: function () {
                        return h.get(this).loop
                    }, set: function (e) {
                        h.get(this).loop = e
                    }
                }, {
                    key: "autoplay", get: function () {
                        return h.get(this).autoplay
                    }, set: function (e) {
                        h.get(this).autoplay = e
                    }
                }, {
                    key: "paused", get: function () {
                        return h.get(this).paused
                    }
                }]), t
            }());
        n.default = v
    }, function (t, n, o) {
        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, n) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !n || "object" !== (void 0 === n ? "undefined" : e(n)) && "function" != typeof n ? t : n
        }

        function a(t, n) {
            if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === n ? "undefined" : e(n)));
            t.prototype = Object.create(n && n.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n)
        }

        Object.defineProperty(n, "__esModule", {value: !0});
        var u = function (e) {
            return e && e.__esModule ? e : {default: e}
        }(o(14)), c = function (e) {
            function t() {
                return r(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, "audio"))
            }

            return a(t, u.default), t
        }();
        n.default = c
    }, function (t, n, o) {
        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(t, n) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !n || "object" !== (void 0 === n ? "undefined" : e(n)) && "function" != typeof n ? t : n
        }

        function a(t, n) {
            if ("function" != typeof n && null !== n) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === n ? "undefined" : e(n)));
            t.prototype = Object.create(n && n.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), n && (Object.setPrototypeOf ? Object.setPrototypeOf(t, n) : t.__proto__ = n)
        }

        Object.defineProperty(n, "__esModule", {value: !0});
        var u = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var o = t[n];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                }
            }

            return function (t, n, o) {
                return n && e(t.prototype, n), o && e(t, o), t
            }
        }(), c = function (e) {
            return e && e.__esModule ? e : {default: e}
        }(o(4)), l = function (e) {
            function t(e) {
                return r(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e))
            }

            return a(t, c.default), u(t, [{
                key: "addTextTrack", value: function () {
                }
            }, {
                key: "captureStream", value: function () {
                }
            }, {
                key: "fastSeek", value: function () {
                }
            }, {
                key: "load", value: function () {
                }
            }, {
                key: "pause", value: function () {
                }
            }, {
                key: "play", value: function () {
                }
            }]), t
        }();
        n.default = l
    }, function (e, t, n) {
        n(16)
    }, function (e, t, n) {
        function o(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function r(e) {
            return function (t) {
                var n = new c(e);
                n.touches = t.touches, n.targetTouches = Array.prototype.slice.call(t.touches), n.changedTouches = t.changedTouches, n.timeStamp = t.timeStamp, a.default.dispatchEvent(n)
            }
        }

        var i = function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e) for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            return t.default = e, t
        }(n(1)), a = function (e) {
            return e && e.__esModule ? e : {default: e}
        }(n(10)), u = n(8), c = function e(t) {
            o(this, e), this.target = i.canvas, this.currentTarget = i.canvas, this.touches = [], this.targetTouches = [], this.changedTouches = [], this.preventDefault = u.noop, this.stopPropagation = u.noop, this.type = t
        };
        wx.onTouchStart(r("touchstart")), wx.onTouchMove(r("touchmove")), wx.onTouchEnd(r("touchend")), wx.onTouchCancel(r("touchcancel"))
    }, function (e, t, n) {
        Object.defineProperty(t, "__esModule", {value: !0});
        var o = n(8), r = {
            platform: wx.getSystemInfoSync().platform,
            language: "zh-cn",
            appVersion: "5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1",
            userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E8301 MicroMessenger/6.6.0 MiniGame NetType/WIFI Language/zh_CN",
            onLine: !0,
            geolocation: {getCurrentPosition: o.noop, watchPosition: o.noop, clearWatch: o.noop}
        };
        t.default = r
    }, function (e, t) {
        function n(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function o(e) {
            if ("function" == typeof this["on" + e]) {
                for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++) n[o - 1] = arguments[o];
                this["on" + e].apply(this, n)
            }
        }

        function r(e) {
            this.readyState = e, o.call(this, "readystatechange")
        }

        Object.defineProperty(t, "__esModule", {value: !0});
        var i = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var o = t[n];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                }
            }

            return function (t, n, o) {
                return n && e(t.prototype, n), o && e(t, o), t
            }
        }(), a = new WeakMap, u = new WeakMap, c = new WeakMap, l = new WeakMap, s = new WeakMap, f = function () {
            function e() {
                n(this, e), this.onabort = null, this.onerror = null, this.onload = null, this.onloadstart = null, this.onprogress = null, this.ontimeout = null, this.onloadend = null, this.onreadystatechange = null, this.readyState = 0, this.response = null, this.responseText = null, this.responseType = "", this.responseXML = null, this.status = 0, this.statusText = "", this.upload = {}, this.withCredentials = !1, c.set(this, {"content-type": "application/x-www-form-urlencoded"}), l.set(this, {})
            }

            return i(e, [{
                key: "abort", value: function () {
                    var e = s.get(this);
                    e && e.abort()
                }
            }, {
                key: "getAllResponseHeaders", value: function () {
                    var e = l.get(this);
                    return Object.keys(e).map(function (t) {
                        return t + ": " + e[t]
                    }).join("\n")
                }
            }, {
                key: "getResponseHeader", value: function (e) {
                    return l.get(this)[e]
                }
            }, {
                key: "open", value: function (t, n) {
                    u.set(this, t), a.set(this, n), r.call(this, e.OPENED)
                }
            }, {
                key: "overrideMimeType", value: function () {
                }
            }, {
                key: "send", value: function () {
                    var t = this, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                    if (this.readyState !== e.OPENED) throw new Error("Failed to execute 'send' on 'XMLHttpRequest': The object's state must be OPENED.");
                    wx.request({
                        data: n,
                        url: a.get(this),
                        method: u.get(this),
                        header: c.get(this),
                        responseType: this.responseType,
                        success: function (n) {
                            var i = n.data, a = n.statusCode, u = n.header;
                            if ("string" != typeof i && !(i instanceof ArrayBuffer)) try {
                                i = JSON.stringify(i)
                            } catch (e) {
                                i = i
                            }
                            if (t.status = a, l.set(t, u), o.call(t, "loadstart"), r.call(t, e.HEADERS_RECEIVED), r.call(t, e.LOADING), t.response = i, i instanceof ArrayBuffer) {
                                t.responseText = "";
                                for (var c = new Uint8Array(i), s = c.byteLength, f = 0; f < s; f++) t.responseText += String.fromCharCode(c[f])
                            } else t.responseText = i;
                            r.call(t, e.DONE), o.call(t, "load"), o.call(t, "loadend")
                        },
                        fail: function (e) {
                            var n = e.errMsg;
                            -1 !== n.indexOf("abort") ? o.call(t, "abort") : o.call(t, "error", n), o.call(t, "loadend")
                        }
                    })
                }
            }, {
                key: "setRequestHeader", value: function (e, t) {
                    var n = c.get(this);
                    n[e] = t, c.set(this, n)
                }
            }]), e
        }();
        f.UNSEND = 0, f.OPENED = 1, f.HEADERS_RECEIVED = 2, f.LOADING = 3, f.DONE = 4, t.default = f
    }, function (e, t) {
        function n(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        Object.defineProperty(t, "__esModule", {value: !0});
        var o = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var o = t[n];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                }
            }

            return function (t, n, o) {
                return n && e(t.prototype, n), o && e(t, o), t
            }
        }(), r = new WeakMap, i = function () {
            function e(t) {
                var o = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                if (n(this, e), this.binaryType = "", this.bufferedAmount = 0, this.extensions = "", this.onclose = null, this.onerror = null, this.onmessage = null, this.onopen = null, this.protocol = "", this.readyState = 3, "string" != typeof t || !/(^ws:\/\/)|(^wss:\/\/)/.test(t)) throw new TypeError("Failed to construct 'WebSocket': The URL '" + t + "' is invalid");
                this.url = t, this.readyState = e.CONNECTING;
                var a = wx.connectSocket({url: t, protocols: Array.isArray(i) ? i : [i]});
                return r.set(this, a), a.onClose(function (t) {
                    o.readyState = e.CLOSED, "function" == typeof o.onclose && o.onclose(t)
                }), a.onMessage(function (e) {
                    "function" == typeof o.onmessage && o.onmessage(e)
                }), a.onOpen(function () {
                    o.readyState = e.OPEN, "function" == typeof o.onopen && o.onopen()
                }), a.onError(function (e) {
                    "function" == typeof o.onerror && o.onerror(new Error(e.errMsg))
                }), this
            }

            return o(e, [{
                key: "close", value: function (t, n) {
                    this.readyState = e.CLOSING, r.get(this).close({code: t, reason: n})
                }
            }, {
                key: "send", value: function (e) {
                    if ("string" != typeof e && !(e instanceof ArrayBuffer)) throw new TypeError("Failed to send message: The data " + e + " is invalid");
                    r.get(this).send({data: e})
                }
            }]), e
        }();
        i.CONNECTING = 0, i.OPEN = 1, i.CLOSING = 2, i.CLOSED = 3, t.default = i
    }, function (e, t) {
        function n(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        Object.defineProperty(t, "__esModule", {value: !0});
        t.default = function e() {
            n(this, e)
        }
    }, function (e, t) {
        Object.defineProperty(t, "__esModule", {value: !0});
        var n = {
            get length() {
                return wx.getStorageInfoSync().keys.length
            }, key: function (e) {
                return wx.getStorageInfoSync().keys[e]
            }, getItem: function (e) {
                return wx.getStorageSync(e)
            }, setItem: function (e, t) {
                return wx.setStorageSync(e, t)
            }, removeItem: function (e) {
                wx.removeStorageSync(e)
            }, clear: function () {
                wx.clearStorageSync()
            }
        };
        t.default = n
    }, function (e, t) {
        Object.defineProperty(t, "__esModule", {value: !0});
        var n = {
            href: "game.js", reload: function () {
            }
        };
        t.default = n
    }]);
});
define("game.js", function (require, module, exports) {
    "use strict";
    require("./js/index.js");
});
require("game.js");
 	